* Basic Introduction
:PROPERTIES:
:ID:       0f4769f0-f893-482f-aea9-9b5c02588045
:END:


** The Organization of the Screen


On a graphical display, such as on GNU/Linux using the X Window System, Emacs occupies a graphical window. On a text terminal, Emacs occupies the entire terminal screen. We will use the term frame to mean a graphical window or terminal screen occupied by Emacs. Emacs behaves very similarly on both kinds of frames. It normally starts out with just one frame, but you can create additional frames if you wish (see Frames and Graphical Displays).

Each frame consists of several distinct regions. At the top of the frame is a menu bar, which allows you to access commands via a series of menus. On a graphical display, directly below the menu bar is a tool bar, a row of icons that perform editing commands when you click on them. At the very bottom of the frame is an echo area, where informative messages are displayed and where you enter information when Emacs asks for it.

The main area of the frame, below the tool bar (if one exists) and above the echo area, is called the window. Henceforth in this manual, we will use the word “window” in this sense. Graphical display systems commonly use the word “window” with a different meaning; but, as stated above, we refer to those graphical windows as “frames”.

An Emacs window is where the buffer—the text or other graphics you are editing or viewing—is displayed. On a graphical display, the window possesses a scroll bar on one side, which can be used to scroll through the buffer. The last line of the window is a mode line. This displays various information about what is going on in the buffer, such as whether there are unsaved changes, the editing modes that are in use, the current line number, and so forth.

When you start Emacs, there is normally only one window in the frame. However, you can subdivide this window horizontally or vertically to create multiple windows, each of which can independently display a buffer (see Multiple Windows).

At any time, one window is the selected window. On a graphical display, the selected window shows a more prominent cursor (usually solid and blinking); other windows show a less prominent cursor (usually a hollow box). On a text terminal, there is only one cursor, which is shown in the selected window. The buffer displayed in the selected window is called the current buffer, and it is where editing happens. Most Emacs commands implicitly apply to the current buffer; the text displayed in unselected windows is mostly visible for reference. If you use multiple frames on a graphical display, selecting a particular frame selects a window in that frame.



*** Point


The cursor in the selected window shows the location where most editing commands take effect, which is called point2. Many Emacs commands move point to different places in the buffer; for example, you can place point by clicking mouse button 1 (normally the left button) at the desired location.

By default, the cursor in the selected window is drawn as a solid block and appears to be on a character, but you should think of point as between two characters; it is situated before the character under the cursor. For example, if your text looks like ‘frob’ with the cursor over the ‘b’, then point is between the ‘o’ and the ‘b’. If you insert the character ‘!’ at that position, the result is ‘fro!b’, with point between the ‘!’ and the ‘b’. Thus, the cursor remains over the ‘b’, as before.

If you are editing several files in Emacs, each in its own buffer, each buffer has its own value of point. A buffer that is not currently displayed remembers its value of point if you later display it again. Furthermore, if a buffer is displayed in multiple windows, each of those windows has its own value of point.

See Displaying the Cursor, for options that control how Emacs displays the cursor.


*** The Echo Area


The line at the very bottom of the frame is the echo area. It is used to display small amounts of text for various purposes.

The echo area is so-named because one of the things it is used for is echoing, which means displaying the characters of a multi-character command as you type. Single-character commands are not echoed. Multi-character commands (see Keys) are echoed if you pause for more than a second in the middle of a command. Emacs then echoes all the characters of the command so far, to prompt you for the rest. Once echoing has started, the rest of the command echoes immediately as you type it. This behavior is designed to give confident users fast response, while giving hesitant users maximum feedback.

The echo area is also used to display an error message when a command cannot do its job. Error messages may be accompanied by beeping or by flashing the screen.

Some commands display informative messages in the echo area to tell you what the command has done, or to provide you with some specific information. These informative messages, unlike error messages, are not accompanied with a beep or flash. For example, C-x = (hold down Ctrl and type x, then let go of Ctrl and type =) displays a message describing the character at point, its position in the buffer, and its current column in the window. Commands that take a long time often display messages ending in ‘...’ while they are working (sometimes also indicating how much progress has been made, as a percentage), and add ‘done’ when they are finished.

Informative echo area messages are saved in a special buffer named *Messages*. (We have not explained buffers yet; see Using Multiple Buffers, for more information about them.) If you miss a message that appeared briefly on the screen, you can switch to the *Messages* buffer to see it again. The *Messages* buffer is limited to a certain number of lines, specified by the variable message-log-max. (We have not explained variables either; see Variables, for more information about them.) Beyond this limit, one line is deleted from the beginning whenever a new message line is added at the end.

See Customization of Display, for options that control how Emacs uses the echo area.

The echo area is also used to display the minibuffer, a special window where you can input arguments to commands, such as the name of a file to be edited. When the minibuffer is in use, the text displayed in the echo area begins with a prompt string, and the active cursor appears within the minibuffer, which is temporarily considered the selected window. You can always get out of the minibuffer by typing C-g. See The Minibuffer.



*** Kinds of User Input


GNU Emacs is primarily designed for use with the keyboard. While it is possible to use the mouse to issue editing commands through the menu bar and tool bar, that is usually not as efficient as using the keyboard.

Keyboard input into Emacs is based on a heavily-extended version of ASCII. Simple characters, like ‘a’, ‘B’, ‘3’, ‘=’, and the space character (denoted as SPC), are entered by typing the corresponding key. Control characters, such as RET, TAB, DEL, ESC, F1, Home, and LEFT, are also entered this way, as are certain characters found on non-English keyboards (see International Character Set Support).

Emacs also recognizes control characters that are entered using modifier keys. Two commonly-used modifier keys are Control (usually labeled Ctrl), and Meta (usually labeled Alt)3. For example, Control-a is entered by holding down the Ctrl key while pressing a; we will refer to this as C-a for short. Similarly, Meta-a, or M-a for short, is entered by holding down the Alt key and pressing a. Modifier keys can also be applied to non-alphanumerical characters, e.g., C-F1 or M-LEFT.

You can also type Meta characters using two-character sequences starting with ESC. Thus, you can enter M-a by typing ESC a. You can enter C-M-a (holding down both Ctrl and Alt, then pressing a) by typing ESC C-a. Unlike Meta, ESC is entered as a separate character. You don’t hold down ESC while typing the next character; instead, press ESC and release it, then enter the next character. This feature is useful on certain text terminals where the Meta key does not function reliably.

Emacs supports 3 additional modifier keys, see Modifier Keys.

Emacs has extensive support for using mouse buttons, mouse wheels and other pointing devices like touchpads and touch screens. See Mouse Input, for details.

On graphical displays, the window manager might block some keyboard inputs, including M-TAB, M-SPC, C-M-d and C-M-l. If you have this problem, you can either customize your window manager to not block those keys, or rebind the affected Emacs commands (see Customization).

Simple characters and control characters, as well as certain non-keyboard inputs such as mouse clicks, are collectively referred to as input events. For details about how Emacs internally handles input events, see Input Events in The Emacs Lisp Reference Manual.







*** Multiple Windows

Emacs can split a frame into two or many windows. Multiple windows can display parts of different buffers, or different parts of one buffer. Multiple frames always imply multiple windows, because each frame has its own set of windows. Each window belongs to one and only one frame.

**** Concepts of Emacs Windows

Each Emacs window displays one Emacs buffer at any time. A single buffer may appear in more than one window; if it does, any changes in its text are displayed in all the windows where it appears. But these windows can show different parts of the buffer, because each window has its own value of point.

At any time, one Emacs window is the selected window; the buffer this window is displaying is the current buffer. On graphical displays, the point is indicated by a solid blinking cursor in the selected window, and by a hollow box in non-selected windows. On text terminals, the cursor is drawn only in the selected window. See Displaying the Cursor.

Commands to move point affect the value of point for the selected Emacs window only. They do not change the value of point in other Emacs windows, even those showing the same buffer. The same is true for buffer-switching commands such as C-x b; they do not affect other windows at all. However, there are other commands such as C-x 4 b that select a different window and switch buffers in it. Also, all commands that display information in a window, including (for example) C-h f (describe-function) and C-x C-b (list-buffers), usually work by displaying buffers in a nonselected window without affecting the selected window.

When multiple windows show the same buffer, they can have different regions, because they can have different values of point. However, they all have the same value for the mark, because each buffer has only one mark position.

Each window has its own mode line, which displays the buffer name, modification status and major and minor modes of the buffer that is displayed in the window. The selected window’s mode line appears in a different color. See The Mode Line, for details.


**** Splitting Windows

C-x 2
Split the selected window into two windows, one above the other (split-window-below).

C-x 3
Split the selected window into two windows, positioned side by side (split-window-right).

C-mouse-2
In the mode line of a window, split that window.

C-x 2 (split-window-below) splits the selected window into two windows, one above the other. After splitting, the selected window is the upper one, and the newly split-off window is below. Both windows have the same value of point as before, and display the same portion of the buffer (or as close to it as possible). If necessary, the windows are scrolled to keep point on-screen. By default, the two windows each get half the height of the original window. A positive numeric argument specifies how many lines to give to the top window; a negative numeric argument specifies how many lines to give to the bottom window.

If you change the variable split-window-keep-point to nil, C-x 2 instead adjusts the portion of the buffer displayed by the two windows, as well as the value of point in each window, in order to keep the text on the screen as close as possible to what it was before; furthermore, if point was in the lower half of the original window, the bottom window is selected instead of the upper one.

C-x 3 (split-window-right) splits the selected window into two side-by-side windows. The left window is the selected one; the right window displays the same portion of the same buffer, and has the same value of point. A positive numeric argument specifies how many columns to give the left window; a negative numeric argument specifies how many columns to give the right window.

When you split a window with C-x 3, each resulting window occupies less than the full width of the frame. If it becomes too narrow, the buffer may be difficult to read if continuation lines are in use (see Continuation Lines). Therefore, Emacs automatically switches to line truncation if the window width becomes narrower than 50 columns. This truncation occurs regardless of the value of the variable truncate-lines (see Line Truncation); it is instead controlled by the variable truncate-partial-width-windows. If the value of this variable is a positive integer (the default is 50), that specifies the minimum total width for a partial-width window before automatic line truncation occurs; if the value is nil, automatic line truncation is disabled; and for any other non-nil value, Emacs truncates lines in every partial-width window regardless of its width. The total width of a window is in column units as reported by window-total-width (see Window Sizes in The Emacs Lisp Reference Manual), it includes the fringes, the continuation and truncation glyphs, the margins, and the scroll bar.

On text terminals, side-by-side windows are separated by a vertical divider which is drawn using the vertical-border face.

If you click C-mouse-2 in the mode line of a window, that splits the window, putting a vertical divider where you click. Depending on how Emacs is compiled, you can also split a window by clicking C-mouse-2 in the scroll bar, which puts a horizontal divider where you click (this feature does not work when Emacs uses GTK+ scroll bars).

By default, when you split a window, Emacs gives each of the resulting windows dimensions that are an integral multiple of the default font size of the frame. That might subdivide the screen estate unevenly between the resulting windows. If you set the variable window-resize-pixelwise to a non-nil value, Emacs will give each window the same number of pixels (give or take one pixel if the initial dimension was an odd number of pixels). Note that when a frame’s pixel size is not a multiple of the frame’s character size, at least one window may get resized pixelwise even if this option is nil.


**** Using Other Windows

C-x o
Select another window (other-window).

C-M-v
Scroll the next window upward (scroll-other-window).

C-M-S-v
Scroll the next window downward (scroll-other-window-down).

C-M-S-l
Recenter the next window (recenter-other-window).

mouse-1
mouse-1, in the text area of a window, selects the window and moves point to the position clicked. Clicking in the mode line selects the window without moving point in it.

With the keyboard, you can switch windows by typing C-x o (other-window). That is an o, for “other”, not a zero. When there are more than two windows, this command moves through all the windows in a cyclic order, generally top to bottom and left to right. After the rightmost and bottommost window, it goes back to the one at the upper left corner. A numeric argument means to move several steps in the cyclic order of windows. A negative argument moves around the cycle in the opposite order. When the minibuffer is active, the minibuffer window is the last window in the cycle; you can switch from the minibuffer window to one of the other windows, and later switch back and finish supplying the minibuffer argument that is requested. See Editing in the Minibuffer.

The other-window command will normally only switch to the next window in the current frame (unless otherwise configured). If you work in a multi-frame environment and you want windows in all frames to be part of the cycle, you can rebind C-x o to the next-window-any-frame command. (See Changing Key Bindings Interactively, for how to rebind a command.)

The usual scrolling commands (see Controlling the Display) apply to the selected window only, but there are also commands to scroll the next window. C-M-v (scroll-other-window) scrolls the window that C-x o would select. In other respects, the command behaves like C-v; both move the buffer text upward relative to the window, and take positive and negative arguments. (In the minibuffer, C-M-v scrolls the help window associated with the minibuffer, if any, rather than the next window in the standard cyclic order; see Editing in the Minibuffer.) C-M-S-v (scroll-other-window-down) scrolls the next window downward in a similar way. Likewise, C-M-S-l (recenter-other-window) behaves like C-l (recenter-top-bottom) in the next window.

If you set mouse-autoselect-window to a non-nil value, moving the mouse over a different window selects that window. This feature is off by default.


**** Displaying in Another Window

C-x 4 is a prefix key for a variety of commands that switch to a buffer in a different window—either another existing window, or a new window created by splitting the selected window. See How display-buffer works, for how Emacs picks or creates the window to use.

C-x 4 b bufname RET
Select buffer bufname in another window (switch-to-buffer-other-window). See Creating and Selecting Buffers.

C-x 4 C-o bufname RET ¶
Display buffer bufname in some window, without trying to select it (display-buffer). See Displaying a Buffer in a Window, for details about how the window is chosen.

C-x 4 f filename RET
Visit file filename and select its buffer in another window (find-file-other-window). See Visiting Files.

C-x 4 d directory RET
Select a Dired buffer for directory directory in another window (dired-other-window). See Dired, the Directory Editor.

C-x 4 m
Start composing a mail message, similar to C-x m (see Sending Mail), but in another window (compose-mail-other-window).

C-x 4 .
Find the definition of an identifier, similar to M-. (see Find Identifier References), but in another window (xref-find-definitions-other-window).

C-x 4 r filename RET
Visit file filename read-only, and select its buffer in another window (find-file-read-only-other-window). See Visiting Files.

C-x 4 4
A more general prefix command affects the buffer displayed by the next command invoked immediately after this prefix command. It requests the buffer of the next command to be displayed in another window.

C-x 4 1
This general prefix command requests the buffer of the next command to be displayed in the same window.


**** Deleting and Resizing Windows

C-x 0
Delete the selected window (delete-window).

C-x 1
Delete all windows in the selected frame except the selected window (delete-other-windows).

C-x 4 0
Delete the selected window and kill the buffer that was showing in it (kill-buffer-and-window). The last character in this key sequence is a zero.

C-x w 0 RET buffer RET
Delete windows showing the specified buffer.

C-x ^
Make selected window taller (enlarge-window).

C-x }
Make selected window wider (enlarge-window-horizontally).

C-x {
Make selected window narrower (shrink-window-horizontally).

C-x -
Shrink this window if its buffer doesn’t need so many lines (shrink-window-if-larger-than-buffer).

C-x +
Make all windows the same height (balance-windows).

To delete the selected window, type C-x 0 (delete-window). (That is a zero.) Once a window is deleted, the space that it occupied is given to an adjacent window (but not the minibuffer window, even if that is active at the time). Deleting the window has no effect on the buffer it used to display; the buffer continues to exist, and you can still switch to it with C-x b. The option delete-window-choose-selected controls which window is chosen as the new selected window instead (see Deleting Windows in The Emacs Lisp Reference Manual).

C-x 4 0 (kill-buffer-and-window) is a stronger command than C-x 0; it kills the current buffer and then deletes the selected window.

C-x 1 (delete-other-windows) deletes all the windows, except the selected one; the selected window expands to use the whole frame. (This command cannot be used while the minibuffer window is active; attempting to do so signals an error.)

M-x delete-windows-on deletes windows that show a specific buffer. It prompts for the buffer, defaulting to the current buffer. With prefix argument of zero, C-u 0, this command deletes windows only on the current display’s frames.

The command C-x ^ (enlarge-window) makes the selected window one line taller, taking space from a vertically adjacent window without changing the height of the frame. With a positive numeric argument, this command increases the window height by that many lines; with a negative argument, it reduces the height by that many lines. If there are no vertically adjacent windows (i.e., the window is at the full frame height), that signals an error. The command also signals an error if you attempt to reduce the height of any window below a certain minimum number of lines, specified by the variable window-min-height (the default is 4).

Similarly, C-x } (enlarge-window-horizontally) makes the selected window wider, and C-x { (shrink-window-horizontally) makes it narrower. These commands signal an error if you attempt to reduce the width of any window below a certain minimum number of columns, specified by the variable window-min-width (the default is 10).

Mouse clicks on the mode line (see Mode Line Mouse Commands) or on window dividers (see Window Dividers) provide another way to change window heights and to split or delete windows.

C-x - (shrink-window-if-larger-than-buffer) reduces the height of the selected window, if it is taller than necessary to show the whole text of the buffer it is displaying. It gives the extra lines to other windows in the frame.

You can also use C-x + (balance-windows) to even out the heights of all the windows in the selected frame.


**** Displaying a Buffer in a Window

It is a common Emacs operation to display or pop up some buffer in response to a user command. There are several different ways in which commands do this.

Many commands, like C-x C-f (find-file), by default display the buffer by “taking over” the selected window, expecting that the user’s attention will be diverted to that buffer.

Some commands try to display intelligently, trying not to take over the selected window, e.g., by splitting off a new window and displaying the desired buffer there. Such commands, which include the various help commands (see Help), work by calling display-buffer internally. See How display-buffer works, for details.

Other commands do the same as display-buffer, and additionally select the displaying window so that you can begin editing its buffer. The command M-g M-n (next-error) is one example (see Compilation Mode). Such commands work by calling the function pop-to-buffer internally. See Switching to a Buffer in a Window in The Emacs Lisp Reference Manual.

Commands with names ending in -other-window behave like display-buffer, except that they never display in the selected window. Several of these commands are bound in the C-x 4 prefix key (see Displaying in Another Window).

Commands with names ending in -other-frame behave like display-buffer, except that they (i) never display in the selected window and (ii) prefer to either create a new frame or use a window on some other frame to display the desired buffer. Several of these commands are bound in the C-x 5 prefix key.


***** How display-buffer works

The display-buffer command (as well as commands that call it internally) chooses a window to display by following the steps given below. See Choosing a Window for Displaying a Buffer in The Emacs Lisp Reference Manual, for details about how to alter this sequence of steps.

If the buffer should be displayed in the selected window regardless of other considerations, reuse the selected window. By default, this step is skipped, but you can tell Emacs not to skip it by adding a regular expression matching the buffer’s name together with a reference to the display-buffer-same-window action function (see Action Functions for Buffer Display in The Emacs Lisp Reference Manual) to the option display-buffer-alist (see Choosing a Window for Displaying a Buffer in The Emacs Lisp Reference Manual). For example, to display the buffer *scratch* preferably in the selected window write:
(setopt
display-buffer-alist
'(("\\*scratch\\*" (display-buffer-same-window))))
By default, display-buffer-alist is nil.

Otherwise, if the buffer is already displayed in an existing window, reuse that window. Normally, only windows on the selected frame are considered, but windows on other frames are also reusable if you use the corresponding reusable-frames action alist entry (see Action Alists for Buffer Display in The Emacs Lisp Reference Manual). See the next step for an example of how to do that.
Otherwise, optionally create a new frame and display the buffer there. By default, this step is skipped. To enable it, change the value of the option display-buffer-base-action (see Choosing a Window for Displaying a Buffer in The Emacs Lisp Reference Manual) as follows:
(setopt
display-buffer-base-action
'((display-buffer-reuse-window display-buffer-pop-up-frame)
(reusable-frames . 0)))
This customization will also try to make the preceding step search for a reusable window on all visible or iconified frames.

Otherwise, try to create a new window by splitting a window on the selected frame, and display the buffer in that new window.
The split can be either vertical or horizontal, depending on the variables split-height-threshold and split-width-threshold. These variables should have integer values. If split-height-threshold is smaller than the chosen window’s height, the split puts the new window below. Otherwise, if split-width-threshold is smaller than the window’s width, the split puts the new window on the right. If neither condition holds, Emacs tries to split so that the new window is below—but only if the window was not split before (to avoid excessive splitting).

Otherwise, display the buffer in a window previously showing it. Normally, only windows on the selected frame are considered, but with a suitable reusable-frames action alist entry (see above) the window may be also on another frame.
Otherwise, display the buffer in an existing window on the selected frame.
If all the above methods fail for whatever reason, create a new frame and display the buffer there.


***** Displaying non-editable buffers.

Some buffers are shown in windows for perusal rather than for editing. Help commands (see Help) typically use a buffer called *Help* for that purpose, minibuffer completion (see Completion) uses a buffer called *Completions*, etc. Such buffers are usually displayed only for a short period of time.

Normally, Emacs chooses the window for such temporary displays via display-buffer, as described in the previous subsection. The *Completions* buffer, on the other hand, is normally displayed in a window at the bottom of the selected frame, regardless of the number of windows already shown on that frame.

If you prefer Emacs to display a temporary buffer in a different fashion, customize the variable display-buffer-alist (see Choosing a Window for Displaying a Buffer in The Emacs Lisp Reference Manual) appropriately. For example, to display *Completions* always below the selected window, use the following form in your initialization file (see The Emacs Initialization File):

(setopt
display-buffer-alist
'(("\\*Completions\\*" display-buffer-below-selected)))
The *Completions* buffer is also special in the sense that Emacs usually tries to make its window just as large as necessary to display all of its contents. To resize windows showing other temporary displays, like, for example, the *Help* buffer, turn on the minor mode (see Minor Modes) temp-buffer-resize-mode (see Temporary Displays in The Emacs Lisp Reference Manual).

The maximum size of windows resized by temp-buffer-resize-mode can be controlled by customizing the options temp-buffer-max-height and temp-buffer-max-width (see Temporary Displays in The Emacs Lisp Reference Manual), and cannot exceed the size of the containing frame.


**** Convenience Features for Window Handling

Winner mode is a global minor mode that records the changes in the window configuration (i.e., how the frames are partitioned into windows), so that you can undo them. You can toggle Winner mode with M-x winner-mode, or by customizing the variable winner-mode. When the mode is enabled, C-c left (winner-undo) undoes the last window configuration change. If you change your mind while undoing, you can redo the changes you had undone using C-c right (M-x winner-redo). To prevent Winner mode from binding C-c left and C-c right, you can customize the variable winner-dont-bind-my-keys to a non-nil value. By default, Winner mode stores a maximum of 200 window configurations per frame, but you can change that by modifying the variable winner-ring-size. If there are some buffers whose windows you wouldn’t want Winner mode to restore, add their names to the list variable winner-boring-buffers or to the regexp winner-boring-buffers-regexp.

Follow mode (M-x follow-mode) synchronizes several windows on the same buffer so that they always display adjacent sections of that buffer. See Follow Mode.

The Windmove package defines commands for moving directionally between neighboring windows in a frame. M-x windmove-right selects the window immediately to the right of the currently selected one, and similarly for the left, up, and down counterparts. windmove-default-keybindings binds these commands to S-right etc.; doing so disables shift selection for those keys (see Shift Selection). In the same way as key bindings can be defined for commands that select windows directionally, you can use windmove-display-default-keybindings to define keybindings for commands that specify in what direction to display the window for the buffer that the next command is going to display. Also there is windmove-delete-default-keybindings to define keybindings for commands that delete windows directionally, and windmove-swap-states-default-keybindings that defines key bindings for commands that swap the window contents of the selected window with the window in the specified direction.

The command M-x compare-windows lets you compare the text shown in different windows. See Comparing Files.

Scroll All mode (M-x scroll-all-mode) is a global minor mode that causes scrolling commands and point motion commands to apply to every single window.


**** Window Tab Line

The command global-tab-line-mode toggles the display of a tab line on the top screen line of each window. The Tab Line shows special buttons (“tabs”) for each buffer that was displayed in a window, and allows switching to any of these buffers by clicking the corresponding button. Clicking on the + icon adds a new buffer to the window-local tab line of buffers, and clicking on the x icon of a tab deletes it. The mouse wheel on the tab line scrolls the tabs horizontally.

Selecting the previous window-local tab is the same as typing C-x LEFT (previous-buffer), selecting the next tab is the same as C-x RIGHT (next-buffer). Both commands support a numeric prefix argument as a repeat count.

You can customize the variable tab-line-tabs-function to define the preferred contents of the tab line. By default, it displays all buffers previously visited in the window, as described above. But you can also set it to display a list of buffers with the same major mode as the current buffer, or to display buffers grouped by their major mode, where clicking on the mode name in the first tab displays a list of all major modes where you can select another group of buffers.

Note that the Tab Line is different from the Tab Bar (see Tab Bars). Whereas tabs on the Tab Bar at the top of each frame are used to switch between window configurations containing several windows with buffers, tabs on the Tab Line at the top of each window are used to switch between buffers in the window.




**** Using Multiple Buffers

The text you are editing in Emacs resides in an object called a buffer. Each time you visit a file, a buffer is used to hold the file’s text. Each time you invoke Dired, a buffer is used to hold the directory listing. If you send a message with C-x m, a buffer is used to hold the text of the message. When you ask for a command’s documentation, that appears in a buffer named *Help*.

Buffers exist as long as they are in use, and are deleted (“killed”) when no longer needed, either by you (see Killing Buffers) or by Emacs (e.g., when you exit Emacs, see Exiting Emacs).

Each buffer has a unique name, which can be of any length. When a buffer is displayed in a window, its name is shown in the mode line (see The Mode Line). The distinction between upper and lower case matters in buffer names. Most buffers are made by visiting files, and their names are derived from the files’ names; however, you can also create an empty buffer with any name you want. A newly started Emacs has several buffers, including one named *scratch*, which can be used for evaluating Lisp expressions and is not associated with any file (see Lisp Interaction Buffers).

At any time, one and only one buffer is selected; we call it the current buffer. We sometimes say that a command operates on “the buffer”; this really means that it operates on the current buffer. When there is only one Emacs window, the buffer displayed in that window is current. When there are multiple windows, the buffer displayed in the selected window is current. See Multiple Windows.

A buffer’s contents consist of a series of characters, each of which optionally carries a set of text properties (see Text properties) that can specify more information about that character.

Aside from its textual contents, each buffer records several pieces of information, such as what file it is visiting (if any), whether it is modified, and what major mode and minor modes are in effect (see Major and Minor Modes). These are stored in buffer-local variables—variables that can have a different value in each buffer. See Local Variables.

A buffer’s size cannot be larger than some maximum, which is defined by the largest buffer position representable by Emacs integers. This is because Emacs tracks buffer positions using that data type. For typical 64-bit machines, this maximum buffer size is 2^{61} - 2 bytes, or about 2 EiB. For typical 32-bit machines, the maximum is usually 2^{29} - 2 bytes, or about 512 MiB. Buffer sizes are also limited by the amount of memory in the system.


**** Creating and Selecting Buffers

C-x b buffer RET
Select or create a buffer named buffer (switch-to-buffer).

C-x 4 b buffer RET
Similar, but select buffer in another window (switch-to-buffer-other-window).

C-x 5 b buffer RET
Similar, but select buffer in a separate frame (switch-to-buffer-other-frame).

C-x LEFT
Select the previous buffer in the buffer list (previous-buffer).

C-x RIGHT
Select the next buffer in the buffer list (next-buffer).

C-u M-g M-g
C-u M-g g
Read a number n and move to line n in the most recently selected buffer other than the current buffer, in another window.

The C-x b (switch-to-buffer) command reads a buffer name using the minibuffer. Then it makes that buffer current, and displays it in the currently-selected window. An empty input specifies the buffer that was current most recently among those not now displayed in any window.

While entering the buffer name, you can use the usual completion and history commands (see The Minibuffer). Note that C-x b, and related commands, use permissive completion with confirmation for minibuffer completion: if you type RET when the minibuffer text names a nonexistent buffer, Emacs prints ‘[Confirm]’ and you must type a second RET to submit that buffer name. See Completion Exit, for details. For other completion options and features, see Completion Options.

If you specify a buffer that does not exist, C-x b creates a new, empty buffer that is not visiting any file, and selects it for editing. The default value of the variable major-mode determines the new buffer’s major mode; the default value is Fundamental mode. See Major Modes. One reason to create a new buffer is to use it for making temporary notes. If you try to save it, Emacs asks for the file name to use, and the buffer’s major mode is re-established taking that file name into account (see Choosing File Modes).

For conveniently switching between a few buffers, use the commands C-x LEFT and C-x RIGHT. C-x LEFT (previous-buffer) selects the previous buffer (following the order of most recent selection in the current frame), while C-x RIGHT (next-buffer) moves through buffers in the reverse direction. Both commands support a numeric prefix argument that serves as a repeat count.

To select a buffer in a window other than the current one (see Multiple Windows), type C-x 4 b (switch-to-buffer-other-window). This prompts for a buffer name using the minibuffer, displays that buffer in another window, and selects that window.

Similarly, C-x 5 b (switch-to-buffer-other-frame) prompts for a buffer name, displays that buffer in another frame (see Frames and Graphical Displays), and selects that frame. If the buffer is already being shown in a window on another frame, Emacs selects that window and frame instead of creating a new frame.

See Displaying a Buffer in a Window, for how the C-x 4 b and C-x 5 b commands get the window and/or frame to display in.

In addition, C-x C-f, and any other command for visiting a file, can also be used to switch to an existing file-visiting buffer. See Visiting Files.

C-u M-g M-g, that is goto-line with a plain prefix argument, reads a number n using the minibuffer, selects the most recently selected buffer other than the current buffer in another window, and then moves point to the beginning of line number n in that buffer. This is mainly useful in a buffer that refers to line numbers in another buffer: if point is on or just after a number, goto-line uses that number as the default for n. Note that prefix arguments other than just C-u behave differently. C-u 4 M-g M-g goes to line 4 in the current buffer, without reading a number from the minibuffer. (Remember that M-g M-g without prefix argument reads a number n and then moves to line number n in the current buffer. See Changing the Location of Point.)

Emacs uses buffer names that start with a space for internal purposes. It treats these buffers specially in minor ways—for example, by default they do not record undo information. It is best to avoid using such buffer names yourself.


**** Listing Existing Buffers

C-x C-b
List the existing buffers (list-buffers).

To display a list of existing buffers, type C-x C-b. This pops up a buffer menu in a buffer named *Buffer List*. Each line in the list shows one buffer’s name, size, major mode and visited file. The buffers are listed in the order that they were current; the buffers that were current most recently come first. This section describes how the list of buffers is displayed and how to interpret the various indications in the list; see Operating on Several Buffers, for description of the special mode in the *Buffer List* buffer and the commands available there.

‘.’ in the first field of a line indicates that the buffer is current. ‘%’ indicates a read-only buffer. ‘*’ indicates that the buffer is modified. If several buffers are modified, it may be time to save some with C-x s (see Commands for Saving Files). Here is an example of a buffer list:

CRM Buffer                Size  Mode              File
. * .emacs                3294  Emacs-Lisp        ~/.emacs
%  *Help*                 101  Help
search.c             86055  C                 ~/cvs/emacs/src/search.c
%  src                  20959  Dired by name     ~/cvs/emacs/src/
 *mail*                  42  Mail
%  HELLO                 1607  Fundamental       ~/cvs/emacs/etc/HELLO
%  NEWS                481184  Outline           ~/cvs/emacs/etc/NEWS
*scratch*              191  Lisp Interaction
 *Messages*            1554  Messages
The buffer *Help* was made by a help request (see Help); it is not visiting any file. The buffer src was made by Dired on the directory ~/cvs/emacs/src/. You can list only buffers that are visiting files by giving the command a prefix argument, as in C-u C-x C-b.

list-buffers omits buffers whose names begin with a space, unless they visit files: such buffers are used internally by Emacs.


**** Miscellaneous Buffer Operations

C-x C-q
Toggle read-only status of buffer (read-only-mode).

C-x x r RET buffer RET
Change the name of the current buffer.

C-x x u
Rename the current buffer by adding ‘<number>’ to the end.

M-x view-buffer RET buffer RET
Scroll through buffer buffer. See View Mode.

A buffer can be read-only, which means that commands to insert or delete its text are not allowed. (However, other commands, like C-x RET f, can still mark it as modified, see Specifying a Coding System for File Text). The mode line indicates read-only buffers with ‘%%’ or ‘%*’ near the left margin. See The Mode Line. Read-only buffers are usually made by subsystems such as Dired and Rmail that have special commands to operate on the text. Visiting a file whose access control says you cannot write it also makes the buffer read-only.

The command C-x C-q (read-only-mode) makes a read-only buffer writable, and makes a writable buffer read-only. This works by setting the variable buffer-read-only, which has a local value in each buffer and makes the buffer read-only if its value is non-nil. If you change the option view-read-only to a non-nil value, making the buffer read-only with C-x C-q also enables View mode in the buffer (see View Mode).

C-x x r (rename-buffer changes the name of the current buffer. You specify the new name as a minibuffer argument; there is no default. If you specify a name that is in use for some other buffer, an error happens and no renaming is done.

C-x x u (rename-uniquely) renames the current buffer to a similar name with a numeric suffix added to make it both different and unique. This command does not need an argument. It is useful for creating multiple shell buffers: if you rename the *shell* buffer, then do M-x shell again, it makes a new shell buffer named *shell*; meanwhile, the old shell buffer continues to exist under its new name. This method is also good for mail buffers, compilation buffers, and most Emacs features that create special buffers with particular names. (With some of these features, such as M-x compile, M-x grep, you need to switch to some other buffer before using the command again, otherwise it will reuse the current buffer despite the name change.)

The commands M-x append-to-buffer and C-x x i (insert-buffer) can also be used to copy text from one buffer to another. See Accumulating Text.


**** Killing Buffers

If you continue an Emacs session for a while, you may accumulate a large number of buffers. You may then find it convenient to kill the buffers you no longer need. (Some other editors call this operation close, and talk about “closing the buffer” or “closing the file” visited in the buffer.) On most operating systems, killing a buffer releases the memory Emacs used for the buffer back to the operating system so that other programs can use it. Here are some commands for killing buffers:

C-x k buffer RET
Kill buffer buffer (kill-buffer).

M-x kill-some-buffers
Offer to kill each buffer, one by one.

M-x kill-matching-buffers
Offer to kill all buffers matching a regular expression.

C-x k (kill-buffer) kills one buffer, whose name you specify in the minibuffer. The default, used if you type just RET in the minibuffer, is to kill the current buffer. If you kill the current buffer, another buffer becomes current: one that was current in the recent past but is not displayed in any window now. If you ask to kill a file-visiting buffer that is modified, then you must confirm with yes before the buffer is killed.

The command M-x kill-some-buffers asks about each buffer, one by one. An answer of yes means to kill the buffer, just like kill-buffer. This command ignores buffers whose names begin with a space, which are used internally by Emacs.

The command M-x kill-matching-buffers prompts for a regular expression and kills all buffers whose names match that expression. See Syntax of Regular Expressions. Like kill-some-buffers, it asks for confirmation before each kill. This command normally ignores buffers whose names begin with a space, which are used internally by Emacs. To kill internal buffers as well, call kill-matching-buffers with a prefix argument.

The Buffer Menu feature is also convenient for killing various buffers. See Operating on Several Buffers.

If you want to do something special every time a buffer is killed, you can add hook functions to the hook kill-buffer-hook (see Hooks).

If you run one Emacs session for a period of days, as many people do, it can fill up with buffers that you used several days ago. The command M-x clean-buffer-list is a convenient way to purge them; it kills all the unmodified buffers that you have not used for a long time. An ordinary buffer is killed if it has not been displayed for three days; however, you can specify certain buffers that should never be killed automatically, and others that should be killed if they have been unused for a mere hour. These defaults, and other aspects of this command’s behavior, can be controlled by customizing several options described in the doc string of clean-buffer-list.

You can also have this buffer purging done for you, once a day, by enabling Midnight mode. Midnight mode operates each day at midnight; at that time, it runs clean-buffer-list, or whichever functions you have placed in the normal hook midnight-hook (see Hooks). To enable Midnight mode, use the Customization buffer to set the variable midnight-mode to t. See Easy Customization Interface.


**** Operating on Several Buffers

M-x buffer-menu
Begin editing a buffer listing all Emacs buffers.

M-x buffer-menu-other-window
Similar, but do it in another window.

The Buffer Menu opened by C-x C-b (see Listing Existing Buffers) does not merely list buffers. It also allows you to perform various operations on buffers, through an interface similar to Dired (see Dired, the Directory Editor). You can save buffers, kill them (here called deleting them, for consistency with Dired), or display them.

To use the Buffer Menu, type C-x C-b and switch to the window displaying the *Buffer List* buffer. You can also type M-x buffer-menu to open the Buffer Menu in the selected window. Alternatively, the command M-x buffer-menu-other-window opens the Buffer Menu in another window, and selects that window.

The Buffer Menu is a read-only buffer, and can be changed only through the special commands described in this section. The usual cursor motion commands can be used in this buffer. The following commands apply to the buffer described on the current line:

d ¶
Flag the buffer for deletion (killing), then move point to the next line (Buffer-menu-delete). The deletion flag is indicated by the character ‘D’ on the line, before the buffer name. The deletion occurs only when you type the x command (see below).

C-d ¶
Like d, but move point up instead of down (Buffer-menu-delete-backwards).

s ¶
Flag the buffer for saving (Buffer-menu-save). The save flag is indicated by the character ‘S’ on the line, before the buffer name. The saving occurs only when you type x. You may request both saving and deletion for the same buffer.

x ¶
Perform all flagged deletions and saves (Buffer-menu-execute).

u ¶
Remove all flags from the current line, and move down (Buffer-menu-unmark). With a prefix argument, moves up after removing the flags.

DEL ¶
Move to the previous line and remove all flags on that line (Buffer-menu-backup-unmark).

M-DEL ¶
Remove a particular flag from all lines (Buffer-menu-unmark-all-buffers). This asks for a single character, and unmarks buffers marked with that character; typing RET removes all marks.

U ¶
Remove all flags from all the lines (Buffer-menu-unmark-all).

The commands for removing flags, d and C-d, accept a numeric argument as a repeat count.

The following commands operate immediately on the buffer listed on the current line. They also accept a numeric argument as a repeat count.

~ ¶
Mark the buffer as unmodified (Buffer-menu-not-modified). See Commands for Saving Files.

% ¶
Toggle the buffer’s read-only status (Buffer-menu-toggle-read-only). See Miscellaneous Buffer Operations.

t ¶
Visit the buffer as a tags table (Buffer-menu-visit-tags-table). See Selecting a Tags Table.

The following commands are used to select another buffer or buffers:

q ¶
Quit the Buffer Menu (quit-window). The most recent formerly visible buffer is displayed in its place.

RET ¶
f
Select this line’s buffer, replacing the *Buffer List* buffer in its window (Buffer-menu-this-window).

o ¶
Select this line’s buffer in another window, as if by C-x 4 b, leaving *Buffer List* visible (Buffer-menu-other-window).

C-o ¶
Display this line’s buffer in another window, without selecting it (Buffer-menu-switch-other-window).

1 ¶
Select this line’s buffer in a full-frame window (Buffer-menu-1-window).

2 ¶
Set up two windows on the current frame, with this line’s buffer selected in one, and a previously current buffer (aside from *Buffer List*) in the other (Buffer-menu-2-window).

b ¶
Bury this line’s buffer (Buffer-menu-bury) (i.e., move it to the end of the buffer list).

m ¶
Mark this line’s buffer to be displayed in another window if you exit with the v command (Buffer-menu-mark). The display flag is indicated by the character ‘>’ at the beginning of the line. (A single buffer may not have both deletion and display flags.)

v ¶
Select this line’s buffer, and also display in other windows any buffers flagged with the m command (Buffer-menu-select). If you have not flagged any buffers, this command is equivalent to 1.

The following commands affect the entire buffer list:

S ¶
Sort the Buffer Menu entries according to their values in the column at point. With a numeric prefix argument n, sort according to the n-th column (tabulated-list-sort).

} ¶
Widen the current column width by n (the prefix numeric argument) characters.

{ ¶
Narrow the current column width by n (the prefix numeric argument) characters.

T ¶
Delete, or reinsert, lines for non-file buffers (Buffer-menu-toggle-files-only). This command toggles the inclusion of such buffers in the buffer list.

Normally, the buffer *Buffer List* is not updated automatically when buffers are created and killed; its contents are just text. If you have created, deleted or renamed buffers, the way to update *Buffer List* to show what you have done is to type g (revert-buffer). You can make this happen regularly every auto-revert-interval seconds if you enable Auto Revert mode in this buffer, as long as it is not marked modified. Global Auto Revert mode applies to the *Buffer List* buffer only if global-auto-revert-non-file-buffers is non-nil. See global-auto-revert-non-file-buffers, for details.


**** Indirect Buffers

An indirect buffer shares the text of some other buffer, which is called the base buffer of the indirect buffer. In some ways it is a buffer analogue of a symbolic link between files.

M-x make-indirect-buffer RET base-buffer RET indirect-name RET
Create an indirect buffer named indirect-name with base buffer base-buffer.

M-x clone-indirect-buffer RET
Create an indirect buffer that is a twin copy of the current buffer.

C-x 4 c ¶
Create an indirect buffer that is a twin copy of the current buffer, and select it in another window (clone-indirect-buffer-other-window).

The text of the indirect buffer is always identical to the text of its base buffer; changes made by editing either one are visible immediately in the other. “Text” here includes both the characters and their text properties. But in all other respects, the indirect buffer and its base buffer are completely separate. They can have different names, different values of point, different narrowing, different markers, different overlays, different major modes, and different local variables.

An indirect buffer cannot visit a file, but its base buffer can. If you try to save the indirect buffer, that actually works by saving the base buffer. Killing the base buffer effectively kills the indirect buffer, but killing an indirect buffer has no effect on its base buffer.

One way to use indirect buffers is to display multiple views of an outline. See Viewing One Outline in Multiple Views.

A quick and handy way to make an indirect buffer is with the command C-x 4 c (clone-indirect-buffer-other-window). It creates and selects an indirect buffer whose base buffer is the current buffer. With a numeric argument, it prompts for the name of the indirect buffer; otherwise it uses the name of the current buffer, with a ‘<n>’ suffix added.

The more general way to make an indirect buffer is with the command M-x make-indirect-buffer. It creates an indirect buffer named indirect-name from a buffer base-buffer, prompting for both using the minibuffer.

The functions that create indirect buffers run the hook clone-indirect-buffer-hook after creating the indirect buffer. When this hook runs, the newly created indirect buffer is the current buffer.

Note: When a modification is made to the text of a buffer, the modification hooks are run only in the base buffer, because most of the functions on those hooks are not prepared to work correctly in indirect buffers. So if you need a modification hook function in an indirect buffer, you need to manually add that function to the hook in the base buffer and then make the function operate in the desired indirect buffer.


**** Convenience Features and Customization of Buffer Handling

This section describes several modes and features that make it more convenient to switch between buffers.

***** Making Buffer Names Unique

When several buffers visit identically-named files, Emacs must give the buffers distinct names. The default method adds a suffix based on the names of the directories that contain the files. For example, if you visit files /foo/bar/mumble/name and /baz/quux/mumble/name at the same time, their buffers will be named ‘name<bar/mumble>’ and ‘name<quux/mumble>’, respectively. Emacs adds as many directory parts as are needed to make a unique name.

You can choose from several different styles for constructing unique buffer names, by customizing the option uniquify-buffer-name-style.

The forward naming method includes part of the file’s directory name at the beginning of the buffer name; using this method, buffers visiting the files /u/rms/tmp/Makefile and /usr/projects/zaphod/Makefile would be named ‘tmp/Makefile’ and ‘zaphod/Makefile’.

In contrast, the post-forward naming method would call the buffers ‘Makefile|tmp’ and ‘Makefile|zaphod’. The default method post-forward-angle-brackets is like post-forward, except that it encloses the unique path in angle brackets. The reverse naming method would call them ‘Makefile\tmp’ and ‘Makefile\zaphod’. The nontrivial difference between post-forward and reverse occurs when just one directory name is not enough to distinguish two files; then reverse puts the directory names in reverse order, so that /top/middle/file becomes ‘file\middle\top’, while post-forward puts them in forward order after the file name, as in ‘file|top/middle’. If uniquify-buffer-name-style is set to nil, the buffer names simply get ‘<2>’, ‘<3>’, etc. appended.

The value of uniquify-buffer-name-style can be set to a customized function with two arguments base and extra-strings where base is a string and extra-strings is a list of strings. For example the current implementation for post-forward-angle-brackets could be:

(defun my-post-forward-angle-brackets (base extra-string)
(concat base \"<\" (mapconcat #'identity extra-string \"/\") \">\"))
Which rule to follow for putting the directory names in the buffer name is not very important if you are going to look at the buffer names before you type one. But as an experienced user, if you know the rule, you won’t have to look. And then you may find that one rule or another is easier for you to remember and apply quickly.


***** Fast minibuffer selection

Icomplete global minor mode provides a convenient way to quickly select an element among the possible completions in a minibuffer. When enabled, typing in the minibuffer continuously displays a list of possible completions that match the string you have typed.

At any time, you can type C-j to select the first completion in the list. So the way to select a particular completion is to make it the first in the list. There are two ways to do this. You can type more of the completion name and thus narrow down the list, excluding unwanted completions above the desired one. Alternatively, you can use C-. and C-, to rotate the list until the desired buffer is first.

M-TAB will select the first completion in the list, like C-j but without exiting the minibuffer, so you can edit it further. This is typically used when entering a file name, where M-TAB can be used a few times to descend in the hierarchy of directories.

To enable Icomplete mode, type M-x icomplete-mode, or customize the variable icomplete-mode to t (see Easy Customization Interface).

An alternative to Icomplete mode is Fido mode. This is very similar to Icomplete mode, but retains some functionality from a popular extension called Ido mode (in fact the name is derived from “Fake Ido”). Among other things, in Fido mode, C-s and C-r are also used to rotate the completions list, C-k can be used to delete files and kill buffers in-list. Another noteworthy aspect is that flex is used as the default completion style (see How Completion Alternatives Are Chosen). To change this, add the following to your initialization file (see The Emacs Initialization File):

(defun my-icomplete-styles ()
(setq-local completion-styles '(initials flex)))
(add-hook 'icomplete-minibuffer-setup-hook 'my-icomplete-styles)
To enable Fido mode, type M-x fido-mode, or customize the variable fido-mode to t (see Easy Customization Interface).

Icomplete mode and Fido mode display the possible completions on the same line as the prompt by default. To display the completion candidates vertically under the prompt, type M-x icomplete-vertical-mode, or customize the variable icomplete-vertical-mode to t (see Easy Customization Interface).


***** Customizing Buffer Menus

M-x bs-show
Make a list of buffers similarly to M-x list-buffers but customizable.

M-x ibuffer
Make a list of buffers and operate on them in Dired-like fashion.

M-x bs-show pops up a buffer list similar to the one normally displayed by C-x C-b, but whose display you can customize in a more flexible fashion. For example, you can specify the list of buffer attributes to show, the minimum and maximum width of buffer name column, a regexp for names of buffers that will never be shown and those which will always be shown, etc. If you prefer this to the usual buffer list, you can bind this command to C-x C-b. To customize this buffer list, use the bs Custom group (see Easy Customization Interface), or invoke bs-customize.

MSB global minor mode (“MSB” stands for “mouse select buffer”) provides a different and customizable mouse buffer menu which you may prefer. It replaces the mouse-buffer-menu commands, normally bound to C-Down-mouse-1 and C-F10, with its own commands, and also modifies the menu-bar buffer menu. You can customize the menu in the msb Custom group.

IBuffer is a major mode for viewing a list of buffers and operating on them in a way analogous to that of Dired (see Dired, the Directory Editor), including filtering, marking, sorting in various ways, and acting on buffers.




Here we explain the basics of how to enter text, make corrections, and save the text in a file. If this material is new to you, we suggest you first run the Emacs learn-by-doing tutorial, by typing C-h t (help-with-tutorial).

*** Changing the Location of Point

To do more than insert characters, you have to know how to move point (see Point). The keyboard commands C-f, C-b, C-n, and C-p move point to the right, left, down, and up, respectively. You can also move point using the arrow keys present on most keyboards: RIGHT, LEFT, DOWN, and UP; however, many Emacs users find that it is slower to use the arrow keys than the control keys, because you need to move your hand to the area of the keyboard where those keys are located.

You can also click the left mouse button to move point to the position clicked. Emacs also provides a variety of additional keyboard commands that move point in more sophisticated ways.

C-f ¶
Move forward one character (forward-char).

RIGHT ¶
This command (right-char) behaves like C-f, except when point is in a right-to-left paragraph (see Bidirectional Editing).

C-b ¶
Move backward one character (backward-char).

LEFT ¶
This command (left-char) behaves like C-b, except if the current paragraph is right-to-left (see Bidirectional Editing).

C-n ¶
DOWN
Move down one screen line (next-line). This command attempts to keep the horizontal position unchanged, so if you start in the middle of one line, you move to the middle of the next.

C-p ¶
UP
Move up one screen line (previous-line). This command preserves position within the line, like C-n.

C-a ¶
Home
Move to the beginning of the line (move-beginning-of-line).

C-e ¶
End
Move to the end of the line (move-end-of-line).

M-f
Move forward one word (forward-word). See Words.

C-RIGHT ¶
M-RIGHT
This command (right-word) behaves like M-f, except it moves backward by one word if the current paragraph is right-to-left. See Bidirectional Editing.

M-b
Move backward one word (backward-word). See Words.

C-LEFT ¶
M-LEFT
This command (left-word) behaves like M-b, except it moves forward by one word if the current paragraph is right-to-left. See Bidirectional Editing.

M-r ¶
Without moving the text on the screen, reposition point on the left margin of the center-most text line of the window; on subsequent consecutive invocations, move point to the left margin of the top-most line, the bottom-most line, and so forth, in cyclic order (move-to-window-line-top-bottom).

A numeric argument says which screen line to place point on, counting downward from the top of the window (zero means the top line). A negative argument counts lines up from the bottom (−1 means the bottom line). See Numeric Arguments, for more information on numeric arguments.

M-< ¶
Move to the top of the buffer (beginning-of-buffer). With numeric argument n, move to n/10 of the way from the top. On graphical displays, C-HOME does the same.

M-> ¶
Move to the end of the buffer (end-of-buffer). On graphical displays, C-END does the same.

C-v ¶
PageDown
next
Scroll the display one screen forward, and move point onscreen if necessary (scroll-up-command). See Scrolling.

M-v ¶
PageUp
prior
Scroll one screen backward, and move point onscreen if necessary (scroll-down-command). See Scrolling.

M-g c ¶
Read a number n and move point to buffer position n. Position 1 is the beginning of the buffer. If point is on or just after a number in the buffer, that is the default for n. Just type RET in the minibuffer to use it. You can also specify n by giving M-g c a numeric prefix argument.

M-g M-g ¶
M-g g
Read a number n and move point to the beginning of line number n (goto-line). Line 1 is the beginning of the buffer. If point is on or just after a number in the buffer, that is the default for n. Just type RET in the minibuffer to use it. You can also specify n by giving M-g M-g a numeric prefix argument. See Creating and Selecting Buffers, for the behavior of M-g M-g when you give it a plain prefix argument. Alternatively, you can use the command goto-line-relative to move point to the line relative to the accessible portion of the narrowed buffer.

goto-line has its own history list (see Minibuffer History). You can have either a single list shared between all buffers (the default) or a separate list for each buffer, by customizing the user option goto-line-history-local.

M-g TAB ¶
Read a number n and move to column n in the current line. Column 0 is the leftmost column. If called with a prefix argument, move to the column number specified by the argument’s numeric value.

C-x C-n ¶
Use the current column of point as the semipermanent goal column (set-goal-column) in the current buffer. When a semipermanent goal column is in effect, C-n, C-p, <prior> and <next> always try to move to this column, or as close as possible to it, after moving vertically. The goal column remains in effect until canceled.

C-u C-x C-n
Cancel the goal column. Henceforth, C-n and C-p try to preserve the horizontal position, as usual.

When a line of text in the buffer is longer than the width of the window, Emacs usually displays it on two or more screen lines, a.k.a. visual lines. For convenience, C-n and C-p move point by screen lines, as do the equivalent keys down and up. You can force these commands to move according to logical lines (i.e., according to the text lines in the buffer) by setting the variable line-move-visual to nil; if a logical line occupies multiple screen lines, the cursor then skips over the additional screen lines. For details, see Continuation Lines. See Variables, for how to set variables such as line-move-visual.

Unlike C-n and C-p, most of the Emacs commands that work on lines work on logical lines. For instance, C-a (move-beginning-of-line) and C-e (move-end-of-line) respectively move to the beginning and end of the logical line. Whenever we encounter commands that work on screen lines, such as C-n and C-p, we will point these out.

When line-move-visual is nil, you can also set the variable track-eol to a non-nil value. Then C-n and C-p, when starting at the end of the logical line, move to the end of the next logical line. Normally, track-eol is nil.

C-n normally stops at the end of the buffer when you use it on the last line in the buffer. However, if you set the variable next-line-add-newlines to a non-nil value, C-n on the last line of a buffer creates an additional line at the end and moves down into it.


*** Erasing Text

DEL
BACKSPACE
Delete the character before point, or the region if it is active (delete-backward-char).

Delete
Delete the character after point, or the region if it is active (delete-forward-char).

C-d
Delete the character after point (delete-char).

C-k
Kill to the end of the line (kill-line).

M-d
Kill forward to the end of the next word (kill-word).

M-DEL
M-BACKSPACE
Kill back to the beginning of the previous word (backward-kill-word).

The DEL (delete-backward-char) command removes the character before point, moving the cursor and the characters after it backwards. If point was at the beginning of a line, this deletes the preceding newline, joining this line to the previous one.

If, however, the region is active, DEL instead deletes the text in the region. See The Mark and the Region, for a description of the region.

On most keyboards, DEL is labeled BACKSPACE, but we refer to it as DEL in this manual. (Do not confuse DEL with the Delete key; we will discuss Delete momentarily.) On some text terminals, Emacs may not recognize the DEL key properly. See If DEL Fails to Delete, if you encounter this problem.

The Delete (delete-forward-char) command deletes in the opposite direction: it deletes the character after point, i.e., the character under the cursor. If point was at the end of a line, this joins the following line onto this one. Like DEL, it deletes the text in the region if the region is active (see The Mark and the Region).

C-d (delete-char) deletes the character after point, similar to Delete, but regardless of whether the region is active.

See Deletion, for more detailed information about the above deletion commands.

C-k (kill-line) erases (kills) a line at a time. If you type C-k at the beginning or middle of a line, it kills all the text up to the end of the line. If you type C-k at the end of a line, it joins that line with the following line.

See Killing and Moving Text, for more information about C-k and related commands.


*** Undoing Changes

C-/
C-x u
C-_
Undo one entry of the undo records—usually, one command worth (undo). (The first key might be unavailable on text-mode displays.)

Emacs records a list of changes made in the buffer text, so you can undo recent changes. This is done using the undo command, which is bound to C-/ (as well as C-x u and C-_). Normally, this command undoes the last change, moving point back to where it was before the change. The undo command applies only to changes in the buffer; you can’t use it to undo cursor motion.

On a terminal that supports the Control modifier on all other keys, the easiest way to invoke undo is with C-/, since that doesn’t need the Shift modifier. On terminals which allow only the ASCII control characters, C-/ does not exist, but for many of them C-/ still works because it actually sends C-_ to Emacs, while many others allow you to omit the Shift modifier when you type C-_ (in effect pressing C--), making that the most convenient way to invoke undo.

Although each editing command usually makes a separate entry in the undo records, very simple commands may be grouped together. Sometimes, an entry may cover just part of a complex command.

If you repeat C-/ (or its aliases), each repetition undoes another, earlier change, back to the limit of the undo information available. If all recorded changes have already been undone, the undo command displays an error message and does nothing.

To learn more about the undo command, see Undo.


*** Files

Text that you insert in an Emacs buffer lasts only as long as the Emacs session. To keep any text permanently, you must put it in a file.

Suppose there is a file named test.emacs in your home directory. To begin editing this file in Emacs, type

C-x C-f test.emacs RET
Here the file name is given as an argument to the command C-x C-f (find-file). That command uses the minibuffer to read the argument, and you type RET to terminate the argument (see The Minibuffer).

Emacs obeys this command by visiting the file: it creates a buffer, copies the contents of the file into the buffer, and then displays the buffer for editing. If you alter the text, you can save the new text in the file by typing C-x C-s (save-buffer). This copies the altered buffer contents back into the file test.emacs, making them permanent. Until you save, the changed text exists only inside Emacs, and the file test.emacs is unaltered.

To create a file, just visit it with C-x C-f as if it already existed. This creates an empty buffer, in which you can insert the text you want to put in the file. Emacs actually creates the file the first time you save this buffer with C-x C-s.

To learn more about using files in Emacs, see File Handling.


*** Help

If you forget what a key does, you can find out by typing C-h k (describe-key), followed by the key of interest; for example, C-h k C-n tells you what C-n does.

The prefix key C-h stands for “help”. The key F1 serves as an alias for C-h. Apart from C-h k, there are many other help commands providing different kinds of help.


*** Blank Lines
Here are special commands and techniques for inserting and deleting blank lines.

C-o
Insert a blank line after the cursor (open-line).

C-x C-o
Delete all but one of many consecutive blank lines (delete-blank-lines).

We have seen how RET (newline) starts a new line of text. However, it may be easier to see what you are doing if you first make a blank line and then insert the desired text into it. This is easy to do using the key C-o (open-line), which inserts a newline after point but leaves point in front of the newline. After C-o, type the text for the new line.

You can make several blank lines by typing C-o several times, or by giving it a numeric argument specifying how many blank lines to make. See Numeric Arguments, for how. If you have a fill prefix, the C-o command inserts the fill prefix on the new line, if typed at the beginning of a line. See The Fill Prefix.

The easy way to get rid of extra blank lines is with the command C-x C-o (delete-blank-lines). If point lies within a run of several blank lines, C-x C-o deletes all but one of them. If point is on a single blank line, C-x C-o deletes it. If point is on a nonblank line, C-x C-o deletes all following blank lines, if any exists.


*** Continuation Lines

Sometimes, a line of text in the buffer—a logical line—is too long to fit in the window, and Emacs displays it as two or more screen lines, or visual lines. This is called line wrapping or continuation, and the long logical line is called a continued line. On a graphical display, Emacs indicates line wrapping with small bent arrows in the left and right window fringes. On a text terminal, Emacs indicates line wrapping by displaying a ‘\’ character at the right margin.

Most commands that act on lines act on logical lines, not screen lines. For instance, C-k kills a logical line. As described earlier, C-n (next-line) and C-p (previous-line) are special exceptions: they move point down and up, respectively, by one screen line (see Changing the Location of Point).

Emacs can optionally truncate long logical lines instead of continuing them. This means that every logical line occupies a single screen line; if it is longer than the width of the window, the rest of the line is not displayed. On a graphical display, a truncated line is indicated by a small straight arrow in the right fringe; on a text terminal, it is indicated by a ‘$’ character in the right margin. See Line Truncation.

By default, continued lines are wrapped at the right window edge. Since the wrapping may occur in the middle of a word, continued lines can be difficult to read. The usual solution is to break your lines before they get too long, by inserting newlines. If you prefer, you can make Emacs insert a newline automatically when a line gets too long, by using Auto Fill mode. See Filling Text.

Sometimes, you may need to edit files containing many long logical lines, and it may not be practical to break them all up by adding newlines. In that case, you can use Visual Line mode, which enables word wrapping: instead of wrapping long lines exactly at the right window edge, Emacs wraps them at the word boundaries (i.e., space or tab characters) nearest to the right window edge. Visual Line mode also redefines editing commands such as C-a, C-n, and C-k to operate on screen lines rather than logical lines. See Visual Line Mode.


*** Cursor Position Information

Here are commands to get information about the size and position of parts of the buffer, and to count words and lines.

M-x what-line
Display the line number of point.

M-x line-number-mode
M-x column-number-mode
Toggle automatic display of the current line number or column number. See Optional Mode Line Features. If you want to have a line number displayed before each line, see Customization of Display.

M-=
Display the number of lines, sentences, words, and characters that are present in the region (count-words-region). See The Mark and the Region, for information about the region.

M-x count-words
Display the number of lines, sentences, words, and characters that are present in the buffer. If the region is active (see The Mark and the Region), display the numbers for the region instead.

C-x =
Display the character code of character after point, character position of point, and column of point (what-cursor-position).

M-x hl-line-mode
Enable or disable highlighting of the current line. See Displaying the Cursor.

M-x size-indication-mode
Toggle automatic display of the size of the buffer. See Optional Mode Line Features.

M-x what-line displays the current line number in the echo area. This command is usually redundant because the current line number is shown in the mode line (see The Mode Line). However, if you narrow the buffer, the mode line shows the line number relative to the accessible portion (see Narrowing). By contrast, what-line displays both the line number relative to the narrowed region and the line number relative to the whole buffer.

M-= (count-words-region) displays a message reporting the number of lines, sentences, words, and characters in the region (see The Mark and the Region, for an explanation of the region). With a prefix argument, C-u M-=, the command displays a count for the entire buffer.

The command M-x count-words does the same job, but with a different calling convention. It displays a count for the region if the region is active, and for the buffer otherwise.

The command C-x = (what-cursor-position) shows information about the current cursor position and the buffer contents at that position. It displays a line in the echo area that looks like this:

Char: c (99, #o143, #x63) point=28062 of 36168 (78%) column=53
After ‘Char:’, this shows the character in the buffer at point. The text inside the parenthesis shows the corresponding decimal, octal and hex character codes; for more information about how C-x = displays character information, see Introduction to International Character Sets. After ‘point=’ is the position of point as a character count (the first character in the buffer is position 1, the second character is position 2, and so on). The number after that is the total number of characters in the buffer, and the number in parenthesis expresses the position as a percentage of the total. After ‘column=’ is the horizontal position of point, in columns counting from the left edge of the window.

If the user option what-cursor-show-names is non-nil, the name of the character, as defined by the Unicode Character Database, is shown as well. The part in parentheses would then become:

(99, #o143, #x63, LATIN SMALL LETTER C)
If the buffer has been narrowed, making some of the text at the beginning and the end temporarily inaccessible, C-x = displays additional text describing the currently accessible range. For example, it might display this:

Char: C (67, #o103, #x43) point=252 of 889 (28%) <231-599> column=0
where the two extra numbers give the smallest and largest character position that point is allowed to assume. The characters between those two positions are the accessible ones. See Narrowing.

Related, but different feature is display-line-numbers-mode (see Customization of Display).


*** Numeric Arguments

In the terminology of mathematics and computing, argument means “data provided to a function or operation”. You can give any Emacs command a numeric argument (also called a prefix argument). Some commands interpret the argument as a repetition count. For example, giving C-f an argument of ten causes it to move point forward by ten characters instead of one. With these commands, no argument is equivalent to an argument of one, and negative arguments cause them to move or act in the opposite direction.

The easiest way to specify a numeric argument is to type a digit and/or a minus sign while holding down the Meta key. For example,

M-5 C-n
moves down five lines. The keys M-1, M-2, and so on, as well as M--, are bound to commands (digit-argument and negative-argument) that set up an argument for the next command. M-- without digits normally means −1.

If you enter more than one digit, you need not hold down the Meta key for the second and subsequent digits. Thus, to move down fifty lines, type

M-5 0 C-n
Note that this does not insert five copies of ‘0’ and move down one line, as you might expect—the ‘0’ is treated as part of the prefix argument.

(What if you do want to insert five copies of ‘0’? Type M-5 C-u 0. Here, C-u terminates the prefix argument, so that the next keystroke begins the command that you want to execute. Note that this meaning of C-u applies only to this case. For the usual role of C-u, see below.)

Instead of typing M-1, M-2, and so on, another way to specify a numeric argument is to type C-u (universal-argument) followed by some digits, or (for a negative argument) a minus sign followed by digits. A minus sign without digits normally means −1.

C-u alone has the special meaning of “four times”: it multiplies the argument for the next command by four. C-u C-u multiplies it by sixteen. Thus, C-u C-u C-f moves forward sixteen characters. Other useful combinations are C-u C-n, C-u C-u C-n (move down a good fraction of a screen), C-u C-u C-o (make sixteen blank lines), and C-u C-k (kill four lines).

You can use a numeric argument before a self-inserting character to insert multiple copies of it. This is straightforward when the character is not a digit; for example, C-u 6 4 a inserts 64 copies of the character ‘a’. But this does not work for inserting digits; C-u 6 4 1 specifies an argument of 641. You can separate the argument from the digit to insert with another C-u; for example, C-u 6 4 C-u 1 does insert 64 copies of the character ‘1’.

Some commands care whether there is an argument, but ignore its value. For example, the command M-q (fill-paragraph) fills text; with an argument, it justifies the text as well. (See Filling Text, for more information on M-q.) For these commands, it is enough to specify the argument with a single C-u.

Some commands use the value of the argument as a repeat count but do something special when there is no argument. For example, the command C-k (kill-line) with argument n kills n lines, including their terminating newlines. But C-k with no argument is special: it kills the text up to the next newline, or, if point is right at the end of the line, it kills the newline itself. Thus, two C-k commands with no arguments can kill a nonblank line, just like C-k with an argument of one. (See Killing and Moving Text, for more information on C-k.)

A few commands treat a plain C-u differently from an ordinary argument. A few others may treat an argument of just a minus sign differently from an argument of −1. These unusual cases are described when they come up; they exist to make an individual command more convenient, and they are documented in that command’s documentation string.

We use the term prefix argument to emphasize that you type such arguments before the command, and to distinguish them from minibuffer arguments (see The Minibuffer), which are entered after invoking the command.

On graphical displays, C-0, C-1, etc. act the same as M-0, M-1, etc.


*** Repeating a Command

Many simple commands, such as those invoked with a single key or with M-x command-name RET, can be repeated by invoking them with a numeric argument that serves as a repeat count (see Numeric Arguments). However, if the command you want to repeat prompts for input, or uses a numeric argument in another way, that method won’t work.

The command C-x z (repeat) provides another way to repeat an Emacs command many times. This command repeats the previous Emacs command, whatever that was. Repeating a command uses the same arguments that were used before; it does not read new arguments each time.

To repeat the command more than once, type additional z’s: each z repeats the command one more time. Repetition ends when you type a character other than z or press a mouse button.

For example, suppose you type C-u 2 0 C-d to delete 20 characters. You can repeat that command (including its argument) three additional times, to delete a total of 80 characters, by typing C-x z z z. The first C-x z repeats the command once, and each subsequent z repeats it once again.

You can also activate repeat-mode which allows repeating commands bound to sequences of two or more keys by typing a single character. For example, after typing C-x u (undo, see Undo) to undo the most recent edits, you can undo many more edits by typing u u u…. Similarly, type C-x o o o… instead of C-x o C-x o C-x o… to switch to the window several windows away. This works by entering a transient repeating mode after you type the full key sequence that invokes the command; the single-key shortcuts are shown in the echo area.

Only some commands support repetition in repeat-mode; type M-x describe-repeat-maps RET to see which ones.

The single-character shortcuts enabled by the transient repeating mode do not need to be identical: for example, after typing C-x {, either { or } or ^ or v, or any series that mixes these characters in any order, will resize the selected window in respective ways. Similarly, after M-g n or M-g p, typing any sequence of n and/or p in any mix will repeat next-error and previous-error to navigate in a *compilation* or *grep* buffer (see Compilation Mode).

Typing any key other than those defined to repeat the previous command exits the transient repeating mode, and then the key you typed is executed normally. You can also define a key which will exit the transient repeating mode without executing the key which caused the exit. To this end, customize the user option repeat-exit-key to name a key; one natural value is RET. Finally, it’s possible to break the repetition chain automatically after some amount of idle time: customize the user option repeat-exit-timeout to specify the idle time in seconds after which this transient repetition mode will be turned off automatically.







*** Frames and Graphical Displays

When Emacs is started on a graphical display, e.g., on the X Window System, it occupies a graphical system-level display region. In this manual, we call this a frame, reserving the word “window” for the part of the frame used for displaying a buffer. A frame initially contains one window, but it can be subdivided into multiple windows (see Multiple Windows). A frame normally also contains a menu bar, tool bar, and echo area.

You can also create additional frames (see Creating Frames). All frames created in the same Emacs session have access to the same underlying buffers and other data. For instance, if a buffer is being shown in more than one frame, any changes made to it in one frame show up immediately in the other frames too.

Typing C-x C-c closes all the frames on the current display, and ends the Emacs session if it has no frames open on any other displays (see Exiting Emacs). To close just the selected frame, type C-x 5 0 (that is zero, not o).

This chapter describes Emacs features specific to graphical displays (particularly mouse commands), and features for managing multiple frames. On text terminals, many of these features are unavailable. However, it is still possible to create multiple frames on text terminals; such frames are displayed one at a time, filling the entire terminal screen (see Text Terminals). It is also possible to use the mouse on some text terminals (see Using a Mouse in Text Terminals, for doing so on GNU and Unix systems; and see Mouse Usage on MS-DOS, for doing so on MS-DOS). Menus are supported on all text terminals


**** Mouse Commands for Editing

mouse-1
Move point to where you click (mouse-set-point).

Drag-mouse-1
Activate the region around the text selected by dragging, and put the text in the primary selection (mouse-set-region).

mouse-2
Move point to where you click, and insert the contents of the primary selection there (mouse-yank-primary).

mouse-3
If the region is active, move the nearer end of the region to the click position; otherwise, set mark at the current value of point and point at the click position. Save the resulting region in the kill ring; on a second click, kill it (mouse-save-then-kill).

C-M-mouse-1
Activate a rectangular region around the text selected by dragging. See Rectangles.

The most basic mouse command is mouse-set-point, which is invoked by clicking with the left mouse button, mouse-1, in the text area of a window. This moves point to the position where you clicked. If that window was not the selected window, it becomes the selected window. You can also activate a region by double-clicking mouse-1 (see Mouse Commands for Words and Lines).

Normally, if the frame you clicked in was not the selected frame, it is made the selected frame, in addition to selecting the window and setting the cursor. On the X Window System, you can change this by setting the variable x-mouse-click-focus-ignore-position to t. In that case, the initial click on an unselected frame just selects the frame, without doing anything else; clicking again selects the window and sets the cursor position.

Holding down mouse-1 and dragging the mouse over a stretch of text activates the region around that text (mouse-set-region), placing the mark where you started holding down the mouse button, and point where you release it (see The Mark and the Region). In addition, the text in the region becomes the primary selection (see Cut and Paste with Other Window Applications).

If you change the variable mouse-drag-copy-region to a non-nil value, dragging the mouse over a stretch of text also adds the text to the kill ring. The default is nil.

If this variable is non-empty, only copy to the kill ring if the region is non-empty. For instance, if you mouse drag an area that is less than a half a character, you’d normally get the empty string in your kill ring, but with non-empty, this short mouse drag won’t affect the kill ring.

If you move the mouse off the top or bottom of the window while dragging, the window scrolls at a steady rate until you move the mouse back into the window. This way, you can select regions that don’t fit entirely on the screen. The number of lines scrolled per step depends on how far away from the window edge the mouse has gone; the variable mouse-scroll-min-lines specifies a minimum step size.

If you enable the option mouse-drag-mode-line-buffer and dragging files is supported by the window system, then dragging the mouse on the buffer name portion of the mode line will drag that buffer’s file to another program or frame.

Clicking with the middle mouse button, mouse-2, moves point to the position where you clicked and inserts the contents of the primary selection (mouse-yank-primary). See Cut and Paste with Other Window Applications. This behavior is consistent with other X applications. Alternatively, you can rebind mouse-2 to mouse-yank-at-click, which performs a yank at the position you click.

If you change the variable mouse-yank-at-point to a non-nil value, mouse-2 does not move point; it inserts the text at point, regardless of where you clicked or even which of the frame’s windows you clicked on. This variable affects both mouse-yank-primary and mouse-yank-at-click.

Clicking with the right mouse button, mouse-3, runs the command mouse-save-then-kill. This performs several actions depending on where you click and the status of the region:

If no region is active, clicking mouse-3 activates the region, placing the mark where point was and point at the clicked position.
If a region is active, clicking mouse-3 adjusts the nearer end of the region by moving it to the clicked position. The adjusted region’s text is copied to the kill ring; if the text in the original region was already on the kill ring, it replaces it there.
If you originally specified the region using a double or triple mouse-1, so that the region is defined to consist of entire words or lines (see Mouse Commands for Words and Lines), then adjusting the region with mouse-3 also proceeds by entire words or lines.
If you use mouse-3 a second time consecutively, at the same place, that kills the region already selected. Thus, the simplest way to kill text with the mouse is to click mouse-1 at one end, then click mouse-3 twice at the other end. To copy the text into the kill ring without deleting it from the buffer, press mouse-3 just once—or just drag across the text with mouse-1. Then you can copy it elsewhere by yanking it.
The mouse-save-then-kill command also obeys the variable mouse-drag-copy-region (described above). If the value is non-nil, then whenever the command sets or adjusts the active region, the text in the region is also added to the kill ring. If the latest kill ring entry had been added the same way, that entry is replaced rather than making a new entry.

Whenever you set the region using any of the mouse commands described above, the mark will be deactivated by any subsequent unshifted cursor motion command, in addition to the usual ways of deactivating the mark. See Shift Selection.

Some mice have a “wheel” which can be used for scrolling. Emacs supports scrolling windows with the mouse wheel, by default, on most graphical displays. To toggle this feature, use M-x mouse-wheel-mode. The variables mouse-wheel-follow-mouse and mouse-wheel-scroll-amount determine where and by how much buffers are scrolled. The variable mouse-wheel-progressive-speed determines whether the scroll speed is linked to how fast you move the wheel. This mode also supports increasing or decreasing the font size, by default bound to scrolling with the Ctrl modifier. When this mode is enabled, mouse wheel produces special events like wheel-up and wheel-down. (Some older systems report them as mouse-4 and mouse-5.) If the mouse has a horizontal scroll wheel, it produces wheel-left and wheel-right events as well.

Emacs also supports horizontal scrolling with the Shift modifier. Typing a numeric prefix arg (e.g., M-5) before starting horizontal scrolling changes its step value defined by the user option mouse-wheel-scroll-amount-horizontal.

If your mouse’s wheel can be tilted, or if your touchpad supports it, then you can also enable horizontal scrolling by customizing the variable mouse-wheel-tilt-scroll to a non-nil value. By default, tilting the mouse wheel scrolls the window’s view horizontally in the direction of the tilt: e.g., tilting to the right scrolls the window to the right, so that the text displayed in the window moves horizontally to the left. If you’d like to reverse the direction of horizontal scrolling, customize the variable mouse-wheel-flip-direction to a non-nil value.

When the mouse pointer is over an image in Image mode, see Viewing Image Files, scrolling the mouse wheel with the Ctrl modifier scales the image under the mouse pointer, and scrolling the mouse wheel with the Shift modifier scrolls the image horizontally.


**** Mouse Commands for Words and Lines

These variants of mouse-1 select entire words or lines at a time. Emacs activates the region around the selected text, which is also copied to the kill ring.

Double-mouse-1
Select the text around the word or character which you click on.

Double-clicking on a character with symbol syntax (such as underscore, in C mode) selects the symbol surrounding that character. Double-clicking on a character with open- or close-parenthesis syntax selects the parenthetical grouping which that character starts or ends. Double-clicking on a character with string-delimiter syntax (such as a single-quote or double-quote in C) selects the string constant (Emacs uses heuristics to figure out whether that character is the beginning or the end of it).

Double-clicking on the beginning of a parenthetical grouping or beginning string-delimiter moves point to the end of the region, scrolling the buffer display forward if necessary to show the new location of point. Double-clicking on the end of a parenthetical grouping or end string-delimiter keeps point at the end of the region by default, so the beginning of the region will not be visible if it is above the top of the window; setting the user option mouse-select-region-move-to-beginning to non-nil changes this to move point to the beginning of the region, scrolling the display backward if necessary.

Double-Drag-mouse-1
Select the text you drag across, in units of whole words.

Triple-mouse-1
Select the line you click on.

Triple-Drag-mouse-1
Select the text you drag across, in units of whole lines.


**** Following References with the Mouse

Some Emacs buffers include buttons, or hyperlinks: pieces of text that perform some action (e.g., following a reference) when activated (e.g., by clicking on them). Usually, a button’s text is visually highlighted: it is underlined, or a box is drawn around it. If you move the mouse over a button, the shape of the mouse cursor changes and the button lights up. If you change the variable mouse-highlight to nil, Emacs disables this highlighting.

You can activate a button by moving point to it and typing RET, or by clicking either mouse-1 or mouse-2 on the button. For example, in a Dired buffer, each file name is a button; activating it causes Emacs to visit that file (see Dired, the Directory Editor). In a *Compilation* buffer, each error message is a button, and activating it visits the source code for that error (see Running Compilations under Emacs).

Although clicking mouse-1 on a button usually activates the button, if you hold the mouse button down for a period of time before releasing it (specifically, for more than 450 milliseconds), then Emacs moves point where you clicked, without activating the button. In this way, you can use the mouse to move point over a button without activating it. Dragging the mouse over or onto a button has its usual behavior of setting the region, and does not activate the button.

You can change how mouse-1 applies to buttons by customizing the variable mouse-1-click-follows-link. If the value is a positive integer, that determines how long you need to hold the mouse button down for, in milliseconds, to cancel button activation; the default is 450, as described in the previous paragraph. If the value is nil, mouse-1 just sets point where you clicked, and does not activate buttons. If the value is double, double clicks activate buttons but single clicks just set point.

Normally, mouse-1 on a button activates the button even if it is in a non-selected window. If you change the variable mouse-1-click-in-non-selected-windows to nil, mouse-1 on a button in an unselected window moves point to the clicked position and selects that window, without activating the button.


**** Mouse Clicks for Menus

Several mouse clicks with the Ctrl and SHIFT modifiers bring up menus.

C-mouse-1 ¶
This menu is for selecting a buffer.

The MSB (“mouse select buffer”) global minor mode makes this menu smarter and more customizable. See Customizing Buffer Menus.

C-mouse-2 ¶
This menu contains entries for examining faces and other text properties, and well as for setting them (the latter is mainly useful when editing enriched text; see Enriched Text).

C-mouse-3 ¶
This menu is mode-specific. For most modes if Menu-bar mode is on, this menu has the same items as all the mode-specific menu-bar menus put together. Some modes may specify a different menu for this button. If Menu Bar mode is off, this menu contains all the items which would be present in the menu bar—not just the mode-specific ones—so that you can access them without having to display the menu bar.

S-mouse-1
This menu is for changing the default face within the window’s buffer. See Text Scale.

Many GUI applications use mouse-3 to display context menus: menus that provide access to various pertinent settings and actions for the location and context of the mouse click. If you prefer this in Emacs over the default function of mouse-3, which is bound to the mouse-save-then-kill command (see Mouse Commands for Editing), you can enable the minor mode context-menu-mode. Then Emacs will show context menus when you click mouse-3. The exact contents of these context menus depends on the current major mode and the buffer contents around the place where you click the mouse. To customize the contents of the context menu, you can use the variable context-menu-functions (see Major Mode Conventions in The Emacs Lisp Reference Manual). You can also invoke the context menu by pressing S-F10.


**** Mode Line Mouse Commands

You can use mouse clicks on window mode lines to select and manipulate windows.

Some areas of the mode line, such as the buffer name, and major and minor mode names, have their own special mouse bindings. These areas are highlighted when you hold the mouse over them, and information about the special bindings will be displayed (see Tooltips). This section’s commands do not apply in those areas.

mouse-1 ¶
mouse-1 on a mode line selects the window it belongs to. By dragging mouse-1 on the mode line, you can move it, thus changing the height of the windows above and below. Changing heights with the mouse in this way never deletes windows, it just refuses to make any window smaller than the minimum height.

mouse-2 ¶
mouse-2 on a mode line expands that window to fill its frame.

mouse-3 ¶
mouse-3 on a mode line deletes the window it belongs to. If the frame has only one window, it does nothing.

C-mouse-2
C-mouse-2 on a mode line splits that window, producing two side-by-side windows with the boundary running through the click position (see Splitting Windows).

Furthermore, by clicking and dragging mouse-1 on the divider between two side-by-side mode lines, you can move the vertical boundary to the left or right.

Note that resizing windows is affected by the value of window-resize-pixelwise, see Splitting Windows.


**** Creating Frames

The prefix key C-x 5 is analogous to C-x 4. Whereas each C-x 4 command pops up a buffer in a different window in the selected frame (see Displaying in Another Window), the C-x 5 commands use a different frame. If an existing visible or iconified (a.k.a. “minimized”, see Visibility of Frames in The Emacs Lisp Reference Manual) frame already displays the requested buffer, that frame is raised and deiconified (“un-minimized”); otherwise, a new frame is created on the current display terminal.

The various C-x 5 commands differ in how they find or create the buffer to select:

C-x 5 2 ¶
Create a new frame using the default frame parameters (make-frame-command).

C-x 5 c ¶
Create a new frame using the window configuration and frame parameters of the current frame (clone-frame).

C-x 5 b bufname RET
Select buffer bufname in another frame. This runs switch-to-buffer-other-frame.

C-x 5 f filename RET
Visit file filename and select its buffer in another frame. This runs find-file-other-frame. See Visiting Files.

C-x 5 d directory RET
Select a Dired buffer for directory directory in another frame. This runs dired-other-frame. See Dired, the Directory Editor.

C-x 5 m
Start composing a mail message in another frame. This runs compose-mail-other-frame. It is the other-frame variant of C-x m. See Sending Mail.

C-x 5 .
Find the definition of an identifier in another frame. This runs xref-find-definitions-other-frame, the multiple-frame variant of M-.. See Find Identifier References.

C-x 5 r filename RET ¶
Visit file filename read-only, and select its buffer in another frame. This runs find-file-read-only-other-frame. See Visiting Files.

C-x 5 5
A more general prefix command that affects the buffer displayed by the next command invoked immediately after this prefix command (other-frame-prefix). It requests the buffer of the next command to be displayed in another frame.

You can control the appearance and behavior of the newly-created frames by specifying frame parameters. See Frame Parameters.


**** Frame Commands

The following commands are used to delete and operate on frames:

C-x 5 0 ¶
Delete the selected frame (delete-frame). This signals an error if there is only one frame.

C-x 5 u ¶
When undelete-frame-mode is enabled, undelete one of the 16 most recently deleted frames. Without a prefix argument, undelete the most recently deleted frame. With a numerical prefix argument between 1 and 16, where 1 is the most recently deleted frame, undelete the corresponding deleted frame.

C-z ¶
Minimize (or iconify) the selected Emacs frame (suspend-frame). See Exiting Emacs.

C-x 5 o ¶
Select another frame, and raise it. If you repeat this command, it cycles through all the frames on your terminal.

C-x 5 1 ¶
Delete all frames on the current terminal, except the selected one.

M-F10 ¶
Toggle the maximization state of the current frame. When a frame is maximized, it fills the screen.

F11 ¶
Toggle full-screen mode for the current frame. (The difference between full-screen and maximized is normally that the former hides window manager decorations, giving slightly more screen space to Emacs itself.)

Note that with some window managers you may have to customize the variable frame-resize-pixelwise to a non-nil value in order to make a frame truly maximized or full-screen. This variable, when set to a non-nil value, in general allows resizing frames at pixel resolution, rather than in integral multiples of lines and columns.

The C-x 5 0 (delete-frame) command deletes the selected frame. However, it will refuse to delete the last frame in an Emacs session, to prevent you from losing the ability to interact with the Emacs session. Note that when Emacs is run as a daemon (see Using Emacs as a Server), there is always a virtual frame that remains after all the ordinary, interactive frames are deleted. In this case, C-x 5 0 can delete the last interactive frame; you can use emacsclient to reconnect to the Emacs session.

The C-x 5 1 (delete-other-frames) command deletes all other frames on the current terminal (this terminal refers to either a graphical display, or a text terminal; see Text Terminals). If the Emacs session has frames open on other graphical displays or text terminals, those are not deleted.

The C-x 5 o (other-frame) command selects the next frame on the current terminal. If you are using Emacs on the X Window System with a window manager that selects (or gives focus to) whatever frame the mouse cursor is over, you have to change the variable focus-follows-mouse to t in order for this command to work properly. Then invoking C-x 5 o will also warp the mouse cursor to the chosen frame.


**** Fonts

By default, Emacs displays text on graphical displays using a 10-point monospace font, and the font size can be changed interactively (see Text Scale).

There are several different ways to specify a different font:

Click on ‘Set Default Font’ in the ‘Options’ menu. This makes the selected font the default on all existing graphical frames. To save this for future sessions, click on ‘Save Options’ in the ‘Options’ menu.
Add a line to your init file, modifying the variable default-frame-alist to specify the font parameter (see Frame Parameters), like this:
(add-to-list 'default-frame-alist
'(font . "DejaVu Sans Mono-10"))
This makes the font the default on all graphical frames created after restarting Emacs with that init file.

Add an ‘emacs.font’ X resource setting to your X resource file, like this:
emacs.font: DejaVu Sans Mono-12
You must restart X, or use the xrdb command, for the X resources file to take effect. See X Resources. Do not quote font names in X resource files.

If you are running Emacs on the GNOME desktop or Haiku, you can tell Emacs to adjust the frame’s default font along with changes to the default system font by setting the variable font-use-system-font to t (the default is nil). For this to work, Emacs must have been compiled with support for Gsettings (or the older Gconf). (To be specific, the Gsettings configuration names used are ‘org.gnome.desktop.interface monospace-font-name’ and ‘org.gnome.desktop.interface font-name’.)
Use the command line option ‘-fn’ (or ‘--font’). See Font Specification Options.
To check what font you’re currently using, the C-u C-x = command can be helpful. It describes the character at point, and names the font that it’s rendered in.

There are four different ways to express a font name. The first is to use a Fontconfig pattern. Fontconfig patterns have the following form:

fontname[-fontsize][:name1=values1][:name2=values2]...
Within this format, any of the elements in brackets may be omitted. Here, fontname is the family name of the font, such as ‘Monospace’ or ‘DejaVu Sans Mono’; fontsize is the point size of the font (one printer’s point is about 1/72 of an inch); and the ‘name=values’ entries specify settings such as the slant and weight of the font. Each values may be a single value, or a list of values separated by commas. In addition, some property values are valid with only one kind of property name, in which case the ‘name=’ part may be omitted.

Here is a list of common font properties:

‘slant’
One of ‘italic’, ‘oblique’, or ‘roman’.

‘weight’
One of ‘light’, ‘medium’, ‘demibold’, ‘bold’ or ‘black’.

‘style’
Some fonts define special styles which are a combination of slant and weight. For instance, ‘Dejavu Sans’ defines the ‘book’ style, which overrides the slant and weight properties.

‘width’
One of ‘condensed’, ‘normal’, or ‘expanded’.

‘spacing’
One of ‘monospace’, ‘proportional’, ‘dual-width’, or ‘charcell’.

Here are some examples of Fontconfig patterns:

Monospace
Monospace-12
Monospace-12:bold
DejaVu Sans Mono:bold:italic
Monospace-12:weight=bold:slant=italic
For a more detailed description of Fontconfig patterns, see the Fontconfig manual, which is distributed with Fontconfig and available online at https://fontconfig.org/fontconfig-user.html.

On MS-Windows, only the subset of the form fontname[-fontsize] is supported for all fonts; the full Fontconfig pattern might not work for all of them.

The second way to specify a font is to use a GTK font pattern. These have the syntax

fontname [properties] [fontsize]
where fontname is the family name, properties is a list of property values separated by spaces, and fontsize is the point size. The properties that you may specify for GTK font patterns are as follows:

Slant properties: ‘Italic’ or ‘Oblique’. If omitted, the default (roman) slant is implied.
Weight properties: ‘Bold’, ‘Book’, ‘Light’, ‘Medium’, ‘Semi-bold’, or ‘Ultra-light’. If omitted, ‘Medium’ weight is implied.
Width properties: ‘Semi-Condensed’ or ‘Condensed’. If omitted, a default width is used.
Here are some examples of GTK font patterns:

Monospace 12
Monospace Bold Italic 12
On MS-Windows, only the subset fontname is supported.

The third way to specify a font is to use an XLFD (X Logical Font Description). This is the traditional method for specifying fonts under X, and is also supported on MS-Windows. Each XLFD consists of fourteen words or numbers, separated by dashes, like this:

-misc-fixed-medium-r-semicondensed--13-*-*-*-c-60-iso8859-1
A wildcard character (‘*’) in an XLFD matches any sequence of characters (including none), and ‘?’ matches any single character. However, matching is implementation-dependent, and can be inaccurate when wildcards match dashes in a long name. For reliable results, supply all 14 dashes and use wildcards only within a field. Case is insignificant in an XLFD. The syntax for an XLFD is as follows:

-maker-family-weight-slant-widthtype-style…
…-pixels-height-horiz-vert-spacing-width-registry-encoding
The entries have the following meanings:

maker
The name of the font manufacturer.

family
The name of the font family (e.g., ‘courier’).

weight
The font weight—normally either ‘bold’, ‘medium’ or ‘light’. Some font names support other values.

slant
The font slant—normally ‘r’ (roman), ‘i’ (italic), ‘o’ (oblique), ‘ri’ (reverse italic), or ‘ot’ (other). Some font names support other values.

widthtype
The font width—normally ‘normal’, ‘condensed’, ‘semicondensed’, or ‘extended’. Some font names support other values.

style
An optional additional style name. Usually it is empty—most XLFDs have two hyphens in a row at this point. The style name can also specify a two-letter ISO-639 language name, like ‘ja’ or ‘ko’; some fonts that support CJK scripts have that spelled out in the style name part.

pixels
The font height, in pixels.

height
The font height on the screen, measured in tenths of a printer’s point. This is the point size of the font, times ten. For a given vertical resolution, height and pixels are proportional; therefore, it is common to specify just one of them and use ‘*’ for the other.

horiz
The horizontal resolution, in pixels per inch, of the screen for which the font is intended.

vert
The vertical resolution, in pixels per inch, of the screen for which the font is intended. Normally the resolution of the fonts on your system is the right value for your screen; therefore, you normally specify ‘*’ for this and horiz.

spacing
This is ‘m’ (monospace), ‘p’ (proportional) or ‘c’ (character cell).

width
The average character width, in pixels, multiplied by ten.

registry
encoding
The X font character set that the font depicts. (X font character sets are not the same as Emacs character sets, but they are similar.) You can use the xfontsel program to check which choices you have. Normally you should use ‘iso8859’ for registry and ‘1’ for encoding.

The fourth and final method of specifying a font is to use a font nickname. Certain fonts have shorter nicknames, which you can use instead of a normal font specification. For instance, ‘6x13’ is equivalent to

-misc-fixed-medium-r-semicondensed--13-*-*-*-c-60-iso8859-1
This form is not supported on MS-Windows.

On X, Emacs recognizes two types of fonts: client-side fonts, which are provided by the Xft and Fontconfig libraries, and server-side fonts, which are provided by the X server itself. Most client-side fonts support advanced font features such as antialiasing and subpixel hinting, while server-side fonts do not. Fontconfig and GTK patterns match only client-side fonts.

You will probably want to use a fixed-width default font—that is, a font in which all characters have the same width. For Xft and Fontconfig fonts, you can use the fc-list command to list the available fixed-width fonts, like this:

fc-list :spacing=mono
fc-list :spacing=charcell
For server-side X fonts, you can use the xlsfonts program to list the available fixed-width fonts, like this:

xlsfonts -fn '*x*' | grep -E '^[0-9]+x[0-9]+'
xlsfonts -fn '*-*-*-*-*-*-*-*-*-*-*-m*'
xlsfonts -fn '*-*-*-*-*-*-*-*-*-*-*-c*'
Any font with ‘m’ or ‘c’ in the spacing field of the XLFD is a fixed-width font. To see what a particular font looks like, use the xfd command. For example:

xfd -fn 6x13
displays the entire font ‘6x13’.

While running Emacs, you can also set the font of a specific kind of text (see Text Faces), or a particular frame (see Frame Parameters).


**** Speedbar Frames

The speedbar is a special frame for conveniently navigating in or operating on another frame. The speedbar, when it exists, is always associated with a specific frame, called its attached frame; all speedbar operations act on that frame.

Type M-x speedbar to create the speedbar and associate it with the current frame. To dismiss the speedbar, type M-x speedbar again, or select the speedbar and type q. (You can also delete the speedbar frame like any other Emacs frame.) If you wish to associate the speedbar with a different frame, dismiss it and call M-x speedbar from that frame.

The speedbar can operate in various modes. Its default mode is File Display mode, which shows the files in the current directory of the selected window of the attached frame, one file per line. Clicking on a non-directory visits that file in the selected window of the attached frame, and clicking on a directory shows that directory in the speedbar (see Following References with the Mouse). Each line also has a box, ‘[+]’ or ‘<+>’, that you can click on to expand the contents of that item. Expanding a directory adds the contents of that directory to the speedbar display, underneath the directory’s own line. Expanding an ordinary file adds a list of the tags in that file to the speedbar display; you can click on a tag name to jump to that tag in the selected window of the attached frame. When a file or directory is expanded, the ‘[+]’ changes to ‘[-]’; you can click on that box to contract the item, hiding its contents.

You navigate through the speedbar using the keyboard, too. Typing RET while point is on a line in the speedbar is equivalent to clicking the item on the current line, and SPC expands or contracts the item. U displays the parent directory of the current directory. To copy, delete, or rename the file on the current line, type C, D, and R respectively. To create a new directory, type M.

Another general-purpose speedbar mode is Buffer Display mode; in this mode, the speedbar displays a list of Emacs buffers. To switch to this mode, type b in the speedbar. To return to File Display mode, type f. You can also change the display mode by clicking mouse-3 anywhere in the speedbar window (or mouse-1 on the mode-line) and selecting ‘Displays’ in the pop-up menu.

Some major modes, including Rmail mode, Info, and GUD, have specialized ways of putting useful items into the speedbar for you to select. For example, in Rmail mode, the speedbar shows a list of Rmail files, and lets you move the current message to another Rmail file by clicking on its ‘<M>’ box.

For more details on using and programming the speedbar, See Speedbar in Speedbar Manual.


**** Multiple Displays

A single Emacs can talk to more than one X display. Initially, Emacs uses just one display—the one specified with the DISPLAY environment variable or with the ‘--display’ option (see Initial Options). To connect to another display, use the command make-frame-on-display:

M-x make-frame-on-display RET display RET
Create a new frame on display display.

A single X server can handle more than one screen. When you open frames on two screens belonging to one server, Emacs knows they share a single keyboard, and it treats all the commands arriving from these screens as a single stream of input.

When you open frames on different X servers, Emacs makes a separate input stream for each server. Each server also has its own selected frame. The commands you enter with a particular X server apply to that server’s selected frame.

On multi-monitor displays it is possible to use the command make-frame-on-monitor:

M-x make-frame-on-monitor RET monitor RET
Create a new frame on monitor monitor whose screen area is a part of the current display.


**** Frame Parameters

You can control the default appearance and behavior of all frames by specifying a default list of frame parameters in the variable default-frame-alist. Its value should be a list of entries, each specifying a parameter name and a value for that parameter. These entries take effect whenever Emacs creates a new frame, including the initial frame.

For example, you can add the following lines to your init file (see The Emacs Initialization File) to set the default frame width to 90 character columns, the default frame height to 40 character rows, and the default font to ‘Monospace-10’:

(add-to-list 'default-frame-alist '(width  . 90))
(add-to-list 'default-frame-alist '(height . 40))
(add-to-list 'default-frame-alist '(font . "Monospace-10"))
For a list of frame parameters and their effects, see Frame Parameters in The Emacs Lisp Reference Manual.

You can also specify a list of frame parameters which apply to just the initial frame, by customizing the variable initial-frame-alist.

If Emacs is compiled to use an X toolkit, frame parameters that specify colors and fonts don’t affect menus and the menu bar, since those are drawn by the toolkit and not directly by Emacs.

Frame appearance and behavior can also be customized through X resources (see X Options and Resources); these override the parameters of the initial frame specified in your init file.

Note that if you are using the desktop library to save and restore your sessions, the frames to be restored are recorded in the desktop file, together with their parameters. When these frames are restored, the recorded parameters take precedence over the frame parameters specified by default-frame-alist and initial-frame-alist in your init file. See Saving Emacs Sessions, for how to avoid that.


**** Scroll Bars

On graphical displays, there is a vertical scroll bar on the side of each Emacs window. Clicking mouse-1 on the scroll bar’s up and down buttons scrolls the window by one line at a time (but some toolkits allow you to customize the scroll bars to not have those buttons). Clicking mouse-1 above or below the scroll bar’s inner box scrolls the window by nearly the entire height of the window, like M-v and C-v respectively (see Changing the Location of Point). (This, too, can behave differently with some toolkits.) Dragging the inner box scrolls continuously.

If Emacs is compiled on the X Window System without X toolkit support, the scroll bar behaves differently. Clicking mouse-1 anywhere on the scroll bar scrolls forward like C-v, while mouse-3 scrolls backward like M-v. Clicking mouse-2 in the scroll bar lets you drag the inner box up and down.

To toggle the use of vertical scroll bars, type M-x scroll-bar-mode. This command applies to all frames, including frames yet to be created. To toggle vertical scroll bars for just the selected frame, use the command M-x toggle-scroll-bar.

To control the use of vertical scroll bars at startup, customize the variable scroll-bar-mode (see Customization). Its value should be either right (put scroll bars on the right side of windows), left (put them on the left), or nil (disable vertical scroll bars). By default, Emacs puts scroll bars on the right if it was compiled with GTK+ support on the X Window System, and on MS-Windows or macOS; Emacs puts scroll bars on the left if compiled on the X Window System without GTK+ support (following the old convention for X applications).

You can also use the X resource ‘verticalScrollBars’ to enable or disable the scroll bars (see X Resources). To control the scroll bar width, change the scroll-bar-width frame parameter (see Frame Parameters in The Emacs Lisp Reference Manual).

If you’re using Emacs on X (with GTK+ or Motif), you can customize the variable scroll-bar-adjust-thumb-portion to control overscrolling of the scroll bar, i.e., dragging the thumb down even when the end of the buffer is visible. If its value is non-nil, the scroll bar can be dragged downwards even if the end of the buffer is shown; if nil, the thumb will be at the bottom when the end of the buffer is shown. You cannot over-scroll when the entire buffer is visible.

The visual appearance of the scroll bars is controlled by the scroll-bar face. (Some toolkits, such as GTK+ and MS-Windows, ignore this face; the scroll-bar appearance there can only be customized system-wide, for GTK+ see GTK+ resources).

On graphical frames, vertical scroll bars implicitly serve to separate side-by-side windows visually. When vertical scroll bars are disabled, Emacs by default separates such windows with the help of a one-pixel wide vertical border. That border occupies the first pixel column of the window on the right and may thus overdraw the leftmost pixels of any glyph displayed there. If these pixels convey important information, you can make them visible by enabling window dividers, see Window Dividers. To replicate the look of vertical borders, set the right-divider-width parameter of frames to one and have the window-divider face inherit from that of vertical-border, Window Dividers in The Emacs Lisp Reference Manual.

On graphical displays with toolkit support, Emacs may also supply a horizontal scroll bar on the bottom of each window. Clicking mouse-1 on that scroll bar’s left and right buttons scrolls the window horizontally by one column at a time. (Note that some toolkits allow customizations of the scroll bar that cause these buttons not to be shown.) Clicking mouse-1 on the left or right of the scroll bar’s inner box scrolls the window by four columns. Dragging the inner box scrolls the window continuously.

Note that such horizontal scrolling can make the window’s position of point disappear on the left or the right. Typing a character to insert text or moving point with a keyboard command will usually bring it back into view.

To toggle the use of horizontal scroll bars, type M-x horizontal-scroll-bar-mode. This command applies to all frames, including frames yet to be created. To toggle horizontal scroll bars for just the selected frame, use the command M-x toggle-horizontal-scroll-bar.

To control the use of horizontal scroll bars at startup, customize the variable horizontal-scroll-bar-mode.

You can also use the X resource ‘horizontalScrollBars’ to enable or disable horizontal scroll bars (see X Resources). To control the scroll bar height, change the scroll-bar-height frame parameter (see Frame Parameters in The Emacs Lisp Reference Manual).


**** Window Dividers
On graphical displays, you can use window dividers in order to separate windows visually. Window dividers are bars that can be dragged with the mouse, thus allowing you to easily resize adjacent windows.

To toggle the display of window dividers, use the command M-x window-divider-mode.

To customize where dividers should appear, use the option window-divider-default-places. Its value should be either bottom-only (to show dividers only on the bottom of windows), right-only (to show dividers only on the right of windows), or t (to show them on the bottom and on the right).

To adjust the width of window dividers displayed by this mode customize the options window-divider-default-bottom-width and window-divider-default-right-width.

When vertical scroll bars are disabled, dividers can be also useful to make the first pixel column of a window visible, which would be otherwise covered by the vertical border used to separate side-by-side windows (see Scroll Bars).

For more details about window dividers see Window Dividers in The Emacs Lisp Reference Manual.


**** Drag and Drop

In most graphical desktop environments, Emacs has basic support for drag and drop operations. For instance, dropping text onto an Emacs frame inserts the text where it is dropped. Dropping a file onto an Emacs frame visits that file. As a special case, dropping the file on a Dired buffer moves or copies the file (according to the conventions of the application it came from) into the directory displayed in that buffer.

Dropping a file normally visits it in the window you drop it on. If you prefer to visit the file in a new window in such cases, customize the variable dnd-open-file-other-window.

The XDND and Motif drag and drop protocols, and the old KDE 1.x protocol, are currently supported.

It can be difficult to scroll a window or determine where dropped text will be inserted while dragging text onto an Emacs window. Setting the option dnd-indicate-insertion-point to a non-nil value makes point move to the location any dropped text will be inserted when the mouse moves in a window during drag, and setting dnd-scroll-margin to an integer value causes a window to be scrolled if the mouse moves within that many lines of the top or bottom of the window during drag.

Emacs can also optionally drag the region with the mouse into another portion of this or another buffer. To enable that, customize the variable mouse-drag-and-drop-region to a non-nil value. Normally, the text is moved, i.e. cut and pasted, when the destination is the same buffer as the origin; dropping the region on another buffer copies the text instead. If the value of this variable names a modifier key, such as ‘shift’, ‘control’ or ‘alt’, then pressing that modifier key when dropping the text will copy it instead of cutting it, even if you drop on the same buffer as the one from which the text came.

In order to cut text even when source and destination buffers differ, set the option mouse-drag-and-drop-region-cut-when-buffers-differ to a non-nil value. By default, on a graphic display the selected text is shown in a tooltip and point moves together with the mouse cursor during dragging. To suppress such behavior, set the options mouse-drag-and-drop-region-show-tooltip and/or mouse-drag-and-drop-region-show-cursor to nil.

To drag text from Emacs to other programs, set the option mouse-drag-and-drop-region-cross-program to a non-nil value.

On the X window system, some programs can drop files on Emacs, expecting Emacs to save them. Normally, Emacs will prompt for a file name under which the file will be saved, and then open the file, but that behavior can be changed by changing the variable x-dnd-direct-save-function. See Drag and Drop in The Emacs Lisp Reference Manual.


**** Menu Bars

You can toggle the use of menu bars with M-x menu-bar-mode. With no argument, this command toggles Menu Bar mode, a global minor mode. With an argument, the command turns Menu Bar mode on if the argument is positive, off if the argument is not positive. To control the use of menu bars at startup, customize the variable menu-bar-mode.

Expert users often turn off the menu bar, especially on text terminals, where this makes one additional line available for text. If the menu bar is off, you can still pop up a menu of its contents with C-mouse-3 on a display which supports pop-up menus. Or you can enable context-menu-mode and customize the variable context-menu-functions to pop up a context menu with mouse-3. See Mouse Clicks for Menus.

See The Menu Bar, for information on how to invoke commands with the menu bar. See X Options and Resources, for how to customize the menu bar menus’ visual appearance.


**** Tool Bars

On graphical displays, Emacs puts a tool bar at the top of each frame, just below the menu bar. This is a row of icons which you can click on with the mouse to invoke various commands.

The global (default) tool bar contains general commands. Some major modes define their own tool bars; whenever a buffer with such a major mode is current, the mode’s tool bar replaces the global tool bar.

To toggle the use of tool bars, type M-x tool-bar-mode. This command applies to all frames, including frames yet to be created. To control the use of tool bars at startup, customize the variable tool-bar-mode.

When Emacs is compiled with GTK+ support, each tool bar item can consist of an image, or a text label, or both. By default, Emacs follows the Gnome desktop’s tool bar style setting; if none is defined, it displays tool bar items as just images. To impose a specific tool bar style, customize the variable tool-bar-style.

You can also control the placement of the tool bar for the GTK+ tool bar with the frame parameter tool-bar-position. See Frame Parameters in The Emacs Lisp Reference Manual.

NS builds consider the tool bar to be a window decoration, and therefore do not display it when a window is undecorated. See Frame Parameters in The Emacs Lisp Reference Manual. On macOS the tool bar is hidden when the frame is put into fullscreen, but can be displayed by moving the mouse pointer to the top of the screen.


**** Tab Bars

On graphical displays and on text terminals, Emacs can optionally display a Tab Bar at the top of each frame, just below the menu bar (see Menu Bars) and above or below the tool bar (see Tool Bars) depending on the variable tab-bar-position. The Tab Bar is a row of tabs—buttons that you can click to switch between window configurations.

Each tab on the Tab Bar represents a named persistent window configuration of its frame, i.e., how that frame is partitioned into windows and which buffer is displayed in each window. The tab’s name is composed from the list of names of buffers shown in windows of that window configuration. Clicking on the tab switches to the window configuration recorded by the tab; it is a configuration of windows and buffers which was previously used in the frame when that tab was the current tab.

If you are using the desktop library to save and restore your sessions (see Saving Emacs Sessions), the tabs from the Tab Bar are recorded in the desktop file, together with their associated window configurations, and will be available after restoring the session.

Note that the Tab Bar is different from the Tab Line (see Window Tab Line). Whereas tabs on the Tab Line at the top of each window are used to switch between buffers in the window, tabs on the Tab Bar at the top of each frame are used to switch between window configurations containing several windows showing one or more buffers.

To toggle the use of Tab Bars, type M-x tab-bar-mode. This command applies to all frames, including frames yet to be created. To control the use of tab bars at startup, customize the variable tab-bar-mode and save your customization.

The variable tab-bar-show controls whether the Tab Bar mode is turned on automatically. If the value is t, then tab-bar-mode is enabled when using the commands that create new tabs. The value 1 hides the tab bar when it has only one tab, and shows it again when more tabs are created. More generally, a value that is a non-negative integer causes the Tab Bar to be displayed only if the number of tabs is greater than that integer. The value nil always keeps the Tab Bar hidden; in this case it’s still possible to switch between named window configurations without displaying the Tab Bar by using M-x tab-next, M-x tab-switcher, and other commands that provide completion on tab names. Also it’s possible to create and close tabs without the Tab Bar by using commands M-x tab-new, M-x tab-close, etc.

Note that a numerical value of tab-bar-show can cause the Tab Bar to be displayed on some frames, but not on others, depending on the number of tabs created on each frame.

To toggle the use of the Tab Bar only on the selected frame, type M-x toggle-frame-tab-bar. This command allows to enable the display of the Tab Bar on some frames and disable it on others, regardless of the values of tab-bar-mode and tab-bar-show.

The prefix key C-x t is analogous to C-x 5. Whereas each C-x 5 command pops up a buffer in a different frame (see Creating Frames), the C-x t commands use a different tab with a different window configuration in the selected frame.

The various C-x t commands differ in how they find or create the buffer to select. The following commands can be used to select a buffer in a new tab:

C-x t 2
Add a new tab (tab-new). You can control the choice of the buffer displayed in a new tab by customizing the variable tab-bar-new-tab-choice. You can control the names given by default to new tabs by customizing the variable tab-bar-tab-name-function.

C-x t b bufname RET
Select buffer bufname in another tab. This runs switch-to-buffer-other-tab.

C-x t f filename RET
Visit the file filename (see Visiting Files) and select its buffer in another tab. This runs find-file-other-tab.

C-x t d directory RET
Edit the specified directory (see Dired, the Directory Editor) in another tab. This runs dired-other-tab.

C-x t t
This is a prefix command (other-tab-prefix) that affects the next command invoked immediately after this prefix command. It requests the buffer displayed by the next command to be shown in another tab.

By default, a new tab starts with the buffer that was current before calling the command that adds a new tab. To start a new tab with other buffers, customize the variable tab-bar-new-tab-choice.

The variable tab-bar-new-tab-to defines where to place a new tab. By default, a new tab is added on the right side of the current tab.

The following commands can be used to delete tabs:

C-x t 0
Close the selected tab (tab-close). This has no effect if there is only one tab, unless the variable tab-bar-close-last-tab-choice is customized to a non-default value.

C-x t 1
Close all tabs, except the selected tab, on the selected frame.

The variable tab-bar-close-tab-select defines what tab to select after closing the current tab. By default, it selects a recently used tab.

The command tab-undo restores the last closed tab.

The following commands can be used to switch between tabs:

C-x t o
C-TAB
Switch to the next tab (tab-next). If you repeat this command, it cycles through all the tabs on the selected frame. With a positive numeric argument n, it switches to the nth next tab; with a negative argument −n, it switches back to the nth previous tab.

S-C-TAB
Switch to the previous tab (tab-previous). With a positive numeric argument n, it switches to the nth previous tab; with a negative argument −n, it switches to the nth next tab.

C-x t RET tabname RET
Switch to the tab by its name (tab-switch), with completion on all tab names. The default value and the “future history” of tab names is sorted by recency, so you can use M-n (next-history-element) to get the name of the last visited tab, the second last, and so on.

modifier-tab-number
Switch to the tab by its number tab-number (tab-select). After customizing the variable tab-bar-select-tab-modifiers to specify one or more modifier keys, you can select a tab by its ordinal number using one of the specified modifiers in combination with the tab number to select. The number 9 can be used to select the last tab. You can select any modifiers supported by Emacs, see Modifier Keys. To display the tab number alongside the tab name, you can customize another variable tab-bar-tab-hints. This will help you decide which numerical key to press to select the tab by its number.

modifier-9
Switch to the last tab (tab-last). The key combination is the modifier key defined by tab-bar-select-tab-modifiers and the key 9. With a numeric argument n, switch to the nth last tab.

modifier-0
Switch to the recent tab (tab-recent). The key combination is the modifier key defined by tab-bar-select-tab-modifiers and the key 0. With a numeric argument n, switch to the nth recent tab.

The following commands can be used to operate on tabs:

C-x t r tabname RET
Rename the current tab to tabname (tab-rename).

C-x t m
Move the current tab one position to the right (tab-move). With a positive numeric argument n, move it that many positions to the right; with a negative argument −n, move it n positions to the left.

You can use the mouse to operate on tabs. Clicking mouse-2 closes the tab. Clicking mouse-3 pops up the context menu with the items that operate on the clicked tab. Dragging the tab with mouse-1 moves it to another position on the tab bar. Mouse wheel scrolling switches to the next or previous tab. Holding down the SHIFT key during scrolling moves the tab to the left or right.

You can enable tab-bar-history-mode to remember window configurations used in every tab, and later restore them.

M-x tab-bar-history-back
Restore a previous window configuration used in the current tab. This navigates back in the history of window configurations.

M-x tab-bar-history-forward
Cancel restoration of the previous window configuration. This moves forward in the history of window configurations.

It’s possible to customize the items displayed on the tab bar by the user option tab-bar-format.


**** Using Dialog Boxes

A dialog box is a special kind of menu for asking you a yes-or-no question or some other special question. Many Emacs commands use a dialog box to ask a yes-or-no question, if you used the mouse to invoke the command that led to the question.

To disable the use of dialog boxes, change the variable use-dialog-box to nil. In that case, Emacs always performs yes-or-no prompts using the echo area and keyboard input. This variable also controls whether to use file selection windows (but those are not supported on all platforms).

A file selection window is a special kind of dialog box for asking for file names. You can customize the variable use-file-dialog to suppress the use of file selection windows, even if you still want other kinds of dialogs. This variable has no effect if you have suppressed all dialog boxes with the variable use-dialog-box.

When Emacs is compiled with GTK+ support, it uses the GTK+ file chooser dialog. Emacs adds an additional toggle button to this dialog, which you can use to enable or disable the display of hidden files (files starting with a dot) in that dialog. If you want this toggle to be activated by default, change the variable x-gtk-show-hidden-files to t. In addition, Emacs adds help text to the GTK+ file chooser dialog; to disable this help text, change the variable x-gtk-file-dialog-help-text to nil.


**** Tooltips

Tooltips are small special frames that display text information at the current mouse position. They activate when there is a pause in mouse movement over some significant piece of text in a window, or the mode line, or some other part of the Emacs frame such as a tool bar button or menu item.

You can toggle the use of tooltips with the command M-x tooltip-mode. When Tooltip mode is disabled, the help text is displayed in the echo area instead. To control the use of tooltips at startup, customize the variable tooltip-mode.

The following variables provide customization options for tooltip display:

tooltip-delay ¶
This variable specifies how long Emacs should wait before displaying the first tooltip. The value is in seconds.

tooltip-short-delay ¶
This variable specifies how long Emacs should wait before displaying subsequent tooltips on different items, having already displayed the first tooltip. The value is in seconds.

tooltip-hide-delay ¶
The number of seconds since displaying a tooltip to hide it, if the mouse doesn’t move.

tooltip-x-offset ¶
tooltip-y-offset ¶
The X and Y offsets, in pixels, of the left top corner of the tooltip from the mouse pointer position. Note that these are ignored if tooltip-frame-parameters was customized to include, respectively, the left and top parameters. The values of the offsets should be chosen so that the tooltip doesn’t cover the mouse pointer’s hot spot, or it might interfere with clicking the mouse.

tooltip-frame-parameters ¶
The frame parameters used for displaying tooltips. See Frame Parameters in The Emacs Lisp Reference Manual, and also Tooltips in The Emacs Lisp Reference Manual.

For additional customization options for displaying tooltips, use M-x customize-group RET tooltip RET.

If Emacs is built with the GTK+ toolkit, Nextstep windowing, or Haiku windowing support, it displays tooltips via the toolkit, using the default appearance of the toolkit’s tooltips.8 To disable this, change the variable use-system-tooltips to nil. If you do this, or if Emacs is built without the appropriate windowing support, most attributes of the tooltip text are specified by the tooltip face, and by X resources (see X Options and Resources).

GUD tooltips are special tooltips that show the values of variables when debugging a program with GUD. See Debugger Operation.

Footnotes
(8)
The foreground and background colors of toolkit-created tooltips on Nextstep can also be customized by setting the foreground and background frame parameters that are part of tooltip-frame-parameters.


**** Mouse Avoidance
On graphical terminals, the mouse pointer may obscure the text in the Emacs frame. Emacs provides two methods to avoid this problem.

Firstly, Emacs hides the mouse pointer each time you type a self-inserting character, if the pointer lies inside an Emacs frame; moving the mouse pointer makes it visible again. To disable this feature, set the variable make-pointer-invisible to nil. See Customization of Display.

Secondly, you can use Mouse Avoidance mode, a minor mode, to keep the mouse pointer away from point. To use Mouse Avoidance mode, customize the variable mouse-avoidance-mode. You can set this to various values to move the mouse in several ways:

banish
Move the pointer to a corner of the frame on any key-press. You can customize the variable mouse-avoidance-banish-position to specify where the pointer goes when it is banished.

exile
Banish the pointer only if the cursor gets too close, and allow it to return once the cursor is out of the way.

jump
If the cursor gets too close to the pointer, displace the pointer by a random distance and direction.

animate
As jump, but shows steps along the way for illusion of motion.

cat-and-mouse
The same as animate.

proteus
As animate, but changes the shape of the mouse pointer too.

You can also use the command M-x mouse-avoidance-mode to enable the mode. Whenever Mouse Avoidance mode moves the mouse, it also raises the frame.


**** Text Terminals

On a text terminal, Emacs can display only one Emacs frame at a time. However, you can still create multiple Emacs frames, and switch between them. Switching frames on these terminals is much like switching between different window configurations.

Use C-x 5 2 to create a new frame and switch to it; use C-x 5 o to cycle through the existing frames; use C-x 5 0 to delete the current frame.

Each frame has a number to distinguish it. If your terminal can display only one frame at a time, the selected frame’s number n appears near the beginning of the mode line, in the form ‘Fn’.

‘Fn’ is in fact the frame’s initial name. You can give frames more meaningful names if you wish, and you can select a frame by its name. Use the command M-x set-frame-name RET name RET to specify a new name for the selected frame, and use M-x select-frame-by-name RET name RET to select a frame according to its name. The name you specify appears in the mode line when the frame is selected.


**** Using a Mouse in Text Terminals

Some text terminals support mouse clicks in the terminal window.

In a terminal emulator which is compatible with xterm, you can use M-x xterm-mouse-mode to give Emacs control over simple uses of the mouse—basically, only non-modified single clicks are supported. Newer versions of xterm also support mouse-tracking. The normal xterm mouse functionality for such clicks is still available by holding down the SHIFT key when you press the mouse button. Xterm Mouse mode is a global minor mode (see Minor Modes). Repeating the command turns the mode off again.

In the console on GNU/Linux, you can use M-x gpm-mouse-mode to enable mouse support. You must have the gpm server installed and running on your system in order for this to work. Note that when this mode is enabled, you cannot use the mouse to transfer text between Emacs and other programs which use GPM. This is due to limitations in GPM and the Linux kernel.

See Mouse Usage on MS-DOS, for information about mouse support on MS-DOS.



** Controlling the Display

Since only part of a large buffer fits in the window, Emacs has to show only a part of it. This chapter describes commands and variables that let you specify which part of the text you want to see, and how the text is displayed.

*** Scrolling

If a window is too small to display all the text in its buffer, it displays only a portion of it. Scrolling commands change which portion of the buffer is displayed.

Scrolling forward or up advances the portion of the buffer displayed in the window; equivalently, it moves the buffer text upwards relative to the window. Scrolling backward or down displays an earlier portion of the buffer, and moves the text downwards relative to the window.

In Emacs, scrolling up or down refers to the direction that the text moves in the window, not the direction that the window moves relative to the text. This terminology was adopted by Emacs before the modern meaning of “scrolling up” and “scrolling down” became widespread. Hence, the strange result that PageDown scrolls up in the Emacs sense.

The portion of a buffer displayed in a window always contains point. If you move point past the bottom or top of the window, scrolling occurs automatically to bring it back onscreen (see Automatic Scrolling). You can also scroll explicitly with these commands:

C-v
PageDown
next
Scroll forward by nearly a full window (scroll-up-command).

M-v
PageUp
prior
Scroll backward (scroll-down-command).

C-v (scroll-up-command) scrolls forward by nearly the whole window height. The effect is to take the two lines at the bottom of the window and put them at the top, followed by lines that were not previously visible. If point was in the text that scrolled off the top, it ends up on the window’s new topmost line. The PageDown (or next) key is equivalent to C-v.

M-v (scroll-down-command) scrolls backward in a similar way. The PageUp (or prior) key is equivalent to M-v.

The number of lines of overlap left by these scroll commands is controlled by the variable next-screen-context-lines, whose default value is 2. You can supply the commands with a numeric prefix argument, n, to scroll by n lines; Emacs attempts to leave point unchanged, so that the text and point move up or down together. C-v with a negative argument is like M-v and vice versa.

By default, these commands signal an error (by beeping or flashing the screen) if no more scrolling is possible, because the window has reached the beginning or end of the buffer. If you change the variable scroll-error-top-bottom to t, these commands move point to the farthest possible position. If point is already there, the commands signal an error.

Some users like scroll commands to keep point at the same screen position, so that scrolling back to the same screen conveniently returns point to its original position. You can enable this behavior via the variable scroll-preserve-screen-position. If the value is t, Emacs adjusts point to keep the cursor at the same screen position whenever a scroll command moves it off-window, rather than moving it to the topmost or bottommost line. With any other non-nil value, Emacs adjusts point this way even if the scroll command leaves point in the window. This variable affects all the scroll commands documented in this section, as well as scrolling with the mouse wheel (see Mouse Commands for Editing); in general, it affects any command that has a non-nil scroll-command property. See Property Lists in The Emacs Lisp Reference Manual. The same property also causes Emacs not to exit incremental search when one of these commands is invoked and isearch-allow-scroll is non-nil (see Not Exiting Incremental Search).

Sometimes, particularly when you hold down keys such as C-v and M-v, activating keyboard auto-repeat, Emacs fails to keep up with the rapid rate of scrolling requested; the display doesn’t update and Emacs can become unresponsive to input for quite a long time. You can counter this sluggishness by setting the variable fast-but-imprecise-scrolling to a non-nil value. This instructs the scrolling commands not to fontify (see Font Lock mode) any unfontified text they scroll over, instead to assume it has the default face. This can cause Emacs to scroll to somewhat wrong buffer positions when the faces in use are not all the same size, even with single (i.e., without auto-repeat) scrolling operations.

As an alternative to setting fast-but-imprecise-scrolling you might prefer to enable jit-lock deferred fontification (see Font Lock mode). To do this, customize jit-lock-defer-time to a small positive number such as 0.25, or even 0.1 if you type quickly. This gives you less jerky scrolling when you hold down C-v, but the window contents after any action which scrolls into a fresh portion of the buffer will be momentarily unfontified.

Finally, a third alternative to these variables is redisplay-skip-fontification-on-input. If this variable is non-nil, skip some fontifications if there’s input pending. This usually does not affect the display because redisplay is completely skipped anyway if input was pending, but it can make scrolling smoother by avoiding unnecessary fontification.

The commands M-x scroll-up and M-x scroll-down behave similarly to scroll-up-command and scroll-down-command, except they do not obey scroll-error-top-bottom. Prior to Emacs 24, these were the default commands for scrolling up and down. The commands M-x scroll-up-line and M-x scroll-down-line scroll the current window by one line at a time. If you intend to use any of these commands, you might want to give them key bindings (see Rebinding Keys in Your Init File).


*** Recentering

C-l
Scroll the selected window so the current line is the center-most text line; on subsequent consecutive invocations, make the current line the top line, the bottom line, and so on in cyclic order. Possibly redisplay the screen too (recenter-top-bottom).

C-M-S-l
Scroll the other window; this is equivalent to C-l acting on the other window.

M-x recenter
Scroll the selected window so the current line is the center-most text line. Possibly redisplay the screen too.

C-M-l
Scroll heuristically to bring useful information onto the screen (reposition-window).

The C-l (recenter-top-bottom) command recenters the selected window, scrolling it so that the current screen line is exactly in the center of the window, or as close to the center as possible.

Typling C-l twice in a row (C-l C-l) scrolls the window so that point is on the topmost screen line. Typing a third C-l scrolls the window so that point is on the bottom-most screen line. Each successive C-l cycles through these three positions.

You can change the cycling order by customizing the list variable recenter-positions. Each list element should be the symbol top, middle, or bottom, or a number; an integer means to move the line to the specified screen line, while a floating-point number between 0.0 and 1.0 specifies a percentage of the screen space from the top of the window. The default, (middle top bottom), is the cycling order described above. Furthermore, if you change the variable scroll-margin to a non-zero value n, C-l always leaves at least n screen lines between point and the top or bottom of the window (see Automatic Scrolling).

You can also give C-l a prefix argument. A plain prefix argument, C-u C-l, simply recenters the line showing point. A positive argument n moves line showing point n lines down from the top of the window. An argument of zero moves point’s line to the top of the window. A negative argument −n moves point’s line n lines from the bottom of the window. When given an argument, C-l does not clear the screen or cycle through different screen positions.

If the variable recenter-redisplay has a non-nil value, each invocation of C-l also clears and redisplays the screen; the special value tty (the default) says to do this on text-terminal frames only. Redisplaying is useful in case the screen becomes garbled for any reason (see Garbage on the Screen).

The more primitive command M-x recenter behaves like recenter-top-bottom, but does not cycle among screen positions.

C-M-l (reposition-window) scrolls the current window heuristically in a way designed to get useful information onto the screen. For example, in a Lisp file, this command tries to get the entire current defun onto the screen if possible.


*** Automatic Scrolling

Emacs performs automatic scrolling when point moves out of the visible portion of the text. Normally, automatic scrolling centers point vertically in the window, but there are several ways to alter this behavior.

If you set scroll-conservatively to a small number n, then moving point just a little off the screen (no more than n lines) causes Emacs to scroll just enough to bring point back on screen; if doing so fails to make point visible, Emacs scrolls just far enough to center point in the window. If you set scroll-conservatively to a large number (larger than 100), automatic scrolling never centers point, no matter how far point moves; Emacs always scrolls text just enough to bring point into view, either at the top or bottom of the window depending on the scroll direction. By default, scroll-conservatively is 0, which means to always center point in the window. This said, in minibuffer windows, scrolling is always conservative by default because scroll-minibuffer-conservatively is non-nil, which takes precedence over scroll-conservatively.

Another way to control automatic scrolling is to customize the variable scroll-step. Its value determines the number of lines by which to automatically scroll, when point moves off the screen. If scrolling by that number of lines fails to bring point back into view, point is centered instead. The default value is zero, which (by default) causes point to always be centered after scrolling.

A third way to control automatic scrolling is to customize the variables scroll-up-aggressively and scroll-down-aggressively, which directly specify the vertical position of point after scrolling. The value of scroll-up-aggressively should be either nil (the default), or a floating point number f between 0 and 1. The latter means that when point goes below the bottom window edge (i.e., scrolling forward), Emacs scrolls the window so that point is f parts of the window height from the bottom window edge. Thus, larger f means more aggressive scrolling: more new text is brought into view. The default value, nil, is equivalent to 0.5.

Likewise, scroll-down-aggressively is used when point goes above the top window edge (i.e., scrolling backward). The value specifies how far point should be from the top margin of the window after scrolling. Thus, as with scroll-up-aggressively, a larger value is more aggressive.

Note that the variables scroll-conservatively, scroll-step, and scroll-up-aggressively / scroll-down-aggressively control automatic scrolling in contradictory ways. Therefore, you should pick no more than one of these methods to customize automatic scrolling. In case you customize multiple variables, the order of priority is: scroll-conservatively, then scroll-step, and finally scroll-up-aggressively / scroll-down-aggressively.

The variable scroll-margin restricts how close point can come to the top or bottom of a window (even if aggressive scrolling specifies a fraction f that is larger than the window portion between the top and the bottom margins). Its value is a number of screen lines; if point comes within that many lines of the top or bottom of the window, Emacs performs automatic scrolling. By default, scroll-margin is 0. The effective margin size is limited to a quarter of the window height by default, but this limit can be increased up to half (or decreased down to zero) by customizing maximum-scroll-margin.


*** Horizontal Scrolling

Horizontal scrolling means shifting all the lines sideways within a window, so that some of the text near the left margin is not displayed. When the text in a window is scrolled horizontally, text lines are truncated rather than continued (see Line Truncation). If a window shows truncated lines, Emacs performs automatic horizontal scrolling whenever point moves off the left or right edge of the screen. By default, all the lines in the window are scrolled horizontally together, but if you set the variable auto-hscroll-mode to the special value of current-line, only the line showing the cursor will be scrolled. To disable automatic horizontal scrolling entirely, set the variable auto-hscroll-mode to nil. Note that when the automatic horizontal scrolling is turned off, if point moves off the edge of the screen, the cursor disappears to indicate that. (On text terminals, the cursor is left at the edge instead.)

The variable hscroll-margin controls how close point can get to the window’s left and right edges before automatic scrolling occurs. It is measured in columns. For example, if the value is 5, then moving point within 5 columns of an edge causes horizontal scrolling away from that edge.

The variable hscroll-step determines how many columns to scroll the window when point gets too close to the edge. Zero, the default value, means to center point horizontally within the window. A positive integer value specifies the number of columns to scroll by. A floating-point number (whose value should be between 0 and 1) specifies the fraction of the window’s width to scroll by.

You can also perform explicit horizontal scrolling with the following commands:

C-x <
Scroll text in current window to the left (scroll-left).

C-x >
Scroll to the right (scroll-right).

C-x < (scroll-left) scrolls text in the selected window to the left by the full width of the window, less two columns. (In other words, the text in the window moves left relative to the window.) With a numeric argument n, it scrolls by n columns.

If the text is scrolled to the left, and point moves off the left edge of the window, the cursor will freeze at the left edge of the window, until point moves back to the displayed portion of the text. This is independent of the current setting of auto-hscroll-mode, which, for text scrolled to the left, only affects the behavior at the right edge of the window.

C-x > (scroll-right) scrolls similarly to the right. The window cannot be scrolled any farther to the right once it is displayed normally, with each line starting at the window’s left margin; attempting to do so has no effect. This means that you don’t have to calculate the argument precisely for C-x >; any sufficiently large argument will restore the normal display.

If you use those commands to scroll a window horizontally, that sets a lower bound for automatic horizontal scrolling. Automatic scrolling will continue to scroll the window, but never farther to the right than the amount you previously set by scroll-left. When auto-hscroll-mode is set to current-line, all the lines other than the one showing the cursor will be scrolled by that minimal amount.


*** Narrowing

Narrowing means focusing in on some portion of the buffer, making the rest temporarily inaccessible. The portion which you can still get to is called the accessible portion. Canceling the narrowing, which makes the entire buffer once again accessible, is called widening. The bounds of narrowing in effect in a buffer are called the buffer’s restriction.

Narrowing can make it easier to concentrate on a single subroutine or paragraph by eliminating clutter. It can also be used to limit the range of operation of a replace command or repeating keyboard macro.

C-x n n
Narrow down to between point and mark (narrow-to-region).

C-x n w
Widen to make the entire buffer accessible again (widen).

C-x n p
Narrow down to the current page (narrow-to-page).

C-x n d
Narrow down to the current defun (narrow-to-defun).

When you have narrowed down to a part of the buffer, that part appears to be all there is. You can’t see the rest, you can’t move into it (motion commands won’t go outside the accessible part), you can’t change it in any way. However, it is not gone, and if you save the file all the inaccessible text will be saved. The word ‘Narrow’ appears in the mode line whenever narrowing is in effect.

The primary narrowing command is C-x n n (narrow-to-region). It sets the current buffer’s restrictions so that the text in the current region remains accessible, but all text before the region or after the region is inaccessible. Point and mark do not change.

Alternatively, use C-x n p (narrow-to-page) to narrow down to the current page. See Pages, for the definition of a page. C-x n d (narrow-to-defun) narrows down to the defun containing point (see Top-Level Definitions, or Defuns).

The way to cancel narrowing is to widen with C-x n w (widen). This makes all text in the buffer accessible again.

You can get information on what part of the buffer you are narrowed down to using the C-x = command. See Cursor Position Information.

Because narrowing can easily confuse users who do not understand it, narrow-to-region is normally a disabled command. Attempting to use this command asks for confirmation and gives you the option of enabling it; if you enable the command, confirmation will no longer be required for it. See Disabling Commands.


*** View Mode

View mode is a minor mode that lets you scan a buffer by sequential screenfuls. It provides commands for scrolling through the buffer conveniently but not for changing it. Apart from the usual Emacs cursor motion commands, you can type SPC to scroll forward one windowful, S-SPC or DEL to scroll backward, and s to start an incremental search.

Typing q (View-quit) disables View mode, and switches back to the buffer and position before View mode was enabled. Typing e (View-exit) disables View mode, keeping the current buffer and position.

M-x view-buffer prompts for an existing Emacs buffer, switches to it, and enables View mode. M-x view-file prompts for a file and visits it with View mode enabled.


*** Follow Mode

Follow mode is a minor mode that makes two windows, both showing the same buffer, scroll as a single tall virtual window. To use Follow mode, go to a frame with just one window, split it into two side-by-side windows using C-x 3, and then type M-x follow-mode. From then on, you can edit the buffer in either of the two windows, or scroll either one; the other window follows it.

In Follow mode, if you move point outside the portion visible in one window and into the portion visible in the other window, that selects the other window—again, treating the two as if they were parts of one large window.

To turn off Follow mode, type M-x follow-mode a second time.


*** Text Faces

Emacs can display text in several different styles, called faces. Each face can specify various face attributes, such as the font, height, weight, slant, foreground and background color, and underlining or overlining. Most major modes assign faces to the text automatically, via Font Lock mode. See Font Lock mode, for more information about how these faces are assigned.

To see what faces are currently defined, and what they look like, type M-x list-faces-display. With a prefix argument, this prompts for a regular expression, and displays only faces with names matching that regular expression (see Syntax of Regular Expressions).

It’s possible for a given face to look different in different frames. For instance, some text terminals do not support all face attributes, particularly font, height, and width, and some support a limited range of colors. In addition, most Emacs faces are defined so that their attributes are different on light and dark frame backgrounds, for reasons of legibility. By default, Emacs automatically chooses which set of face attributes to display on each frame, based on the frame’s current background color. However, you can override this by giving the variable frame-background-mode a non-nil value. A value of dark makes Emacs treat all frames as if they have a dark background, whereas a value of light makes it treat all frames as if they have a light background.

You can customize a face to alter its attributes, and save those customizations for future Emacs sessions. See Customizing Faces, for details.

The default face is the default for displaying text, and all of its attributes are specified. Its background color is also used as the frame’s background color. See Colors for Faces.

Another special face is the cursor face. On graphical displays, the background color of this face is used to draw the text cursor. None of the other attributes of this face have any effect; the foreground color for text under the cursor is taken from the background color of the underlying text. On text terminals, the appearance of the text cursor is determined by the terminal, not by the cursor face.

You can also use X resources to specify attributes of any particular face. See X Resources.

Emacs can display variable-width fonts, but some Emacs commands, particularly indentation commands, do not account for variable character display widths. Therefore, we recommend not using variable-width fonts for most faces, particularly those assigned by Font Lock mode.


*** Colors for Faces

Faces can have various foreground and background colors. When you specify a color for a face—for instance, when customizing the face (see Customizing Faces)—you can use either a color name or an RGB triplet.

**** Color Names
A color name is a pre-defined name, such as ‘dark orange’ or ‘medium sea green’. To view a list of color names, type M-x list-colors-display. To control the order in which colors are shown, customize list-colors-sort. If you run this command on a graphical display, it shows the full range of color names known to Emacs (these are the standard X11 color names, defined in X’s rgb.txt file). If you run the command on a text terminal, it shows only a small subset of colors that can be safely displayed on such terminals. However, Emacs understands X11 color names even on text terminals; if a face is given a color specified by an X11 color name, it is displayed using the closest-matching terminal color.


**** RGB Triplets
An RGB triplet is a string of the form ‘#RRGGBB’. Each of the primary color components is represented by a hexadecimal number between ‘00’ (intensity 0) and ‘FF’ (the maximum intensity). It is also possible to use one, three, or four hex digits for each component, so ‘red’ can be represented as ‘#F00’, ‘#fff000000’, or ‘#ffff00000000’. The components must have the same number of digits. For hexadecimal values A to F, either upper or lower case are acceptable.

The M-x list-colors-display command also shows the equivalent RGB triplet for each named color. For instance, ‘medium sea green’ is equivalent to ‘#3CB371’.

You can change the foreground and background colors of a face with M-x set-face-foreground and M-x set-face-background. These commands prompt in the minibuffer for a face name and a color, with completion, and then set that face to use the specified color. They affect the face colors on all frames, but their effects do not persist for future Emacs sessions, unlike using the customization buffer or X resources. You can also use frame parameters to set foreground and background colors for a specific frame; See Frame Parameters.


*** Standard Faces

Here are the standard faces for specifying text appearance. You can apply them to specific text when you want the effects they produce.

default
This face is used for ordinary text that doesn’t specify any face. Its background color is used as the frame’s background color.

bold
This face uses a bold variant of the default font.

italic
This face uses an italic variant of the default font.

bold-italic
This face uses a bold italic variant of the default font.

underline
This face underlines text.

fixed-pitch
This face forces use of a fixed-width font. It’s reasonable to customize this face to use a different fixed-width font, if you like, but you should not make it a variable-width font.

fixed-pitch-serif
This face is like fixed-pitch, except the font has serifs and looks more like traditional typewriting.

variable-pitch
This face forces use of a variable-width (i.e., proportional) font. The font size picked for this face matches the font picked for the default (usually fixed-width) font.

variable-pitch-text
This is like the variable-pitch face (from which it inherits), but is slightly larger. A proportional font of the same height as a monospace font usually appears visually smaller, and can therefore be harder to read. When displaying longer texts, this face can be a good choice over the (slightly smaller) variable-pitch face.

shadow
This face is used for making the text less noticeable than the surrounding ordinary text. Usually this can be achieved by using shades of gray in contrast with either black or white default foreground color.

Here’s an incomplete list of faces used to highlight parts of the text temporarily for specific purposes. (Many other modes define their own faces for this purpose.)

highlight
This face is used for text highlighting in various contexts, such as when the mouse cursor is moved over a hyperlink.

isearch
This face is used to highlight the current Isearch match (see Incremental Search).

query-replace
This face is used to highlight the current Query Replace match (see Replacement Commands).

lazy-highlight
This face is used to highlight lazy matches for Isearch and Query Replace (matches other than the current one).

region
This face is used for displaying an active region (see The Mark and the Region). When Emacs is built with GTK+ support, its colors are taken from the current GTK+ theme.

secondary-selection
This face is used for displaying a secondary X selection (see Secondary Selection).

trailing-whitespace
The face for highlighting excess spaces and tabs at the end of a line when show-trailing-whitespace is non-nil (see Useless Whitespace).

escape-glyph
The face for displaying control characters and escape sequences (see How Text Is Displayed).

homoglyph
The face for displaying lookalike characters, i.e., characters that look like but are not the characters being represented (see How Text Is Displayed).

nobreak-space
The face for displaying no-break space characters (see How Text Is Displayed).

nobreak-hyphen
The face for displaying no-break hyphen characters (see How Text Is Displayed).

The following faces control the appearance of parts of the Emacs frame:

mode-line ¶
This is the base face used for the mode lines, as well as header lines and for menu bars when toolkit menus are not used. By default, it’s drawn with shadows for a raised effect on graphical displays, and drawn as the inverse of the default face on text terminals.

The mode-line-active and mode-line-inactive faces (which are the ones used on the mode lines) inherit from this face.

mode-line-active ¶
Like mode-line, but used for the mode line of the currently selected window. This face inherits from mode-line, so changes in that face affect mode lines in all windows.

mode-line-inactive ¶
Like mode-line, but used for mode lines of the windows other than the selected one (if mode-line-in-non-selected-windows is non-nil). This face inherits from mode-line, so changes in that face affect mode lines in all windows.

mode-line-highlight ¶
Like highlight, but used for mouse-sensitive portions of text on mode lines. Such portions of text typically pop up tooltips (see Tooltips) when the mouse pointer hovers above them.

mode-line-buffer-id ¶
This face is used for buffer identification parts in the mode line.

header-line ¶
Similar to mode-line for a window’s header line, which appears at the top of a window just as the mode line appears at the bottom. Most windows do not have a header line—only some special modes, such Info mode, create one.

header-line-highlight ¶
Similar to highlight and mode-line-highlight, but used for mouse-sensitive portions of text on header lines. This is a separate face because the header-line face might be customized in a way that does not interact well with highlight.

tab-line ¶
Similar to mode-line for a window’s tab line, which appears at the top of a window with tabs representing window buffers. See Window Tab Line.

vertical-border ¶
This face is used for the vertical divider between windows on text terminals.

minibuffer-prompt ¶
This face is used for the prompt strings displayed in the minibuffer. By default, Emacs automatically adds this face to the value of minibuffer-prompt-properties, which is a list of text properties (see Text Properties in the Emacs Lisp Reference Manual) used to display the prompt text. (This variable takes effect when you enter the minibuffer.)

fringe ¶
The face for the fringes to the left and right of windows on graphic displays. (The fringes are the narrow portions of the Emacs frame between the text area and the window’s right and left borders.) See Window Fringes.

cursor
The :background attribute of this face specifies the color of the text cursor. See Displaying the Cursor.

tooltip
This face is used for tooltip text. By default, if Emacs is built with GTK+ support, tooltips are drawn via GTK+ and this face has no effect. See Tooltips.

mouse
This face determines the color of the mouse pointer.

The following faces likewise control the appearance of parts of the Emacs frame, but only on text terminals, or when Emacs is built on X with no toolkit support. (For all other cases, the appearance of the respective frame elements is determined by system-wide settings.)

scroll-bar
This face determines the visual appearance of the scroll bar. See Scroll Bars.

tool-bar
This face determines the color of tool bar icons. See Tool Bars.

tab-bar
This face determines the color of tab bar icons. See Tab Bars.

menu ¶
This face determines the colors and font of Emacs’s menus. See Menu Bars.

tty-menu-enabled-face ¶
This face is used to display enabled menu items on text-mode terminals.

tty-menu-disabled-face
This face is used to display disabled menu items on text-mode terminals.

tty-menu-selected-face
This face is used to display on text-mode terminals the menu item that would be selected if you click a mouse or press RET.


*** Icons

Emacs sometimes displays clickable buttons (or other informative icons), and you can customize how these look on display.

The main customization point here is the icon-preference user option. By using this, you can tell Emacs your overall preferences for icons. This is a list of icon types, and the first icon type that’s supported will be used. The supported types are:

image
Use an image for the icon.

emoji
Use a colorful emoji for the icon.

symbol
Use a monochrome symbol for the icon.

text
Use a simple text for the icon.

In addition, each individual icon can be customized with M-x customize-icon, and themes can further alter the looks of the icons.

To get a quick description of an icon, use the M-x describe-icon command.


*** Text Scale

To increase the font size of the default face in the current buffer, type C-x C-+ or C-x C-=. To decrease it, type C-x C--. To restore the default (global) font size, type C-x C-0. These keys are all bound to the same command, text-scale-adjust, which looks at the last key typed to determine which action to take and adjusts the font size accordingly by changing the height of the default face.

Most faces don’t have an explicit setting of the :height attribute, and thus inherit the height from the default face. Those faces are also scaled by the above commands.

Faces other than default that have an explicit setting of the :height attribute are not affected by these font size changes. The header-line face is an exception: it will be scaled even if it has an explicit setting of the :height attribute.

Similarly, scrolling the mouse wheel with the Ctrl modifier pressed, when the mouse pointer is above buffer text, will increase or decrease the font size of the affected faces, depending on the direction of the scrolling.

The final key of these commands may be repeated without the leading C-x and without the modifiers. For instance, C-x C-= C-= C-= and C-x C-= = = increase the face height by three steps. Each step scales the text height by a factor of 1.2; to change this factor, customize the variable text-scale-mode-step. A numeric argument of 0 to the text-scale-adjust command restores the default height, the same as typing C-x C-0.

Similarly, to change the sizes of the fonts globally, type C-x C-M-+, C-x C-M-=, C-x C-M-- or C-x C-M-0, or scroll the mouse wheel with both the Ctrl and Meta modifiers pressed. To enable frame resizing when the font size is changed globally, customize the variable global-text-scale-adjust-resizes-frames (see Easy Customization Interface).

The commands text-scale-increase and text-scale-decrease increase or decrease the size of the font in the current buffer, just like C-x C-+ and C-x C-- respectively. You may find it convenient to bind to these commands, rather than text-scale-adjust.

The command text-scale-set scales the size of the font in the current buffer to an absolute level specified by its prefix argument.

The above commands automatically enable the minor mode text-scale-mode if the current font scaling is other than 1, and disable it otherwise.

The command text-scale-pinch increases or decreases the text scale based on the distance between fingers on a touchpad when a pinch gesture is performed by placing two fingers on a touchpad and moving them towards or apart from each other. This is only available on some systems with supported hardware.

The command mouse-wheel-text-scale also changes the text scale. Normally, it is run when you press Ctrl while moving the mouse wheel. The text scale is increased when the wheel is moved downwards, and it is decreased when the wheel is moved upwards.


*** Font Lock mode

Font Lock mode is a minor mode, always local to a particular buffer, which assigns faces to (or fontifies) the text in the buffer. Each buffer’s major mode tells Font Lock mode which text to fontify; for instance, programming language modes fontify syntactically relevant constructs like comments, strings, and function names.

Font Lock mode is enabled by default in major modes that support it. To toggle it in the current buffer, type M-x font-lock-mode. A positive numeric argument unconditionally enables Font Lock mode, and a negative or zero argument disables it.

Type M-x global-font-lock-mode to toggle Font Lock mode in all buffers. To impose this setting for future Emacs sessions, customize the variable global-font-lock-mode (see Easy Customization Interface), or add the following line to your init file:

(global-font-lock-mode 0)
If you have disabled Global Font Lock mode, you can still enable Font Lock for specific major modes by adding the function font-lock-mode to the mode hooks (see Hooks). For example, to enable Font Lock mode for editing C files, you can do this:

(add-hook 'c-mode-hook 'font-lock-mode)
Font Lock mode uses several specifically named faces to do its job, including font-lock-string-face, font-lock-comment-face, and others. The easiest way to find them all is to use M-x customize-group RET font-lock-faces RET. You can then use that customization buffer to customize the appearance of these faces. See Customizing Faces.

Fontifying very large buffers can take a long time. To avoid large delays when a file is visited, Emacs initially fontifies only the visible portion of a buffer. As you scroll through the buffer, each portion that becomes visible is fontified as soon as it is displayed; this type of Font Lock is called Just-In-Time (or JIT) Lock. You can control how JIT Lock behaves, including telling it to perform fontification while idle, by customizing variables in the customization group ‘jit-lock’. See Customizing Specific Items.

The information that major modes use for determining which parts of buffer text to fontify and what faces to use can be based on several different ways of analyzing the text:

Search for keywords and other textual patterns based on regular expressions (see Regular Expression Search).
Find syntactically distinct parts of text based on built-in syntax tables (see Syntax Tables in The Emacs Lisp Reference Manual).
Use syntax tree produced by a full-blown parser, via a special-purpose library, such as the tree-sitter library (see Parsing Program Source in The Emacs Lisp Reference Manual), or an external program.

**** Traditional Font Lock

“Traditional” methods of providing font-lock information are based on regular-expression search and on syntactic analysis using syntax tables built into Emacs. This subsection describes the use and customization of font-lock for major modes which use these traditional methods.

You can control the amount of fontification applied by Font Lock mode by customizing the variable font-lock-maximum-decoration, for major modes that support this feature. The value of this variable should be a number (with 1 representing a minimal amount of fontification; some modes support levels as high as 3); or t, meaning “as high as possible” (the default). To be effective for a given file buffer, the customization of font-lock-maximum-decoration should be done before the file is visited; if you already have the file visited in a buffer when you customize this variable, kill the buffer and visit the file again after the customization.

You can also specify different numbers for particular major modes; for example, to use level 1 for C/C++ modes, and the default level otherwise, use the value

'((c-mode . 1) (c++-mode . 1)))
Comment and string fontification (or “syntactic” fontification) relies on analysis of the syntactic structure of the buffer text. For the sake of speed, some modes, including Lisp mode, rely on a special convention: an open-parenthesis or open-brace in the leftmost column always defines the beginning of a defun, and is thus always outside any string or comment. Therefore, you should avoid placing an open-parenthesis or open-brace in the leftmost column, if it is inside a string or comment. See Left Margin Convention, for details.

Font Lock highlighting patterns already exist for most modes, but you may want to fontify additional patterns. You can use the function font-lock-add-keywords, to add your own highlighting patterns for a particular mode. For example, to highlight ‘FIXME:’ words in C comments, use this:

(add-hook 'c-mode-hook
(lambda ()
(font-lock-add-keywords nil
'(("\\<\\(FIXME\\):" 1
font-lock-warning-face t)))))
To remove keywords from the font-lock highlighting patterns, use the function font-lock-remove-keywords. See Search-based Fontification in The Emacs Lisp Reference Manual. Alternatively, you can selectively disable highlighting due to some keywords by customizing the font-lock-ignore option, see Customizing Keywords in The Emacs Lisp Reference Manual.


**** Parser-based Font Lock

If your Emacs was built with the tree-sitter library, it can use the results of parsing the buffer text by that library for the purposes of fontification. This is usually faster and more accurate than the “traditional” methods described in the previous subsection, since the tree-sitter library provides full-blown parsers for programming languages and other kinds of formatted text which it supports. Major modes which utilize the tree-sitter library are named foo-ts-mode, with the ‘-ts-’ part indicating the use of the library. This subsection documents the Font Lock support based on the tree-sitter library.

You can control the amount of fontification applied by Font Lock mode of major modes based on tree-sitter by customizing the variable treesit-font-lock-level. Its value is a number between 1 and 4:

Level 1
This level usually fontifies only comments and function names in function definitions.

Level 2
This level adds fontification of keywords, strings, and data types.

Level 3
This is the default level; it adds fontification of assignments, numbers, etc.

Level 4
This level adds everything else that can be fontified: operators, delimiters, brackets, other punctuation, function names in function calls, property look ups, variables, etc.

What exactly constitutes each of the syntactical categories mentioned above depends on the major mode and the parser grammar used by tree-sitter for the major-mode’s language. However, in general the categories follow the conventions of the programming language or the file format supported by the major mode. The buffer-local value of the variable treesit-font-lock-feature-list holds the fontification features supported by a tree-sitter based major mode, where each sub-list shows the features provided by the corresponding fontification level.

Once you change the value of treesit-font-lock-level via M-x customize-variable (see Customizing Specific Items), it takes effect immediately in all the existing buffers and for files you visit in the future in the same session.


*** Interactive Highlighting

Highlight Changes mode is a minor mode that highlights the parts of the buffer that were changed most recently, by giving that text a different face. To enable or disable Highlight Changes mode, use M-x highlight-changes-mode.

Hi Lock mode is a minor mode that highlights text that matches regular expressions you specify. For example, you can use it to highlight all the references to a certain variable in a program source file, highlight certain parts in a voluminous output of some program, or highlight certain names in an article. To enable or disable Hi Lock mode, use the command M-x hi-lock-mode. To enable Hi Lock mode for all buffers, use M-x global-hi-lock-mode or place (global-hi-lock-mode 1) in your .emacs file.

Hi Lock mode works like Font Lock mode (see Font Lock mode), except that you specify explicitly the regular expressions to highlight. You can control them with the following commands. (The key bindings below that begin with C-x w are deprecated in favor of the global M-s h bindings, and will be removed in some future Emacs version.)

M-s h r regexp RET face RET ¶
C-x w h regexp RET face RET
Highlight text that matches regexp using face face (highlight-regexp). The highlighting will remain as long as the buffer is loaded. For example, to highlight all occurrences of the word “whim” using the default face (a yellow background), type M-s h r whim RET RET. Any face can be used for highlighting, Hi Lock provides several of its own and these are pre-loaded into a list of default values. While being prompted for a face use M-n and M-p to cycle through them. A prefix numeric argument limits the highlighting to the corresponding subexpression.

Setting the option hi-lock-auto-select-face to a non-nil value causes this command (and other Hi Lock commands that read faces) to automatically choose the next face from the default list without prompting.

You can use this command multiple times, specifying various regular expressions to highlight in different ways.

M-s h u regexp RET ¶
C-x w r regexp RET
Unhighlight regexp (unhighlight-regexp). If you invoke this from the menu, you select the expression to unhighlight from a list. If you invoke this from the keyboard, you use the minibuffer. It will show the most recently added regular expression; use M-n to show the next older expression and M-p to select the next newer expression. (You can also type the expression by hand, with completion.) When the expression you want to unhighlight appears in the minibuffer, press RET to exit the minibuffer and unhighlight it.

M-s h l regexp RET face RET ¶
C-x w l regexp RET face RET
Highlight entire lines containing a match for regexp, using face face (highlight-lines-matching-regexp).

M-s h p phrase RET face RET ¶
C-x w p phrase RET face RET
Highlight matches of phrase, using face face (highlight-phrase). phrase can be any regexp, but spaces will be replaced by matches to whitespace and initial lower-case letters will become case insensitive.

M-s h . ¶
C-x w .
Highlight the symbol found near point, using the next available face (highlight-symbol-at-point).

M-s h w ¶
C-x w b
Insert all the current highlighting regexp/face pairs into the buffer at point, with comment delimiters to prevent them from changing your program. (This key binding runs the hi-lock-write-interactive-patterns command.)

These patterns are extracted from the comments, if appropriate, if you invoke M-x hi-lock-find-patterns, or if you visit the file while Hi Lock mode is enabled (since that runs hi-lock-find-patterns).

M-s h f ¶
C-x w i
Extract regexp/face pairs from comments in the current buffer (hi-lock-find-patterns). Thus, you can enter patterns interactively with highlight-regexp, store them into the file with hi-lock-write-interactive-patterns, edit them (perhaps including different faces for different parenthesized parts of the match), and finally use this command (hi-lock-find-patterns) to have Hi Lock highlight the edited patterns.

The variable hi-lock-file-patterns-policy controls whether Hi Lock mode should automatically extract and highlight patterns found in a file when it is visited. Its value can be nil (never highlight), ask (query the user), or a function. If it is a function, hi-lock-find-patterns calls it with the patterns as argument; if the function returns non-nil, the patterns are used. The default is ask. Note that patterns are always highlighted if you call hi-lock-find-patterns directly, regardless of the value of this variable.

Also, hi-lock-find-patterns does nothing if the current major mode’s symbol is a member of the list hi-lock-exclude-modes.


*** Window Fringes

On graphical displays, each Emacs window normally has narrow fringes on the left and right edges. The fringes are used to display symbols that provide information about the text in the window. You can type M-x fringe-mode to toggle display of the fringes or to modify their width. This command affects fringes in all frames; to modify fringes on the selected frame only, use M-x set-fringe-style. You can make your changes to the fringes permanent by customizing the variable fringe-mode.

The most common use of the fringes is to indicate a continuation line (see Continuation Lines). When one line of text is split into multiple screen lines, the left fringe shows a curving arrow for each screen line except the first, indicating that this is not the real beginning. The right fringe shows a curving arrow for each screen line except the last, indicating that this is not the real end. If the line’s direction is right-to-left (see Bidirectional Editing), the meanings of the curving arrows in the fringes are swapped.

The fringes indicate line truncation (see Line Truncation) with short horizontal arrows meaning there’s more text on this line which is scrolled horizontally out of view. Clicking the mouse on one of the arrows scrolls the display horizontally in the direction of the arrow.

The fringes can also indicate other things, such as buffer boundaries (see Displaying Boundaries), unused lines near the end of the window (see indicate-empty-lines), and where a program you are debugging is executing (see Running Debuggers Under Emacs).

The fringe is also used for drawing the cursor, if the current line is exactly as wide as the window and point is at the end of the line. To disable this, change the variable overflow-newline-into-fringe to nil; this causes Emacs to continue or truncate lines that are exactly as wide as the window.

If you customize fringe-mode to remove the fringes on one or both sides of the window display, the features that display on the fringe are not available. Indicators of line continuation and truncation are an exception: when fringes are not available, Emacs uses the leftmost and rightmost character cells to indicate continuation and truncation with special ASCII characters, see Continuation Lines, and Line Truncation. This reduces the width available for displaying text on each line, because the character cells used for truncation and continuation indicators are reserved for that purpose. Since buffer text can include bidirectional text, and thus both left-to-right and right-to-left paragraphs (see Bidirectional Editing), removing only one of the fringes still reserves two character cells, one on each side of the window, for truncation and continuation indicators, because these indicators are displayed on opposite sides of the window in right-to-left paragraphs.


*** Displaying Boundaries

Emacs can display an indication of the fill-column position (see Explicit Fill Commands). The fill-column indicator is a useful functionality especially in prog-mode and its descendants (see Major Modes) to indicate the position of a specific column that has some special meaning for formatting the source code of a program. This assumes the buffer uses a fixed-pitch font, where all the characters (with the possible exception of double-width characters) have the same width on display. If the buffer uses variable-pitch fonts, the fill-column indicators on different lines might appear unaligned.

To activate the fill-column indication display, use the minor modes display-fill-column-indicator-mode and global-display-fill-column-indicator-mode, which enable the indicator locally or globally, respectively.

Alternatively, you can set the two buffer-local variables display-fill-column-indicator and display-fill-column-indicator-character to activate the indicator and control the character used for the indication. Note that both variables must be non-nil for the indication to be displayed. (Turning on the minor mode sets both these variables.)

There are 2 buffer local variables and a face to customize this mode:

display-fill-column-indicator-column ¶
Specifies the column number where the indicator should be set. It can take positive numerical values for the column, or the special value t, which means that the value of the variable fill-column will be used.

Any other value disables the indicator. The default value is t.

display-fill-column-indicator-character ¶
Specifies the character used for the indicator. This character can be any valid character including Unicode ones if the font supports them. The value nil disables the indicator. When the mode is enabled through the functions display-fill-column-indicator-mode or global-display-fill-column-indicator-mode, they will use the character specified by this variable, if it is non-nil; otherwise Emacs will use the character U+2502 BOX DRAWINGS LIGHT VERTICAL, falling back to ‘|’ if U+2502 cannot be displayed.

fill-column-indicator ¶
Specifies the face used to display the indicator. It inherits its default values from the face shadow, but without background color. To change the indicator color, you need only set the foreground color of this face.

On graphical displays, Emacs can indicate the buffer boundaries in the fringes. If you enable this feature, the first line and the last line are marked with angle images in the fringes. This can be combined with up and down arrow images which say whether it is possible to scroll the window.

The buffer-local variable indicate-buffer-boundaries controls how the buffer boundaries and window scrolling is indicated in the fringes. If the value is left or right, both angle and arrow bitmaps are displayed in the left or right fringe, respectively.

If value is an alist (see Association Lists in the Emacs Lisp Reference Manual), each element (indicator . position) specifies the position of one of the indicators. The indicator must be one of top, bottom, up, down, or t which specifies the default position for the indicators not present in the alist. The position is one of left, right, or nil which specifies not to show this indicator.

For example, ((top . left) (t . right)) places the top angle bitmap in left fringe, the bottom angle bitmap in right fringe, and both arrow bitmaps in right fringe. To show just the angle bitmaps in the left fringe, but no arrow bitmaps, use ((top . left) (bottom . left)).


*** Useless Whitespace

It is easy to leave unnecessary spaces at the end of a line, or empty lines at the end of a buffer, without realizing it. In most cases, this trailing whitespace has no effect, but sometimes it can be a nuisance.

You can make trailing whitespace at the end of a line visible by setting the buffer-local variable show-trailing-whitespace to t. Then Emacs displays trailing whitespace, using the face trailing-whitespace.

This feature does not apply when point is at the end of the line containing the whitespace. Strictly speaking, that is trailing whitespace nonetheless, but displaying it specially in that case looks ugly while you are typing in new text. In this special case, the location of point is enough to show you that the spaces are present.

Type M-x delete-trailing-whitespace to delete all trailing whitespace. This command deletes all extra spaces at the end of each line in the buffer, and all empty lines at the end of the buffer; to ignore the latter, change the variable delete-trailing-lines to nil. If the region is active, the command instead deletes extra spaces at the end of each line in the region.

On graphical displays, Emacs can indicate unused lines at the end of the window with a small image in the left fringe (see Window Fringes). The image appears for screen lines that do not correspond to any buffer text, so blank lines at the end of the buffer stand out because they lack this image. To enable this feature, set the buffer-local variable indicate-empty-lines to a non-nil value. You can enable or disable this feature for all new buffers by setting the default value of this variable, e.g., (setq-default indicate-empty-lines t).

Whitespace mode is a buffer-local minor mode that lets you visualize many kinds of whitespace in the buffer, by either drawing the whitespace characters with a special face or displaying them as special glyphs. To toggle this mode, type M-x whitespace-mode. The kinds of whitespace visualized are determined by the list variable whitespace-style. Individual elements in that list can be toggled on or off in the current buffer by typing M-x whitespace-toggle-options. Here is a partial list of possible elements (see the variable’s documentation for the full list):

face
Enable all visualizations which use special faces. This element has a special meaning: if it is absent from the list, none of the other visualizations take effect except space-mark, tab-mark, and newline-mark.

trailing
Highlight trailing whitespace.

tabs
Highlight tab characters.

spaces
Highlight space and non-breaking space characters.

lines ¶
Highlight lines longer than 80 columns. To change the column limit, customize the variable whitespace-line-column.

newline
Highlight newlines.

missing-newline-at-eof
Highlight the final character if the buffer doesn’t end with a newline character.

empty
Highlight empty lines at the beginning and/or end of the buffer.

big-indent ¶
Highlight too-deep indentation. By default any sequence of at least 4 consecutive tab characters or 32 consecutive space characters is highlighted. To change that, customize the regular expression whitespace-big-indent-regexp.

space-mark
Draw space and non-breaking characters with a special glyph.

tab-mark
Draw tab characters with a special glyph.

newline-mark
Draw newline characters with a special glyph.

Global Whitespace mode is a global minor mode that lets you visualize whitespace in all buffers. To toggle individual features, use M-x global-whitespace-toggle-options.


*** Selective Display

Emacs has the ability to hide lines indented more than a given number of columns. You can use this to get an overview of a part of a program.

To hide lines in the current buffer, type C-x $ (set-selective-display) with a numeric argument n. Then lines with at least n columns of indentation disappear from the screen. The only indication of their presence is that three dots (‘…’) appear at the end of each visible line that is followed by one or more hidden ones.

The commands C-n and C-p move across the hidden lines as if they were not there.

The hidden lines are still present in the buffer, and most editing commands see them as usual, so you may find point in the middle of the hidden text. When this happens, the cursor appears at the end of the previous line, after the three dots. If point is at the end of the visible line, before the newline that ends it, the cursor appears before the three dots.

To make all lines visible again, type C-x $ with no argument.

If you set the variable selective-display-ellipses to nil, the three dots do not appear at the end of a line that precedes hidden lines. Then there is no visible indication of the hidden lines. This variable becomes local automatically when set.

See also Outline Mode for another way to hide part of the text in a buffer.


*** Optional Mode Line Features

The buffer percentage pos indicates the percentage of the buffer above the top of the window. You can additionally display the size of the buffer by typing M-x size-indication-mode to turn on Size Indication mode. The size will be displayed immediately following the buffer percentage like this:

pos of size
Here size is the human readable representation of the number of characters in the buffer, which means that ‘k’ for 10^3, ‘M’ for 10^6, ‘G’ for 10^9, etc., are used to abbreviate.

The current line number of point appears in the mode line when Line Number mode is enabled. Use the command M-x line-number-mode to turn this mode on and off; normally it is on. The line number appears after the buffer percentage pos, with the letter ‘L’ to indicate what it is.

Similarly, you can display the current column number by turning on Column Number mode with M-x column-number-mode. The column number is indicated by the letter ‘C’. However, when both of these modes are enabled, the line and column numbers are displayed in parentheses, the line number first, rather than with ‘L’ and ‘C’. For example: ‘(561,2)’. See Minor Modes, for more information about minor modes and about how to use these commands.

In Column Number mode, the displayed column number counts from zero starting at the left margin of the window. If you would prefer for the displayed column number to count from one, you may set column-number-indicator-zero-based to nil.

If you have narrowed the buffer (see Narrowing), the displayed line number is relative to the accessible portion of the buffer. Thus, it isn’t suitable as an argument to goto-line. (The command what-line shows the line number relative to the whole file.) You can use goto-line-relative command to move point to the line relative to the accessible portion of the narrowed buffer.

If the buffer is very large (larger than the value of line-number-display-limit), Emacs won’t compute the line number, because that would be too slow; therefore, the line number won’t appear on the mode-line. To remove this limit, set line-number-display-limit to nil.

Line-number computation can also be slow if the lines in the buffer are too long. For this reason, Emacs doesn’t display line numbers if the average width, in characters, of lines near point is larger than the value of line-number-display-limit-width. The default value is 200 characters.

Emacs can optionally display the time and system load in all mode lines. To enable this feature, type M-x display-time or customize the option display-time-mode. The information added to the mode line looks like this:

hh:mmPM l.ll
Here hh and mm are the hour and minute, followed always by ‘AM’ or ‘PM’. l.ll is the average number, collected for the last few minutes, of processes in the whole system that were either running or ready to run (i.e., were waiting for an available processor). (Some fields may be missing if your operating system cannot support them.) If you prefer time display in 24-hour format, set the variable display-time-24hr-format to t.

The word ‘Mail’ appears after the load level if there is mail for you that you have not read yet. On graphical displays, you can use an icon instead of ‘Mail’ by customizing display-time-use-mail-icon; this may save some space on the mode line. You can customize display-time-mail-face to make the mail indicator prominent. Use display-time-mail-file to specify the mail file to check, or set display-time-mail-directory to specify the directory to check for incoming mail (any nonempty regular file in the directory is considered to be newly arrived mail).

When running Emacs on a laptop computer, you can display the battery charge on the mode-line, by using the command display-battery-mode or customizing the variable display-battery-mode. The variable battery-mode-line-format determines the way the battery charge is displayed; the exact mode-line message depends on the operating system, and it usually shows the current battery charge as a percentage of the total charge. The functions in battery-update-functions are run after updating the mode line, and can be used to trigger actions based on the battery status.

On graphical displays, the mode line is drawn as a 3D box. If you don’t like this effect, you can disable it by customizing the mode-line face and setting its box attribute to nil. See Customizing Faces.

By default, the mode line of nonselected windows is displayed in a different face, called mode-line-inactive. Only the selected window is displayed in the mode-line face. This helps show which window is selected. When the minibuffer is selected, since it has no mode line, the window from which you activated the minibuffer has its mode line displayed using mode-line; as a result, ordinary entry to the minibuffer does not change any mode lines.

You can disable use of mode-line-inactive by setting variable mode-line-in-non-selected-windows to nil; then all mode lines are displayed in the mode-line face.

You can customize the mode line display for each of the end-of-line formats by setting each of the variables eol-mnemonic-unix, eol-mnemonic-dos, eol-mnemonic-mac, and eol-mnemonic-undecided to the strings you prefer.


*** How Text Is Displayed

Most characters are printing characters: when they appear in a buffer, they are displayed literally on the screen. Printing characters include ASCII numbers, letters, and punctuation characters, as well as many non-ASCII characters.

The ASCII character set contains non-printing control characters. Two of these are displayed specially: the newline character (Unicode code point U+000A) is displayed by starting a new line, while the tab character (U+0009) is displayed as a space that extends to the next tab stop column (normally every 8 columns). The number of spaces per tab is controlled by the buffer-local variable tab-width, which must have an integer value between 1 and 1000, inclusive. Note that the way the tab character in the buffer is displayed has nothing to do with the definition of TAB as a command.

Other ASCII control characters, whose codes are below U+0020 (octal 40, decimal 32), are displayed as a caret (‘^’) followed by the non-control version of the character, with the escape-glyph face. For instance, the ‘control-A’ character, U+0001, is displayed as ‘^A’.

The raw bytes with codes U+0080 (octal 200) through U+009F (octal 237) are displayed as octal escape sequences, with the escape-glyph face. For instance, character code U+0098 (octal 230) is displayed as ‘\230’. If you change the buffer-local variable ctl-arrow to nil, the ASCII control characters are also displayed as octal escape sequences instead of caret escape sequences. (You can also request that raw bytes be shown in hex, see display-raw-bytes-as-hex.)

Some non-ASCII characters have the same appearance as an ASCII space or hyphen (minus) character. Such characters can cause problems if they are entered into a buffer without your realization, e.g., by yanking; for instance, source code compilers typically do not treat non-ASCII spaces as whitespace characters. To deal with this problem, Emacs displays such characters specially: it displays U+00A0 NO-BREAK SPACE and other characters from the Unicode horizontal space class with the nobreak-space face, and it displays U+00AD SOFT HYPHEN, U+2010 HYPHEN, and U+2011 NON-BREAKING HYPHEN with the nobreak-hyphen face. To disable this, change the variable nobreak-char-display to nil. If you give this variable a non-nil and non-t value, Emacs instead displays such characters as a highlighted backslash followed by a space or hyphen.

You can customize the way any particular character code is displayed by means of a display table. See Display Tables in The Emacs Lisp Reference Manual.

On graphical displays, some characters may have no glyphs in any of the fonts available to Emacs. These glyphless characters are normally displayed as boxes containing the hexadecimal character code. Similarly, on text terminals, characters that cannot be displayed using the terminal encoding (see Coding Systems for Terminal I/O) are normally displayed as question signs. You can control the display method by customizing the variable glyphless-char-display-control. You can also customize the glyphless-char face to make these characters more prominent on display. See Glyphless Character Display in The Emacs Lisp Reference Manual, for details.

The glyphless-display-mode minor mode can be used to toggle the display of glyphless characters in the current buffer. The glyphless characters will be displayed as boxes with acronyms of their names inside.

Emacs tries to determine if the curved quotes ‘ and ’ can be displayed on the current display. By default, if this seems to be so, then Emacs will translate the ASCII quotes (‘`’ and ‘'’), when they appear in messages and help texts, to these curved quotes. You can influence or inhibit this translation by customizing the user option text-quoting-style (see Keys in Documentation in The Emacs Lisp Reference Manual).

If the curved quotes ‘, ’, “, and ” are known to look just like ASCII characters, they are shown with the homoglyph face. Curved quotes that are known not to be displayable are shown as their ASCII approximations ‘`’, ‘'’, and ‘"’ with the homoglyph face.


*** Displaying the Cursor

On a text terminal, the cursor’s appearance is controlled by the terminal, largely out of the control of Emacs. Some terminals offer two different cursors: a visible static cursor, and a very visible blinking cursor. By default, Emacs uses the very visible cursor, and switches to it when you start or resume Emacs. If the variable visible-cursor is nil when Emacs starts or resumes, it uses the normal cursor.

On a graphical display, many more properties of the text cursor can be altered. To customize its color, change the :background attribute of the face named cursor (see Customizing Faces). (The other attributes of this face have no effect; the text shown under the cursor is drawn using the frame’s background color.) To change its shape, customize the buffer-local variable cursor-type; possible values are box (the default), (box . size) (box cursor becoming a hollow box under masked images larger than size pixels in either dimension), hollow (a hollow box), bar (a vertical bar), (bar . n) (a vertical bar n pixels wide), hbar (a horizontal bar), (hbar . n) (a horizontal bar n pixels tall), or nil (no cursor at all).

By default, the cursor stops blinking after 10 blinks, if Emacs does not get any input during that time; any input event restarts the count. You can customize the variable blink-cursor-blinks to control that: its value says how many times to blink without input before stopping. Setting that variable to a zero or negative value will make the cursor blink forever. To disable cursor blinking altogether, change the variable blink-cursor-mode to nil (see Easy Customization Interface), or add the line

(blink-cursor-mode 0)
to your init file. Alternatively, you can change how the cursor looks when it blinks off by customizing the list variable blink-cursor-alist. Each element in the list should have the form (on-type . off-type); this means that if the cursor is displayed as on-type when it blinks on (where on-type is one of the cursor types described above), then it is displayed as off-type when it blinks off.

Some characters, such as tab characters, are extra wide. When the cursor is positioned over such a character, it is normally drawn with the default character width. You can make the cursor stretch to cover wide characters, by changing the variable x-stretch-cursor to a non-nil value.

The cursor normally appears in non-selected windows as a non-blinking hollow box. (For a bar cursor, it instead appears as a thinner bar.) To turn off cursors in non-selected windows, change the variable cursor-in-non-selected-windows to nil.

To make the cursor even more visible, you can use HL Line mode, a minor mode that highlights the line containing point. Use M-x hl-line-mode to enable or disable it in the current buffer. M-x global-hl-line-mode enables or disables the same mode globally.


*** Line Truncation

As an alternative to continuation (see Continuation Lines), Emacs can display long lines by truncation. This means that all the characters that do not fit in the width of the screen or window do not appear at all. On graphical displays, a small straight arrow in the fringe indicates truncation at either end of the line. On text terminals, this is indicated with ‘$’ signs in the rightmost and/or leftmost columns.

Horizontal scrolling automatically causes line truncation (see Horizontal Scrolling). You can explicitly enable line truncation for a particular buffer with the command C-x x t (toggle-truncate-lines). This works by locally changing the variable truncate-lines. If that variable is non-nil, long lines are truncated; if it is nil, they are continued onto multiple screen lines. Setting the variable truncate-lines in any way makes it local to the current buffer; until that time, the default value, which is normally nil, is in effect.

Since line truncation and word wrap (described in the next section) are contradictory, toggle-truncate-lines disables word wrap when it turns on line truncation.

If a split window becomes too narrow, Emacs may automatically enable line truncation. See Splitting Windows, for the variable truncate-partial-width-windows which controls this.


*** Visual Line Mode

Another alternative to ordinary line continuation (see Continuation Lines) is to use word wrap. Here, each long logical line is divided into two or more screen lines, or “visual lines”, like in ordinary line continuation. However, Emacs attempts to wrap the line at word boundaries near the right window edge. (If the line’s direction is right-to-left, it is wrapped at the left window edge instead.) This makes the text easier to read, as wrapping does not occur in the middle of words.

Word wrap is enabled by Visual Line mode, an optional minor mode. To turn on Visual Line mode in the current buffer, type M-x visual-line-mode; repeating this command turns it off. You can also turn on Visual Line mode using the menu bar: in the Options menu, select the ‘Line Wrapping in this Buffer’ submenu, followed by the ‘Word Wrap (Visual Line mode)’ menu item. While Visual Line mode is enabled, the mode line shows the string ‘wrap’ in the mode display. The command M-x global-visual-line-mode toggles Visual Line mode in all buffers.

Since word wrap and line truncation (described in the previous section) are contradictory, turning on visual-line-mode disables line truncation.

In Visual Line mode, some editing commands work on screen lines instead of logical lines: C-a (beginning-of-visual-line) moves to the beginning of the screen line, C-e (end-of-visual-line) moves to the end of the screen line, and C-k (kill-visual-line) kills text to the end of the screen line.

To move by logical lines, use the commands M-x next-logical-line and M-x previous-logical-line. These move point to the next logical line and the previous logical line respectively, regardless of whether Visual Line mode is enabled. If you use these commands frequently, it may be convenient to assign key bindings to them. See Rebinding Keys in Your Init File.

By default, word-wrapped lines do not display fringe indicators. Visual Line mode is often used to edit files that contain many long logical lines, so having a fringe indicator for each wrapped line would be visually distracting. You can change this by customizing the variable visual-line-fringe-indicators.

By default, Emacs only breaks lines after whitespace characters like SPC and TAB, but does not break after whitespace characters like EN QUAD. Emacs provides a minor mode called word-wrap-whitespace-mode that switches on word wrapping in the current mode, and sets up which characters to wrap lines on based on the word-wrap-whitespace-characters user option. There’s also a globalized version of that mode called global-word-wrap-whitespace-mode.

Only breaking after whitespace character produces incorrect results when CJK and Latin text are mixed together (because CJK characters don’t use whitespace to separate words). You can customize the option word-wrap-by-category to allow Emacs to break lines after any character with ‘|’ category (see Categories in the Emacs Lisp Reference Manual), which provides better support for CJK characters. Also, if this variable is set using Customize, Emacs automatically loads kinsoku.el. When kinsoku.el is loaded, Emacs respects kinsoku rules when breaking lines. That means characters with the ‘>’ category don’t appear at the beginning of a line (e.g., U+FF0C FULLWIDTH COMMA), and characters with the ‘<’ category don’t appear at the end of a line (e.g., U+300A LEFT DOUBLE ANGLE BRACKET). You can view the category set of a character using the commands char-category-set and category-set-mnemonics, or by typing C-u C-x = with point on the character and looking at the “category” section in the report. You can add categories to a character using the command modify-category-entry.


*** Customization of Display

This section describes variables that control miscellaneous aspects of the appearance of the Emacs screen. Beginning users can skip it.

If you want to have Emacs display line numbers for every line in the buffer, customize the buffer-local variable display-line-numbers; it is nil by default. This variable can have several different values to support various modes of line-number display:

t
Display (an absolute) line number before each non-continuation screen line that displays buffer text. If the line is a continuation line, or if the entire screen line displays a display or an overlay string, that line will not be numbered.

relative
Display relative line numbers before non-continuation lines which show buffer text. The line numbers are relative to the line showing point, so the numbers grow both up and down as lines become farther from the current line.

visual
This value causes Emacs to count lines visually: only lines actually shown on the display will be counted (disregarding any lines in invisible parts of text), and lines which wrap to consume more than one screen line will be numbered that many times. The displayed numbers are relative, as with relative value above. This is handy in modes that fold text, such as Outline mode (see Outline Mode), and when you need to move by exact number of screen lines.

anything else
Any other non-nil value is treated as t.

The command M-x display-line-numbers-mode provides a convenient way to turn on display of line numbers. This mode has a globalized variant, global-display-line-numbers-mode. The user option display-line-numbers-type controls which sub-mode of line-number display, described above, these modes will activate.

Note that line numbers are not displayed in the minibuffer and in the tooltips, even if you turn on display-line-numbers-mode globally.

When Emacs displays relative line numbers, you can control the number displayed before the current line, the line showing point. By default, Emacs displays the absolute number of the current line there, even though all the other line numbers are relative. If you customize the variable display-line-numbers-current-absolute to a nil value, the number displayed for the current line will be zero. This is handy if you don’t care about the number of the current line, and want to leave more horizontal space for text in large buffers.

In a narrowed buffer (see Narrowing) lines are normally numbered starting at the beginning of the narrowing. However, if you customize the variable display-line-numbers-widen to a non-nil value, line numbers will disregard any narrowing and will start at the first character of the buffer.

If the value of display-line-numbers-offset is non-zero, it is added to each absolute line number, and lines are counted from the beginning of the buffer, as if display-line-numbers-widen were non-nil. It has no effect when set to zero, or when line numbers are not absolute.

In selective display mode (see Selective Display), and other modes that hide many lines from display (such as Outline and Org modes), you may wish to customize the variables display-line-numbers-width-start and display-line-numbers-grow-only, or set display-line-numbers-width to a large enough value, to avoid occasional miscalculations of space reserved for the line numbers.

The line numbers are displayed in a special face line-number. The current line number is displayed in a different face, line-number-current-line, so you can make the current line’s number have a distinct appearance, which will help locating the line showing point. Additional faces line-number-major-tick and line-number-minor-tick can be used to highlight the line numbers of lines which are a multiple of certain numbers. Customize display-line-numbers-major-tick and display-line-numbers-minor-tick respectively to set those numbers.

If the variable visible-bell is non-nil, Emacs attempts to make the whole screen blink when it would normally make an audible bell sound. This variable has no effect if your terminal does not have a way to make the screen blink.

The variable echo-keystrokes controls the echoing of multi-character keys; its value is the number of seconds of pause required to cause echoing to start, or zero, meaning don’t echo at all. The value takes effect when there is something to echo. See The Echo Area.

On graphical displays, Emacs displays the mouse pointer as an hourglass if Emacs is busy. To disable this feature, set the variable display-hourglass to nil. The variable hourglass-delay determines the number of seconds of busy time before the hourglass is shown; the default is 1.

If the mouse pointer lies inside an Emacs frame, Emacs makes it invisible each time you type a character to insert text, to prevent it from obscuring the text. (To be precise, the hiding occurs when you type a self-inserting character. See Inserting Text.) Moving the mouse pointer makes it visible again. To disable this feature, set the variable make-pointer-invisible to nil.

On graphical displays, the variable underline-minimum-offset determines the minimum distance between the baseline and underline, in pixels, for underlined text. By default, the value is 1; increasing it may improve the legibility of underlined text for certain fonts. (However, Emacs will never draw the underline below the current line area.) The variable x-underline-at-descent-line determines how to draw underlined text. The default is nil, which means to draw it at the baseline level of the font; if you change it to t, Emacs draws the underline at the same height as the font’s descent line. (If non-default line spacing was specified for the underlined text, see Line Height in The Emacs Lisp Reference Manual, Emacs draws the underline below the additional spacing.)

The variable overline-margin specifies the vertical position of an overline above the text, including the height of the overline itself, in pixels; the default is 2.

On some text terminals, bold face and inverse video together result in text that is hard to read. Call the function tty-suppress-bold-inverse-default-colors with a non-nil argument to suppress the effect of bold-face in this case.

Raw bytes are displayed in octal format by default, for example a byte with a decimal value of 128 is displayed as \200. To change display to the hexadecimal format of \x80, set the variable display-raw-bytes-as-hex to t. Care may be needed when interpreting a raw byte when copying text from a terminal containing an Emacs session, or when a terminal’s escape-glyph face looks like the default face. For example, by default Emacs displays the four characters ‘\’, ‘2’, ‘0’, ‘0’ with the same characters it displays a byte with decimal value 128. The problem can be worse with hex displays, where the raw byte 128 followed by the character ‘7’ is displayed as \x807, which Emacs Lisp reads as the single character U+0807 SAMARITAN LETTER IT; this confusion does not occur with the corresponding octal display \2007 because octal escapes contain at most three digits.



** Basic Editing Commands

Here we explain the basics of how to enter text, make corrections, and save the text in a file. If this material is new to you, we suggest you first run the Emacs learn-by-doing tutorial, by typing C-h t (help-with-tutorial).

*** Changing the Location of Point

To do more than insert characters, you have to know how to move point (see Point). The keyboard commands C-f, C-b, C-n, and C-p move point to the right, left, down, and up, respectively. You can also move point using the arrow keys present on most keyboards: RIGHT, LEFT, DOWN, and UP; however, many Emacs users find that it is slower to use the arrow keys than the control keys, because you need to move your hand to the area of the keyboard where those keys are located.

You can also click the left mouse button to move point to the position clicked. Emacs also provides a variety of additional keyboard commands that move point in more sophisticated ways.

C-f ¶
Move forward one character (forward-char).

RIGHT ¶
This command (right-char) behaves like C-f, except when point is in a right-to-left paragraph (see Bidirectional Editing).

C-b ¶
Move backward one character (backward-char).

LEFT ¶
This command (left-char) behaves like C-b, except if the current paragraph is right-to-left (see Bidirectional Editing).

C-n ¶
DOWN
Move down one screen line (next-line). This command attempts to keep the horizontal position unchanged, so if you start in the middle of one line, you move to the middle of the next.

C-p ¶
UP
Move up one screen line (previous-line). This command preserves position within the line, like C-n.

C-a ¶
Home
Move to the beginning of the line (move-beginning-of-line).

C-e ¶
End
Move to the end of the line (move-end-of-line).

M-f
Move forward one word (forward-word). See Words.

C-RIGHT ¶
M-RIGHT
This command (right-word) behaves like M-f, except it moves backward by one word if the current paragraph is right-to-left. See Bidirectional Editing.

M-b
Move backward one word (backward-word). See Words.

C-LEFT ¶
M-LEFT
This command (left-word) behaves like M-b, except it moves forward by one word if the current paragraph is right-to-left. See Bidirectional Editing.

M-r ¶
Without moving the text on the screen, reposition point on the left margin of the center-most text line of the window; on subsequent consecutive invocations, move point to the left margin of the top-most line, the bottom-most line, and so forth, in cyclic order (move-to-window-line-top-bottom).

A numeric argument says which screen line to place point on, counting downward from the top of the window (zero means the top line). A negative argument counts lines up from the bottom (−1 means the bottom line). See Numeric Arguments, for more information on numeric arguments.

M-< ¶
Move to the top of the buffer (beginning-of-buffer). With numeric argument n, move to n/10 of the way from the top. On graphical displays, C-HOME does the same.

M-> ¶
Move to the end of the buffer (end-of-buffer). On graphical displays, C-END does the same.

C-v ¶
PageDown
next
Scroll the display one screen forward, and move point onscreen if necessary (scroll-up-command). See Scrolling.

M-v ¶
PageUp
prior
Scroll one screen backward, and move point onscreen if necessary (scroll-down-command). See Scrolling.

M-g c ¶
Read a number n and move point to buffer position n. Position 1 is the beginning of the buffer. If point is on or just after a number in the buffer, that is the default for n. Just type RET in the minibuffer to use it. You can also specify n by giving M-g c a numeric prefix argument.

M-g M-g ¶
M-g g
Read a number n and move point to the beginning of line number n (goto-line). Line 1 is the beginning of the buffer. If point is on or just after a number in the buffer, that is the default for n. Just type RET in the minibuffer to use it. You can also specify n by giving M-g M-g a numeric prefix argument. See Creating and Selecting Buffers, for the behavior of M-g M-g when you give it a plain prefix argument. Alternatively, you can use the command goto-line-relative to move point to the line relative to the accessible portion of the narrowed buffer.

goto-line has its own history list (see Minibuffer History). You can have either a single list shared between all buffers (the default) or a separate list for each buffer, by customizing the user option goto-line-history-local.

M-g TAB ¶
Read a number n and move to column n in the current line. Column 0 is the leftmost column. If called with a prefix argument, move to the column number specified by the argument’s numeric value.

C-x C-n ¶
Use the current column of point as the semipermanent goal column (set-goal-column) in the current buffer. When a semipermanent goal column is in effect, C-n, C-p, <prior> and <next> always try to move to this column, or as close as possible to it, after moving vertically. The goal column remains in effect until canceled.

C-u C-x C-n
Cancel the goal column. Henceforth, C-n and C-p try to preserve the horizontal position, as usual.

When a line of text in the buffer is longer than the width of the window, Emacs usually displays it on two or more screen lines, a.k.a. visual lines. For convenience, C-n and C-p move point by screen lines, as do the equivalent keys down and up. You can force these commands to move according to logical lines (i.e., according to the text lines in the buffer) by setting the variable line-move-visual to nil; if a logical line occupies multiple screen lines, the cursor then skips over the additional screen lines. For details, see Continuation Lines. See Variables, for how to set variables such as line-move-visual.

Unlike C-n and C-p, most of the Emacs commands that work on lines work on logical lines. For instance, C-a (move-beginning-of-line) and C-e (move-end-of-line) respectively move to the beginning and end of the logical line. Whenever we encounter commands that work on screen lines, such as C-n and C-p, we will point these out.

When line-move-visual is nil, you can also set the variable track-eol to a non-nil value. Then C-n and C-p, when starting at the end of the logical line, move to the end of the next logical line. Normally, track-eol is nil.

C-n normally stops at the end of the buffer when you use it on the last line in the buffer. However, if you set the variable next-line-add-newlines to a non-nil value, C-n on the last line of a buffer creates an additional line at the end and moves down into it.


*** Erasing Text

DEL
BACKSPACE
Delete the character before point, or the region if it is active (delete-backward-char).

Delete
Delete the character after point, or the region if it is active (delete-forward-char).

C-d
Delete the character after point (delete-char).

C-k
Kill to the end of the line (kill-line).

M-d
Kill forward to the end of the next word (kill-word).

M-DEL
M-BACKSPACE
Kill back to the beginning of the previous word (backward-kill-word).

The DEL (delete-backward-char) command removes the character before point, moving the cursor and the characters after it backwards. If point was at the beginning of a line, this deletes the preceding newline, joining this line to the previous one.

If, however, the region is active, DEL instead deletes the text in the region. See The Mark and the Region, for a description of the region.

On most keyboards, DEL is labeled BACKSPACE, but we refer to it as DEL in this manual. (Do not confuse DEL with the Delete key; we will discuss Delete momentarily.) On some text terminals, Emacs may not recognize the DEL key properly. See If DEL Fails to Delete, if you encounter this problem.

The Delete (delete-forward-char) command deletes in the opposite direction: it deletes the character after point, i.e., the character under the cursor. If point was at the end of a line, this joins the following line onto this one. Like DEL, it deletes the text in the region if the region is active (see The Mark and the Region).

C-d (delete-char) deletes the character after point, similar to Delete, but regardless of whether the region is active.

See Deletion, for more detailed information about the above deletion commands.

C-k (kill-line) erases (kills) a line at a time. If you type C-k at the beginning or middle of a line, it kills all the text up to the end of the line. If you type C-k at the end of a line, it joins that line with the following line.

See Killing and Moving Text, for more information about C-k and related commands.


*** Undoing Changes

C-/
C-x u
C-_
Undo one entry of the undo records—usually, one command worth (undo). (The first key might be unavailable on text-mode displays.)

Emacs records a list of changes made in the buffer text, so you can undo recent changes. This is done using the undo command, which is bound to C-/ (as well as C-x u and C-_). Normally, this command undoes the last change, moving point back to where it was before the change. The undo command applies only to changes in the buffer; you can’t use it to undo cursor motion.

On a terminal that supports the Control modifier on all other keys, the easiest way to invoke undo is with C-/, since that doesn’t need the Shift modifier. On terminals which allow only the ASCII control characters, C-/ does not exist, but for many of them C-/ still works because it actually sends C-_ to Emacs, while many others allow you to omit the Shift modifier when you type C-_ (in effect pressing C--), making that the most convenient way to invoke undo.

Although each editing command usually makes a separate entry in the undo records, very simple commands may be grouped together. Sometimes, an entry may cover just part of a complex command.

If you repeat C-/ (or its aliases), each repetition undoes another, earlier change, back to the limit of the undo information available. If all recorded changes have already been undone, the undo command displays an error message and does nothing.

To learn more about the undo command, see Undo.


*** Files

Text that you insert in an Emacs buffer lasts only as long as the Emacs session. To keep any text permanently, you must put it in a file.

Suppose there is a file named test.emacs in your home directory. To begin editing this file in Emacs, type

C-x C-f test.emacs RET
Here the file name is given as an argument to the command C-x C-f (find-file). That command uses the minibuffer to read the argument, and you type RET to terminate the argument (see The Minibuffer).

Emacs obeys this command by visiting the file: it creates a buffer, copies the contents of the file into the buffer, and then displays the buffer for editing. If you alter the text, you can save the new text in the file by typing C-x C-s (save-buffer). This copies the altered buffer contents back into the file test.emacs, making them permanent. Until you save, the changed text exists only inside Emacs, and the file test.emacs is unaltered.

To create a file, just visit it with C-x C-f as if it already existed. This creates an empty buffer, in which you can insert the text you want to put in the file. Emacs actually creates the file the first time you save this buffer with C-x C-s.

To learn more about using files in Emacs, see File Handling.


*** Help

If you forget what a key does, you can find out by typing C-h k (describe-key), followed by the key of interest; for example, C-h k C-n tells you what C-n does.

The prefix key C-h stands for “help”. The key F1 serves as an alias for C-h. Apart from C-h k, there are many other help commands providing different kinds of help.


*** Blank Lines
Here are special commands and techniques for inserting and deleting blank lines.

C-o
Insert a blank line after the cursor (open-line).

C-x C-o
Delete all but one of many consecutive blank lines (delete-blank-lines).

We have seen how RET (newline) starts a new line of text. However, it may be easier to see what you are doing if you first make a blank line and then insert the desired text into it. This is easy to do using the key C-o (open-line), which inserts a newline after point but leaves point in front of the newline. After C-o, type the text for the new line.

You can make several blank lines by typing C-o several times, or by giving it a numeric argument specifying how many blank lines to make. See Numeric Arguments, for how. If you have a fill prefix, the C-o command inserts the fill prefix on the new line, if typed at the beginning of a line. See The Fill Prefix.

The easy way to get rid of extra blank lines is with the command C-x C-o (delete-blank-lines). If point lies within a run of several blank lines, C-x C-o deletes all but one of them. If point is on a single blank line, C-x C-o deletes it. If point is on a nonblank line, C-x C-o deletes all following blank lines, if any exists.


*** Continuation Lines

Sometimes, a line of text in the buffer—a logical line—is too long to fit in the window, and Emacs displays it as two or more screen lines, or visual lines. This is called line wrapping or continuation, and the long logical line is called a continued line. On a graphical display, Emacs indicates line wrapping with small bent arrows in the left and right window fringes. On a text terminal, Emacs indicates line wrapping by displaying a ‘\’ character at the right margin.

Most commands that act on lines act on logical lines, not screen lines. For instance, C-k kills a logical line. As described earlier, C-n (next-line) and C-p (previous-line) are special exceptions: they move point down and up, respectively, by one screen line (see Changing the Location of Point).

Emacs can optionally truncate long logical lines instead of continuing them. This means that every logical line occupies a single screen line; if it is longer than the width of the window, the rest of the line is not displayed. On a graphical display, a truncated line is indicated by a small straight arrow in the right fringe; on a text terminal, it is indicated by a ‘$’ character in the right margin. See Line Truncation.

By default, continued lines are wrapped at the right window edge. Since the wrapping may occur in the middle of a word, continued lines can be difficult to read. The usual solution is to break your lines before they get too long, by inserting newlines. If you prefer, you can make Emacs insert a newline automatically when a line gets too long, by using Auto Fill mode. See Filling Text.

Sometimes, you may need to edit files containing many long logical lines, and it may not be practical to break them all up by adding newlines. In that case, you can use Visual Line mode, which enables word wrapping: instead of wrapping long lines exactly at the right window edge, Emacs wraps them at the word boundaries (i.e., space or tab characters) nearest to the right window edge. Visual Line mode also redefines editing commands such as C-a, C-n, and C-k to operate on screen lines rather than logical lines. See Visual Line Mode.


*** Cursor Position Information

Here are commands to get information about the size and position of parts of the buffer, and to count words and lines.

M-x what-line
Display the line number of point.

M-x line-number-mode
M-x column-number-mode
Toggle automatic display of the current line number or column number. See Optional Mode Line Features. If you want to have a line number displayed before each line, see Customization of Display.

M-=
Display the number of lines, sentences, words, and characters that are present in the region (count-words-region). See The Mark and the Region, for information about the region.

M-x count-words
Display the number of lines, sentences, words, and characters that are present in the buffer. If the region is active (see The Mark and the Region), display the numbers for the region instead.

C-x =
Display the character code of character after point, character position of point, and column of point (what-cursor-position).

M-x hl-line-mode
Enable or disable highlighting of the current line. See Displaying the Cursor.

M-x size-indication-mode
Toggle automatic display of the size of the buffer. See Optional Mode Line Features.

M-x what-line displays the current line number in the echo area. This command is usually redundant because the current line number is shown in the mode line (see The Mode Line). However, if you narrow the buffer, the mode line shows the line number relative to the accessible portion (see Narrowing). By contrast, what-line displays both the line number relative to the narrowed region and the line number relative to the whole buffer.

M-= (count-words-region) displays a message reporting the number of lines, sentences, words, and characters in the region (see The Mark and the Region, for an explanation of the region). With a prefix argument, C-u M-=, the command displays a count for the entire buffer.

The command M-x count-words does the same job, but with a different calling convention. It displays a count for the region if the region is active, and for the buffer otherwise.

The command C-x = (what-cursor-position) shows information about the current cursor position and the buffer contents at that position. It displays a line in the echo area that looks like this:

Char: c (99, #o143, #x63) point=28062 of 36168 (78%) column=53
After ‘Char:’, this shows the character in the buffer at point. The text inside the parenthesis shows the corresponding decimal, octal and hex character codes; for more information about how C-x = displays character information, see Introduction to International Character Sets. After ‘point=’ is the position of point as a character count (the first character in the buffer is position 1, the second character is position 2, and so on). The number after that is the total number of characters in the buffer, and the number in parenthesis expresses the position as a percentage of the total. After ‘column=’ is the horizontal position of point, in columns counting from the left edge of the window.

If the user option what-cursor-show-names is non-nil, the name of the character, as defined by the Unicode Character Database, is shown as well. The part in parentheses would then become:

(99, #o143, #x63, LATIN SMALL LETTER C)
If the buffer has been narrowed, making some of the text at the beginning and the end temporarily inaccessible, C-x = displays additional text describing the currently accessible range. For example, it might display this:

Char: C (67, #o103, #x43) point=252 of 889 (28%) <231-599> column=0
where the two extra numbers give the smallest and largest character position that point is allowed to assume. The characters between those two positions are the accessible ones. See Narrowing.

Related, but different feature is display-line-numbers-mode (see Customization of Display).


*** Numeric Arguments

In the terminology of mathematics and computing, argument means “data provided to a function or operation”. You can give any Emacs command a numeric argument (also called a prefix argument). Some commands interpret the argument as a repetition count. For example, giving C-f an argument of ten causes it to move point forward by ten characters instead of one. With these commands, no argument is equivalent to an argument of one, and negative arguments cause them to move or act in the opposite direction.

The easiest way to specify a numeric argument is to type a digit and/or a minus sign while holding down the Meta key. For example,

M-5 C-n
moves down five lines. The keys M-1, M-2, and so on, as well as M--, are bound to commands (digit-argument and negative-argument) that set up an argument for the next command. M-- without digits normally means −1.

If you enter more than one digit, you need not hold down the Meta key for the second and subsequent digits. Thus, to move down fifty lines, type

M-5 0 C-n
Note that this does not insert five copies of ‘0’ and move down one line, as you might expect—the ‘0’ is treated as part of the prefix argument.

(What if you do want to insert five copies of ‘0’? Type M-5 C-u 0. Here, C-u terminates the prefix argument, so that the next keystroke begins the command that you want to execute. Note that this meaning of C-u applies only to this case. For the usual role of C-u, see below.)

Instead of typing M-1, M-2, and so on, another way to specify a numeric argument is to type C-u (universal-argument) followed by some digits, or (for a negative argument) a minus sign followed by digits. A minus sign without digits normally means −1.

C-u alone has the special meaning of “four times”: it multiplies the argument for the next command by four. C-u C-u multiplies it by sixteen. Thus, C-u C-u C-f moves forward sixteen characters. Other useful combinations are C-u C-n, C-u C-u C-n (move down a good fraction of a screen), C-u C-u C-o (make sixteen blank lines), and C-u C-k (kill four lines).

You can use a numeric argument before a self-inserting character to insert multiple copies of it. This is straightforward when the character is not a digit; for example, C-u 6 4 a inserts 64 copies of the character ‘a’. But this does not work for inserting digits; C-u 6 4 1 specifies an argument of 641. You can separate the argument from the digit to insert with another C-u; for example, C-u 6 4 C-u 1 does insert 64 copies of the character ‘1’.

Some commands care whether there is an argument, but ignore its value. For example, the command M-q (fill-paragraph) fills text; with an argument, it justifies the text as well. (See Filling Text, for more information on M-q.) For these commands, it is enough to specify the argument with a single C-u.

Some commands use the value of the argument as a repeat count but do something special when there is no argument. For example, the command C-k (kill-line) with argument n kills n lines, including their terminating newlines. But C-k with no argument is special: it kills the text up to the next newline, or, if point is right at the end of the line, it kills the newline itself. Thus, two C-k commands with no arguments can kill a nonblank line, just like C-k with an argument of one. (See Killing and Moving Text, for more information on C-k.)

A few commands treat a plain C-u differently from an ordinary argument. A few others may treat an argument of just a minus sign differently from an argument of −1. These unusual cases are described when they come up; they exist to make an individual command more convenient, and they are documented in that command’s documentation string.

We use the term prefix argument to emphasize that you type such arguments before the command, and to distinguish them from minibuffer arguments (see The Minibuffer), which are entered after invoking the command.

On graphical displays, C-0, C-1, etc. act the same as M-0, M-1, etc.


*** Repeating a Command

Many simple commands, such as those invoked with a single key or with M-x command-name RET, can be repeated by invoking them with a numeric argument that serves as a repeat count (see Numeric Arguments). However, if the command you want to repeat prompts for input, or uses a numeric argument in another way, that method won’t work.

The command C-x z (repeat) provides another way to repeat an Emacs command many times. This command repeats the previous Emacs command, whatever that was. Repeating a command uses the same arguments that were used before; it does not read new arguments each time.

To repeat the command more than once, type additional z’s: each z repeats the command one more time. Repetition ends when you type a character other than z or press a mouse button.

For example, suppose you type C-u 2 0 C-d to delete 20 characters. You can repeat that command (including its argument) three additional times, to delete a total of 80 characters, by typing C-x z z z. The first C-x z repeats the command once, and each subsequent z repeats it once again.

You can also activate repeat-mode which allows repeating commands bound to sequences of two or more keys by typing a single character. For example, after typing C-x u (undo, see Undo) to undo the most recent edits, you can undo many more edits by typing u u u…. Similarly, type C-x o o o… instead of C-x o C-x o C-x o… to switch to the window several windows away. This works by entering a transient repeating mode after you type the full key sequence that invokes the command; the single-key shortcuts are shown in the echo area.

Only some commands support repetition in repeat-mode; type M-x describe-repeat-maps RET to see which ones.

The single-character shortcuts enabled by the transient repeating mode do not need to be identical: for example, after typing C-x {, either { or } or ^ or v, or any series that mixes these characters in any order, will resize the selected window in respective ways. Similarly, after M-g n or M-g p, typing any sequence of n and/or p in any mix will repeat next-error and previous-error to navigate in a *compilation* or *grep* buffer (see Compilation Mode).

Typing any key other than those defined to repeat the previous command exits the transient repeating mode, and then the key you typed is executed normally. You can also define a key which will exit the transient repeating mode without executing the key which caused the exit. To this end, customize the user option repeat-exit-key to name a key; one natural value is RET. Finally, it’s possible to break the repetition chain automatically after some amount of idle time: customize the user option repeat-exit-timeout to specify the idle time in seconds after which this transient repetition mode will be turned off automatically.







** Keys

Emacs utilizes a flexible system of key sequences, allowing commands to be invoked by a series of key inputs. Some commands are triggered by a single input event (e.g., C-f), while others require a sequence of two or more input events (e.g., C-x C-f or C-x 4 C-f). The key sequence system includes complete keys and prefix keys, each playing an essential role in Emacs' command structure.

*** Key Prefix

A prefix key is an incomplete sequence that needs to be followed by additional input to form a valid command. Typing just the prefix does not trigger any action on its own; Emacs waits for further input.

Example: C-x is a prefix key. Typing C-x alone doesn’t invoke a command but instead waits for additional input, such as C-x C-f or C-x 4.

When a prefix key is typed, Emacs will often display the key sequence in the echo area if you pause before continuing the sequence.

Common prefix keys include: C-x, C-c, ESC, C-h, and F1.


*** Key Sequence

A key sequence is a series of one or more input events that forms a complete command. This sequence may involve a prefix key, but once the entire sequence is entered, it triggers a specific function.

Complete Key: A sequence that directly invokes a command.

Example: C-f moves the cursor forward by one character in the buffer.

Example: C-x C-f opens a file.


Prefix Key Sequence: A key sequence that begins with a prefix key, requiring additional input to form a valid command.

Example: C-x 4 C-f opens a file in another window, with C-x 4 being the prefix.


*** Combined Keys (Prefix + Sequence)

Combined keys refer to a key sequence where a prefix key is combined with one or more input events to form a longer sequence that triggers a command.

A key sequence involving a prefix, like C-x, requires you to combine it with subsequent keys to make it a complete command.

Example: C-x C-f is a combined key sequence where C-x is the prefix and C-f is the final key that forms the complete command for opening a file.

The flexibility of the system allows for chains of prefixes and sequences (e.g., C-x 4 C-f or ESC C-h).


*** Keys and Commands


This manual is full of passages that tell you what particular keys do. But Emacs does not assign meanings to keys directly. Instead, Emacs assigns meanings to named commands, and then gives keys their meanings by binding them to commands.

Every command has a name chosen by a programmer. The name is usually made of a few English words separated by dashes; for example, next-line or forward-word. Internally, each command is a special type of Lisp function, and the actions associated with the command are performed by running the function. See What Is a Function in The Emacs Lisp Reference Manual.

The bindings between keys and commands are recorded in tables called keymaps. See Keymaps.

When we say that “C-n moves down vertically one line” we are glossing over a subtle distinction that is irrelevant in ordinary use, but vital for Emacs customization. The command next-line does a vertical move downward. C-n has this effect because it is bound to next-line. If you rebind C-n to the command forward-word, C-n will move forward one word instead.

In this manual, we will often speak of keys like C-n as commands, even though strictly speaking the key is bound to a command. Usually, we state the name of the command which really does the work in parentheses after mentioning the key that runs it. For example, we will say that “The command C-n (next-line) moves point vertically down”, meaning that the command next-line moves vertically down, and the key C-n is normally bound to it.

Since we are discussing customization, we should tell you about variables. Often the description of a command will say, “To change this, set the variable mumble-foo.” A variable is a name used to store a value. Most of the variables documented in this manual are meant for customization: some command or other part of Emacs examines the variable and behaves differently according to the value that you set. You can ignore the information about variables until you are interested in customizing them. Then read the basic information on variables (see Variables) and the information about specific variables will make sense.








** The Minibuffer

The minibuffer is where Emacs commands read complicated arguments, such as file names, buffer names, Emacs command names, or Lisp expressions. We call it the “minibuffer” because it’s a special-purpose buffer with a small amount of screen space. You can use the usual Emacs editing commands in the minibuffer to edit the argument text.

*** Using the Minibuffer

When the minibuffer is in use, it appears in the echo area, with a cursor. The minibuffer starts with a prompt, usually ending with a colon. The prompt states what kind of input is expected, and how it will be used. The prompt is highlighted using the minibuffer-prompt face (see Text Faces).

The simplest way to enter a minibuffer argument is to type the text, then RET to submit the argument and exit the minibuffer. Alternatively, you can type C-g to exit the minibuffer by canceling the command asking for the argument (see Quitting and Aborting).

Sometimes, the prompt shows a default argument, inside parentheses before the colon. This default will be used as the argument if you just type RET. For example, commands that read buffer names usually show a buffer name as the default; you can type RET to operate on that default buffer. You can customize how the default argument is shown with the user option minibuffer-default-prompt-format.

If you enable Minibuffer Electric Default mode, a global minor mode, Emacs hides the default argument as soon as you modify the contents of the minibuffer (since typing RET would no longer submit that default). If you ever bring back the original minibuffer text, the prompt again shows the default. To enable this minor mode, type M-x minibuffer-electric-default-mode.

Since the minibuffer appears in the echo area, it can conflict with other uses of the echo area. If an error message or an informative message is emitted while the minibuffer is active, the message is displayed in brackets after the minibuffer text for a few seconds, or until you type something; then the message disappears. While the minibuffer is in use, Emacs does not echo keystrokes.

While using the minibuffer, you can switch to a different frame, perhaps to note text you need to enter (see Frame Commands). By default, the active minibuffer moves to this new frame. If you set the user option minibuffer-follows-selected-frame to nil, then the minibuffer stays in the frame where you opened it, and you must switch back to that frame in order to complete (or abort) the current command. If you set that option to a value which is neither nil nor t, the minibuffer moves frame only after a recursive minibuffer has been opened in the current command (see (elisp)Recursive Mini). This option is mainly to retain (approximately) the behavior prior to Emacs 28.1. Note that the effect of the command, when you finally finish using the minibuffer, always takes place in the frame where you first opened it. The sole exception is that when that frame no longer exists, the action takes place in the currently selected frame.


*** Minibuffers for File Names

Commands such as C-x C-f (find-file) use the minibuffer to read a file name argument (see Files). When the minibuffer is used to read a file name, it typically starts out with some initial text ending in a slash. This is the default directory. For example, it may start out like this:

Find file: /u2/emacs/src/
Here, ‘Find file: ’ is the prompt and ‘/u2/emacs/src/’ is the default directory. If you now type buffer.c as input, that specifies the file /u2/emacs/src/buffer.c. See File Names, for information about the default directory.

Alternative defaults for the file name you may want are available by typing M-n, see Minibuffer History.

You can specify a file in the parent directory with ..: /a/b/../foo.el is equivalent to /a/foo.el. Alternatively, you can use M-DEL to kill directory names backwards (see Words).

To specify a file in a completely different directory, you can kill the entire default with C-a C-k (see Editing in the Minibuffer). Alternatively, you can ignore the default, and enter an absolute file name starting with a slash or a tilde after the default directory. For example, you can specify /etc/termcap as follows:

Find file: /u2/emacs/src//etc/termcap
A double slash causes Emacs to ignore everything before the second slash in the pair. In the example above, /u2/emacs/src/ is ignored, so the argument you supplied is /etc/termcap. The ignored part of the file name is dimmed if the terminal allows it. (To disable this dimming, turn off File Name Shadow mode with the command M-x file-name-shadow-mode.)

When completing remote file names (see Remote Files), a double slash behaves slightly differently: it causes Emacs to ignore only the file-name part, leaving the rest (method, host and username, etc.) intact. Typing three slashes in a row ignores everything in remote file names. See File name completion in The Tramp Manual.

Emacs interprets ~/ as your home directory. Thus, ~/foo/bar.txt specifies a file named bar.txt, inside a directory named foo, which is in turn located in your home directory. In addition, ~user-id/ means the home directory of a user whose login name is user-id. Any leading directory name in front of the ~ is ignored: thus, /u2/emacs/~/foo/bar.txt is equivalent to ~/foo/bar.txt.

On MS-Windows and MS-DOS systems, where a user doesn’t always have a home directory, Emacs uses several alternatives. For MS-Windows, see HOME and Startup Directories on MS-Windows; for MS-DOS, see File Names on MS-DOS. On these systems, the ~user-id/ construct is supported only for the current user, i.e., only if user-id is the current user’s login name.

To prevent Emacs from inserting the default directory when reading file names, change the variable insert-default-directory to nil. In that case, the minibuffer starts out empty. Nonetheless, relative file name arguments are still interpreted based on the same default directory.

You can also enter remote file names in the minibuffer. See Remote Files.


*** Editing in the Minibuffer

The minibuffer is an Emacs buffer, albeit a peculiar one, and the usual Emacs commands are available for editing the argument text. (The prompt, however, is read-only, and cannot be changed.)

Since RET in the minibuffer submits the argument, you can’t use it to insert a newline. You can do that with C-q C-j, which inserts a C-j control character, which is formally equivalent to a newline character (see Inserting Text). Alternatively, you can use the C-o (open-line) command (see Blank Lines).

Inside a minibuffer, the keys TAB, SPC, and ? are often bound to completion commands, which allow you to easily fill in the desired text without typing all of it. See Completion. As with RET, you can use C-q to insert a TAB, SPC, or ‘?’ character. If you want to make SPC and ? insert normally instead of starting completion, you can put the following in your init file:

(keymap-unset minibuffer-local-completion-map "SPC")
(keymap-unset minibuffer-local-completion-map "?")
For convenience, C-a (move-beginning-of-line) in a minibuffer moves point to the beginning of the argument text, not the beginning of the prompt. For example, this allows you to erase the entire argument with C-a C-k.

When the minibuffer is active, the echo area is treated much like an ordinary Emacs window. For instance, you can switch to another window (with C-x o), edit text there, then return to the minibuffer window to finish the argument. You can even kill text in another window, return to the minibuffer window, and yank the text into the argument. There are some restrictions on the minibuffer window, however: for instance, you cannot split it. See Multiple Windows.

Normally, the minibuffer window occupies a single screen line. However, if you add two or more lines’ worth of text into the minibuffer, it expands automatically to accommodate the text. The variable resize-mini-windows controls the resizing of the minibuffer. The default value is grow-only, which means the behavior we have just described. If the value is t, the minibuffer window will also shrink automatically if you remove some lines of text from the minibuffer, down to a minimum of one screen line. If the value is nil, the minibuffer window never changes size automatically, but you can use the usual window-resizing commands on it (see Multiple Windows).

The variable max-mini-window-height controls the maximum height for resizing the minibuffer window. A floating-point number specifies a fraction of the frame’s height; an integer specifies the maximum number of lines; nil means do not resize the minibuffer window automatically. The default value is 0.25.

The C-M-v command in the minibuffer scrolls the help text from commands that display help text of any sort in another window. You can also scroll the help text with M-PageUp and M-PageDown (or, equivalently, M-prior and M-next). This is especially useful with long lists of possible completions. See Using Other Windows.

Emacs normally disallows most commands that use the minibuffer while the minibuffer is active. To allow such commands in the minibuffer, set the variable enable-recursive-minibuffers to t. You might need also to enable minibuffer-depth-indicate-mode to show the current recursion depth in the minibuffer prompt on recursive use of the minibuffer.

When active, the minibuffer is usually in minibuffer-mode. This is an internal Emacs mode without any special features.

When not active, the minibuffer is in minibuffer-inactive-mode, and clicking mouse-1 there shows the *Messages* buffer. If you use a dedicated frame for minibuffers, Emacs also recognizes certain keys there, for example, n to make a new frame.


*** Completion

You can often use a feature called completion to help enter arguments. This means that after you type part of the argument, Emacs can fill in the rest, or some of it, based on what was typed so far.

When completion is available, certain keys (usually TAB, RET, and SPC) are rebound in the minibuffer to special completion commands (see Completion Commands). These commands attempt to complete the text in the minibuffer, based on a set of completion alternatives provided by the command that requested the argument. You can usually type ? to see a list of completion alternatives.

Although completion is usually done in the minibuffer, the feature is sometimes available in ordinary buffers too. See Completion for Symbol Names.

**** Completion Example

A simple example may help here. M-x uses the minibuffer to read the name of a command, so completion works by matching the minibuffer text against the names of existing Emacs commands. Suppose you wish to run the command auto-fill-mode. You can do that by typing M-x auto-fill-mode RET, but it is easier to use completion.

If you type M-x a u TAB, the TAB looks for completion alternatives (in this case, command names) that start with ‘au’. There are several, including auto-fill-mode and autoconf-mode, but they all begin with auto, so the ‘au’ in the minibuffer completes to ‘auto’. (More commands may be defined in your Emacs session. For example, if a command called authorize-me was defined, Emacs could only complete as far as ‘aut’.)

If you type TAB again immediately, it cannot determine the next character; it could be ‘-’, ‘a’, or ‘c’. So it does not add any characters; instead, TAB displays a list of all possible completions in another window.

Next, type -f. The minibuffer now contains ‘auto-f’, and the only command name that starts with this is auto-fill-mode. If you now type TAB, completion fills in the rest of the argument ‘auto-fill-mode’ into the minibuffer.

Hence, typing just a u TAB - f TAB allows you to enter ‘auto-fill-mode’.

TAB also works while point is not at the end of the minibuffer. In that case, it will fill in text both at point and at the end of the minibuffer. If you type M-x autocm, then press C-b to move point before the ‘m’, you can type TAB to insert the text ‘onf-’ at point and ‘ode’ at the end of the minibuffer, so that the minibuffer contains ‘autoconf-mode’.


**** Completion Commands

Here is a list of the completion commands defined in the minibuffer when completion is allowed.

***** TAB
Complete the text in the minibuffer as much as possible; if unable to complete, display a list of possible completions (minibuffer-complete).

***** SPC
Complete up to one word from the minibuffer text before point (minibuffer-complete-word). This command is not available for arguments that often include spaces, such as file names.

***** RET
Submit the text in the minibuffer as the argument, possibly completing first (minibuffer-complete-and-exit). See Completion Exit.

***** ?
Display a list of completions (minibuffer-completion-help).

***** TAB (minibuffer-complete)
is the most fundamental completion command. It searches for all possible completions that match the existing minibuffer text, and attempts to complete as much as it can. See How Completion Alternatives Are Chosen, for how completion alternatives are chosen.

***** SPC (minibuffer-complete-word)
completes like TAB, but only up to the next hyphen or space. If you have ‘auto-f’ in the minibuffer and type SPC, it finds that the completion is ‘auto-fill-mode’, but it only inserts ‘ill-’, giving ‘auto-fill-’. Another SPC at this point completes all the way to ‘auto-fill-mode’.

If TAB or SPC is unable to complete, it displays a list of matching completion alternatives (if there are any) in another window. You can display the same list with ? (minibuffer-completion-help). The following commands can be used with the completion list:

***** M-DOWN / M-UP
While in the minibuffer, M-DOWN (minibuffer-next-completion and M-UP (minibuffer-previous-completion) navigate through the completions and displayed in the completions buffer. When minibuffer-completion-auto-choose is non-nil (which is the default), using these commands also inserts the current completion candidate into the minibuffer. If minibuffer-completion-auto-choose is nil, you can use the M-RET command (minibuffer-choose-completion) to insert the completion candidates into the minibuffer. By default, that exits the minibuffer, but with a prefix argument, C-u M-RET inserts the currently active candidate without exiting the minibuffer.

***** M-v / PageUp
prior
Typing M-v, while in the minibuffer, selects the window showing the completion list (switch-to-completions). This paves the way for using the commands below. PageUp, prior and M-g M-c do the same. You can also select the window in other ways (see Multiple Windows).

***** RET / mouse-1 / mouse-2
While in the completion list buffer, this chooses the completion at point (choose-completion). With a prefix argument, C-u RET inserts the completion at point into the minibuffer, but doesn’t exit the minibuffer—thus, you can change your mind and choose another candidate.

***** TAB RIGHT n
While in the completion list buffer, these keys move point to the following completion alternative (next-completion).

***** S-TAB LEFT p
While in the completion list buffer, these keys move point to the previous completion alternative (previous-completion).

***** q
While in the completion list buffer, this quits the window showing it and selects the window showing the minibuffer (quit-window).

***** z
While in the completion list buffer, kill it and delete the window showing it (kill-current-buffer).


**** Completion Exit

When a command reads an argument using the minibuffer with completion, it also controls what happens when you type RET (minibuffer-complete-and-exit) to submit the argument. There are four types of behavior:

Strict completion accepts only exact completion matches. Typing RET exits the minibuffer only if the minibuffer text is an exact match, or completes to one. Otherwise, Emacs refuses to exit the minibuffer; instead it tries to complete, and if no completion can be done it momentarily displays ‘[No match]’ after the minibuffer text. (You can still leave the minibuffer by typing C-g to cancel the command.)
An example of a command that uses this behavior is M-x, since it is meaningless for it to accept a non-existent command name.

Cautious completion is like strict completion, except RET exits only if the text is already an exact match. If the text completes to an exact match, RET performs that completion but does not exit yet; you must type a second RET to exit.
Cautious completion is used for reading file names for files that must already exist, for example.

Permissive completion allows any input; the completion candidates are just suggestions. Typing RET does not complete, it just submits the argument as you have entered it.
Permissive completion with confirmation is like permissive completion, with an exception: if you typed TAB and this completed the text up to some intermediate state (i.e., one that is not yet an exact completion match), typing RET right afterward does not submit the argument. Instead, Emacs asks for confirmation by momentarily displaying ‘[Confirm]’ after the text; type RET again to confirm and submit the text. This catches a common mistake, in which one types RET before realizing that TAB did not complete as far as desired.
You can tweak the confirmation behavior by customizing the variable confirm-nonexistent-file-or-buffer. The default value, after-completion, gives the behavior we have just described. If you change it to nil, Emacs does not ask for confirmation, falling back on permissive completion. If you change it to any other non-nil value, Emacs asks for confirmation whether or not the preceding command was TAB.

This behavior is used by most commands that read file names, like C-x C-f, and commands that read buffer names, like C-x b.


**** How Completion Alternatives Are Chosen

Completion commands work by narrowing a large list of possible completion alternatives to a smaller subset that matches what you have typed in the minibuffer. In Completion Example, we gave a simple example of such matching. The procedure of determining what constitutes a match is quite intricate. Emacs attempts to offer plausible completions under most circumstances.

Emacs performs completion using one or more completion styles—sets of criteria for matching minibuffer text to completion alternatives. During completion, Emacs tries each completion style in turn. If a style yields one or more matches, that is used as the list of completion alternatives. If a style produces no matches, Emacs falls back on the next style.

The list variable completion-styles specifies the completion styles to use. Each list element is the name of a completion style (a Lisp symbol). The available style symbols are stored in the variable completion-styles-alist (see Completion Variables in The Emacs Lisp Reference Manual). The default completion styles are (in order):

***** basic ¶
A matching completion alternative must have the same beginning as the text in the minibuffer before point. Furthermore, if there is any text in the minibuffer after point, the rest of the completion alternative must contain that text as a substring.

***** partial-completion
This aggressive completion style divides the minibuffer text into words separated by hyphens or spaces, and completes each word separately. (For example, when completing command names, ‘em-l-m’ completes to ‘emacs-lisp-mode’.)

***** Furthermore, a ‘*’ in the minibuffer text
is treated as a wildcard—it matches any string of characters at the corresponding position in the completion alternative.

***** emacs22 ¶
This completion style is similar to basic, except that it ignores the text in the minibuffer after point. It is so-named because it corresponds to the completion behavior in Emacs 22.

The following additional completion styles are also defined, and you can add them to completion-styles if you wish (see Customization):

***** substring ¶
A matching completion alternative must contain the text in the minibuffer before point, and the text in the minibuffer after point, as substrings (in that same order).

Thus, if the text in the minibuffer is ‘foobar’, with point between ‘foo’ and ‘bar’, that matches ‘afoobbarc’, where a, b, and c can be any string including the empty string.

***** flex ¶
This aggressive completion style, also known as flx or fuzzy or scatter completion, attempts to complete using in-order substrings. For example, it can consider ‘foo’ to match ‘frodo’ or ‘fbarbazoo’.

***** initials ¶
This very aggressive completion style attempts to complete acronyms and initialisms. For example, when completing command names, it matches ‘lch’ to ‘list-command-history’.

There is also a very simple completion style called emacs21. In this style, if the text in the minibuffer is ‘foobar’, only matches starting with ‘foobar’ are considered.

You can use different completion styles in different situations, by setting the variable completion-category-overrides. For example, the default setting says to use only basic and substring completion for buffer names.


**** Completion Options

Case is significant when completing case-sensitive arguments, such as command names. For example, when completing command names, ‘AU’ does not complete to ‘auto-fill-mode’. Case differences are ignored when completing arguments in which case does not matter.

When completing file names, case differences are ignored if the variable read-file-name-completion-ignore-case is non-nil. The default value is nil on systems that have case-sensitive file-names, such as GNU/Linux; it is non-nil on systems that have case-insensitive file-names, such as Microsoft Windows. When completing buffer names, case differences are ignored if the variable read-buffer-completion-ignore-case is non-nil; the default is nil.

When completing file names, Emacs usually omits certain alternatives that are considered unlikely to be chosen, as determined by the list variable completion-ignored-extensions. Each element in the list should be a string; any file name ending in such a string is ignored as a completion alternative. Any element ending in a slash (/) represents a subdirectory name. The standard value of completion-ignored-extensions has several elements including ".o", ".elc", and "~". For example, if a directory contains ‘foo.c’ and ‘foo.elc’, ‘foo’ completes to ‘foo.c’. However, if all possible completions end in otherwise-ignored strings, they are not ignored: in the previous example, ‘foo.e’ completes to ‘foo.elc’. Emacs disregards completion-ignored-extensions when showing completion alternatives in the completion list.

Shell completion is an extended version of filename completion, see Shell Mode Options.

If completion-auto-help is set to nil, the completion commands never display the completion list buffer; you must type ? to display the list. If the value is lazy, Emacs only shows the completion list buffer on the second attempt to complete. In other words, if there is nothing to complete, the first TAB echoes ‘Next char not unique’; the second TAB shows the completion list buffer. If the value is always, the completion list buffer is always shown when completion is attempted.

The display of the completion list buffer after it is shown for the first time is also controlled by completion-auto-help. If the value is t or lazy, the window showing the completions pops down when Emacs is able to complete (and may pop up again if Emacs is again unable to complete after you type some more text); if the value is always, the window pops down only when you exit the completion. The value visible is a hybrid: it behaves like t when it decides whether to pop up the window showing the completion list buffer, and like always when it decides whether to pop it down.

Emacs can optionally select the window showing the completions when it shows that window. To enable this behavior, customize the user option completion-auto-select to t, which changes the behavior of TAB when Emacs pops up the completions: pressing TAB will switch to the completion list buffer, and you can then move to a candidate by cursor motion commands and select it with RET. If the value of completion-auto-select is second-tab, then the first TAB will pop up the completions list buffer, and the second one will switch to it.

If completion-cycle-threshold is non-nil, completion commands can cycle through completion alternatives. Normally, if there is more than one completion alternative for the text in the minibuffer, a completion command completes up to the longest common substring. If you change completion-cycle-threshold to t, the completion command instead completes to the first of those completion alternatives; each subsequent invocation of the completion command replaces that with the next completion alternative, in a cyclic manner. If you give completion-cycle-threshold a numeric value n, completion commands switch to this cycling behavior only when there are n or fewer alternatives.

When displaying completions, Emacs will normally pop up a new buffer to display the completions. The completions will by default be sorted horizontally, using as many columns as will fit in the window-width, but this can be changed by customizing the completions-format user option. If its value is vertical, Emacs will sort the completions vertically instead, and if it’s one-column, Emacs will use just one column.

The completions-sort user option controls the order in which the completions are sorted in the ‘*Completions*’ buffer. The default is alphabetical, which sorts in alphabetical order. The value nil disables sorting. The value can also be a function, which will be called with the list of completions, and should return the list in the desired order.

When completions-max-height is non-nil, it limits the size of the completions window. It is specified in lines and include mode, header line and a bottom divider, if any. For a more complex control of the Completion window display properties, you can use display-buffer-alist (see Action Alists for Buffer Display in The Emacs Lisp Reference Manual).

The variable completions-header-format is a format spec string to control the informative line shown before the completions list of candidates. If it contains a ‘%s’ construct, that get replaced by the number of completions shown in the completion list buffer. To suppress the display of the heading line, customize this variable to nil. The string that is the value of this variable can have text properties to change the visual appearance of the heading line; some useful properties face or cursor-intangible (see Properties with Special Meanings in The Emacs Lisp Reference Manual).

When completions-highlight-face names a face, the current completion candidate, the one that will be selected by typing RET or clicking the mouse, will be highlighted using that face. The default value of this variable is completions-highlight; the value is nil disables this highlighting. This feature uses the special text property cursor-face.


***  Minibuffer History

Everything you type in the minibuffer is saved in a minibuffer history list so you can easily use it again later. This includes completion candidates (such as file names, buffer names, command names, etc.) and any other kind of minibuffer input. You can use the following commands to quickly fetch an earlier or alternative response into the minibuffer:

**** M-p
Move to the previous item in the minibuffer history, an earlier argument (previous-history-element).

**** M-n
Move to the next item in the minibuffer history (next-history-element).

**** UP / DOWN
Like M-p and M-n, but move to the previous or next line of a multi-line item before going to the previous history item (previous-line-or-history-element and next-line-or-history-element) .

**** M-r regexp RET
Move to an earlier item in the minibuffer history that matches regexp (previous-matching-history-element).

**** M-s regexp RET
Move to a later item in the minibuffer history that matches regexp (next-matching-history-element).


*** Continuation for minibuffer history
While in the minibuffer, M-p (previous-history-element) moves through the minibuffer history list, one item at a time. Each M-p fetches an earlier item from the history list into the minibuffer, replacing its existing contents. Typing M-n (next-history-element) moves through the minibuffer history list in the opposite direction, fetching later entries into the minibuffer.

If you type M-n in the minibuffer when there are no later entries in the minibuffer history (e.g., if you haven’t previously typed M-p), Emacs tries fetching from a list of default arguments: values that you are likely to enter. You can think of this as moving through the “future history”.

The “future history” for file names includes several possible alternatives you may find useful, such as the file name or the URL at point in the current buffer. The defaults put into the “future history” in this case are controlled by the functions mentioned in the value of the option file-name-at-point-functions. By default, its value invokes the ffap package (see Finding Files and URLs at Point), which tries to guess the default file or URL from the text around point. To disable this guessing, customize the option to a nil value, then the “future history” of file names will include only the file, if any, visited by the current buffer, and the default directory.

The arrow keys UP and DOWN work like M-p and M-n, but if the current history item is longer than a single line, they allow you to move to the previous or next line of the current history item before going to the previous or next history item.

If you edit the text inserted by the M-p or M-n minibuffer history commands, this does not change its entry in the history list. However, the edited argument does go at the end of the history list when you submit it.

You can use M-r (previous-matching-history-element) to search through older elements in the history list, and M-s (next-matching-history-element) to search through newer entries. Each of these commands asks for a regular expression as an argument, and fetches the first matching entry into the minibuffer. See Syntax of Regular Expressions, for an explanation of regular expressions. A numeric prefix argument n means to fetch the nth matching entry. These commands are unusual, in that they use the minibuffer to read the regular expression argument, even though they are invoked from the minibuffer. An upper-case letter in the regular expression makes the search case-sensitive (see Lax Matching During Searching).

You can also search through the history using an incremental search. See Searching the Minibuffer.

Emacs keeps separate history lists for several different kinds of arguments. For example, there is a list for file names, used by all the commands that read file names. Other history lists include buffer names, command names (used by M-x), and command arguments (used by commands like query-replace).

The variable history-length specifies the maximum length of a minibuffer history list; adding a new element deletes the oldest element if the list gets too long. If the value is t, there is no maximum length.

The variable history-delete-duplicates specifies whether to delete duplicates in history. If it is non-nil, adding a new element deletes from the list all other elements that are equal to it. The default is nil.

*** Repeating Minibuffer Commands

Every command that uses the minibuffer once is recorded on a special history list, the command history, together with the values of its arguments, so that you can repeat the entire command. In particular, every use of M-x is recorded there, since M-x uses the minibuffer to read the command name.

C-x ESC ESC
Re-execute a recent minibuffer command from the command history (repeat-complex-command).

M-x list-command-history
Display the entire command history, showing all the commands C-x ESC ESC can repeat, most recent first.

C-x ESC ESC re-executes a recent command that used the minibuffer. With no argument, it repeats the last such command. A numeric argument specifies which command to repeat; 1 means the last one, 2 the previous, and so on.

C-x ESC ESC works by turning the previous command into a Lisp expression and then entering a minibuffer initialized with the text for that expression. Even if you don’t know Lisp, it will probably be obvious which command is displayed for repetition. If you type just RET, that repeats the command unchanged. You can also change the command by editing the Lisp expression before you execute it. The executed command is added to the front of the command history unless it is identical to the most recent item.

Once inside the minibuffer for C-x ESC ESC, you can use the usual minibuffer history commands (see Minibuffer History) to move through the history list. After finding the desired previous command, you can edit its expression as usual and then execute it by typing RET.

Incremental search does not, strictly speaking, use the minibuffer. Therefore, although it behaves like a complex command, it normally does not appear in the history list for C-x ESC ESC. You can make incremental search commands appear in the history by setting isearch-resume-in-command-history to a non-nil value. See Incremental Search.

The list of previous minibuffer-using commands is stored as a Lisp list in the variable command-history. Each element is a Lisp expression that describes one command and its arguments. Lisp programs can re-execute a command by calling eval with the command-history element.


*** Entering passwords

Sometimes, you may need to enter a password into Emacs. For instance, when you tell Emacs to visit a file on another machine via a network protocol such as FTP, you often need to supply a password to gain access to the machine (see Remote Files).

Entering a password is similar to using a minibuffer. Emacs displays a prompt in the echo area (such as ‘Password: ’); after you type the required password, press RET to submit it. To prevent others from seeing your password, every character you type is displayed as an asterisk (‘*’) instead of its usual form.

Most of the features and commands associated with the minibuffer cannot be used when entering a password. There is no history or completion, and you cannot change windows or perform any other action with Emacs until you have submitted the password.

While you are typing the password, you may press DEL to delete backwards, removing the last character entered. C-u deletes everything you have typed so far. C-g quits the password prompt (see Quitting and Aborting). C-y inserts the current kill into the password (see Killing and Moving Text). You may type either RET or ESC to submit the password. Any other self-inserting character key inserts the associated character into the password, and all other input is ignored.


*** Yes or No Prompts

An Emacs command may require you to answer a yes-or-no question during the course of its execution. Such queries come in two main varieties.

For the first type of yes-or-no query, the prompt ends with ‘(y or n)’. You answer the query by typing a single key, either ‘y’ or ‘n’, which immediately exits the minibuffer and delivers the response. For example, if you type C-x C-w (write-file) to save a buffer, and enter the name of an existing file, Emacs issues a prompt like this:

File ‘foo.el’ exists; overwrite? (y or n)
The second type of yes-or-no query is typically employed if giving the wrong answer would have serious consequences; it thus features a longer prompt ending with ‘(yes or no)’. For example, if you invoke C-x k (kill-buffer) on a file-visiting buffer with unsaved changes, Emacs activates the minibuffer with a prompt like this:

Buffer foo.el modified; kill anyway? (yes or no)
To answer, you must type ‘yes’ or ‘no’ into the minibuffer, followed by RET.

With both types of yes-or-no query the minibuffer behaves as described in the previous sections; you can recenter the selected window with C-l, scroll that window (C-v or PageDown scrolls forward, M-v or PageUp scrolls backward), switch to another window with C-x o, use the history commands M-p and M-n, etc. Type C-g to dismiss the query, and quit the minibuffer and the querying command (see Quitting and Aborting).





*** Running Commands by Name

Every Emacs command has a name that you can use to run it. For convenience, many commands also have key bindings. You can run those commands by typing the keys, or run them by name. Most Emacs commands have no key bindings, so the only way to run them is by name. (See Customizing Key Bindings, for how to set up key bindings.)

By convention, a command name consists of one or more words, separated by hyphens; for example, auto-fill-mode or manual-entry. Command names mostly use complete English words to make them easier to remember.

To run a command by name, start with M-x, type the command name, then terminate it with RET. M-x uses the minibuffer to read the command name. The string ‘M-x’ appears at the beginning of the minibuffer as a prompt to remind you to enter a command name to be run. RET exits the minibuffer and runs the command. See The Minibuffer, for more information on the minibuffer.

You can use completion to enter the command name. For example, to invoke the command forward-char, you can type

M-x forward-char RET
or

M-x forw TAB c RET
Note that forward-char is the same command that you invoke with the key C-f. The existence of a key binding does not stop you from running the command by name.

When M-x completes on commands, it ignores the commands that were declared obsolete in any previous major version of Emacs; for these, you will have to type their full name. Commands that were marked obsolete in the current version of Emacs are listed. (Obsolete commands are those for which newer, better alternatives exist, and which are slated for removal in some future Emacs release.)

In addition, M-x completion can exclude commands that are not relevant to, and generally cannot work with, the current buffer’s major mode (see Major Modes) and minor modes (see Minor Modes). By default, no commands are excluded, but you can customize the option read-extended-command-predicate to exclude those irrelevant commands from completion results.

Conversely, Emacs can exclude all commands except those that are particularly relevant to the current buffer. The M-S-x (that’s “meta shift x”) command works just like M-x, but instead of listing all (or most) of the commands Emacs knows about, it will only list the commands that have been marked as “belonging” to the current major mode, or any enabled minor modes.

To cancel the M-x and not run a command, type C-g instead of entering the command name. This takes you back to command level.

To pass a numeric argument to the command you are invoking with M-x, specify the numeric argument before M-x. The argument value appears in the prompt while the command name is being read, and finally M-x passes the argument to that command. For example, to pass the numeric argument of 42 to the command forward-char you can type C-u 42 M-x forward-char RET.

When the command you run with M-x has a key binding, Emacs mentions this in the echo area after running the command. For example, if you type M-x forward-word, the message says that you can run the same command by typing M-f. You can turn off these messages by setting the variable suggest-key-bindings to nil. The value of suggest-key-bindings can also be a number, in which case Emacs will show the binding for that many seconds before removing it from display. The default behavior is to display the binding for 2 seconds.

Additionally, when suggest-key-bindings is non-nil, the completion list of M-x shows equivalent key bindings for all commands that have them.

Commands that don’t have key bindings, can still be invoked after typing less than their full name at the ‘M-x’ prompt. Emacs mentions such shorthands in the echo area if they are significantly shorter than the full command name, and extended-command-suggest-shorter is non-nil. The setting of suggest-key-bindings affects these hints as well.

In this manual, when we speak of running a command by name, we often omit the RET that terminates the name. Thus we might say M-x auto-fill-mode rather than M-x auto-fill-mode RET. We mention the RET only for emphasis, such as when the command is followed by arguments.

M-x works by running the command execute-extended-command, which is responsible for reading the name of another command and invoking it.


** Major and Minor Modes ( See choosing file modes ✓✓✓ )

Emacs contains many editing modes that alter its basic behavior in useful ways. These are divided into major modes and minor modes.

Major modes provide specialized facilities for working on a particular file type, such as a C source file (see Editing Programs), or a particular type of non-file buffer, such as a shell buffer (see Running Shell Commands from Emacs). Major modes are mutually exclusive; each buffer has one and only one major mode at any time.

Minor modes are optional features which you can turn on or off, not necessarily specific to a type of file or buffer. For example, Auto Fill mode is a minor mode in which SPC breaks lines between words as you type (see Auto Fill Mode). Minor modes are independent of one another, and of the selected major mode.

*** Major Modes

Every buffer possesses a major mode, which determines the editing behavior of Emacs while that buffer is current. The mode line normally shows the name of the current major mode, in parentheses (see The Mode Line).

The least specialized major mode is called Fundamental mode. This mode has no mode-specific redefinitions or variable settings, so that each Emacs command behaves in its most general manner, and each user option variable is in its default state.

For editing text of a specific type that Emacs knows about, such as Lisp code or English text, you typically use a more specialized major mode, such as Lisp mode or Text mode. Most major modes fall into three major groups. The first group contains modes for normal text, either plain or with mark-up. It includes Text mode, HTML mode, SGML mode, TeX mode and Outline mode. The second group contains modes for specific programming languages. These include Lisp mode (which has several variants), C mode, Fortran mode, and others. The third group consists of major modes that are not associated directly with files; they are used in buffers created for specific purposes by Emacs. Examples include Dired mode for buffers made by Dired (see Dired, the Directory Editor), Message mode for buffers made by C-x m (see Sending Mail), and Shell mode for buffers used to communicate with an inferior shell process (see Interactive Subshell).

Usually, the major mode is automatically set by Emacs, when you first visit a file or create a buffer (see Choosing File Modes). You can explicitly select a new major mode by using an M-x command. Take the name of the mode and add -mode to get the name of the command to select that mode (e.g., M-x lisp-mode enters Lisp mode). Since every buffer has exactly one major mode, there is no way to “turn off” a major mode; instead you must switch to a different one.

The value of the buffer-local variable major-mode is a symbol with the same name as the major mode command (e.g., lisp-mode). This variable is set automatically; you should not change it yourself.

The default value of major-mode determines the major mode to use for files that do not specify a major mode, and for new buffers created with C-x b. Normally, this default value is the symbol fundamental-mode, which specifies Fundamental mode. You can change this default value via the Customization interface (see Easy Customization Interface), or by adding a line like this to your init file (see The Emacs Initialization File):

(setq-default major-mode 'text-mode)
If the default value of major-mode is nil, the major mode is taken from the previously current buffer.

Specialized major modes often change the meanings of certain keys to do something more suitable for the mode. For instance, programming language modes bind TAB to indent the current line according to the rules of the language (see Indentation). The keys that are commonly changed are TAB, DEL, and C-j. Many modes also define special commands of their own, usually bound to key sequences whose prefix key is C-c (see Keys). Major modes can also alter user options and variables; for instance, programming language modes typically set a buffer-local value for the variable comment-start, which determines how source code comments are delimited (see Manipulating Comments).

To view the documentation for the current major mode, including a list of its key bindings, type C-h m (describe-mode). See Other Help Commands.

Every major mode, apart from Fundamental mode, defines a mode hook, a customizable list of Lisp functions to run each time the mode is enabled in a buffer. See Hooks, for more information about hooks. Each mode hook is named after its major mode, e.g., Fortran mode has fortran-mode-hook. Furthermore, all text-based major modes run text-mode-hook, and many programming language modes 11 (including all those distributed with Emacs) run prog-mode-hook, prior to running their own mode hooks. Hook functions can look at the value of the variable major-mode to see which mode is actually being entered.

Mode hooks are commonly used to enable minor modes (see Minor Modes). For example, you can put the following lines in your init file to enable Flyspell minor mode in all text-based major modes (see Checking and Correcting Spelling), and ElDoc minor mode in Emacs Lisp mode (see Programming Language Documentation Lookup):

(add-hook 'text-mode-hook 'flyspell-mode)
(add-hook 'emacs-lisp-mode-hook 'eldoc-mode)
Footnotes
(11)
More specifically, the modes which are “derived” from prog-mode (see Derived Modes in The Emacs Lisp Reference Manual).


*** Minor Modes

A minor mode is an optional editing mode that alters the behavior of Emacs in some well-defined way. Unlike major modes, any number of minor modes can be in effect at any time. Some minor modes are buffer-local, and can be turned on (enabled) in certain buffers and off (disabled) in others. Other minor modes are global: while enabled, they affect everything you do in the Emacs session, in all buffers. Most minor modes are disabled by default, but a few are enabled by default.

Most buffer-local minor modes say in the mode line when they are enabled, just after the major mode indicator. For example, ‘Fill’ in the mode line means that Auto Fill mode is enabled. See The Mode Line.

Like major modes, each minor mode is associated with a mode command, whose name consists of the mode name followed by ‘-mode’. For instance, the mode command for Auto Fill mode is auto-fill-mode. But unlike a major mode command, which simply enables the mode, the mode command for a minor mode can either enable or disable it:

If you invoke the mode command directly with no prefix argument (either via M-x, or by binding it to a key and typing that key; see Customizing Key Bindings), that toggles the minor mode. The minor mode is turned on if it was off, and turned off if it was on.
If you invoke the mode command with a prefix argument, the minor mode is unconditionally turned off if that argument is zero or negative; otherwise, it is unconditionally turned on.
If the mode command is called via Lisp, the minor mode is unconditionally turned on if the argument is omitted or nil. This makes it easy to turn on a minor mode from a major mode’s mode hook (see Major Modes). A non-nil argument is handled like an interactive prefix argument, as described above.
Most minor modes also have a mode variable, with the same name as the mode command. Its value is non-nil if the mode is enabled, and nil if it is disabled. In general, you should not try to enable or disable the mode by changing the value of the mode variable directly in Lisp; you should run the mode command instead. However, setting the mode variable through the Customize interface (see Easy Customization Interface) will always properly enable or disable the mode, since Customize automatically runs the mode command for you.

The following is a list of some buffer-local minor modes:

Abbrev mode automatically expands text based on pre-defined abbreviation definitions. See Abbrevs.
Auto Fill mode inserts newlines as you type to prevent lines from becoming too long. See Filling Text.
Auto Save mode saves the buffer contents periodically to reduce the amount of work you can lose in case of a crash. See Auto-Saving: Protection Against Disasters.
Electric Quote mode automatically converts quotation marks. For example, it requotes text typed `like this' to text ‘like this’. You can control what kind of text it operates in, and you can disable it entirely in individual buffers. See Quotation Marks.
Enriched mode enables editing and saving of formatted text. See Enriched Text.
Flyspell mode automatically highlights misspelled words. See Checking and Correcting Spelling.
Font-Lock mode automatically highlights certain textual units found in programs. It is enabled globally by default, but you can disable it in individual buffers. See Text Faces.
Display Line Numbers mode is a convenience wrapper around display-line-numbers, setting it using the value of display-line-numbers-type. See Customization of Display.
Outline minor mode provides similar facilities to the major mode called Outline mode. See Outline Mode.
Overwrite mode causes ordinary printing characters to replace existing text instead of shoving it to the right. For example, if point is in front of the ‘B’ in ‘FOOBAR’, then in Overwrite mode typing a G changes it to ‘FOOGAR’, instead of producing ‘FOOGBAR’ as usual. In Overwrite mode, the command C-q inserts the next character whatever it may be, even if it is a digit—this gives you a way to insert a character instead of replacing an existing character. The mode command, overwrite-mode, is bound to the Insert key.
Binary Overwrite mode is a variant of Overwrite mode for editing binary files; it treats newlines and tabs like other characters, so that they overwrite other characters and can be overwritten by them. In Binary Overwrite mode, digits after C-q specify an octal character code, as usual.
Visual Line mode performs word wrapping, causing long lines to be wrapped at word boundaries. See Visual Line Mode.
And here are some useful global minor modes:

Column Number mode enables display of the current column number in the mode line. See The Mode Line.
Delete Selection mode causes text insertion to first delete the text in the region, if the region is active. See Operating on the Region.
Icomplete mode displays an indication of available completions when you are in the minibuffer and completion is active. See Fast minibuffer selection.
Line Number mode enables display of the current line number in the mode line. It is enabled by default. See The Mode Line.
Menu Bar mode gives each frame a menu bar. It is enabled by default. See Menu Bars.
Scroll Bar mode gives each window a scroll bar. It is enabled by default, but the scroll bar is only displayed on graphical terminals. See Scroll Bars.
Tool Bar mode gives each frame a tool bar. It is enabled by default, but the tool bar is only displayed on graphical terminals. See Tool Bars.
Tab Bar mode gives each frame a tab bar. See Tab Bars.
Tab Line mode gives each window a tab line. See Window Tab Line.
Transient Mark mode highlights the region, and makes many Emacs commands operate on the region when the mark is active. It is enabled by default. See The Mark and the Region.


*** Choosing File Modes ✓✓✓✓✓✓ 

When you visit a file, Emacs chooses a major mode automatically. Normally, it makes the choice based on the file name—for example, files whose names end in ‘.c’ are normally edited in C mode—but sometimes it chooses the major mode based on special text in the file. This special text can also be used to enable buffer-local minor modes.

Here is the exact procedure:

First, Emacs checks whether the file contains file-local mode variables. See Local Variables in Files. If there is a file-local variable that specifies a major mode, then Emacs uses that major mode, ignoring all other criteria. There are several methods to specify a major mode using a file-local variable; the simplest is to put the mode name in the first nonblank line, preceded and followed by ‘-*-’. Other text may appear on the line as well. For example,

; -*-Lisp-*-
tells Emacs to use Lisp mode. Note how the semicolon is used to make Lisp treat this line as a comment. You could equivalently write

; -*- mode: Lisp;-*-
You can also use file-local variables to specify buffer-local minor modes, by using eval specifications. For example, this first nonblank line puts the buffer in Lisp mode and enables Auto-Fill mode:

; -*- mode: Lisp; eval: (auto-fill-mode 1); -*-
Note, however, that it is usually inappropriate to enable minor modes this way, since most minor modes represent individual user preferences. If you personally want to use a minor mode for a particular file type, it is better to enable the minor mode via a major mode hook (see Major Modes).

Second, Emacs checks whether the file’s extension matches an entry in any directory-local auto-mode-alist. These are found using the .dir-locals.el facility (see Per-Directory Local Variables).

Third, if there is no file variable specifying a major mode, Emacs checks whether the file’s contents begin with ‘#!’. If so, that indicates that the file can serve as an executable shell command, which works by running an interpreter named on the file’s first line (the rest of the file is used as input to the interpreter). Therefore, Emacs tries to use the interpreter name to choose a mode. For instance, a file that begins with ‘#!/usr/bin/perl’ is opened in Perl mode. The variable interpreter-mode-alist specifies the correspondence between interpreter program names and major modes.

When the first line starts with ‘#!’, you usually cannot use the ‘-*-’ feature on the first line, because the system would get confused when running the interpreter. So Emacs looks for ‘-*-’ on the second line in such files as well as on the first line. The same is true for man pages which start with the magic string ‘'\"’ to specify a list of troff preprocessors.

Fourth, Emacs tries to determine the major mode by looking at the text at the start of the buffer, based on the variable magic-mode-alist. By default, this variable is nil (an empty list), so Emacs skips this step; however, you can customize it in your init file (see The Emacs Initialization File). The value should be a list of elements of the form

(regexp . mode-function)
where regexp is a regular expression (see Syntax of Regular Expressions), and mode-function is a major mode command. If the text at the beginning of the file matches regexp, Emacs chooses the major mode specified by mode-function.

Alternatively, an element of magic-mode-alist may have the form

(match-function . mode-function)
where match-function is a Lisp function that is called at the beginning of the buffer; if the function returns non-nil, Emacs set the major mode with mode-function.

Fifth—if Emacs still hasn’t found a suitable major mode—it looks at the file’s name. The correspondence between file names and major modes is controlled by the variable auto-mode-alist. Its value is a list in which each element has this form,

(regexp . mode-function)
or this form,

(regexp mode-function flag)
For example, one element normally found in the list has the form ("\\.c\\'" . c-mode), and it is responsible for selecting C mode for files whose names end in .c. (Note that ‘\\’ is needed in Lisp syntax to include a ‘\’ in the string, which must be used to suppress the special meaning of ‘.’ in regexps.)

If the element has the form (regexp mode-function flag) and flag is non-nil, then after calling mode-function (if it is non-nil), Emacs discards the suffix that matched regexp and searches the list again for another match. This “recursive extension stripping” is used for files which have multiple extensions, and the “outer” extension hides the “inner” one that actually specifies the right mode. For example, backup files and GPG-encrypted files with .gpg extension use this feature.

On GNU/Linux and other systems with case-sensitive file names, Emacs performs a case-sensitive search through auto-mode-alist; if this search fails, it performs a second case-insensitive search through the alist. To suppress the second search, change the variable auto-mode-case-fold to nil. On systems with case-insensitive file names, such as Microsoft Windows, Emacs performs a single case-insensitive search through auto-mode-alist.

Finally, if Emacs still hasn’t found a major mode to use, it compares the text at the start of the buffer to the variable magic-fallback-mode-alist. This variable works like magic-mode-alist, described above, except that it is consulted only after auto-mode-alist. By default, magic-fallback-mode-alist contains forms that check for image files, HTML/XML/SGML files, PostScript files, and Unix style Conf files.

Once a major mode is found, Emacs does a final check to see if the mode has been remapped by major-mode-remap-alist, in which case it uses the remapped mode instead. This is used when several different major modes can be used for the same file type, so you can specify which mode you prefer.

If you have changed the major mode of a buffer, you can return to the major mode Emacs would have chosen automatically, by typing M-x normal-mode. This is the same function that find-file calls to choose the major mode. If the buffer is visiting a file, this command also processes the file’s ‘-*-’ line and file-local variables list (if any). See Local Variables in Files. If the buffer doesn’t visit a file, the command processes only the major mode specification, if any, in the ‘-*-’ line and in the file-local variables list.

The commands C-x C-w and set-visited-file-name change to a new major mode if the new file name implies a mode (see Saving Files). (C-x C-s does this too, if the buffer wasn’t visiting a file.) However, this does not happen if the buffer contents specify a major mode, and certain special major modes do not allow the mode to change. You can turn off this mode-changing feature by setting change-major-mode-with-file-name to nil.




** Saving Emacs Sessions

You can use the desktop library to save the state of Emacs from one session to another. The saved Emacs desktop configuration includes the buffers, their file names, major modes, buffer positions, window and frame configuration, and some important global variables.

To enable this feature, use the Customization buffer (see Easy Customization Interface) to set desktop-save-mode to t for future sessions, or add this line in your init file (see The Emacs Initialization File):

(desktop-save-mode 1)
If you turn on desktop-save-mode in your init file, then when Emacs starts, it looks for a saved desktop in desktop-path (which defaults to user-emacs-directory and then your home directory) and uses the first desktop it finds. While Emacs runs with desktop-save-mode turned on, it by default auto-saves the desktop whenever any of the desktop configuration changes. The variable desktop-auto-save-timeout determines how frequently Emacs checks for modifications to your desktop. The desktop is also saved when you exit Emacs.

Specify the option ‘--no-desktop’ on the Emacs command line when you don’t want it to reload any saved desktop configurations. This turns off desktop-save-mode for the current session. Starting Emacs with the ‘--no-init-file’ option also disables desktop reloading, since it bypasses the init file, where desktop-save-mode is usually turned on.

You can have separate saved desktop configurations in different directories; starting Emacs from a directory where you have a saved desktop configuration will restore that configuration, provided that you customize desktop-path to prepend . (the current directory) to the other directories there. You can save the current desktop and reload the one saved in another directory by typing M-x desktop-change-dir. Typing M-x desktop-revert reverts to the previously reloaded desktop.

The file in which Emacs saves the desktop is locked while the session runs, to avoid inadvertently overwriting it from another Emacs session. That lock is normally removed when Emacs exits, but if Emacs or your system crashes, the lock stays, and when you restart Emacs, it will by default ask you whether to use the locked desktop file. You can avoid the question by customizing the variable desktop-load-locked-desktop to either nil, which means never load the desktop in this case, or t, which means load the desktop without asking. You can also customize the variable to the special value check-pid, which means to load the file if the Emacs process that has locked the desktop is not running on the local machine. This should not be used in circumstances where the locking Emacs might still be running on another machine, which could be the case in multi-user environments where your home directory is mounted remotely using NFS or similar.

When Emacs starts in daemon mode, it cannot ask you any questions, so if it finds the desktop file locked, it will not load it, unless desktop-load-locked-desktop is t. Note that restoring the desktop in daemon mode is somewhat problematic for other reasons: e.g., the daemon cannot use GUI features, so parameters such as frame position, size, and decorations cannot be restored. For that reason, you may wish to delay restoring the desktop in daemon mode until the first client connects, by calling desktop-read (see below) in a hook function that you add to server-after-make-frame-hook (see Creating Frames in The Emacs Lisp Reference Manual).

Whenever you want, you can use the command M-x desktop-save to force immediate saving of the current desktop. This is useful either if you do not want to use the automatic desktop restoration, and thus don’t turn on desktop-save-mode, or when you have made significant changes to the desktop, and want to make sure the configuration doesn’t get lost if Emacs or your system crashes. You can use M-x desktop-read to restore a previously-saved desktop if the current Emacs session didn’t load any desktop yet.

By default, the desktop tries to save and restore the frame and window configuration. To disable this, set desktop-restore-frames to nil. (See that variable’s documentation for some related options that you can customize to fine-tune this behavior.)

When the desktop restores the frame and window configuration, it uses the recorded values of frame parameters, disregarding any settings for those parameters you have in your init file (see The Emacs Initialization File). This means that frame parameters such as fonts and faces for the restored frames will come from the desktop file, where they were saved when you exited your previous Emacs session; any settings for those parameters in your init file will be ignored. To disable this, customize the value of frameset-filter-alist to filter out the frame parameters you don’t want to be restored; they will then be set according to your customizations in the init file.

Information about buffers visiting remote files is not saved by default. Customize the variable desktop-files-not-to-save to change this.

By default, all the buffers in the desktop are restored in one go. However, this may be slow if there are a lot of buffers in the desktop. You can specify the maximum number of buffers to restore immediately with the variable desktop-restore-eager; the remaining buffers are restored lazily, when Emacs is idle.

Type M-x desktop-clear to empty the Emacs desktop; this can be useful, for example, if you want to switch to another desktop by invoking M-x desktop-read next. The desktop-clear command kills all buffers except for internal ones, and clears the global variables listed in desktop-globals-to-clear. If you want it to preserve certain buffers, customize the variable desktop-clear-preserve-buffers-regexp, whose value is a regular expression matching the names of buffers not to kill.

If you want to save minibuffer history from one session to another, use the savehist library. You can also save selected minibuffer-history variables as part of desktop-save-mode if you add those variables to the value of desktop-globals-to-save.




** Recursive Editing Levels

A recursive edit is a situation in which you are using Emacs commands to perform arbitrary editing while in the middle of another Emacs command. For example, when you type C-r inside of a query-replace, you enter a recursive edit in which you can change the current buffer. On exiting from the recursive edit, you go back to the query-replace. See Query Replace.

Exiting the recursive edit means returning to the unfinished command, which continues execution. The command to exit is C-M-c (exit-recursive-edit).

You can also abort the recursive edit. This is like exiting, but also quits the unfinished command immediately. Use the command C-] (abort-recursive-edit) to do this. See Quitting and Aborting.

The mode line shows you when you are in a recursive edit by displaying square brackets around the parentheses that always surround the major and minor mode names. Every window’s mode line shows this in the same way, since being in a recursive edit is true of Emacs as a whole rather than any particular window or buffer.

It is possible to be in recursive edits within recursive edits. For example, after typing C-r in a query-replace, you may type a command that enters the debugger. This begins a recursive editing level for the debugger, within the recursive editing level for C-r. Mode lines display a pair of square brackets for each recursive editing level currently in progress.

Exiting the inner recursive edit (such as with the debugger c command) resumes the command running in the next level up. When that command finishes, you can then use C-M-c to exit another recursive editing level, and so on. Exiting applies to the innermost level only. Aborting also gets out of only one level of recursive edit; it returns immediately to the command level of the previous recursive edit. If you wish, you can then abort the next recursive editing level.

Alternatively, the command M-x top-level aborts all levels of recursive edits, returning immediately to the top-level command reader. It also exits the minibuffer, if it is active.

The text being edited inside the recursive edit need not be the same text that you were editing at top level. It depends on what the recursive edit is for. If the command that invokes the recursive edit selects a different buffer first, that is the buffer you will edit recursively. In any case, you can switch buffers within the recursive edit in the normal manner (as long as the buffer-switching keys have not been rebound). You could probably do all the rest of your editing inside the recursive edit, visiting files and all. But this could have surprising effects (such as stack overflow) from time to time. So remember to exit or abort the recursive edit when you no longer need it.

In general, we try to minimize the use of recursive editing levels in GNU Emacs. This is because they constrain you to go back in a particular order—from the innermost level toward the top level. When possible, we present different activities in separate buffers so that you can switch between them as you please. Some commands switch to a new major mode which provides a command to switch back. These approaches give you more flexibility to go back to unfinished tasks in the order you choose.



** Quitting and Aborting

C-g
C-Break (MS-DOS only)
Quit: cancel running or partially typed command.

C-]
Abort innermost recursive editing level and cancel the command which invoked it (abort-recursive-edit).

ESC ESC ESC
Either quit or abort, whichever makes sense (keyboard-escape-quit).

M-x top-level
Abort all recursive editing levels that are currently executing.

C-/
C-x u
C-_
Cancel a previously made change in the buffer contents (undo).

There are two ways of canceling a command before it has finished: quitting with C-g, and aborting with C-] or M-x top-level. Quitting cancels a partially typed command, or one which is still running. Aborting exits a recursive editing level and cancels the command that invoked the recursive edit (see Recursive Editing Levels).

Quitting with C-g is the way to get rid of a partially typed command, or a numeric argument that you don’t want. Furthermore, if you are in the middle of a command that is running, C-g stops the command in a relatively safe way. For example, if you quit out of a kill command that is taking a long time, either your text will all still be in the buffer, or it will all be in the kill ring, or maybe both. If the region is active, C-g deactivates the mark, unless Transient Mark mode is off (see Disabling Transient Mark Mode). If you are in the middle of an incremental search, C-g behaves specially; it may take two successive C-g characters to get out of a search. See Incremental Search, for details.

If you type C-g in a minibuffer, this quits the command that opened that minibuffer, closing it. If that minibuffer is not the most recently opened one (which can happen when minibuffer-follows-selected-frame is nil (see Using the Minibuffer)), C-g also closes the more recently opened ones, quitting their associated commands, after asking you for confirmation.

On MS-DOS, the character C-Break serves as a quit character like C-g. The reason is that it is not feasible, on MS-DOS, to recognize C-g while a command is running, between interactions with the user. By contrast, it is feasible to recognize C-Break at all times. See Keyboard Usage on MS-DOS.

C-g works by setting the variable quit-flag to t the instant C-g is typed; Emacs Lisp checks this variable frequently, and quits if it is non-nil. C-g is only actually executed as a command if you type it while Emacs is waiting for input. In that case, the command it runs is keyboard-quit.

On a text terminal, if you quit with C-g a second time before the first C-g is recognized, you activate the emergency-escape feature and return to the shell. See Emergency Escape.

There are some situations where you cannot quit. When Emacs is waiting for the operating system to do something, quitting is impossible unless special pains are taken for the particular system call within Emacs where the waiting occurs. We have done this for the system calls that users are likely to want to quit from, but it’s possible you will encounter a case not handled. In one very common case—waiting for file input or output using NFS—Emacs itself knows how to quit, but many NFS implementations simply do not allow user programs to stop waiting for NFS when the NFS server is hung.

Aborting with C-] (abort-recursive-edit) is used to get out of a recursive editing level and cancel the command which invoked it. Quitting with C-g does not do this, and could not do this, because it is used to cancel a partially typed command within the recursive editing level. Both operations are useful. For example, if you are in a recursive edit and type C-u 8 to enter a numeric argument, you can cancel that argument with C-g and remain in the recursive edit.

The sequence ESC ESC ESC (keyboard-escape-quit) can either quit or abort. (We defined it this way because ESC means “get out” in many PC programs.) It can cancel a prefix argument, clear a selected region, or get out of a Query Replace, like C-g. It can get out of the minibuffer or a recursive edit, like C-]. It can also get out of splitting the frame into multiple windows, as with C-x 1. One thing it cannot do, however, is stop a command that is running. That’s because it executes as an ordinary command, and Emacs doesn’t notice it until it is ready for the next command.

The command M-x top-level is equivalent to enough C-] commands to get you out of all the levels of recursive edits that you are in; it also exits the minibuffer if it is active. C-] gets you out one level at a time, but M-x top-level goes out all levels at once. Both C-] and M-x top-level are like all other commands, and unlike C-g, in that they take effect only when Emacs is ready for a command. C-] is an ordinary key and has its meaning only because of its binding in the keymap. See Recursive Editing Levels.

C-/ (undo) is not strictly speaking a way of canceling a command, but you can think of it as canceling a command that already finished executing. See Undo, for more information about the undo facility.



* The Emacs Initialization File

When Emacs is started, it normally tries to load a Lisp program from an initialization file, or init file for short. This file, if it exists, specifies how to initialize Emacs for you. Traditionally, file ~/.emacs is used as the init file, although Emacs also looks at ~/.emacs.el, ~/.emacs.d/init.el, ~/.config/emacs/init.el, or other locations. See How Emacs Finds Your Init File.

You may find it convenient to have all your Emacs configuration in one directory, in which case you should use ~/.emacs.d/init.el or the XDG-compatible ~/.config/emacs/init.el.

You can use the command line switch ‘-q’ to prevent loading your init file, and ‘-u’ (or ‘--user’) to specify a different user’s init file (see Initial Options).

There can also be a default init file, which is the library named default.el, found via the standard search path for libraries. The Emacs distribution contains no such library; your site may create one for local customizations. If this library exists, it is loaded whenever you start Emacs (except when you specify ‘-q’). But your init file, if any, is loaded first; if it sets inhibit-default-init non-nil, then default is not loaded.

Your site may also have a site startup file; this is named site-start.el, if it exists. Like default.el, Emacs finds this file via the standard search path for Lisp libraries. Emacs loads this library before it loads your init file. To inhibit loading of this library, use the option ‘--no-site-file’. See Initial Options. We recommend against using site-start.el for changes that some users may not like. It is better to put them in default.el, so that users can more easily override them.

You can place default.el and site-start.el in any of the directories which Emacs searches for Lisp libraries. The variable load-path (see Libraries of Lisp Code for Emacs) specifies these directories. Many sites put these files in a subdirectory named site-lisp in the Emacs installation directory, such as /usr/local/share/emacs/site-lisp.

Byte-compiling your init file is not recommended (see Byte Compilation in the Emacs Lisp Reference Manual). It generally does not speed up startup very much, and often leads to problems when you forget to recompile the file. A better solution is to use the Emacs server to reduce the number of times you have to start Emacs (see Using Emacs as a Server). If your init file defines many functions, consider moving them to a separate (byte-compiled) file that you load in your init file.

If you are going to write actual Emacs Lisp programs that go beyond minor customization, you should read the Emacs Lisp Reference Manual. See Emacs Lisp in the Emacs Lisp Reference Manual.


*** Init File Syntax

The init file contains one or more Lisp expressions. Each of these consists of a function name followed by arguments, all surrounded by parentheses. For example, (setq fill-column 60) calls the function setq to set the variable fill-column (see Filling Text) to 60.

You can set any Lisp variable with setq, but with certain variables setq won’t do what you probably want in the init file. Some variables automatically become buffer-local when set with setq; what you want in the init file is to set the default value, using setq-default. (The following section has examples of both of these methods.)

Some customizable minor mode variables do special things to enable the mode when you set them with Customize, but ordinary setq won’t do that; to enable the mode in your init file, call the minor mode command. Finally, a few customizable user options are initialized in complex ways, and these have to be set either via the customize interface (see Customization), or by using customize-set-variable/setopt (see Examining and Setting Variables).

The second argument to setq is an expression for the new value of the variable. This can be a constant, a variable, or a function call expression. In the init file, constants are used most of the time. They can be:

Numbers:
Numbers are written in decimal, with an optional initial minus sign.

Strings: ¶
Lisp string syntax is the same as C string syntax with a few extra features. Use a double-quote character to begin and end a string constant.

In a string, you can include newlines and special characters literally. But often it is cleaner to use backslash sequences for them: ‘\n’ for newline, ‘\b’ for backspace, ‘\r’ for carriage return, ‘\t’ for tab, ‘\f’ for formfeed (control-L), ‘\e’ for escape, ‘\\’ for a backslash, ‘\"’ for a double-quote, or ‘\ooo’ for the character whose octal code is ooo. Backslash and double-quote are the only characters for which backslash sequences are mandatory.

‘\C-’ can be used as a prefix for a control character, as in ‘\C-s’ for ASCII control-S, and ‘\M-’ can be used as a prefix for a Meta character, as in ‘\M-a’ for Meta-A or ‘\M-\C-a’ for Ctrl-Meta-A.

See Non-ASCII Characters in Init Files, for information about including non-ASCII in your init file.

Characters: ¶
Lisp character constant syntax consists of a ‘?’ followed by either a character or an escape sequence starting with ‘\’. Examples: ?x, ?\n, ?\", ?\). Note that strings and characters are not interchangeable in Lisp; some contexts require one and some contexts require the other.

See Non-ASCII Characters in Init Files, for information about binding commands to keys which send non-ASCII characters.

True:
t stands for “true”.

False:
nil stands for “false”.

Other Lisp objects: ¶
Write a single-quote (') followed by the Lisp object you want.

For more information on the Emacs Lisp syntax, see Introduction in The Emacs Lisp Reference Manual.


*** Init File Examples

Here are some examples of doing certain commonly desired things with Lisp expressions:

Add a directory to the variable load-path. You can then put Lisp libraries that are not included with Emacs in this directory, and load them with M-x load-library. See Libraries of Lisp Code for Emacs.
(add-to-list 'load-path "/path/to/lisp/libraries")
Make TAB in C mode just insert a tab if point is in the middle of a line.
(setq c-tab-always-indent nil)
Here we have a variable whose value is normally t for “true” and the alternative is nil for “false”.

Make searches case sensitive by default (in all buffers that do not override this).
(setq-default case-fold-search nil)
This sets the default value, which is effective in all buffers that do not have local values for the variable (see Local Variables). Setting case-fold-search with setq affects only the current buffer’s local value, which is probably not what you want to do in an init file.

Specify your own email address, if Emacs can’t figure it out correctly.
(setq user-mail-address "cheney@torture.gov")
Various Emacs packages, such as Message mode, consult user-mail-address when they need to know your email address. See Mail Header Fields.

Make Text mode the default mode for new buffers.
(setq-default major-mode 'text-mode)
Note that text-mode is used because it is the command for entering Text mode. The single-quote before it makes the symbol a constant; otherwise, text-mode would be treated as a variable name.

Set up defaults for the Latin-1 character set, which supports most of the languages of Western Europe.
(set-language-environment "Latin-1")
Turn off Line Number mode, a global minor mode.
(line-number-mode 0)
Turn on Auto Fill mode automatically in Text mode and related modes (see Hooks).
(add-hook 'text-mode-hook 'auto-fill-mode)
Change the coding system used when using the clipboard (see Coding Systems for Interprocess Communication).
(setopt selection-coding-system 'utf-8)
Load the installed Lisp library named foo (actually a file foo.elc or foo.el in a standard Emacs directory).
(load "foo")
When the argument to load is a relative file name, not starting with ‘/’ or ‘~’, load searches the directories in load-path (see Libraries of Lisp Code for Emacs).

Load the compiled Lisp file foo.elc from your home directory.
(load "~/foo.elc")
Here a full file name is used, so no searching is done.

Tell Emacs to find the definition for the function myfunction by loading a Lisp library named mypackage (i.e., a file mypackage.elc or mypackage.el):
(autoload 'myfunction "mypackage" "Do what I say." t)
Here the string "Do what I say." is the function’s documentation string. You specify it in the autoload definition so it will be available for help commands even when the package is not loaded. The last argument, t, indicates that this function is interactive; that is, it can be invoked interactively by typing M-x myfunction RET or by binding it to a key. If the function is not interactive, omit the t or use nil.

Rebind the key C-x l to run the function make-symbolic-link (see Rebinding Keys in Your Init File).
(keymap-global-set "C-x l" 'make-symbolic-link)
or

(keymap-set global-map "C-x l" 'make-symbolic-link)
Note once again the single-quote used to refer to the symbol make-symbolic-link instead of its value as a variable.

Do the same thing for Lisp mode only.
(keymap-set lisp-mode-map "C-x l" 'make-symbolic-link)
Redefine all keys which now run next-line in Fundamental mode so that they run forward-line instead.
(keymap-substitute global-map 'next-line 'forward-line)
Make C-x C-v undefined.
(keymap-global-unset "C-x C-v")
One reason to undefine a key is so that you can make it a prefix. Simply defining C-x C-v anything will make C-x C-v a prefix, but C-x C-v must first be freed of its usual non-prefix definition.

Make ‘$’ have the syntax of punctuation in Text mode. Note the use of a character constant for ‘$’.
(modify-syntax-entry ?\$ "." text-mode-syntax-table)
Enable the use of the command narrow-to-region without confirmation.
(put 'narrow-to-region 'disabled nil)
Adjusting the configuration to various platforms and Emacs versions.
Users typically want Emacs to behave the same on all systems, so the same init file is right for all platforms. However, sometimes it happens that a function you use for customizing Emacs is not available on some platforms or in older Emacs versions. To deal with that situation, put the customization inside a conditional that tests whether the function or facility is available, like this:

(if (fboundp 'blink-cursor-mode)
    (blink-cursor-mode 0))

(if (boundp 'coding-category-utf-8)
    (set-coding-priority '(coding-category-utf-8)))
You can also simply disregard the errors that occur if the function is not defined.

(ignore-errors (set-face-background 'region "grey75"))
A setq on a variable which does not exist is generally harmless, so those do not need a conditional.

Using use-package to automatically load and configure a package.
(use-package hi-lock
  :defer t
  :init (add-hook 'some-hook 'hi-lock-mode)
  :config (use-package my-hi-lock)
  :bind (("M-o l" . highlight-lines-matching-regexp)
         ("M-o r" . highlight-regexp)
         ("M-o w" . highlight-phrase)))
This will load hi-lock when some of its commands or variables are first used, bind 3 keys to its commands, and additionally load the my-hi-lock package (presumably further customizing hi-lock) after loading hi-lock. The use-package facility is fully documented in its own manual, see use-package User manual.


*** Terminal-specific Initialization

Each terminal type can have a Lisp library to be loaded into Emacs when it is run on that type of terminal. For a terminal type named termtype, the library is called term/termtype. (If there is an entry of the form (termtype . alias) in the term-file-aliases association list, Emacs uses alias in place of termtype.) The library is found by searching the directories load-path as usual and trying the suffixes ‘.elc’ and ‘.el’. Normally it appears in the subdirectory term of the directory where most Emacs libraries are kept.

The usual purpose of the terminal-specific library is to map the escape sequences used by the terminal’s function keys onto more meaningful names, using input-decode-map. See the file term/lk201.el for an example of how this is done. Many function keys are mapped automatically according to the information in the Termcap data base; the terminal-specific library needs to map only the function keys that Termcap does not specify.

When the terminal type contains a hyphen, only the part of the name before the first hyphen is significant in choosing the library name. Thus, terminal types ‘aaa-48’ and ‘aaa-30-rv’ both use the library term/aaa. The code in the library can use (getenv "TERM") to find the full terminal type name.

The library’s name is constructed by concatenating the value of the variable term-file-prefix and the terminal type. Your .emacs file can prevent the loading of the terminal-specific library by setting term-file-prefix to nil.

Emacs runs the hook tty-setup-hook at the end of initialization, after both your .emacs file and any terminal-specific library have been read in. Add hook functions to this hook if you wish to override part of any of the terminal-specific libraries and to define initializations for terminals that do not have a library. See Hooks.


*** How Emacs Finds Your Init File

Emacs normally finds your init file in a location under your home directory25. See The Emacs Initialization File.

Emacs looks for your init file using the filenames ~/.emacs.el, ~/.emacs, or ~/.emacs.d/init.el in that order; you can choose to use any one of these names. (Note that only the locations directly in your home directory have a leading dot in the location’s basename.)

Emacs can also look in an XDG-compatible location for init.el, the default is the directory ~/.config/emacs. This can be overridden by setting XDG_CONFIG_HOME in your environment, its value replaces ~/.config in the name of the default XDG init file. However ~/.emacs.d, ~/.emacs, and ~/.emacs.el are always preferred if they exist, which means that you must delete or rename them in order to use the XDG location.

Note also that if neither the XDG location nor ~/.emacs.d exist, then Emacs will create ~/.emacs.d (and therefore use it during subsequent invocations).

Emacs will set user-emacs-directory to the directory it decides to use.

Although this is backward-compatible with older Emacs versions, modern POSIX platforms prefer putting your initialization files under ~/.config so that troubleshooting a problem that might be due to a bad init file, or archiving a collection of init files, can be done by renaming that directory. To help older Emacs versions find configuration files in their current default locations, you can execute the following Emacs Lisp code:

(make-symbolic-link ".config/emacs" "~/.emacs.d")
However, if you run Emacs from a shell started by su and XDG_CONFIG_HOME is not set in your environment, Emacs tries to find your own initialization files, not that of the user you are currently pretending to be. The idea is that you should get your own editor customizations even if you are running as the super user.

More precisely, Emacs first determines which user’s init file to use. It gets your user name from the environment variables LOGNAME and USER; if neither of those exists, it uses the effective user-ID. If that user name matches the real user-ID, then Emacs uses HOME; otherwise, it looks up the home directory corresponding to that user name in the system’s data base of users.

For brevity the rest of the Emacs documentation generally uses just the current default location ~/.emacs.d/init.el for the init file.

Footnotes
(25)
On MS-Windows, there’s no single directory considered by all programs as “the home directory” of the user. Emacs uses one of the pertinent directories as the equivalent of your home directory; see HOME and Startup Directories on MS-Windows, for the details.


*** Non-ASCII Characters in Init Files

Language and coding systems may cause problems if your init file contains non-ASCII characters, such as accented letters, in strings or key bindings.

If you want to use non-ASCII characters in your init file, you should put a ‘-*-coding: coding-system-*-’ tag on the first line of the init file, and specify a coding system that supports the character(s) in question. See Recognizing Coding Systems. This is because the defaults for decoding non-ASCII text might not yet be set up by the time Emacs reads those parts of your init file which use such strings, possibly leading Emacs to decode those strings incorrectly. You should then avoid adding Emacs Lisp code that modifies the coding system in other ways, such as calls to set-language-environment.

An alternative to using non-ASCII characters directly is to use one of the character escape syntaxes described in see General Escape Syntax in The Emacs Lisp Reference Manual, as they allow all Unicode codepoints to be specified using only ASCII characters.

To bind non-ASCII keys, you must use a vector (see Rebinding Keys in Your Init File). The string syntax cannot be used, since the non-ASCII characters will be interpreted as meta keys. For instance:

(global-set-key [?char] 'some-function)
Type C-q, followed by the key you want to bind, to insert char.


*** The Early Init File

Most customizations for Emacs should be put in the normal init file. See The Emacs Initialization File. However, it is sometimes necessary to have customizations take effect during Emacs startup earlier than the normal init file is processed. Such customizations can be put in the early init file, ~/.config/emacs/early-init.el or ~/.emacs.d/early-init.el. This file is loaded before the package system and GUI is initialized, so in it you can customize variables that affect the package initialization process, such as package-enable-at-startup, package-load-list, and package-user-dir. Note that variables like package-archives which only affect the installation of new packages, and not the process of making already-installed packages available, may be customized in the regular init file. See Package Installation.

We do not recommend that you move into early-init.el customizations that can be left in the normal init files. That is because the early init file is read before the GUI is initialized, so customizations related to GUI features will not work reliably in early-init.el. By contrast, the normal init files are read after the GUI is initialized. If you must have customizations in the early init file that rely on GUI features, make them run off hooks provided by the Emacs startup, such as window-setup-hook or tty-setup-hook. See Hooks.

For more information on the early init file, see Init File in The Emacs Lisp Reference Manual.



** Keeping Persistent Authentication Information

Some Emacs packages, which connect to other services, require authentication (see Entering passwords), e.g., see Gnus in The Gnus Manual, or Tramp in The Tramp Manual. Because it might be annoying to provide the same user name and password again and again, Emacs offers to keep this information persistent via the auth-source library.

By default, the authentication information is taken from the file ~/.authinfo or ~/.authinfo.gpg or ~/.netrc. These files have a syntax similar to netrc files as known from the ftp program, like this:

machine mymachine login myloginname password mypassword port myport
Similarly, the auth-source library supports multiple storage backend, currently either the classic netrc backend, JSON files, the Secret Service API, and pass, the standard unix password manager.

All these alternatives can be customized via the user option auth-sources, see Emacs auth-source in Emacs auth-source.

When a password is entered interactively, which is not found via the configured backend, some of the backends offer to save it persistently. This can be changed by customizing the user option auth-source-save-behavior.


* security ???

** Host Security

Emacs runs inside an operating system such as GNU/Linux, and relies on the operating system to check security constraints such as accesses to files. The default settings for Emacs are designed for typical use; they may require some tailoring in environments where security is more of a concern, or less of a concern, than usual. For example, file-local variables can be risky, and you can set the variable enable-local-variables to :safe or (even more conservatively) to nil; conversely, if your files can all be trusted and the default checking for these variables is irritating, you can set enable-local-variables to :all. See Safety of File Variables.

See Security Considerations in The Emacs Lisp Reference Manual, for more information about security considerations when using Emacs as part of a larger application.


** Network Security

Whenever Emacs establishes any network connection, it passes the established connection to the Network Security Manager (NSM). NSM is responsible for enforcing the network security under your control. Currently, this works by using the Transport Layer Security (TLS) features.

The network-security-level variable determines the security level that NSM enforces. If its value is low, no security checks are performed. This is not recommended, and will basically mean that your network connections can’t be trusted. However, the setting can be useful in limited circumstances, as when testing network issues.

If this variable is medium (which is the default), a number of checks will be performed. If as result NSM determines that the network connection might not be trustworthy, it will make you aware of that, and will ask you what to do about the network connection.

You can decide to register a permanent security exception for an unverified connection, a temporary exception, or refuse the connection entirely.

In addition to the basic certificate correctness checks, several TLS algorithm checks are available. Some encryption technologies that were previously thought to be secure have shown themselves to be fragile, so Emacs (by default) warns you about some of these problems.

The protocol network checks is controlled via the network-security-protocol-checks variable.

It’s an alist where the first element of each association is the name of the check, and the second element is the security level where the check should be used.

An element like (rc4 medium) will result in the function nsm-protocol-check--rc4 being called like thus: (nsm-protocol-check--rc4 host port status settings). The function should return non-nil if the connection should proceed and nil otherwise.

Below is a list of the checks done on the default medium level.

unable to verify a TLS certificate
If the connection is a TLS, SSL or STARTTLS connection, NSM will check whether the certificate used to establish the identity of the server we’re connecting to can be verified.

While an invalid certificate is often the cause for concern (there could be a Man-in-the-Middle hijacking your network connection and stealing your password), there may be valid reasons for going ahead with the connection anyway. For instance, the server may be using a self-signed certificate, or the certificate may have expired. It’s up to you to determine whether it’s acceptable to continue with the connection.

a self-signed certificate has changed
If you’ve previously accepted a self-signed certificate, but it has now changed, that could mean that the server has just changed the certificate, but it might also mean that the network connection has been hijacked.

previously encrypted connection now unencrypted
If the connection is unencrypted, but it was encrypted in previous sessions, this might mean that there is a proxy between you and the server that strips away STARTTLS announcements, leaving the connection unencrypted. This is usually very suspicious.

talking to an unencrypted service when sending a password
When connecting to an IMAP or POP3 server, these should usually be encrypted, because it’s common to send passwords over these connections. Similarly, if you’re sending email via SMTP that requires a password, you usually want that connection to be encrypted. If the connection isn’t encrypted, NSM will warn you.

Diffie-Hellman low prime bits
When doing the public key exchange, the number of prime bits should be high enough to ensure that the channel can’t be eavesdropped on by third parties. If this number is too low, Emacs will warn you. (This is the diffie-hellman-prime-bits check in network-security-protocol-checks).

RC4 stream cipher
The RC4 stream cipher is believed to be of low quality and may allow eavesdropping by third parties. (This is the rc4 check in network-security-protocol-checks).

SHA1 in the host certificate or in intermediate certificates
It is believed that if an intermediate certificate uses the SHA1 hashing algorithm, then third parties can issue certificates pretending to be that issuing instance. These connections are therefore vulnerable to man-in-the-middle attacks. (These are the signature-sha1 and intermediate-sha1 checks in network-security-protocol-checks).

SSL1, SSL2 and SSL3
The protocols older than TLS1.0 are believed to be vulnerable to a variety of attacks, and you may want to avoid using these if what you’re doing requires higher security. (This is the ssl check in network-security-protocol-checks).

If network-security-level is high, the following checks will be made, in addition to the above:

3DES cipher
The 3DES stream cipher provides at most 112 bits of effective security, which is considered to be towards the low end. (This is the 3des check in network-security-protocol-checks).

a validated certificate changes the public key
Servers change their keys occasionally, and that is normally nothing to be concerned about. However, if you are worried that your network connections are being hijacked by agencies who have access to pliable Certificate Authorities which issue new certificates for third-party services, you may want to keep track of these changes.

Finally, if network-security-level is paranoid, you will also be notified the first time NSM sees any new certificate. This will allow you to inspect all the certificates from all the connections that Emacs makes.

The following additional variables can be used to control details of NSM operation:

nsm-settings-file ¶
This is the file where NSM stores details about connections. It defaults to ~/.emacs.d/network-security.data.

nsm-save-host-names ¶
By default, host names will not be saved for non-STARTTLS connections. Instead a host/port hash is used to identify connections. This means that one can’t casually read the settings file to see what servers the user has connected to. If this variable is t, NSM will also save host names in the nsm-settings-file.




* Hyperlinking and Web Navigation Features ?

The following subsections describe convenience features for handling URLs and other types of links occurring in Emacs buffer text.

** Web Browsing with EWW

EWW, the Emacs Web Wowser, is a web browser package for Emacs. It allows browsing URLs within an Emacs buffer. The command M-x eww will open a URL or search the web. You can open a file using the command M-x eww-open-file. You can use EWW as the web browser for browse-url, see Following URLs. For full details, see EWW in The Emacs Web Wowser Manual.


** Embedded WebKit Widgets

If Emacs was compiled with the appropriate support packages, it is able to show browser widgets in its buffers. The command M-x xwidget-webkit-browse-url asks for a URL to display in the browser widget. The URL normally defaults to the URL at or before point, but if there is an active region (see The Mark and the Region), the default URL comes from the region instead, after removing any whitespace from it. The command then creates a new buffer with the embedded browser showing the specified URL. The buffer is put in the Xwidget-WebKit mode (similar to Image mode, see Viewing Image Files), which provides one-key commands for scrolling the widget, changing its size, and reloading it. Type C-h b in that buffer to see the key bindings.

By default, typing a self-inserting character inside an xwidget webkit buffer will do nothing, or trigger some special action. To make those characters and other common editing keys insert themselves when pressed, you can enable xwidget-webkit-edit-mode, which redefines them to be passed through to the WebKit xwidget.

You can also enable xwidget-webkit-edit-mode by typing e inside the xwidget webkit buffer.

xwidget-webkit-isearch-mode is a minor mode that behaves similarly to incremental search (see Incremental Search), but operates on the contents of a WebKit widget instead of the current buffer. It is bound to C-s and C-r inside xwidget-webkit buffers. When it is invoked by C-r, the initial search will be performed in reverse direction.

Typing any self-inserting character will cause the character to be inserted into the current search query. Typing C-s will cause the WebKit widget to display the next search result, while typing C-r will cause it to display the previous one.

To leave incremental search, you can type C-g.

The command xwidget-webkit-browse-history displays a buffer containing a list of pages previously loaded by the current WebKit buffer, and lets you navigate to those pages by hitting RET.

It is bound to H.


** Following URLs

M-x browse-url RET url RET
Load a URL into a Web browser.

The Browse-URL package allows you to easily follow URLs from within Emacs. Most URLs are followed by invoking a web browser; ‘mailto:’ URLs are followed by invoking the compose-mail Emacs command to send mail to the specified address (see Sending Mail).

The command M-x browse-url prompts for a URL, and follows it. If point is located near a plausible URL, that URL is offered as the default. The Browse-URL package also provides other commands which you might like to bind to keys, such as browse-url-at-point and browse-url-at-mouse.

You can customize Browse-URL’s behavior via various options in the browse-url Customize group. In particular, the option browse-url-mailto-function lets you define how to follow ‘mailto:’ URLs, while browse-url-browser-function specifies your default browser.

You can define that certain URLs are browsed with other functions by customizing browse-url-handlers, an alist of regular expressions or predicates paired with functions to browse matching URLs.

For more information, view the package commentary by typing C-h P browse-url RET.

Emacs also has a minor mode that has some support for handling URLs as if they were files. url-handler-mode is a global minor mode that affects most of the Emacs commands and primitives that deal with file names. After switching on this mode, you can say, for instance, C-x C-f https://www.gnu.org/ RET to see the HTML for that web page, and you can then edit it and save it to a local file, for instance.


** Activating URLs

M-x goto-address-mode
Activate URLs and e-mail addresses in the current buffer.

M-x global-goto-address-mode
Activate goto-address-mode in all buffers.

You can make Emacs mark out URLs specially in the current buffer, by typing M-x goto-address-mode. When this buffer-local minor mode is enabled, it finds all the URLs in the buffer, highlights them, and turns them into clickable buttons. You can follow the URL by typing C-c RET (goto-address-at-point) while point is on its text; or by clicking with mouse-2, or by clicking mouse-1 quickly (see Following References with the Mouse). Following a URL is done by calling browse-url as a subroutine (see Following URLs).

It can be useful to add goto-address-mode to mode hooks and hooks for displaying an incoming message (e.g., rmail-show-message-hook for Rmail). This is not needed for Gnus or MH-E, which have similar features of their own.


** Finding Files and URLs at Point

The FFAP package replaces certain key bindings for finding files, such as C-x C-f, with commands that provide more sensible defaults. These commands behave like the ordinary ones when given a prefix argument. Otherwise, they get the default file name or URL from the text around point. If what is found in the buffer has the form of a URL rather than a file name, the commands use browse-url to view it (see Following URLs).

This feature is useful for following references in mail or news buffers, README files, MANIFEST files, and so on. For more information, view the package commentary by typing C-h P ffap RET.

To enable FFAP, type M-x ffap-bindings. This makes the following key bindings, and also installs hooks for additional FFAP functionality in Rmail, Gnus and VM article buffers.

C-x C-f filename RET ¶
Find filename, guessing a default from text around point (find-file-at-point).

C-x C-r filename RET ¶
ffap-read-only, analogous to find-file-read-only.

C-x C-v filename RET ¶
ffap-alternate-file, analogous to find-alternate-file.

C-x d directory RET ¶
Start Dired on directory, defaulting to the directory at point (dired-at-point).

C-x C-d directory RET
ffap-list-directory, analogous to list-directory.

C-x 4 f filename RET ¶
ffap-other-window, analogous to find-file-other-window.

C-x 4 r filename RET
ffap-read-only-other-window, analogous to find-file-read-only-other-window.

C-x 4 d directory RET
ffap-dired-other-window, like dired-other-window.

C-x 5 f filename RET ¶
ffap-other-frame, analogous to find-file-other-frame.

C-x 5 r filename RET
ffap-read-only-other-frame, analogous to find-file-read-only-other-frame.

C-x 5 d directory RET
ffap-dired-other-frame, analogous to dired-other-frame.

C-x t C-f filename return
ffap-other-tab, analogous to find-file-other-tab.

C-x t C-r filename return
ffap-read-only-other-tab, analogous to find-file-read-only-other-tab.

M-x ffap-next
Search buffer for next file name or URL, then find that file or URL.

S-mouse-3 ¶
ffap-at-mouse finds the file guessed from text around the position of a mouse click.

C-S-mouse-3 ¶
Display a menu of files and URLs mentioned in current buffer, then find the one you select (ffap-menu).



* Using Emacs as a Server

Various programs can invoke your choice of editor to edit a particular piece of text. For instance, version control programs invoke an editor to enter version control logs (see Version Control), and the Unix mail utility invokes an editor to enter a message to send. By convention, your choice of editor is specified by the environment variable EDITOR. If you set EDITOR to ‘emacs’, Emacs would be invoked, but in an inconvenient way—by starting a new Emacs process. This is inconvenient because the new Emacs process doesn’t share buffers, a command history, or other kinds of information with any existing Emacs process.

You can solve this problem by setting up Emacs as an edit server, so that it “listens” for external edit requests and acts accordingly. There are various ways to start an Emacs server:

Run the command server-start in an existing Emacs process: either type M-x server-start, or put the expression (server-start) in your init file (see The Emacs Initialization File). The existing Emacs process is the server; when you exit Emacs, the server dies with the Emacs process.
Run Emacs as a daemon, using one of the ‘--daemon’ command-line options. See Initial Options. When Emacs is started this way, it calls server-start after initialization and does not open an initial frame. It then waits for edit requests from clients.
Run the command emacsclient with the ‘--alternate-editor=""’ command-line option. This starts an Emacs daemon only if no Emacs daemon is already running.
If your operating system uses systemd to manage startup, you can automatically start Emacs in daemon mode when you login using the supplied systemd unit file. To activate this:
systemctl --user enable emacs
(If your Emacs was installed into a non-standard location, you may need to copy the emacs.service file to a standard directory such as ~/.config/systemd/user/.)

An external process can invoke the Emacs server when a connection event occurs upon a specified socket and pass the socket to the new Emacs server process. An instance of this is the socket functionality of systemd: the systemd service creates a socket and listens for connections on it; when emacsclient connects to it for the first time, systemd can launch the Emacs server and hand over the socket to it for servicing emacsclient connections. A setup to use this functionality could be:
~/.config/systemd/user/emacs.socket:

[Socket]
ListenStream=/path/to/.emacs.socket
DirectoryMode=0700

[Install]
WantedBy=sockets.target
(The emacs.service file described above must also be installed.)

The ListenStream path will be the path that Emacs listens for connections from emacsclient; this is a file of your choice.

Once an Emacs server is started, you can use a shell command called emacsclient to connect to the Emacs process and tell it to visit a file. You can then set the EDITOR environment variable to ‘emacsclient’, so that external programs will use the existing Emacs process for editing.23

You can run multiple Emacs servers on the same machine by giving each one a unique server name, using the variable server-name. For example, M-x set-variable RET server-name RET "foo" RET sets the server name to ‘foo’. The emacsclient program can specify a server by name, using the ‘-s’ or the ‘-f’ option (see emacsclient Options), depending on whether or not the server uses a TCP socket (see TCP Emacs server).

If you want to run multiple Emacs daemons (see Initial Options), you can give each daemon its own server name like this:

  emacs --daemon=foo
The Emacs server can optionally be stopped automatically when certain conditions are met. To do this, call the function server-stop-automatically in your init file (see The Emacs Initialization File), with one of the following arguments:

With the argument empty, the server is stopped when it has no clients, no unsaved file-visiting buffers and no running processes anymore.
With the argument delete-frame, when the last client frame is being closed, you are asked whether each unsaved file-visiting buffer must be saved and each unfinished process can be stopped, and if so, the server is stopped.
With the argument kill-terminal, when the last client frame is being closed with C-x C-c (save-buffers-kill-terminal), you are asked whether each unsaved file-visiting buffer must be saved and each unfinished process can be stopped, and if so, the server is stopped.
If you have defined a server by a unique server name, it is possible to connect to the server from another Emacs instance and evaluate Lisp expressions on the server, using the server-eval-at function. For instance, (server-eval-at "foo" '(+ 1 2)) evaluates the expression (+ 1 2) on the ‘foo’ server, and returns 3. (If there is no server with that name, an error is signaled.) Currently, this feature is mainly useful for developers.

If your operating system’s desktop environment is freedesktop.org-compatible (which is true of most GNU/Linux and other recent Unix-like GUIs), you may use the ‘Emacs (Client)’ menu entry to connect to an Emacs server with emacsclient. The daemon starts if not already running.

** TCP Emacs server

An Emacs server usually listens to connections on a local Unix domain socket. Some operating systems, such as MS-Windows, do not support local sockets; in that case, the server uses TCP sockets instead. In some cases it is useful to have the server listen on a TCP socket even if local sockets are supported, e.g., if you need to contact the Emacs server from a remote machine. You can set server-use-tcp to non-nil to have Emacs listen on a TCP socket instead of a local socket. This is the default if your OS does not support local sockets.

If the Emacs server is set to use TCP, it will by default listen on a random port on the localhost interface. This can be changed to another interface and/or a fixed port using the variables server-host and server-port.

A TCP socket is not subject to file system permissions. To retain some control over which users can talk to an Emacs server over TCP sockets, the emacsclient program must send an authorization key to the server. This key is normally randomly generated by the Emacs server. This is the recommended mode of operation.

If needed, you can set the authorization key to a static value by setting the server-auth-key variable. The key must consist of 64 ASCII printable characters except for space (this means characters from ‘!’ to ‘~’, or from decimal code 33 to 126). You can use M-x server-generate-key to get a random key.

When you start a TCP Emacs server, Emacs creates a server file containing the TCP information to be used by emacsclient to connect to the server. The variable server-auth-dir specifies the default directory containing the server file; by default, this is ~/.emacs.d/server/. In the absence of a local socket with file permissions, the permissions of this directory determine which users can have their emacsclient processes talk to the Emacs server. If server-name is an absolute file name, the server file is created where specified by that file name.

To tell emacsclient to connect to the server over TCP with a specific server file, use the ‘-f’ or ‘--server-file’ option, or set the EMACS_SERVER_FILE environment variable (see emacsclient Options). If server-auth-dir is set to a non-standard value, or if server-name is set to an absolute file name, emacsclient needs an absolute file name to the server file, as the default server-auth-dir is hard-coded in emacsclient to be used as the directory for resolving relative filenames.


** Invoking emacsclient

The simplest way to use the emacsclient program is to run the shell command ‘emacsclient file’, where file is a file name. This connects to an Emacs server, and tells that Emacs process to visit file in one of its existing frames—either a graphical frame, or one in a text terminal (see Frames and Graphical Displays). You can then select that frame to begin editing.

If there is no Emacs server, the emacsclient program halts with an error message (you can prevent this from happening by using the ‘--alternate-editor=""’ option to emacsclient, see emacsclient Options). If the Emacs process has no existing frame—which can happen if it was started as a daemon (see Using Emacs as a Server)—then Emacs opens a frame on the terminal in which you called emacsclient.

You can also force emacsclient to open a new frame on a graphical display using the ‘-c’ option, or on a text terminal using the ‘-t’ option. See emacsclient Options.

If you are running on a single text terminal, you can switch between emacsclient’s shell and the Emacs server using one of two methods: (i) run the Emacs server and emacsclient on different virtual terminals, and switch to the Emacs server’s virtual terminal after calling emacsclient; or (ii) call emacsclient from within the Emacs server itself, using Shell mode (see Interactive Subshell) or Term mode (see Term Mode); emacsclient blocks only the subshell under Emacs, and you can still use Emacs to edit the file.

When you finish editing file in the Emacs server, type C-x # (server-edit) in its buffer. This saves the file and sends a message back to the emacsclient program, telling it to exit. Programs that use EDITOR usually wait for the editor—in this case emacsclient—to exit before doing something else.

If you want to abandon the edit instead, use the M-x server-edit-abort command. This sends a message back to the emacsclient program, telling it to exit with abnormal exit status, and doesn’t save any buffers.

You can also call emacsclient with multiple file name arguments: ‘emacsclient file1 file2 ...’ tells the Emacs server to visit file1, file2, and so forth. Emacs selects the buffer visiting file1, and buries the other buffers at the bottom of the buffer list (see Using Multiple Buffers). The emacsclient program exits once all the specified files are finished (i.e., once you have typed C-x # in each server buffer).

Finishing with a server buffer also kills the buffer, unless it already existed in the Emacs session before the server was asked to create it. However, if you set server-kill-new-buffers to nil, then a different criterion is used: finishing with a server buffer kills it if the file name matches the regular expression server-temp-file-regexp. This is set up to distinguish certain temporary files.

Each C-x # checks for other pending external requests to edit various files, and selects the next such file. You can switch to a server buffer manually if you wish; you don’t have to arrive at it with C-x #. But C-x # is the way to tell emacsclient that you are finished.

If you set the value of the variable server-window to a window or a frame, C-x # always displays the next server buffer in that window or in that frame.

When emacsclient connects, the server will normally output a message that says how to exit the client frame. If server-client-instructions is set to nil, this message is inhibited.



* Getting Help in Emacs

Emacs provides a wide variety of help commands, all accessible through the prefix key C-h (or, equivalently, the function key F1). These help commands are described in the following sections. You can also type C-h C-h to view a list of help commands (help-for-help). You can scroll the list with SPC and DEL, then type the help command you want. To cancel, type C-g.

Many help commands display their information in a special help buffer. In this buffer, you can type SPC and DEL to scroll and type RET to follow hyperlinks. See Help Mode Commands.

By default, help commands display the help buffer in a separate window without selecting that window. The variable help-window-select controls this: its default value is nil; if it’s customized to the value t, the help window is unconditionally selected by help commands, and if its value is other, the help window is selected only if there are more than two windows on the selected frame.

Conversely, many commands in the ‘*Help*’ buffer will pop up a new window to display the results. For instance, clicking on the link to show the source code, or using the i command to display the manual entry, will (by default) pop up a new window. If help-window-keep-selected is changed to non-nil, the window displaying the ‘*Help*’ buffer will be reused instead.

If you are looking for a certain feature, but don’t know what it is called or where to look, we recommend three methods. First, try an apropos command, then try searching the manual index, then look in the FAQ and the package keywords, and finally try listing external packages.

C-h a topics RET
This searches for commands whose names match the argument topics. The argument can be a keyword, a list of keywords, or a regular expression (see Syntax of Regular Expressions). See Apropos.

C-h i d m emacs RET i topic RET
This searches for topic in the indices of the Emacs Info manual, displaying the first match found. Press , to see subsequent matches. You can use a regular expression as topic.

C-h i d m emacs RET s topic RET
Similar, but searches the text of the manual rather than the indices.

C-h C-f
This displays the Emacs FAQ, using Info.

C-h p
This displays the available Emacs packages based on keywords. See Keyword Search for Packages.

M-x list-packages
This displays a list of external packages. See Emacs Lisp Packages.

C-h or F1 mean “help” in various other contexts as well. For instance, you can type them after a prefix key to view a list of the keys that can follow the prefix key. (You can also use ? in this context. A few prefix keys don’t support C-h or ? in this way, because they define other meanings for those inputs, but they all support F1.)


*** Help Summary

Here is a summary of help commands for accessing the built-in documentation. Most of these are described in more detail in the following sections.

**** C-h a topics RET
Display a list of commands whose names match topics (apropos-command). See Apropos.

**** C-h b
Display all active key bindings; minor mode bindings first, then those of the major mode, then global bindings (describe-bindings). See Other Help Commands.

**** C-h C-q
Toggle display of a window showing popular commands and their key bindings. See Other Help Commands.

**** C-h c key
Show the name of the command that the key sequence key is bound to (describe-key-briefly). Here c stands for “character”. For more extensive information on key, use C-h k. See Documentation for a Key.

**** C-h d topics RET
Display the commands and variables whose documentation matches topics (apropos-documentation). See Apropos.

**** C-h e
Display the *Messages* buffer (view-echo-area-messages). See Other Help Commands.

**** C-h f function RET
Display documentation on the Lisp function named function (describe-function). Since commands are Lisp functions, this works for commands too, but you can also use C-h x. See Help by Command or Variable Name.

**** C-h h
Display the HELLO file, which shows examples of various character sets.

**** C-h i
Run Info, the GNU documentation browser (info). The Emacs manual is available in Info. See Other Help Commands.

**** C-h k key
Display the name and documentation of the command that key runs (describe-key). See Documentation for a Key.

**** C-h l
Display a description of your last 300 keystrokes (view-lossage). See Other Help Commands.

**** C-h m
Display documentation of the current major mode and minor modes (describe-mode). See Other Help Commands.

**** C-h n
Display news of recent Emacs changes (view-emacs-news). See Help Files.

**** C-h o symbol
Display documentation of the Lisp symbol named symbol (describe-symbol). This will show the documentation of all kinds of symbols: functions, variables, and faces. See Help by Command or Variable Name.

**** C-h p
Find packages by topic keyword (finder-by-keyword). See Keyword Search for Packages. This lists packages using a package menu buffer. See Emacs Lisp Packages.

**** C-h P package RET
Display documentation about the specified package (describe-package). See Keyword Search for Packages.

**** C-h r
Display the Emacs manual in Info (info-emacs-manual).

**** C-h s
Display the contents of the current syntax table (describe-syntax). See Other Help Commands. The syntax table says which characters are opening delimiters, which are parts of words, and so on. See Syntax Tables in The Emacs Lisp Reference Manual, for details.

**** C-h t
Enter the Emacs interactive tutorial (help-with-tutorial).

**** C-h v var RET
Display the documentation of the Lisp variable var (describe-variable). See Help by Command or Variable Name.

**** C-h w command RET
Show which keys run the command named command (where-is). See Documentation for a Key.

**** C-h x command RET
Display documentation on the named command (describe-command). See Help by Command or Variable Name.

**** C-h C coding RET
Describe the coding system coding (describe-coding-system). See Coding Systems.

**** C-h C RET
Describe the coding systems currently in use.

**** C-h F command RET
Enter Info and go to the node that documents the Emacs command command (Info-goto-emacs-command-node). See Help by Command or Variable Name.

**** C-h I method RET
Describe the input method method (describe-input-method). See Selecting an Input Method.

**** C-h K key
Enter Info and go to the node that documents the key sequence key (Info-goto-emacs-key-command-node). See Documentation for a Key.

**** C-h L language-env RET
Display information on the character sets, coding systems, and input methods used in language environment language-env (describe-language-environment). See Language Environments.

**** C-h S symbol RET
Display the Info documentation on symbol symbol according to the programming language you are editing (info-lookup-symbol). See Other Help Commands.

**** C-h .
Display the help message for a special text area, if point is in one (display-local-help). (These include, for example, links in *Help* buffers.) See Help on Active Text and Tooltips. If you invoke this command with a prefix argument, C-u C-h ., and point is on a button or a widget, this command will pop a new buffer that describes that button/widget.


*** Documentation for a Key

The help commands to get information about a key sequence are C-h c (describe-key-briefly) and C-h k (describe-key).

C-h c key displays in the echo area the name of the command that key is bound to. For example, C-h c C-f displays ‘forward-char’.

C-h k key is similar but gives more information: it displays a help buffer containing the command’s documentation string, which describes exactly what the command does.

C-h K key displays the section of the Emacs manual that describes the command corresponding to key.

C-h c, C-h k and C-h K work for any sort of key sequences, including function keys, menus, and mouse events (except that C-h c ignores mouse movement events). For instance, after C-h k you can select a menu item from the menu bar, to view the documentation string of the command it runs.

C-h w command RET lists the keys that are bound to command. It displays the list in the echo area. If it says the command is not on any key, that means you must use M-x to run it. C-h w runs the command where-is.

Some modes in Emacs use various buttons (see Buttons in The Emacs Lisp Reference Manual) and widgets (see Introduction in Emacs Widgets) that can be clicked to perform some action. To find out what function is ultimately invoked by these buttons, Emacs provides the button-describe and widget-describe commands, that should be run with point over the button.

*** Help by Command or Variable Name

C-h x command RET (describe-command) displays the documentation of the named command, in a window. For example,

C-h x auto-fill-mode RET
displays the documentation of auto-fill-mode. This is how you would get the documentation of a command that is not bound to any key (one which you would normally run using M-x).

C-h f function RET (describe-function) displays the documentation of Lisp function. This command is intended for Lisp functions that you use in a Lisp program. For example, if you have just written the expression (make-vector len) and want to check that you are using make-vector properly, type C-h f make-vector RET. Additionally, since all commands are Lisp functions, you can also use this command to view the documentation of any command.

If you type C-h f RET, it describes the function called by the innermost Lisp expression in the buffer around point, provided that function name is a valid, defined Lisp function. (That name appears as the default while you enter the argument.) For example, if point is located following the text ‘(make-vector (car x)’, the innermost list containing point is the one that starts with ‘(make-vector’, so C-h f RET describes the function make-vector.

C-h f is also useful just to verify that you spelled a function name correctly. If the minibuffer prompt for C-h f shows the function name from the buffer as the default, it means that name is defined as a Lisp function. Type C-g to cancel the C-h f command if you don’t really want to view the documentation.

If you request help for an autoloaded function whose autoload form (see Autoload in The Emacs Lisp Reference Manual) doesn’t provide a doc string, the *Help* buffer won’t have any doc string to display. In that case, if help-enable-symbol-autoload is non-nil, Emacs will try to load the file in which the function is defined to see whether there’s a doc string there.

You can get an overview of functions relevant for a particular topic by using the M-x shortdoc command. This will prompt you for an area of interest, e.g., string, and pop you to a buffer where many of the functions relevant for handling strings are listed.

C-h v (describe-variable) is like C-h f but describes Lisp variables instead of Lisp functions. Its default is the Lisp symbol around or before point, if that is the name of a defined Lisp variable. See Variables.

Help buffers that describe Emacs variables and functions normally have hyperlinks to the corresponding source code, if you have the source files installed (see Hyperlinking and Web Navigation Features).

To find a command’s documentation in a manual, use C-h F (Info-goto-emacs-command-node). This knows about various manuals, not just the Emacs manual, and finds the right one.

C-h o (describe-symbol) is like C-h f and C-h v, but it describes any symbol, be it a function, a variable, or a face. If the symbol has more than one definition, like it has both definition as a function and as a variable, this command will show the documentation of all of them, one after the other.

If the completions-detailed user option is non-nil, some commands provide details about the possible values when displaying completions. For instance, C-h o TAB will then include the first line of the doc string, and will also say whether each symbol is a function or a variable (and so on). Which details are included varies depending on the command used.


*** Apropos

The apropos commands answer questions like, “What are the commands for working with files?” More precisely, you specify your query as an apropos pattern, which is either a word, a list of words, or a regular expression.

Each of the following apropos commands reads an apropos pattern in the minibuffer, searches for items that match the pattern, and displays the results in a different window.

C-h a ¶
Search for commands (apropos-command). With a prefix argument, search for noninteractive functions too.

M-x apropos ¶
Search for functions and variables. Both interactive functions (commands) and noninteractive functions can be found by this.

M-x apropos-user-option ¶
Search for user-customizable variables. With a prefix argument, search for non-customizable variables too.

M-x apropos-variable ¶
Search for variables. With a prefix argument, search for customizable variables only.

M-x apropos-local-variable ¶
Search for buffer-local variables.

M-x apropos-value ¶
Search for variables whose values match the specified pattern. With a prefix argument, search also for functions with definitions matching the pattern, and Lisp symbols with properties matching the pattern.

M-x apropos-local-value ¶
Search for buffer-local variables whose values match the specified pattern.

C-h d ¶
Search for functions and variables whose documentation strings match the specified pattern (apropos-documentation).

The simplest kind of apropos pattern is one word. Anything containing that word matches the pattern. Thus, to find commands that work on files, type C-h a file RET. This displays a list of all command names that contain ‘file’, including copy-file, find-file, and so on. Each command name comes with a brief description and a list of keys you can currently invoke it with. In our example, it would say that you can invoke find-file by typing C-x C-f.

By default, the window showing the apropos buffer with the results of the query is not selected, but you can cause it to be selected by customizing the variable help-window-select to any non-nil value.

For more information about a function definition, variable or symbol property listed in an apropos buffer, you can click on it with mouse-1 or mouse-2, or move there and type RET.

When you specify more than one word in the apropos pattern, a name must contain at least two of the words in order to match. Thus, if you are looking for commands to kill a chunk of text before point, you could try C-h a kill back backward behind before RET. The real command name kill-backward will match that; if there were a command kill-text-before, it would also match, since it contains two of the specified words.

For even greater flexibility, you can specify a regular expression (see Syntax of Regular Expressions). An apropos pattern is interpreted as a regular expression if it contains any of the regular expression special characters, ‘^$*+?.\[’.

Following the conventions for naming Emacs commands, here are some words that you’ll find useful in apropos patterns. By using them in C-h a, you will also get a feel for the naming conventions.

char, line, word, sentence, paragraph, region, page, sexp, list, defun, rect, buffer, frame, window, face, file, dir, register, mode, beginning, end, forward, backward, next, previous, up, down, search, goto, kill, delete, mark, insert, yank, fill, indent, case, change, set, what, list, find, view, describe, default.

If the variable apropos-do-all is non-nil, most apropos commands behave as if they had been given a prefix argument. There is one exception: apropos-variable without a prefix argument will always search for all variables, no matter what the value of apropos-do-all is.

By default, all apropos commands except apropos-documentation list their results in alphabetical order. If the variable apropos-sort-by-scores is non-nil, these commands instead try to guess the relevance of each result, and display the most relevant ones first. The apropos-documentation command lists its results in order of relevance by default; to list them in alphabetical order, change the variable apropos-documentation-sort-by-scores to nil.


*** Help Mode Commands

Help buffers have Help mode as their major mode. Help mode provides the same commands as View mode (see View Mode); for instance, SPC scrolls forward, and DEL or S-SPC scrolls backward. It also provides a few special commands:

RET
Follow a cross reference at point (help-follow).

TAB
Move point forward to the next hyperlink (forward-button).

S-TAB
Move point back to the previous hyperlink (backward-button).

mouse-1
mouse-2
Follow a hyperlink that you click on.

n
p
Move forward and back between pages in the Help buffer.

C-c C-c
Show all documentation about the symbol at point (help-follow-symbol).

C-c C-f
r
Go forward in history of help commands (help-go-forward).

C-c C-b
l
Go back in history of help commands (help-go-back).

s
View the source of the current help topic (if any) (help-view-source).

i
Look up the current topic in the manual(s) (help-goto-info).

I
Look up the current topic in the Emacs Lisp manual (help-goto-lispref-info).

c
Customize the variable or the face (help-customize).

When a function name, variable name, or face name (see Text Faces) appears in the documentation in the help buffer, it is normally an underlined hyperlink. To view the associated documentation, move point there and type RET (help-follow), or click on the hyperlink with mouse-1 or mouse-2. Doing so replaces the contents of the help buffer; to retrace your steps, type C-c C-b or l (help-go-back). While retracing your steps, you can go forward by using C-c C-f or r (help-go-forward).

To move between hyperlinks in a help buffer, use TAB (forward-button) to move forward to the next hyperlink and S-TAB (backward-button) to move back to the previous hyperlink. These commands act cyclically; for instance, typing TAB at the last hyperlink moves back to the first hyperlink.

By default, many links in the help buffer are displayed surrounded by quote characters. If the help-clean-buttons user option is non-nil, these quote characters are removed from the buffer.

Help buffers produced by some Help commands (like C-h b, which shows a long list of key bindings) are divided into pages by the ‘^L’ character. In such buffers, the n (help-goto-next-page) command will take you to the next start of page, and the p (help-goto-previous-page) command will take you to the previous start of page. This way you can quickly navigate between the different kinds of documentation in a help buffer.

A help buffer can also contain hyperlinks to Info manuals, source code definitions, and URLs (web pages). The first two are opened in Emacs, and the third using a web browser via the browse-url command (see Following URLs).

To view all documentation about any symbol in the text, move point to the symbol and type C-c C-c (help-follow-symbol). This shows the documentation for all the meanings of the symbol—as a variable, as a function, and/or as a face.


*** Keyword Search for Packages

Most optional features in Emacs are grouped into packages. Emacs contains several hundred built-in packages, and more can be installed over the network (see Emacs Lisp Packages).

To make it easier to find packages related to a topic, most packages are associated with one or more keywords based on what they do. Type C-h p (finder-by-keyword) to bring up a list of package keywords, together with a description of what the keywords mean. To view a list of packages for a given keyword, type RET on that line; this displays the list of packages in a Package Menu buffer (see The Package Menu Buffer).

C-h P (describe-package) prompts for the name of a package (see Emacs Lisp Packages), and displays a help buffer describing the attributes of the package and the features that it implements. The buffer lists the keywords that relate to the package in the form of buttons. Click on a button with mouse-1 or mouse-2 to see the list of other packages related to that keyword.


*** Help for International Language Support

For information on a specific language environment (see Language Environments), type C-h L (describe-language-environment). This displays a help buffer describing the languages supported by the language environment, and listing the associated character sets, coding systems, and input methods, as well as some sample text for that language environment.

The command C-h h (view-hello-file) displays the file etc/HELLO, which demonstrates various character sets by showing how to say “hello” in many languages.

The command C-h I (describe-input-method) describes an input method—either a specified input method, or by default the input method currently in use. See Input Methods.

The command C-h C (describe-coding-system) describes coding systems—either a specified coding system, or the ones currently in use. See Coding Systems.


*** Other Help Commands

C-h i (info) runs the Info program, which browses structured documentation files. C-h 4 i (info-other-window) does the same, but shows the Info buffer in another window. The entire Emacs manual is available within Info, along with many other manuals for the GNU system. Type h after entering Info to run a tutorial on using Info.

With a numeric argument n, C-h i selects the Info buffer ‘*info*<n>’. This is useful if you want to browse multiple Info manuals simultaneously. If you specify just C-u as the prefix argument, C-h i prompts for the name of a documentation file, so you can browse a file which doesn’t have an entry in the top-level Info menu.

The help commands C-h F function RET and C-h K key, described above, enter Info and go straight to the documentation of function or key.

When editing a program, if you have an Info version of the manual for the programming language, you can use C-h S (info-lookup-symbol) to find an entry for a symbol (keyword, function or variable) in the proper manual. The details of how this command works depend on the major mode.

If something surprising happens, and you are not sure what you typed, use C-h l (view-lossage). C-h l displays your last input keystrokes and the commands they invoked. By default, Emacs stores the last 300 keystrokes; if you wish, you can change this number with the command lossage-size. If you see commands that you are not familiar with, you can use C-h k or C-h f to find out what they do.

To review recent echo area messages, use C-h e (view-echo-area-messages). This displays the buffer *Messages*, where those messages are kept.

Each Emacs major mode typically redefines a few keys and makes other changes in how editing works. C-h m (describe-mode) displays documentation on the current major mode, which normally describes the commands and features that are changed in this mode, and also its key bindings.

C-h b (describe-bindings) and C-h s (describe-syntax) show other information about the current environment within Emacs. C-h b displays a list of all the key bindings now in effect: first the local bindings of the current minor modes, then the local bindings defined by the current major mode, and finally the global bindings (see Customizing Key Bindings). C-h s displays the contents of the syntax table, with explanations of each character’s syntax (see Syntax Tables in The Emacs Lisp Reference Manual).

C-h C-q (help-quick-toggle) toggles on and off the display of a buffer showing the most popular Emacs commands and their respective key bindings (a.k.a. “cheat sheet”). The contents of that buffer are created by the command help-quick. Each key binding shown in this buffer is a button: click on it with mouse-1 or mouse-2 to show the documentation of the command bound to that key sequence.

You can get a list of subcommands for a particular prefix key by typing C-h, ?, or F1 (describe-prefix-bindings) after the prefix key. (There are a few prefix keys for which not all of these keys work—those that provide their own bindings for that key. One of these prefix keys is ESC, because ESC C-h and ESC ? are actually C-M-h (mark-defun) and M-? (xref-find-references), respectively. However, ESC F1 works fine.)

Finally, M-x describe-keymap prompts for the name of a keymap, with completion, and displays a listing of all key bindings in that keymap.


*** Help Files

Apart from the built-in documentation and manuals, Emacs contains several other files describing topics like copying conditions, release notes, instructions for debugging and reporting bugs, and so forth. You can use the following commands to view these files. Apart from C-h g, they all have the form C-h C-char.

**** C-h C-c
Display the rules under which you can copy and redistribute Emacs (describe-copying).

**** C-h C-d
Display help for debugging Emacs (view-emacs-debugging).

**** C-h C-e
Display information about where to get external packages (view-external-packages).

**** C-h C-f
Display the Emacs frequently-answered-questions list (view-emacs-FAQ).

**** C-h g
Visit the page with information about the GNU Project (describe-gnu-project).

**** C-h C-m
Display information about ordering printed copies of Emacs manuals (view-order-manuals).

**** C-h C-n
Display the news, which lists the new features in this version of Emacs (view-emacs-news).

**** C-h C-o
Display how to order or download the latest version of Emacs and other GNU software (describe-distribution).

**** C-h C-p
Display the list of known Emacs problems, sometimes with suggested workarounds (view-emacs-problems).

**** C-h C-t
Display the Emacs to-do list (view-emacs-todo).

**** C-h C-w
Display the full details on the complete absence of warranty for GNU Emacs (describe-no-warranty).


*** Help on Active Text and Tooltips

In Emacs, stretches of active text (text that does something special in response to mouse clicks or RET) often have associated help text. This includes hyperlinks in Emacs buffers, as well as parts of the mode line. On graphical displays, as well as some text terminals which support mouse tracking, moving the mouse over the active text displays the help text as a tooltip. See Tooltips.

On terminals that don’t support mouse-tracking, you can display the help text for active buffer text at point by typing C-h . (display-local-help). This shows the help text in the echo area. To display help text automatically whenever it is available at point, set the variable help-at-pt-display-when-idle to t.



* Dealing with Emacs Trouble

This section describes how to recognize and deal with situations in which Emacs does not work as you expect, such as keyboard code mixups, garbled displays, running out of memory, and crashes and hangs.

See Reporting Bugs, for what to do when you think you have found a bug in Emacs.

*** Recursive Editing Levels

Recursive editing levels are important and useful features of Emacs, but they can seem like malfunctions if you do not understand them.

If the mode line has square brackets ‘[…]’ around the parentheses that contain the names of the major and minor modes, you have entered a recursive editing level. If you did not do this on purpose, or if you don’t understand what that means, you should just get out of the recursive editing level. To do so, type M-x top-level. See Recursive Editing Levels.


*** Garbage on the Screen

If the text on a text terminal looks wrong, the first thing to do is see whether it is wrong in the buffer. Type C-l (recenter-top-bottom) to redisplay the entire screen. If the screen appears correct after this, the problem was entirely in the previous screen update. (Otherwise, see the following section.)

Display updating problems often result from an incorrect terminfo entry for the terminal you are using. The file etc/TERMS in the Emacs distribution gives the fixes for known problems of this sort. INSTALL contains general advice for these problems in one of its sections. If you seem to be using the right terminfo entry, it is possible that there is a bug in the terminfo entry, or a bug in Emacs that appears for certain terminal types


*** Garbage in the Text

If C-l shows that the text is wrong, first type C-h l (view-lossage) to see what commands you typed to produce the observed results. Then try undoing the changes step by step using C-x u (undo), until it gets back to a state you consider correct.

If a large portion of text appears to be missing at the beginning or end of the buffer, check for the word ‘Narrow’ in the mode line. If it appears, the text you don’t see is probably still present, but temporarily off-limits. To make it accessible again, type C-x n w (widen). See Narrowing.


*** Running out of Memory

If you get the error message ‘Virtual memory exceeded’, save your modified buffers with C-x s (save-some-buffers). This method of saving them has the smallest need for additional memory. Emacs keeps a reserve of memory which it makes available when this error happens; that should be enough to enable C-x s to complete its work. When the reserve has been used, ‘!MEM FULL!’ appears at the beginning of the mode line, indicating there is no more reserve.

Once you have saved your modified buffers, you can exit this Emacs session and start another, or you can use M-x kill-some-buffers to free space in the current Emacs job. If this frees up sufficient space, Emacs will refill its memory reserve, and ‘!MEM FULL!’ will disappear from the mode line. That means you can safely go on editing in the same Emacs session.

Do not use M-x buffer-menu to save or kill buffers when you run out of memory, because the Buffer Menu needs a fair amount of memory itself, and the reserve supply may not be enough.

On GNU/Linux systems, Emacs does not normally get notified about out-of-memory situations; instead, the OS can kill the Emacs process when it runs out of memory. This feature is known as the out-of-memory killer, or OOM killer. When this behavior is in effect, Emacs is unable to detect the out-of-memory situation in time, and won’t be able to let you save your buffer as described above. However, it is possible to turn off this behavior of the OS, and thus allow Emacs a chance to handle the out-of-memory situation in a more useful manner, before it is killed. To do that, become the super user, edit the file /etc/sysctl.conf to contain the lines shown below, and then invoke the command sysctl -p from the shell prompt:

vm.overcommit_memory=2
vm.overcommit_ratio=0
Please note that the above setting affects all the processes on the system, and in general the behavior of the system under memory pressure, not just the Emacs process alone.


*** When Emacs Crashes

Emacs is not supposed to crash, but if it does, it produces a crash report prior to exiting. The crash report is printed to the standard error stream. If Emacs was started from a graphical desktop on a GNU or Unix system, the standard error stream is commonly redirected to a file such as ~/.xsession-errors, so you can look for the crash report there. On MS-Windows, the crash report is written to a file named emacs_backtrace.txt in the current directory of the Emacs process, in addition to the standard error stream.

The format of the crash report depends on the platform. On some platforms, such as those using the GNU C Library, the crash report includes a backtrace describing the execution state prior to crashing, which can be used to help debug the crash. Here is an example for a GNU system:

Fatal error 11: Segmentation fault
Backtrace:
emacs[0x5094e4]
emacs[0x4ed3e6]
emacs[0x4ed504]
/lib64/libpthread.so.0[0x375220efe0]
/lib64/libpthread.so.0(read+0xe)[0x375220e08e]
emacs[0x509af6]
emacs[0x5acc26]
…
The number ‘11’ is the system signal number corresponding to the crash—in this case a segmentation fault. The hexadecimal numbers are program addresses, which can be associated with source code lines using a debugging tool. For example, the GDB command ‘list *0x509af6’ prints the source-code lines corresponding to the ‘emacs[0x509af6]’ entry. If your system has the addr2line utility, the following shell command outputs a backtrace with source-code line numbers:

sed -n 's/.*\[\(.*\)]$/\1/p' backtrace |
  addr2line -C -f -i -p -e bindir/emacs-binary
On MS-Windows, the backtrace looks somewhat differently, for example:

Backtrace:
00007ff61166a12e
00007ff611538be1
00007ff611559601
00007ff6116ce84a
00007ff9b7977ff0
…
Therefore, the filtering via sed is not required, and the command to show the source-code line number is

 addr2line -C -f -i -p -e bindir/emacs-binary < backtrace
Here, backtrace is the name of a text file containing a copy of the backtrace (on MS-Windows, emacs_backtrace.txt in the directory where Emacs was started), bindir is the name of the directory that contains the Emacs executable, and emacs-binary is the name of the Emacs executable file, normally emacs on GNU and Unix systems and emacs.exe on MS-Windows and MS-DOS. Omit the -p option if your version of addr2line is too old to have it.

Optionally, Emacs can generate a core dump when it crashes, on systems that support core files. A core dump is a file containing voluminous data about the state of the program prior to the crash, usually examined by loading it into a debugger such as GDB. On many platforms, core dumps are disabled by default, and you must explicitly enable them by running the shell command ‘ulimit -c unlimited’ (e.g., in your shell startup script).


*** Recovery After a Crash

If Emacs or the computer crashes, you can recover the files you were editing at the time of the crash from their auto-save files. To do this, start Emacs again and type the command M-x recover-session.

This command initially displays a buffer which lists interrupted session files, each with its date. You must choose which session to recover from. Typically the one you want is the most recent one. Move point to the one you choose, and type C-c C-c.

Then recover-session considers each of the files that you were editing during that session; for each such file, it asks whether to recover that file. If you answer y for a file, it shows the dates of that file and its auto-save file, then asks once again whether to recover that file. For the second question, you must confirm with yes. If you do, Emacs visits the file but gets the text from the auto-save file.

When recover-session is done, the files you’ve chosen to recover are present in Emacs buffers. You should then save them. Only this—saving them—updates the files themselves.

As a last resort, if you had buffers with content which were not associated with any files, or if the autosave was not recent enough to have recorded important changes, you can use the etc/emacs-buffer.gdb script with GDB (the GNU Debugger) to retrieve them from a core dump—provided that a core dump was saved, and that the Emacs executable was not stripped of its debugging symbols.

As soon as you get the core dump, rename it to another name such as core.emacs, so that another crash won’t overwrite it.

To use this script, run gdb with the file name of your Emacs executable and the file name of the core dump, e.g., ‘gdb /usr/bin/emacs core.emacs’. At the (gdb) prompt, load the recovery script: ‘source /usr/src/emacs/etc/emacs-buffer.gdb’. Then type the command ybuffer-list to see which buffers are available. For each buffer, it lists a buffer number. To save a buffer, use ysave-buffer; you specify the buffer number, and the file name to write that buffer into. You should use a file name which does not already exist; if the file does exist, the script does not make a backup of its old contents.


*** Emergency Escape

On text terminals, the emergency escape feature suspends Emacs immediately if you type C-g a second time before Emacs can actually respond to the first one by quitting. This is so you can always get out of GNU Emacs no matter how badly it might be hung. When things are working properly, Emacs recognizes and handles the first C-g so fast that the second one won’t trigger emergency escape. However, if some problem prevents Emacs from handling the first C-g properly, then the second one will get you back to the shell.

When you resume Emacs after a suspension caused by emergency escape, it reports the resumption and asks a question or two before going back to what it had been doing:

Emacs is resuming after an emergency escape.
Auto-save? (y or n)
Abort (and dump core)? (y or n)
Answer each question with y or n followed by RET.

Saying y to ‘Auto-save?’ causes immediate auto-saving of all modified buffers in which auto-saving is enabled. Saying n skips this. This question is omitted if Emacs is in a state where auto-saving cannot be done safely.

Saying y to ‘Abort (and dump core)?’ causes Emacs to crash, dumping core. This is to enable a wizard to figure out why Emacs was failing to quit in the first place. Execution does not continue after a core dump.

If you answer this question n, Emacs execution resumes. With luck, Emacs will ultimately do the requested quit. If not, each subsequent C-g invokes emergency escape again.

If Emacs is not really hung, just slow, you may invoke the double C-g feature without really meaning to. Then just resume and answer n to both questions, and you will get back to the former state. The quit you requested will happen by and by.

Emergency escape is active only for text terminals. On graphical displays, you can use the mouse to kill Emacs or switch to another program.

On MS-DOS, you must type C-Break (twice) to cause emergency escape—but there are cases where it won’t work, when a system call hangs or when Emacs is stuck in a tight loop in C code.


*** If DEL Fails to Delete

Every keyboard has a large key, usually labeled BACKSPACE, which is ordinarily used to erase the last character that you typed. In Emacs, this key is supposed to be equivalent to DEL.

When Emacs starts up on a graphical display, it determines automatically which key should be DEL. In some unusual cases, Emacs gets the wrong information from the system, and BACKSPACE ends up deleting forwards instead of backwards.

Some keyboards also have a Delete key, which is ordinarily used to delete forwards. If this key deletes backward in Emacs, that too suggests Emacs got the wrong information—but in the opposite sense.

On a text terminal, if you find that BACKSPACE prompts for a Help command, like Control-h, instead of deleting a character, it means that key is actually sending the ‘BS’ character. Emacs ought to be treating BS as DEL, but it isn’t.

In all of those cases, the immediate remedy is the same: use the command M-x normal-erase-is-backspace-mode. This toggles between the two modes that Emacs supports for handling DEL, so if Emacs starts in the wrong mode, this should switch to the right mode. On a text terminal, if you want to ask for help when BS is treated as DEL, use F1 instead of C-h; C-? may also work, if it sends character code 127.

To fix the problem in every Emacs session, put one of the following lines into your initialization file (see The Emacs Initialization File). For the first case above, where BACKSPACE deletes forwards instead of backwards, use this line to make BACKSPACE act as DEL:

(normal-erase-is-backspace-mode 0)
For the other two cases, use this line:

(normal-erase-is-backspace-mode 1)
Another way to fix the problem for every Emacs session is to customize the variable normal-erase-is-backspace: the value t specifies the mode where BS or BACKSPACE is DEL, and nil specifies the other mode. See Easy Customization Interface.



* Entering Emacs

The usual way to invoke Emacs is with the shell command emacs. From a terminal window running a Unix shell on a GUI terminal, you can run Emacs in the background with emacs &; this way, Emacs won’t tie up the terminal window, so you can use it to run other shell commands. (For comparable methods of starting Emacs on MS-Windows, see How to Start Emacs on MS-Windows.)

When Emacs starts up, the initial frame displays a special buffer named ‘*GNU Emacs*’. This startup screen contains information about Emacs and links to common tasks that are useful for beginning users. For instance, activating the ‘Emacs Tutorial’ link opens the Emacs tutorial; this does the same thing as the command C-h t (help-with-tutorial). To activate a link, either move point onto it and type RET, or click on it with mouse-1 (the left mouse button).

Using a command line argument, you can tell Emacs to visit one or more files as soon as it starts up. For example, emacs foo.txt starts Emacs with a buffer displaying the contents of the file ‘foo.txt’. This feature exists mainly for compatibility with other editors, which are designed to be launched from the shell for short editing sessions. If you call Emacs this way, the initial frame is split into two windows—one showing the specified file, and the other showing the startup screen. See Multiple Windows.

Generally, it is unnecessary and wasteful to start Emacs afresh each time you want to edit a file. The recommended way to use Emacs is to start it just once, just after you log in, and do all your editing in the same Emacs session. See File Handling, for information on visiting more than one file. If you use Emacs this way, the Emacs session accumulates valuable context, such as the kill ring, registers, undo history, and mark ring data, which together make editing more convenient. These features are described later in the manual.

To edit a file from another program while Emacs is running, you can use the emacsclient helper program to open a file in the existing Emacs session. See Using Emacs as a Server.

Emacs accepts other command line arguments that tell it to load certain Lisp files, where to put the initial frame, and so forth. See Command Line Arguments for Emacs Invocation.

If the variable inhibit-startup-screen is non-nil, Emacs does not display the startup screen. In that case, if one or more files were specified on the command line, Emacs simply displays those files; otherwise, it displays a buffer named *scratch*, which can be used to evaluate Emacs Lisp expressions interactively. See Lisp Interaction Buffers. You can set the variable inhibit-startup-screen using the Customize facility (see Easy Customization Interface), or by editing your initialization file (see The Emacs Initialization File).4

You can also force Emacs to display a file or directory at startup by setting the variable initial-buffer-choice to a string naming that file or directory. The value of initial-buffer-choice may also be a function (of no arguments) that should return a buffer which is then displayed. If initial-buffer-choice is non-nil, then if you specify any files on the command line, Emacs still visits them, but does not display them initially.


* Exiting Emacs

C-x C-c
Kill Emacs (save-buffers-kill-terminal).

C-z
On a text terminal, suspend Emacs; on a graphical display, iconify (or “minimize”) the selected frame (suspend-frame).

Killing Emacs means terminating the Emacs program. To do this, type C-x C-c (save-buffers-kill-terminal). A two-character key sequence is used to make it harder to type by accident. If there are any modified file-visiting buffers when you type C-x C-c, Emacs first offers to save these buffers. If you do not save them all, it asks for confirmation again, since the unsaved changes will be lost. Emacs also asks for confirmation if any subprocesses are still running, since killing Emacs will also kill the subprocesses (see Running Shell Commands from Emacs).

C-x C-c behaves specially if you are using Emacs as a server. If you type it from a client frame, it closes the client connection. See Using Emacs as a Server.

Emacs can, optionally, record certain session information when you kill it, such as the files you were visiting at the time. This information is then available the next time you start Emacs. See Saving Emacs Sessions.

If the value of the variable confirm-kill-emacs is non-nil, C-x C-c assumes that its value is a predicate function, and calls that function. If the result of the function call is non-nil, the session is killed, otherwise Emacs continues to run. One convenient function to use as the value of confirm-kill-emacs is the function yes-or-no-p. The default value of confirm-kill-emacs is nil.

If the value of the variable confirm-kill-processes is nil, C-x C-c does not ask for confirmation before killing subprocesses started by Emacs. The value is t by default.

To further customize what happens when Emacs is exiting, see Killing Emacs in The GNU Emacs Lisp Reference Manual.

To kill Emacs without being prompted about saving, type M-x kill-emacs.

C-z runs the command suspend-frame. On a graphical display, this command minimizes (or iconifies) the selected Emacs frame, hiding it in a way that lets you bring it back later (exactly how this hiding occurs depends on the window system). On a text terminal, the C-z command suspends Emacs, stopping the program temporarily and returning control to the parent process (usually a shell); in most shells, you can resume Emacs after suspending it with the shell command %emacs.

Text terminals usually listen for certain special characters whose meaning is to kill or suspend the program you are running. This terminal feature is turned off while you are in Emacs. The meanings of C-z and C-x C-c as keys in Emacs were inspired by the use of C-z and C-c on several operating systems as the characters for stopping or killing a program, but that is their only relationship with the operating system. You can customize these keys to run any commands of your choice (see Keymaps).


* Emacs Lisp Packages

Emacs is extended by implementing additional features in packages, which are Emacs Lisp libraries. These could be written by you or provided by someone else. If you want to install such a package so it is available in your future Emacs session, you need to compile it and put it in a directory where Emacs looks for Lisp libraries. See Libraries of Lisp Code for Emacs, for more details about this manual installation method. Many packages provide installation and usage instructions in the large commentary near the beginning of the Lisp file; you can use those instructions for installing and fine-tuning your use of the package.

Packages can also be provided by package archives, which are large collections of Emacs Lisp packages. Each package is a separate Emacs Lisp program, sometimes including other components such as an Info manual. Emacs includes a facility that lets you easily download and install packages from such archives. The rest of this chapter describes this facility.

To list the packages available for installation from package archives, type M-x list-packages RET. It brings up a buffer named *Packages* with a list of all packages. You can install or uninstall packages via this buffer. See The Package Menu Buffer.

The command C-h P (describe-package) prompts for the name of a package, and displays a help buffer describing the attributes of the package and the features that it implements.

By default, Emacs downloads packages from a package archive maintained by the Emacs developers and hosted by the GNU project. Optionally, you can also download packages from archives maintained by third parties. See Package Installation.

For information about turning an Emacs Lisp program into an installable package, See Packaging in The Emacs Lisp Reference Manual.

** The Package Menu Buffer

The command M-x list-packages brings up the package menu. This is a buffer listing all the packages that Emacs knows about, one on each line, with the following information:

The package name (e.g., ‘auctex’).
The package’s version number (e.g., ‘11.86’).
The package’s status—normally one of ‘available’ (can be downloaded from the package archive), ‘installed’, or ‘built-in’ (included in Emacs by default). See Package Statuses.
Which package archive this package is from, if you have more than one package archive enabled.
A short description of the package.
The list-packages command accesses the network, to retrieve the list of available packages from package archive servers. If the network is unavailable, it falls back on the most recently retrieved list.

The main command to use in the package list buffer is the x command. If the package under point isn’t installed already, this command will install it. If the package under point is already installed, this command will delete it.

The following commands are available in the package menu:

h ¶
Print a short message summarizing how to use the package menu (package-menu-quick-help).

? ¶
RET
Display a help buffer for the package on the current line (package-menu-describe-package), similar to the help window displayed by the C-h P command (see Emacs Lisp Packages).

i ¶
Mark the package on the current line for installation (package-menu-mark-install). If the package status is ‘available’, this adds an ‘I’ character to the start of the line; typing x (see below) will download and install the package.

d ¶
Mark the package on the current line for deletion (package-menu-mark-delete). If the package status is ‘installed’, this adds a ‘D’ character to the start of the line; typing x (see below) will delete the package. See Package Files and Directory Layout, for information about what package deletion entails.

w ¶
Open the package website on the current line in a browser (package-browse-url). browse-url is used to open the browser.

~ ¶
Mark all obsolete packages for deletion (package-menu-mark-obsolete-for-deletion). This marks for deletion all the packages whose status is ‘obsolete’.

u ¶
DEL
Remove any installation or deletion mark previously added to the current line by an i or d command (package-menu-mark-unmark).

U ¶
Mark all package with a newer available version for upgrading (package-menu-mark-upgrades). This places an installation mark on the new available versions, and a deletion mark on the old installed versions (marked with status ‘obsolete’). By default, this won’t mark built-in packages for which a newer version is available, but customizing package-install-upgrade-built-in can change that. See Package Installation. If you customize package-install-upgrade-built-in to a non-nil value, be sure to review all the built-in packages the U command marks, to avoid updating built-in packages you don’t want to overwrite.

x ¶
Download and install all packages marked with i, and their dependencies; also, delete all packages marked with d (package-menu-execute). This also removes the marks. If no packages are marked, this command will install the package under point (if it isn’t installed already), or delete the package under point (if it’s already installed).

g
r ¶
Refresh the package list (revert-buffer). This fetches the list of available packages from the package archive again, and redisplays the package list.

H ¶
Hide packages whose names match a regexp (package-menu-hide-package). This prompts for a regexp, and then hides the packages with matching names. The default value of the regexp will hide only the package whose name is at point, so just pressing RET to the prompt will hide the current package.

( ¶
Toggle visibility of old versions of packages and also of versions from lower-priority archives (package-menu-toggle-hiding).

/ a ¶
Filter package list by archive (package-menu-filter-by-archive). This prompts for a package archive (e.g., ‘gnu’), then shows only packages from that archive. You can specify several archives by typing their names separated by commas.

/ d ¶
Filter package list by description (package-menu-filter-by-description). This prompts for a regular expression, then shows only packages with descriptions matching that regexp.

/ k ¶
Filter package list by keyword (package-menu-filter-by-keyword). This prompts for a keyword (e.g., ‘games’), then shows only packages with that keyword. You can specify several keywords by typing them separated by commas.

/ N ¶
Filter package list by name or description (package-menu-filter-by-name-or-description). This prompts for a regular expression, then shows only packages with a name or description matching that regexp.

/ n ¶
Filter package list by name (package-menu-filter-by-name). This prompts for a regular expression, then shows only packages with names matching that regexp.

/ s ¶
Filter package list by status (package-menu-filter-by-status). This prompts for one or more statuses (e.g., ‘available’, see Package Statuses), then shows only packages with matching status. You can specify several status values by typing them separated by commas.

/ v ¶
Filter package list by version (package-menu-filter-by-version). This prompts first for one of the comparison symbols ‘<’, ‘>’ or ‘=’ and for a version string, and then shows packages whose versions are correspondingly lower, equal or higher than the version you typed.

/ m ¶
Filter package list by non-empty mark (package-menu-filter-marked). This shows only the packages that have been marked to be installed or deleted.

/ u ¶
Filter package list to show only packages for which there are available upgrades (package-menu-filter-upgradable). By default, this filter excludes the built-in packages for which a newer version is available, but customizing package-install-upgrade-built-in can change that. See Package Installation.

/ / ¶
Clear filter currently applied to the package list (package-menu-filter-clear).

For example, you can install a package by typing i on the line listing that package, followed by x.


** Package Statuses

A package can have one of the following statuses:

‘available’
The package is not installed, but can be downloaded and installed from the package archive.

‘avail-obso’
The package is available for installation, but a newer version is also available. Packages with this status are hidden by default.

‘built-in’
The package is included in Emacs by default. It cannot be deleted through the package menu, and by default is not considered for upgrading (but you can change that by customizing package-install-upgrade-built-in, see Package Installation).

‘dependency’
The package was installed automatically to satisfy a dependency of another package.

‘disabled’
The package has been disabled using the package-load-list variable.

‘external’
The package is not built-in and not from the directory specified by package-user-dir (see Package Files and Directory Layout). External packages are treated much like ‘built-in’ packages and cannot be deleted.

‘held’
The package is held, See Package Installation.

‘incompat’
The package cannot be installed for some reason, for example because it depends on uninstallable packages.

‘installed’
The package is installed.

‘new’
Equivalent to ‘available’, except that the package became newly available on the package archive after your last invocation of M-x list-packages.

‘obsolete’
The package is an outdated installed version; in addition to this version of the package, a newer version is also installed.


** Package Installation
Packages are most conveniently installed using the package menu (see The Package Menu Buffer), but you can also use the command M-x package-install. This prompts for the name of a package with the ‘available’ status, then downloads and installs it. Similarly, if you want to upgrade a package, you can use the M-x package-upgrade command, and if you want to upgrade all the packages, you can use the M-x package-upgrade-all command.

By default, package-install doesn’t consider built-in packages for which new versions are available from the archives. (A package is built-in if it is included in the Emacs distribution.) In particular, it will not show built-in packages in the list of completion candidates when you type at its prompt. But if you invoke package-install with a prefix argument, it will also consider built-in packages that can be upgraded. You can make this behavior the default by customizing the variable package-install-upgrade-built-in: if its value is non-nil, package-install will consider built-in packages even when invoked without a prefix argument. Note that the package-menu commands (see The Package Menu Buffer) are also affected by package-install-upgrade-built-in.

By contrast, package-upgrade and package-upgrade-all never consider built-in packages. If you want to use these commands for upgrading some built-in packages, you need to upgrade each of those packages, once, either via C-u M-x package-install RET, or by customizing package-install-upgrade-built-in to a non-nil value, and then upgrading the package once via the package menu or by package-install.

If you customize package-install-upgrade-built-in to a non-nil value, be very careful when using commands that update many packages at once, like package-upgrade-all and U in the package menu: those might overwrite built-in packages that you didn’t intent to replace with newer versions from the archives. Don’t use these bulk commands if you want to update only a small number of built-in packages.

A package may require certain other packages to be installed, because it relies on functionality provided by them. When Emacs installs such a package, it also automatically downloads and installs any required package that is not already installed. (If a required package is somehow unavailable, Emacs signals an error and stops installation.) A package’s requirements list is shown in its help buffer.

By default, packages are downloaded from a single package archive maintained by the Emacs developers. This is controlled by the variable package-archives, whose value is a list of package archives known to Emacs. Each list element must have the form (id . location), where id is the name of a package archive and location is the URL or name of the package archive directory. You can alter this list if you wish to use third party package archives—but do so at your own risk, and use only third parties that you think you can trust!

The maintainers of package archives can increase the trust that you can have in their packages by signing them. They generate a private/public pair of cryptographic keys, and use the private key to create a signature file for each package. With the public key, you can use the signature files to verify the package creator and make sure the package has not been tampered with. Signature verification uses the GnuPG package via the EasyPG interface (see EasyPG in Emacs EasyPG Assistant Manual). A valid signature is not a cast-iron guarantee that a package is not malicious, so you should still exercise caution. Package archives should provide instructions on how you can obtain their public key. One way is to download the key from a server such as https://pgp.mit.edu/. Use M-x package-import-keyring to import the key into Emacs. Emacs stores package keys in the directory specified by the variable package-gnupghome-dir, by default in the gnupg subdirectory of package-user-dir, which causes Emacs to invoke GnuPG with the option ‘--homedir’ when verifying signatures. If package-gnupghome-dir is nil, GnuPG’s option ‘--homedir’ is omitted. The public key for the GNU package archive is distributed with Emacs, in the etc/package-keyring.gpg. Emacs uses it automatically.

If the user option package-check-signature is non-nil, Emacs attempts to verify signatures when you install packages. If the option has the value allow-unsigned, and a usable OpenPGP configuration is found, signed packages will be checked, but you can still install a package that is not signed. If you use some archives that do not sign their packages, you can add them to the list package-unsigned-archives. (If the value is allow-unsigned and no usable OpenPGP is found, this option is treated as if its value was nil.) If the value is t, at least one signature must be valid; if the value is all, all of them must be valid.

For more information on cryptographic keys and signing, see GnuPG in The GNU Privacy Guard Manual. Emacs comes with an interface to GNU Privacy Guard, see EasyPG in Emacs EasyPG Assistant Manual.

If you have more than one package archive enabled, and some of them offer different versions of the same package, you may find the option package-pinned-packages useful. You can add package/archive pairs to this list, to ensure that the specified package is only ever downloaded from the specified archive.

Another option that is useful when you have several package archives enabled is package-archive-priorities. It specifies the priority of each archive (higher numbers specify higher priority archives). By default, archives have the priority of zero, unless specified otherwise by this option’s value. Packages from lower-priority archives will not be shown in the menu, if the same package is available from a higher-priority archive. (This is controlled by the value of package-menu-hide-low-priority.)

Once a package is downloaded, byte-compiled and installed, it is made available to the current Emacs session. Making a package available adds its directory to load-path and loads its autoloads. The effect of a package’s autoloads varies from package to package. Most packages just make some new commands available, while others have more wide-ranging effects on the Emacs session. For such information, consult the package’s help buffer.

Installed packages are automatically made available by Emacs in all subsequent sessions. This happens at startup, before processing the init file but after processing the early init file (see The Early Init File). As an exception, Emacs does not make packages available at startup if invoked with the ‘-q’ or ‘--no-init-file’ options (see Initial Options).

To keep Emacs from automatically making packages available at startup, change the variable package-enable-at-startup to nil. You must do this in the early init file, as the variable is read before loading the regular init file. Currently this variable cannot be set via Customize.

If you have many packages installed, you can improve startup times by setting the user option package-quickstart to t. Setting this option will make Emacs precompute many things instead of re-computing them on every Emacs startup. However, if you do this, then you have to manually run the command package-quickstart-refresh when the activations need to be changed, such as when you change the value of package-load-list.

If you have set package-enable-at-startup to nil, you can still make packages available either during or after startup. To make installed packages available during startup, call the function package-activate-all in your init file. To make installed packages available after startup, invoke the command M-: (package-activate-all) RET.

For finer control over which packages are made available at startup, you can use the variable package-load-list. Its value should be a list. A list element of the form (name version) tells Emacs to make available version version of the package named name. Here, version should be a version string (corresponding to a specific version of the package), or t (which means to make available any installed version), or nil (which means no version; this disables the package, preventing it from being made available). A list element can also be the symbol all, which means to make available the latest installed version of any package not named by the other list elements. The default value is just '(all).

For example, if you set package-load-list to '((muse "3.20") all), then Emacs only makes available version 3.20 of the ‘muse’ package, plus any installed version of packages other than ‘muse’. Any other version of ‘muse’ that happens to be installed will be ignored. The ‘muse’ package will be listed in the package menu with the ‘held’ status.

Emacs byte code is quite stable, but it’s possible for byte code to become outdated, or for the compiled files to rely on macros that have changed in new versions of Emacs. You can use the command M-x package-recompile to recompile a particular package, or M-x package-recompile-all to recompile all the packages. (The latter command might take quite a while to run if you have many installed packages.)


** Package Files and Directory Layout

Each package is downloaded from the package archive in the form of a single package file—either an Emacs Lisp source file, or a tar file containing multiple Emacs Lisp source and other files. Package files are automatically retrieved, processed, and disposed of by the Emacs commands that install packages. Normally, you will not need to deal directly with them, unless you are making a package (see Packaging in The Emacs Lisp Reference Manual). Should you ever need to install a package directly from a package file, use the command M-x package-install-file.

Once installed, the contents of a package are placed in a subdirectory of ~/.emacs.d/elpa/ (you can change the name of that directory by changing the variable package-user-dir). The package subdirectory is named name-version, where name is the package name and version is its version string.

In addition to package-user-dir, Emacs looks for installed packages in the directories listed in package-directory-list. These directories are meant for system administrators to make Emacs packages available system-wide; Emacs itself never installs packages there. The package subdirectories for package-directory-list are laid out in the same way as in package-user-dir.

Deleting a package (see The Package Menu Buffer) involves deleting the corresponding package subdirectory. This only works for packages installed in package-user-dir; if told to act on a package in a system-wide package directory, the deletion command signals an error.


** Fetching Package Sources

By default package-install downloads a Tarball from a package archive and installs its files. This might be inadequate if you wish to hack on the package sources and share your changes with others. In that case, you may prefer to directly fetch and work on the upstream source. This often makes it easier to develop patches and report bugs.

One way to do this is to use package-vc-install, to fetch the source code for a package directly from source. The command will also automatically ensure that all files are byte-compiled and auto-loaded, just like with a regular package. Packages installed this way behave just like any other package. You can upgrade them using package-upgrade or package-upgrade-all and delete them again using package-delete. They are even displayed in the regular package listing. If you just wish to clone the source of a package, without adding it to the package list, use package-vc-checkout.

With the source checkout, you might want to reproduce a bug against the current development head or implement a new feature to scratch an itch. If the package metadata indicates how to contact the maintainer, you can use the command package-report-bug to report a bug via Email. This report will include all the user options that you have customized. If you have made a change you wish to share with the maintainers, first commit your changes then use the command package-vc-prepare-patch to share it. See Preparing Patches.

If you maintain your own packages you might want to use a local checkout instead of cloning a remote repository. You can do this by using package-vc-install-from-checkout, which creates a symbolic link from the package directory (see Package Files and Directory Layout) to your checkout and initializes the code. Note that you might have to use package-vc-rebuild to repeat the initialization and update the autoloads.

*** Specifying Package Sources

To install a package from source, Emacs must know where to get the package’s source code (such as a code repository) and basic information about the structure of the code (such as the main file in a multi-file package). A package specification describes these properties.

When supported by a package archive (see Package Archives in The Emacs Lisp Reference Manual), Emacs can automatically download a package’s specification from said archive. If the first argument passed to package-vc-install is a symbol naming a package, then Emacs will use the specification provided by the archive for that package.

;; Emacs will download BBDB's specification from GNU ELPA:
(package-vc-install 'bbdb)
The first argument to package-vc-install may also be a package specification. This allows you to install source packages from locations other than the known archives listed in the user option package-archives. A package specification is a list of the form (name . spec), in which spec should be a property list using any of the keys in the table below.

For definitions of basic terms for working with code repositories and version control systems, see VCS Concepts in The GNU Emacs Manual.

:url
A string providing the URL that specifies the repository from which to fetch the package’s source code.

:branch
A string providing the revision of the code to install. Do not confuse this with a package’s version number.

:lisp-dir
A string providing the repository-relative name of the directory to use for loading the Lisp sources, which defaults to the root directory of the repository.

:main-file
A string providing the main file of the project, from which to gather package metadata. If not given, the default is the package name with ".el" appended to it.

:doc
A string providing the repository-relative name of the documentation file from which to build an Info file. This can be a Texinfo file or an Org file.

:vc-backend
A symbol naming the VC backend to use for downloading a copy of the package’s repository (see Version Control Systems in The GNU Emacs Manual). If omitted, Emacs will attempt to make a guess based on the provided URL, or, failing that, the process will fall back onto the value of package-vc-default-backend.

;; Specifying information manually:
(package-vc-install
  '(bbdb :url "https://git.savannah.nongnu.org/git/bbdb.git"
         :lisp-dir "lisp"
         :doc "doc/bbdb.texi"))


     
* Text Manipulation


** Commands for Human Languages

This chapter describes Emacs commands that act on text, by which we mean sequences of characters in a human language (as opposed to, say, a computer programming language). These commands act in ways that take into account the syntactic and stylistic conventions of human languages: conventions involving words, sentences, paragraphs, and capital letters. There are also commands for filling, which means rearranging the lines of a paragraph to be approximately equal in length. These commands, while intended primarily for editing text, are also often useful for editing programs.

Emacs has several major modes for editing human-language text. If the file contains ordinary text, use Text mode, which customizes Emacs in small ways for the syntactic conventions of text. Outline mode provides special commands for operating on text with an outline structure. See Outline Mode.

Org mode extends Outline mode and turns Emacs into a full-fledged organizer: you can manage TODO lists, store notes and publish them in many formats. See the Org Info manual, which is distributed with Emacs.

Emacs has other major modes for text which contains embedded commands, such as TeX and LaTeX (see TeX Mode); HTML and SGML (see SGML and HTML Modes); XML (see the nXML mode Info manual, which is distributed with Emacs); and Groff and Nroff (see Nroff Mode).

If you need to edit ASCII art pictures made out of text characters, use Picture mode, a special major mode for editing such pictures. See Editing Pictures.


*** Words

Emacs defines several commands for moving over or operating on words:

M-f
Move forward over a word (forward-word).

M-b
Move backward over a word (backward-word).

M-d
Kill up to the end of a word (kill-word).

M-DEL
Kill back to the beginning of a word (backward-kill-word).

M-@
Set mark at the end of the next word (mark-word).

M-t
Transpose two words or drag a word across others (transpose-words).

Notice how these keys form a series that parallels the character-based C-f, C-b, C-d, DEL and C-t. M-@ is cognate to C-@, which is an alias for C-SPC.

The commands M-f (forward-word) and M-b (backward-word) move forward and backward over words. These Meta-based key sequences are analogous to the key sequences C-f and C-b, which move over single characters. The analogy extends to numeric arguments, which serve as repeat counts. M-f with a negative argument moves backward, and M-b with a negative argument moves forward. Forward motion stops right after the last letter of the word, while backward motion stops right before the first letter.

M-d (kill-word) kills the word after point. To be precise, it kills everything from point to the place M-f would move to. Thus, if point is in the middle of a word, M-d kills just the part after point. If some punctuation comes between point and the next word, it is killed along with the word. (If you wish to kill only the next word but not the punctuation before it, simply do M-f to get the end, and kill the word backwards with M-DEL.) M-d takes arguments just like M-f.

M-DEL (backward-kill-word) kills the word before point. It kills everything from point back to where M-b would move to. For instance, if point is after the space in ‘FOO, BAR’, it kills ‘FOO, ’. If you wish to kill just ‘FOO’, and not the comma and the space, use M-b M-d instead of M-DEL.

M-t (transpose-words) exchanges the word before or containing point with the following word. The delimiter characters between the words do not move. For example, ‘FOO, BAR’ transposes into ‘BAR, FOO’ rather than ‘BAR FOO,’. See Transposing Text, for more on transposition.

To operate on words with an operation which acts on the region, use the command M-@ (mark-word). This command sets the mark where M-f would move to. See Commands to Mark Textual Objects, for more information about this command.

The word commands’ understanding of word boundaries is controlled by the syntax table. Any character can, for example, be declared to be a word delimiter. See Syntax Tables in The Emacs Lisp Reference Manual.

In addition, see Cursor Position Information for the M-= (count-words-region) and M-x count-words commands, which count and report the number of words in the region or buffer.


*** Sentences

The Emacs commands for manipulating sentences and paragraphs are mostly on Meta keys, like the word-handling commands.

M-a
Move back to the beginning of the sentence (backward-sentence).

M-e
Move forward to the end of the sentence (forward-sentence).

M-k
Kill forward to the end of the sentence (kill-sentence).

C-x DEL
Kill back to the beginning of the sentence (backward-kill-sentence).

The commands M-a (backward-sentence) and M-e (forward-sentence) move to the beginning and end of the current sentence, respectively. Their bindings were chosen to resemble C-a and C-e, which move to the beginning and end of a line. Unlike them, M-a and M-e move over successive sentences if repeated.

Moving backward over a sentence places point just before the first character of the sentence; moving forward places point right after the punctuation that ends the sentence. Neither one moves over the whitespace at the sentence boundary.

Just as C-a and C-e have a kill command, C-k, to go with them, M-a and M-e have a corresponding kill command: M-k (kill-sentence) kills from point to the end of the sentence. With a positive numeric argument n, it kills the next n sentences; with a negative argument −n, it kills back to the beginning of the nth preceding sentence.

The C-x DEL (backward-kill-sentence) kills back to the beginning of a sentence.

The sentence commands assume that you follow the American typist’s convention of putting two spaces at the end of a sentence. That is, a sentence ends wherever there is a ‘.’, ‘?’ or ‘!’ followed by the end of a line or two spaces, with any number of ‘)’, ‘]’, ‘'’, or ‘"’ characters allowed in between. A sentence also begins or ends wherever a paragraph begins or ends. It is useful to follow this convention, because it allows the Emacs sentence commands to distinguish between periods that end a sentence and periods that indicate abbreviations.

If you want to use just one space between sentences, you can set the variable sentence-end-double-space to nil to make the sentence commands stop for single spaces. However, this has a drawback: there is no way to distinguish between periods that end sentences and those that indicate abbreviations. For convenient and reliable editing, we therefore recommend you follow the two-space convention. The variable sentence-end-double-space also affects filling (see Explicit Fill Commands).

The variable sentence-end controls how to recognize the end of a sentence. If non-nil, its value should be a regular expression, which is used to match the last few characters of a sentence, together with the whitespace following the sentence (see Syntax of Regular Expressions). If the value is nil, the default, then Emacs computes sentence ends according to various criteria such as the value of sentence-end-double-space.

Some languages, such as Thai, do not use periods to indicate the end of a sentence. Set the variable sentence-end-without-period to t in such cases.


*** Paragraphs

The Emacs commands for manipulating paragraphs are also on Meta keys.

M-{
Move back to previous paragraph beginning (backward-paragraph).

M-}
Move forward to next paragraph end (forward-paragraph).

M-h
Put point and mark around this or next paragraph (mark-paragraph).

M-{ (backward-paragraph) moves to the beginning of the current or previous paragraph, depending on where point is when the command is invoked (see below for the definition of a paragraph). M-} (forward-paragraph) similarly moves to the end of the current or next paragraph. If there is a blank line before the paragraph, M-{ moves to the blank line.

When you wish to operate on a paragraph, type M-h (mark-paragraph) to set the region around it. For example, M-h C-w kills the paragraph around or after point. M-h puts point at the beginning and mark at the end of the paragraph point was in. If point is between paragraphs (in a run of blank lines, or at a boundary), M-h sets the region around the paragraph following point. If there are blank lines preceding the first line of the paragraph, one of these blank lines is included in the region. If the region is already active, the command sets the mark without changing point, and each subsequent M-h further advances the mark by one paragraph.

The definition of a paragraph depends on the major mode. In Fundamental mode, as well as Text mode and related modes, a paragraph is separated from neighboring paragraphs by one or more blank lines—lines that are either empty, or consist solely of space, tab and/or formfeed characters. In programming language modes, paragraphs are usually defined in a similar way, so that you can use the paragraph commands even though there are no paragraphs as such in a program.

Note that an indented line is not itself a paragraph break in Text mode. If you want indented lines to separate paragraphs, use Paragraph-Indent Text mode instead. See Text Mode.

If you set a fill prefix, then paragraphs are delimited by all lines which don’t start with the fill prefix. See Filling Text.

The precise definition of a paragraph boundary is controlled by the variables paragraph-separate and paragraph-start. The value of paragraph-start is a regular expression that should match lines that either start or separate paragraphs (see Syntax of Regular Expressions). The value of paragraph-separate is another regular expression that should match lines that separate paragraphs without being part of any paragraph (for example, blank lines). Lines that start a new paragraph and are contained in it must match only paragraph-start, not paragraph-separate. For example, in Fundamental mode, paragraph-start is "\f\\|[ \t]*$", and paragraph-separate is "[ \t\f]*$".

Note that paragraph-start and paragraph-separate are matched against the text at the left margin, which is not necessarily the beginning of the line, so these regexps should not use ‘^’ as an anchor, to ensure that the paragraph functions will work equally within a region of text indented by a margin setting.


*** Pages

Within some text files, text is divided into pages delimited by the formfeed character (ASCII code 12, also denoted as ‘control-L’), which is displayed in Emacs as the escape sequence ‘^L’ (see How Text Is Displayed). Traditionally, when such text files are printed to hardcopy, each formfeed character forces a page break. Most Emacs commands treat it just like any other character, so you can insert it with C-q C-l, delete it with DEL, etc. In addition, Emacs provides commands to move over pages and operate on them.

M-x what-page
Display the page number of point, and the line number within that page.

C-x [
Move point to previous page boundary (backward-page).

C-x ]
Move point to next page boundary (forward-page).

C-x C-p
Put point and mark around this page (or another page) (mark-page).

C-x l
Count the lines in this page (count-lines-page).

M-x what-page counts pages from the beginning of the file, and counts lines within the page, showing both numbers in the echo area.

The C-x [ (backward-page) command moves point to immediately after the previous page delimiter. If point is already right after a page delimiter, it skips that one and stops at the previous one. A numeric argument serves as a repeat count. The C-x ] (forward-page) command moves forward past the next page delimiter.

The C-x C-p command (mark-page) puts point at the beginning of the current page (after that page delimiter at the front), and the mark at the end of the page (after the page delimiter at the end).

C-x C-p C-w is a handy way to kill a page to move it elsewhere. If you move to another page delimiter with C-x [ and C-x ], then yank the killed page, all the pages will be properly delimited once again. Making sure this works as expected is the reason C-x C-p includes only the following page delimiter in the region.

A numeric argument to C-x C-p specifies which page to go to, relative to the current one. Zero means the current page, one means the next page, and −1 means the previous one.

The C-x l command (count-lines-page) is good for deciding where to break a page in two. It displays in the echo area the total number of lines in the current page, and then divides it up into those preceding the current line and those following, as in

Page has 96 (72+25) lines
Notice that the sum is off by one; this is correct if point is not at the beginning of a line.

The variable page-delimiter controls where pages begin. Its value is a regular expression that matches the beginning of a line that separates pages (see Syntax of Regular Expressions). The normal value of this variable is "^\f", which matches a formfeed character at the beginning of a line.


*** Quotation Marks

One common way to quote is the typewriter convention, which quotes using straight apostrophes ‘'like this'’ or double-quotes ‘"like this"’. Another common way is the curved quote convention, which uses left and right single or double quotation marks ‘like this’ or “like this”12. In text files, typewriter quotes are simple and portable; curved quotes are less ambiguous and typically look nicer.

Electric Quote mode makes it easier to type curved quotes. As you type characters it optionally converts ` to ‘, ' to ’, `` to “, and '' to ”. It’s possible to change the default quotes listed above, by customizing the variable electric-quote-chars, a list of four characters, where the items correspond to the left single quote, the right single quote, the left double quote and the right double quote, respectively, whose default value is '(?‘ ?’ ?“ ?”).

You can customize the behavior of Electric Quote mode by customizing variables that control where it is active. It is active in text paragraphs if electric-quote-paragraph is non-nil, in programming-language comments if electric-quote-comment is non-nil, and in programming-language strings if electric-quote-string is non-nil. The default is nil for electric-quote-string and t for the other variables.

You can also set the option electric-quote-replace-double to a non-nil value. Then, typing " inserts an appropriate curved double quote depending on context: “ at the beginning of the buffer or after a line break, whitespace, opening parenthesis, or quote character, and ” otherwise.

Electric Quote mode is disabled by default. To toggle it in a single buffer, use M-x electric-quote-local-mode. To toggle it globally, type M-x electric-quote-mode. To suppress it for a single use, type C-q ` or C-q ' instead of ` or '. To insert a curved quote even when Electric Quote is disabled or inactive, you can type C-x 8 [ for ‘, C-x 8 ] for ’, C-x 8 { for “, and C-x 8 } for ”. See Inserting Text. Note that the value of electric-quote-chars does not affect these key bindings, they are not key bindings of electric-quote-mode but bound in global-map.

Footnotes
(12)
The curved single quote characters are U+2018 LEFT SINGLE QUOTATION MARK and U+2019 RIGHT SINGLE QUOTATION MARK; the curved double quotes are U+201C LEFT DOUBLE QUOTATION MARK and U+201D RIGHT DOUBLE QUOTATION MARK. On text terminals which cannot display these characters, the Info reader might show them as the typewriter ASCII quote characters.


*** Filling Text

Filling text means breaking it up into lines that fit a specified width. Emacs does filling in two ways. In Auto Fill mode, inserting text with self-inserting characters also automatically fills it. There are also explicit fill commands that you can use when editing text.

**** Auto Fill Mode

Auto Fill mode is a buffer-local minor mode (see Minor Modes) in which lines are broken automatically when the line becomes too wide and you type SPC or RET.

M-x auto-fill-mode
Enable or disable Auto Fill mode.

SPC
RET
In Auto Fill mode, break lines when appropriate.

The mode command M-x auto-fill-mode toggles Auto Fill mode in the current buffer. Like any other minor mode, with a positive numeric argument, it enables Auto Fill mode, and with a negative argument it disables it. To enable Auto Fill mode automatically in certain major modes, add auto-fill-mode to the mode hooks (see Major Modes). When Auto Fill mode is enabled, the mode indicator ‘Fill’ appears in the mode line (see The Mode Line).

Auto Fill mode breaks lines automatically at the appropriate places whenever lines get longer than the desired width. This line breaking occurs only when you type SPC or RET. If you wish to insert a space or newline without permitting line-breaking, type C-q SPC or C-q C-j respectively. Also, C-o inserts a newline without line breaking.

The place where Auto Fill breaks a line depends on the line’s characters. For characters from ASCII, Latin, and most other scripts Emacs breaks a line on space characters, to keep the words intact. But for CJK scripts, a line can be broken between any two characters. (If you load the kinsoku library, Emacs will avoid breaking a line between certain pairs of CJK characters, where special rules prohibit that.)

When Auto Fill mode breaks a line, it tries to obey the adaptive fill prefix: if a fill prefix can be deduced from the first and/or second line of the current paragraph, it is inserted into the new line (see Adaptive Filling). Otherwise the new line is indented, as though you had typed TAB on it (see Indentation). In a programming language mode, if a line is broken in the middle of a comment, the comment is split by inserting new comment delimiters as appropriate.

Auto Fill mode does not refill entire paragraphs; it breaks lines but does not merge lines. Therefore, editing in the middle of a paragraph can result in a paragraph that is not correctly filled. To fill it, call the explicit fill commands (see Explicit Fill Commands).

A similar feature that wraps long lines automatically at display time is Visual Line Mode (see Visual Line Mode).


**** Explicit Fill Commands

M-q
Fill current paragraph (fill-paragraph).

C-x f
Set the fill column (set-fill-column).

M-x fill-region
Fill each paragraph in the region (fill-region).

M-x fill-region-as-paragraph
Fill the region, considering it as one paragraph.

M-x center-line
Center a line.

The command M-q (fill-paragraph) fills the current paragraph. It redistributes the line breaks within the paragraph, and deletes any excess space and tab characters occurring within the paragraph, in such a way that the lines end up fitting within a certain maximum width. Like Auto Fill mode, this and other filling commands usually break lines at space characters, but for CJK characters these commands can break a line between almost any two characters, and they can also obey the kinsoku rules. See Auto Fill Mode.

Normally, M-q acts on the paragraph where point is, but if point is between paragraphs, it acts on the paragraph after point. If the region is active, it acts instead on the text in the region. You can also call M-x fill-region to specifically fill the text in the region.

M-q and fill-region use the usual Emacs criteria for finding paragraph boundaries (see Paragraphs). For more control, you can use M-x fill-region-as-paragraph, which refills everything between point and mark as a single paragraph. This command deletes any blank lines within the region, so separate blocks of text end up combined into one block.

A numeric argument to M-q tells it to justify the text as well as filling it. This means that extra spaces are inserted to make the right margin line up exactly at the fill column. To remove the extra spaces, use M-q with no argument. (Likewise for fill-region.)

The maximum line width for filling is specified by the buffer-local variable fill-column. The default value (see Local Variables) is 70. The easiest way to set fill-column in the current buffer is to use the command C-x f (set-fill-column). With a numeric argument, it uses that as the new fill column. With just C-u as argument, it sets fill-column to the current horizontal position of point. Note that, by its very nature, fill-column is measured in column units; the actual position of that column on a graphical display depends on the font being used. In particular, using variable-pitch fonts will cause the fill-column occupy different horizontal positions on display in different lines.

The command M-x center-line centers the current line within the current fill column. With an argument n, it centers n lines individually and moves past them. This binding is made by Text mode and is available only in that and related modes (see Text Mode).

By default, Emacs considers a period followed by two spaces or by a newline as the end of a sentence; a period followed by just one space indicates an abbreviation, not the end of a sentence. Accordingly, the fill commands will not break a line after a period followed by just one space. If you set the variable sentence-end-double-space to nil, the fill commands will break a line after a period followed by one space, and put just one space after each period. See Sentences, for other effects and possible drawbacks of this.

If the variable colon-double-space is non-nil, the fill commands put two spaces after a colon.

To specify additional conditions where line-breaking is not allowed, customize the abnormal hook variable fill-nobreak-predicate (see Hooks). Each function in this hook is called with no arguments, with point positioned where Emacs is considering breaking a line. If a function returns a non-nil value, Emacs will not break the line there. Functions you can use there include: fill-single-word-nobreak-p (don’t break after the first word of a sentence or before the last); fill-single-char-nobreak-p (don’t break after a one-letter word preceded by a whitespace character); fill-french-nobreak-p (don’t break after ‘(’ or before ‘)’, ‘:’ or ‘?’); and fill-polish-nobreak-p (don’t break after a one letter word, even if preceded by a non-whitespace character).

Emacs can display an indicator in the fill-column position using the Display fill column indicator mode (see display-fill-column-indicator).


**** The Fill Prefix

The fill prefix feature allows paragraphs to be filled so that each line starts with a special string of characters (such as a sequence of spaces, giving an indented paragraph). You can specify a fill prefix explicitly; otherwise, Emacs tries to deduce one automatically (see Adaptive Filling).

C-x .
Set the fill prefix (set-fill-prefix).

M-q
Fill a paragraph using current fill prefix (fill-paragraph).

M-x fill-individual-paragraphs
Fill the region, considering each change of indentation as starting a new paragraph.

M-x fill-nonuniform-paragraphs
Fill the region, considering only paragraph-separator lines as starting a new paragraph.

To specify a fill prefix for the current buffer, move to a line that starts with the desired prefix, put point at the end of the prefix, and type C-x . (set-fill-prefix). (That’s a period after the C-x.) To turn off the fill prefix, specify an empty prefix: type C-x . with point at the beginning of a line.

When a fill prefix is in effect, the fill commands remove the fill prefix from each line of the paragraph before filling, and insert it on each line after filling. (The beginning of the first line of the paragraph is left unchanged, since often that is intentionally different.) Auto Fill mode also inserts the fill prefix automatically when it makes a new line (see Auto Fill Mode). The C-o command inserts the fill prefix on new lines it creates, when you use it at the beginning of a line (see Blank Lines). Conversely, the command M-^ deletes the prefix (if it occurs) after the newline that it deletes (see Indentation).

For example, if fill-column is 40 and you set the fill prefix to ‘;; ’, then M-q in the following text

;; This is an
;; example of a paragraph
;; inside a Lisp-style comment.
produces this:

;; This is an example of a paragraph
;; inside a Lisp-style comment.
Lines that do not start with the fill prefix are considered to start paragraphs, both in M-q and the paragraph commands; this gives good results for paragraphs with hanging indentation (every line indented except the first one). Lines which are blank or indented once the prefix is removed also separate or start paragraphs; this is what you want if you are writing multi-paragraph comments with a comment delimiter on each line.

You can use M-x fill-individual-paragraphs to set the fill prefix for each paragraph automatically. This command divides the region into paragraphs, treating every change in the amount of indentation as the start of a new paragraph, and fills each of these paragraphs. Thus, all the lines in one paragraph have the same amount of indentation. That indentation serves as the fill prefix for that paragraph.

M-x fill-nonuniform-paragraphs is a similar command that divides the region into paragraphs in a different way. It considers only paragraph-separating lines (as defined by paragraph-separate) as starting a new paragraph. Since this means that the lines of one paragraph may have different amounts of indentation, the fill prefix used is the smallest amount of indentation of any of the lines of the paragraph. This gives good results with styles that indent a paragraph’s first line more or less that the rest of the paragraph.

The fill prefix is stored in the variable fill-prefix. Its value is a string, or nil when there is no fill prefix. This is a per-buffer variable; altering the variable affects only the current buffer, but there is a default value which you can change as well. See Local Variables.

The indentation text property provides another way to control the amount of indentation paragraphs receive. See Indentation in Enriched Text.


**** Adaptive Filling

The fill commands can deduce the proper fill prefix for a paragraph automatically in certain cases: either whitespace or certain punctuation characters at the beginning of a line are propagated to all lines of the paragraph.

If the paragraph has two or more lines, the fill prefix is taken from the paragraph’s second line, but only if it appears on the first line as well.

If a paragraph has just one line, fill commands may take a prefix from that line. The decision is complicated because there are three reasonable things to do in such a case:

Use the first line’s prefix on all the lines of the paragraph.
Indent subsequent lines with whitespace, so that they line up under the text that follows the prefix on the first line, but don’t actually copy the prefix from the first line.
Don’t do anything special with the second and following lines.
All three of these styles of formatting are commonly used. So the fill commands try to determine what you would like, based on the prefix that appears and on the major mode. Here is how.

If the prefix found on the first line matches adaptive-fill-first-line-regexp, or if it appears to be a comment-starting sequence (this depends on the major mode), then the prefix found is used for filling the paragraph, provided it would not act as a paragraph starter on subsequent lines.

Otherwise, the prefix found is converted to an equivalent number of spaces, and those spaces are used as the fill prefix for the rest of the lines, provided they would not act as a paragraph starter on subsequent lines.

In Text mode, and other modes where only blank lines and page delimiters separate paragraphs, the prefix chosen by adaptive filling never acts as a paragraph starter, so it can always be used for filling.

The variable adaptive-fill-regexp determines what kinds of line beginnings can serve as a fill prefix: any characters at the start of the line that match this regular expression are used. If you set the variable adaptive-fill-mode to nil, the fill prefix is never chosen automatically.

You can specify more complex ways of choosing a fill prefix automatically by setting the variable adaptive-fill-function to a function. This function is called with point after the left margin of a line, and it should return the appropriate fill prefix based on that line. If it returns nil, adaptive-fill-regexp gets a chance to find a prefix.


*** Case Conversion Commands

Emacs has commands for converting either a single word or any arbitrary range of text to upper case or to lower case.

M-l
Convert following word to lower case (downcase-word).

M-u
Convert following word to upper case (upcase-word).

M-c
Capitalize the following word (capitalize-word).

C-x C-l
Convert region to lower case (downcase-region).

C-x C-u
Convert region to upper case (upcase-region).

M-l (downcase-word) converts the word after point to lower case, moving past it. Thus, repeating M-l converts successive words. M-u (upcase-word) converts to all capitals instead, while M-c (capitalize-word) puts the first letter of the word into upper case and the rest into lower case. All these commands convert several words at once if given an argument. They are especially convenient for converting a large amount of text from all upper case to mixed case, because you can move through the text using M-l, M-u or M-c on each word as appropriate, occasionally using M-f instead to skip a word.

When given a negative argument, the word case conversion commands apply to the appropriate number of words before point, but do not move point. This is convenient when you have just typed a word in the wrong case: you can give the case conversion command and continue typing.

If a word case conversion command is given in the middle of a word, it applies only to the part of the word which follows point. (This is comparable to what M-d (kill-word) does.) With a negative argument, case conversion applies only to the part of the word before point.

The other case conversion commands are C-x C-u (upcase-region) and C-x C-l (downcase-region), which convert everything between point and mark to the specified case. Point and mark do not move.

The region case conversion commands upcase-region and downcase-region are normally disabled. This means that they ask for confirmation if you try to use them. When you confirm, you may enable the command, which means it will not ask for confirmation again. See Disabling Commands.


*** Text Mode

Text mode is a major mode for editing files of text in a human language. Files which have names ending in the extension .txt are usually opened in Text mode (see Choosing File Modes). To explicitly switch to Text mode, type M-x text-mode.

In Text mode, only blank lines and page delimiters separate paragraphs. As a result, paragraphs can be indented, and adaptive filling determines what indentation to use when filling a paragraph. See Adaptive Filling.

In Text mode, the TAB (indent-for-tab-command) command usually inserts whitespace up to the next tab stop, instead of indenting the current line. See Indentation, for details.

Text mode turns off the features concerned with comments except when you explicitly invoke them. It changes the syntax table so that apostrophes are considered part of words (e.g., ‘don't’ is considered one word). However, if a word starts with an apostrophe, it is treated as a prefix for the purposes of capitalization (e.g., M-c converts ‘'hello'’ into ‘'Hello'’, as expected).

If you indent the first lines of paragraphs, then you should use Paragraph-Indent Text mode (M-x paragraph-indent-text-mode) rather than Text mode. In that mode, you do not need to have blank lines between paragraphs, because the first-line indentation is sufficient to start a paragraph; however paragraphs in which every line is indented are not supported. Use M-x paragraph-indent-minor-mode to enable an equivalent minor mode for situations where you shouldn’t change the major mode—in mail composition, for instance.

Text mode binds M-TAB to ispell-complete-word. This command performs completion of the partial word in the buffer before point, using the spelling dictionary as the space of possible words. See Checking and Correcting Spelling. If your window manager defines M-TAB to switch windows, you can type ESC TAB or C-M-i instead.

Entering Text mode runs the mode hook text-mode-hook (see Major Modes).

The following sections describe several major modes that are derived from Text mode. These derivatives share most of the features of Text mode described above. In particular, derivatives of Text mode run text-mode-hook prior to running their own mode hooks.


*** Outline Mode

Outline mode is a major mode derived from Text mode, which is specialized for editing outlines. It provides commands to navigate between entries in the outline structure, and commands to make parts of a buffer temporarily invisible, so that the outline structure may be more easily viewed. Type M-x outline-mode to switch to Outline mode. Entering Outline mode runs the hook text-mode-hook followed by the hook outline-mode-hook (see Hooks).

When you use an Outline mode command to make a line invisible (see Outline Visibility Commands), the line disappears from the screen. An ellipsis (three periods in a row) is displayed at the end of the previous visible line, to indicate the hidden text. Multiple consecutive invisible lines produce just one ellipsis.

Editing commands that operate on lines, such as C-n and C-p, treat the text of the invisible line as part of the previous visible line. Killing the ellipsis at the end of a visible line really kills all the following invisible text associated with the ellipsis.


**** Outline Minor Mode

Outline minor mode is a buffer-local minor mode which provides the same commands as the major mode, Outline mode, but can be used in conjunction with other major modes. You can type M-x outline-minor-mode to toggle Outline minor mode in the current buffer, or use a file-local variable setting to enable it in a specific file (see Local Variables in Files).

The major mode, Outline mode, provides special key bindings on the C-c prefix. Outline minor mode provides similar bindings with C-c @ as the prefix; this is to reduce the conflicts with the major mode’s special commands. (The variable outline-minor-mode-prefix controls the prefix used.)

If outline-minor-mode-use-buttons is non-nil, Outline minor mode will use buttons at the beginning of the heading lines, in addition to ellipsis, to show that a section is hidden. Clicking the mouse on the button toggles display of the section. If the value of this variable is insert, the buttons are inserted directly into the buffer text, so RET on the button will also toggle display of the section, like a mouse click does. Using the value insert is not recommended in editable buffers because it modifies them. If the value is in-margins, Outline minor mode will use the window margins to indicate that a section is hidden. The buttons are customizable as icons (see Icons).

If the outline-minor-mode-cycle user option is non-nil, the TAB and S-TAB keys that cycle the visibility are enabled on the outline heading lines (see outline-cycle). TAB cycles hiding, showing the sub-heading, and showing all for the current section. S-TAB does the same for the entire buffer.


**** Format of Outlines

Outline mode assumes that the lines in the buffer are of two types: heading lines and body lines. A heading line represents a topic in the outline. Heading lines start with one or more asterisk (‘*’) characters; the number of asterisks determines the depth of the heading in the outline structure. Thus, a heading line with one ‘*’ is a major topic; all the heading lines with two ‘*’s between it and the next one-‘*’ heading are its subtopics; and so on. Any line that is not a heading line is a body line. Body lines belong with the preceding heading line.

Another first-level topic with its header line.
A heading line together with all following body lines is called collectively an entry. A heading line together with all following deeper heading lines and their body lines is called a subtree.

You can customize the criterion for distinguishing heading lines by setting the variable outline-regexp. (The recommended ways to do this are in a major mode function or with a file local variable.) Any line whose beginning has a match for this regexp is considered a heading line. Matches that start within a line (not at the left margin) do not count.

The length of the matching text determines the level of the heading; longer matches make a more deeply nested level. Thus, for example, if a text formatter has commands ‘@chapter’, ‘@section’ and ‘@subsection’ to divide the document into chapters and sections, you could make those lines count as heading lines by setting outline-regexp to ‘"@chap\\|@\\(sub\\)*section"’. Note the trick: the two words ‘chapter’ and ‘section’ are equally long, but by defining the regexp to match only ‘chap’ we ensure that the length of the text matched on a chapter heading is shorter, so that Outline mode will know that sections are contained in chapters. This works as long as no other command starts with ‘@chap’.

You can explicitly specify a rule for calculating the level of a heading line by setting the variable outline-level. The value of outline-level should be a function that takes no arguments and returns the level of the current heading. The recommended ways to set this variable are in a major mode command or with a file local variable.


**** Outline Motion Commands

Outline mode provides special motion commands that move backward and forward to heading lines.

C-c C-n ¶
Move point to the next visible heading line (outline-next-visible-heading).

C-c C-p ¶
Move point to the previous visible heading line (outline-previous-visible-heading).

C-c C-f ¶
Move point to the next visible heading line at the same level as the one point is on (outline-forward-same-level).

C-c C-b ¶
Move point to the previous visible heading line at the same level (outline-backward-same-level).

C-c C-u ¶
Move point up to a lower-level (more inclusive) visible heading line (outline-up-heading).

All of the above commands accept numeric arguments as repeat counts. For example, C-c C-f, when given an argument, moves forward that many visible heading lines on the same level, and C-c C-u with an argument moves out of that many nested levels.


**** Outline Visibility Commands

Outline mode provides several commands for temporarily hiding or revealing parts of the buffer, based on the outline structure. These commands are not undoable; their effects are simply not recorded by the undo mechanism, so you can undo right past them (see Undo).

Many of these commands act on the current heading line. If point is on a heading line, that is the current heading line; if point is on a body line, the current heading line is the nearest preceding header line.

C-c C-c
Make the current heading line’s body invisible (outline-hide-entry).

C-c C-e
Make the current heading line’s body visible (outline-show-entry).

C-c C-d
Make everything under the current heading invisible, not including the heading itself (outline-hide-subtree).

C-c C-s
Make everything under the current heading visible, including body, subheadings, and their bodies (outline-show-subtree).

C-c C-l
Make the body of the current heading line, and of all its subheadings, invisible (outline-hide-leaves).

C-c C-k
Make all subheadings of the current heading line, at all levels, visible (outline-show-branches).

C-c C-i
Make immediate subheadings (one level down) of the current heading line visible (outline-show-children).

C-c C-t
Make all body lines in the buffer invisible (outline-hide-body).

C-c C-a
Make all lines in the buffer visible (outline-show-all).

C-c C-q
Hide everything except the top n levels of heading lines (outline-hide-sublevels).

C-c C-o
Hide everything except for the heading or body that point is in, plus the headings leading up from there to the top level of the outline (outline-hide-other).

The simplest of these commands are C-c C-c (outline-hide-entry), which hides the body lines directly following the current heading line, and C-c C-e (outline-show-entry), which reveals them. Subheadings and their bodies are not affected.

The commands C-c C-d (outline-hide-subtree) and C-c C-s (outline-show-subtree) are more powerful. They apply to the current heading line’s subtree: its body, all of its subheadings, both direct and indirect, and all of their bodies.

The command C-c C-l (outline-hide-leaves) hides the body of the current heading line as well as all the bodies in its subtree; the subheadings themselves are left visible. The command C-c C-k (outline-show-branches) reveals the subheadings, if they had previously been hidden (e.g., by C-c C-d). The command C-c C-i (outline-show-children) is a weaker version of this; it reveals just the direct subheadings, i.e., those one level down.

The command C-c C-o (outline-hide-other) hides everything except the entry that point is in, plus its parents (the headers leading up from there to top level in the outline) and the top level headings. It also reveals body lines preceding the first heading in the buffer.

The remaining commands affect the whole buffer. C-c C-t (outline-hide-body) makes all body lines invisible, so that you see just the outline structure (as a special exception, it will not hide lines at the top of the file, preceding the first header line, even though these are technically body lines). C-c C-a (outline-show-all) makes all lines visible. C-c C-q (outline-hide-sublevels) hides all but the top level headings at and above the level of the current heading line (defaulting to 1 if point is not on a heading); with a numeric argument n, it hides everything except the top n levels of heading lines. Note that it completely reveals all the n top levels and the body lines before the first heading.

Outline also provides two convenience commands to cycle the visibility of each section and the whole buffer. Typing TAB (outline-cycle) on a heading cycles the current section between “hide all”, “subheadings”, and “show all” states. Typing S-TAB (outline-cycle-buffer) cycles the whole buffer between “only top-level headings”, “all headings and subheadings”, and “show all” states.

When incremental search finds text that is hidden by Outline mode, it makes that part of the buffer visible. If you exit the search at that position, the text remains visible. To toggle whether or not an active incremental search can match hidden text, type M-s i. To change the default for future searches, customize the option search-invisible. (This option also affects how query-replace and related functions treat hidden text, see Query Replace.) You can also automatically make text visible as you navigate in it by using Reveal mode (M-x reveal-mode), a buffer-local minor mode.

The outline-default-state variable controls what headings will be visible after Outline mode is turned on. If non-nil, some headings are initially outlined. If equal to a number, show only headings up to and including the corresponding level. If equal to outline-show-all, all text of buffer is shown. If equal to outline-show-only-headings, show only headings, whatever their level is. If equal to a lambda function or function name, this function is expected to toggle headings visibility, and will be called without arguments after the mode is enabled.


**** Viewing One Outline in Multiple Views

You can display two views of a single outline at the same time, in different windows. To do this, you must create an indirect buffer using M-x make-indirect-buffer. The first argument of this command is the existing outline buffer name, and its second argument is the name to use for the new indirect buffer. See Indirect Buffers.

Once the indirect buffer exists, you can display it in a window in the normal fashion, with C-x 4 b or other Emacs commands. The Outline mode commands to show and hide parts of the text operate on each buffer independently; as a result, each buffer can have its own view. If you want more than two views on the same outline, create additional indirect buffers.


**** Folding Editing

The Foldout package extends Outline mode and Outline minor mode with folding commands. The idea of folding is that you zoom in on a nested portion of the outline, while hiding its relatives at higher levels.

Consider an Outline mode buffer with all the text and subheadings under level-1 headings hidden. To look at what is hidden under one of these headings, you could use C-c C-e (M-x outline-show-entry) to expose the body, or C-c C-i to expose the child (level-2) headings.

With Foldout, you use C-c C-z (M-x foldout-zoom-subtree). This exposes the body and child subheadings, and narrows the buffer so that only the level-1 heading, the body and the level-2 headings are visible. Now to look under one of the level-2 headings, position the cursor on it and use C-c C-z again. This exposes the level-2 body and its level-3 child subheadings and narrows the buffer again. Zooming in on successive subheadings can be done as much as you like. A string in the mode line shows how deep you’ve gone.

When zooming in on a heading, to see only the child subheadings specify a numeric argument: C-u C-c C-z. The number of levels of children can be specified too (compare M-x outline-show-children), e.g., M-2 C-c C-z exposes two levels of child subheadings. Alternatively, the body can be specified with a negative argument: M-- C-c C-z. The whole subtree can be expanded, similarly to C-c C-s (M-x outline-show-subtree), by specifying a zero argument: M-0 C-c C-z.

While you’re zoomed in, you can still use Outline mode’s exposure and hiding functions without disturbing Foldout. Also, since the buffer is narrowed, global editing actions will only affect text under the zoomed-in heading. This is useful for restricting changes to a particular chapter or section of your document.

To unzoom (exit) a fold, use C-c C-x (M-x foldout-exit-fold). This hides all the text and subheadings under the top-level heading and returns you to the previous view of the buffer. Specifying a numeric argument exits that many levels of folds. Specifying a zero argument exits all folds.

To cancel the narrowing of a fold without hiding the text and subheadings, specify a negative argument. For example, M--2 C-c C-x exits two folds and leaves the text and subheadings exposed.

Foldout mode also provides mouse commands for entering and exiting folds, and for showing and hiding text:

C-M-mouse-1 zooms in on the heading clicked on
single click: expose body.
double click: expose subheadings.
triple click: expose body and subheadings.
quad click: expose entire subtree.
C-M-mouse-2 exposes text under the heading clicked on
single click: expose body.
double click: expose subheadings.
triple click: expose body and subheadings.
quad click: expose entire subtree.
C-M-mouse-3 hides text under the heading clicked on or exits fold
single click: hide subtree.
double click: exit fold and hide text.
triple click: exit fold without hiding text.
quad click: exit all folds and hide text.
You can specify different modifier keys (instead of Ctrl-Meta-) by setting foldout-mouse-modifiers; but if you have already loaded the foldout.el library, you must reload it in order for this to take effect.

To use the Foldout package, you can type M-x load-library RET foldout RET; or you can arrange for to do that automatically by putting the following in your init file:

(with-eval-after-load "outline"
  (require 'foldout))


  
*** Org Mode

Org mode is a variant of Outline mode for using Emacs as an organizer and/or authoring system. Files with names ending in the extension .org are opened in Org mode (see Choosing File Modes). To explicitly switch to Org mode, type M-x org-mode.

In Org mode, as in Outline mode, each entry has a heading line that starts with one or more ‘*’ characters. See Format of Outlines. In addition, any line that begins with the ‘#’ character is treated as a comment.

Org mode provides commands for easily viewing and manipulating the outline structure. The simplest of these commands is TAB (org-cycle). If invoked on a heading line, it cycles through the different visibility states of the subtree: (i) showing only that heading line, (ii) showing only the heading line and the heading lines of its direct children, if any, and (iii) showing the entire subtree. If invoked in a body line, the global binding for TAB is executed.

Typing S-TAB (org-shifttab) anywhere in an Org mode buffer cycles the visibility of the entire outline structure, between (i) showing only top-level heading lines, (ii) showing all heading lines but no body lines, and (iii) showing everything.

You can move an entire entry up or down in the buffer, including its body lines and subtree (if any), by typing M-UP (org-metaup) or M-DOWN (org-metadown) on the heading line. Similarly, you can promote or demote a heading line with M-LEFT (org-metaleft) and M-RIGHT (org-metaright). These commands execute their global bindings if invoked on a body line.

The following subsections give basic instructions for using Org mode as an organizer and as an authoring system. For details, see Introduction in The Org Manual.

**** Org as an organizer

You can tag an Org entry as a TODO item by typing C-c C-t (org-todo) anywhere in the entry. This adds the keyword ‘TODO’ to the heading line. Typing C-c C-t again switches the keyword to ‘DONE’; another C-c C-t removes the keyword entirely, and so forth. You can customize the keywords used by C-c C-t via the variable org-todo-keywords.

Apart from marking an entry as TODO, you can attach a date to it, by typing C-c C-s (org-schedule) in the entry. This prompts for a date by popping up the Emacs Calendar (see The Calendar and the Diary), and then adds the tag ‘SCHEDULED’, together with the selected date, beneath the heading line. The command C-c C-d (org-deadline) has the same effect, except that it uses the tag DEADLINE.

Once you have some TODO items planned in an Org file, you can add that file to the list of agenda files by typing C-c [ (org-agenda-file-to-front). Org mode is designed to let you easily maintain multiple agenda files, e.g., for organizing different aspects of your life. The list of agenda files is stored in the variable org-agenda-files.

To view items coming from your agenda files, type M-x org-agenda. This command prompts for what you want to see: a list of things to do this week, a list of TODO items with specific keywords, etc. See Agenda Views in The Org Manual, for details.


**** Org as an authoring system

You may want to format your Org notes nicely and to prepare them for export and publication. To export the current buffer, type C-c C-e (org-export-dispatch) anywhere in an Org buffer. This command prompts for an export format; currently supported formats include HTML, LaTeX, Texinfo, OpenDocument (.odt), iCalendar, Markdown, man-page, and PDF. Some formats, such as PDF, require certain system tools to be installed.

To export several files at once to a specific directory, either locally or over the network, you must define a list of projects through the variable org-publish-project-alist. See its documentation for details.

Org supports a simple markup scheme for applying text formatting to exported documents:

- This text is /emphasized/
- This text is *in bold*
- This text is _underlined_
- This text uses =a teletype font=

#+begin_quote
``This is a quote.''
#+end_quote

#+begin_example
This is an example.
#+end_example
For further details, Exporting in The Org Manual, and Publishing in The Org Manual.


*** TeX Mode

TeX is a powerful text formatter written by Donald Knuth; like GNU Emacs, it is free software. The TeX format has several variants, including LaTeX, a simplified input format for TeX; DocTeX, a special file format in which the LaTeX sources are written, combining sources with documentation; and SliTeX, an obsolete special form of LaTeX13.

Emacs provides a TeX major mode for each of these variants: Plain TeX mode, LaTeX mode, DocTeX mode, and SliTeX mode. Emacs selects the appropriate mode by looking at the contents of the buffer. (This is done by invoking the tex-mode command, which is normally called automatically when you visit a TeX-like file. See Choosing File Modes.) If the contents are insufficient to determine this, Emacs chooses the mode specified by the variable tex-default-mode; its default value is latex-mode. If Emacs does not guess right, you can select the correct variant of TeX mode using the commands plain-tex-mode, latex-mode, slitex-mode, or doctex-mode.

The following sections document the features of TeX mode and its variants. There are several other TeX-related Emacs packages, which are not documented in this manual:

BibTeX mode is a major mode for BibTeX files, which are commonly used for keeping bibliographic references for LaTeX documents. For more information, see the documentation string for the command bibtex-mode.
The RefTeX package provides a minor mode which can be used with LaTeX mode to manage bibliographic references. For more information, see the RefTeX Info manual, which is distributed with Emacs.
The AUCTeX package provides more advanced features for editing TeX and its related formats, including the ability to preview TeX equations within Emacs buffers. Unlike BibTeX mode and the RefTeX package, AUCTeX is not distributed with Emacs by default. It can be downloaded via the Package Menu (see Emacs Lisp Packages); once installed, see the AUCTeX manual, which is included with the package.


**** TeX Editing Commands

"
Insert, according to context, either ‘``’ or ‘"’ or ‘''’ (tex-insert-quote).

C-j
Insert a paragraph break (two newlines) and check the previous paragraph for unbalanced braces or dollar signs (tex-terminate-paragraph).

M-x tex-validate-region
Check each paragraph in the region for unbalanced braces or dollar signs.

C-c {
Insert ‘{}’ and position point between them (tex-insert-braces).

C-c }
Move forward past the next unmatched close brace (up-list).

In TeX, the character ‘"’ is not normally used; instead, quotations begin with ‘``’ and end with ‘''’. TeX mode therefore binds the " key to the tex-insert-quote command. This inserts ‘``’ after whitespace or an open brace, ‘"’ after a backslash, and ‘''’ after any other character.

As a special exception, if you type " when the text before point is either ‘``’ or ‘''’, Emacs replaces that preceding text with a single ‘"’ character. You can therefore type "" to insert ‘"’, should you ever need to do so. (You can also use C-q " to insert this character.)

In TeX mode, ‘$’ has a special syntax code which attempts to understand the way TeX math mode delimiters match. When you insert a ‘$’ that is meant to exit math mode, the position of the matching ‘$’ that entered math mode is displayed for a second. This is the same feature that displays the open brace that matches a close brace that is inserted. However, there is no way to tell whether a ‘$’ enters math mode or leaves it; so when you insert a ‘$’ that enters math mode, the previous ‘$’ position is shown as if it were a match, even though they are actually unrelated.

TeX uses braces as delimiters that must match. Some users prefer to keep braces balanced at all times, rather than inserting them singly. Use C-c { (tex-insert-braces) to insert a pair of braces. It leaves point between the two braces so you can insert the text that belongs inside. Afterward, use the command C-c } (up-list) to move forward past the close brace. You can also invoke C-c { after marking some text: then the command encloses the marked text in braces.

There are two commands for checking the matching of braces. C-j (tex-terminate-paragraph) checks the paragraph before point, and inserts two newlines to start a new paragraph. It outputs a message in the echo area if any mismatch is found. M-x tex-validate-region checks a region, paragraph by paragraph. The errors are listed in an *Occur* buffer; you can use the usual Occur mode commands in that buffer, such as C-c C-c, to visit a particular mismatch (see Other Search-and-Loop Commands).

Note that Emacs commands count square brackets and parentheses in TeX mode, not just braces. This is not strictly correct for the purpose of checking TeX syntax. However, parentheses and square brackets are likely to be used in text as matching delimiters, and it is useful for the various motion commands and automatic match display to work with them.


**** LaTeX Editing Commands

LaTeX mode provides a few extra features not applicable to plain TeX:

C-c C-o
Insert ‘\begin’ and ‘\end’ for LaTeX block and position point on a line between them (latex-insert-block).

C-c C-e
Close the innermost LaTeX block not yet closed (latex-close-block).

In LaTeX input, ‘\begin’ and ‘\end’ tags are used to group blocks of text. To insert a block, type C-c C-o (latex-insert-block). This prompts for a block type, and inserts the appropriate matching ‘\begin’ and ‘\end’ tags, leaving a blank line between the two and moving point there.

When entering the block type argument to C-c C-o, you can use the usual completion commands (see Completion). The default completion list contains the standard LaTeX block types. If you want additional block types for completion, customize the list variable latex-block-names.

In LaTeX input, ‘\begin’ and ‘\end’ tags must balance. You can use C-c C-e (latex-close-block) to insert an ‘\end’ tag which matches the last unmatched ‘\begin’. It also indents the ‘\end’ to match the corresponding ‘\begin’, and inserts a newline after the ‘\end’ tag if point is at the beginning of a line. The minor mode latex-electric-env-pair-mode automatically inserts an ‘\end’ or ‘\begin’ tag for you when you type the corresponding one.


**** TeX Printing Commands

You can invoke TeX as a subprocess of Emacs, supplying either the entire contents of the buffer or just part of it (e.g., one chapter of a larger document).

C-c C-b
Invoke TeX on the entire current buffer (tex-buffer).

C-c C-r
Invoke TeX on the current region, together with the buffer’s header (tex-region).

C-c C-f
Invoke TeX on the current file (tex-file).

C-c C-v
Preview the output from the last C-c C-b, C-c C-r, or C-c C-f command (tex-view).

C-c C-p
Print the output from the last C-c C-b, C-c C-r, or C-c C-f command (tex-print).

C-c TAB
Invoke BibTeX on the current file (tex-bibtex-file).

C-c C-l
Recenter the window showing output from TeX so that the last line can be seen (tex-recenter-output-buffer).

C-c C-k
Kill the TeX subprocess (tex-kill-job).

C-c C-c
Invoke some other compilation command on the entire current buffer (tex-compile).

To pass the current buffer through TeX, type C-c C-b (tex-buffer). The formatted output goes in a temporary file, normally a .dvi file. Afterwards, you can type C-c C-v (tex-view) to launch an external program, such as xdvi, to view this output file. You can also type C-c C-p (tex-print) to print a hardcopy of the output file.

By default, C-c C-b runs TeX in the current directory. The output of TeX is also created in this directory. To run TeX in a different directory, change the variable tex-directory to the desired directory. If your environment variable TEXINPUTS contains relative names, or if your files contain ‘\input’ commands with relative file names, then tex-directory must be "." or you will get the wrong results. Otherwise, it is safe to specify some other directory, such as "/tmp".

The buffer’s TeX variant determines what shell command C-c C-b actually runs. In Plain TeX mode, it is specified by the variable tex-run-command, which defaults to "tex". In LaTeX mode, it is specified by latex-run-command, which defaults to "latex". The shell command that C-c C-v runs to view the .dvi output is determined by the variable tex-dvi-view-command, regardless of the TeX variant. The shell command that C-c C-p runs to print the output is determined by the variable tex-dvi-print-command. The variable tex-print-file-extension can be set to the required file extension for viewing and printing TeX-compiled files. For example, you can set it to .pdf, and update tex-dvi-view-command and tex-dvi-print-command accordingly, as well as latex-run-command or tex-run-command.

Normally, Emacs automatically appends the output file name to the shell command strings described in the preceding paragraph. For example, if tex-dvi-view-command is "xdvi", C-c C-v runs xdvi output-file-name. In some cases, however, the file name needs to be embedded in the command, e.g., if you need to provide the file name as an argument to one command whose output is piped to another. You can specify where to put the file name with ‘*’ in the command string. For example,

(setq tex-dvi-print-command "dvips -f * | lpr")
The terminal output from TeX, including any error messages, appears in a buffer called *tex-shell*. If TeX gets an error, you can switch to this buffer and feed it input (this works as in Shell mode; see Interactive Subshell). Without switching to this buffer you can scroll it so that its last line is visible by typing C-c C-l.

Type C-c C-k (tex-kill-job) to kill the TeX process if you see that its output is no longer useful. Using C-c C-b or C-c C-r also kills any TeX process still running.

You can also pass an arbitrary region through TeX by typing C-c C-r (tex-region). This is tricky, however, because most files of TeX input contain commands at the beginning to set parameters and define macros, without which no later part of the file will format correctly. To solve this problem, C-c C-r allows you to designate a part of the file as containing essential commands; it is included before the specified region as part of the input to TeX. The designated part of the file is called the header.

To indicate the bounds of the header in Plain TeX mode, you insert two special strings in the file. Insert ‘%**start of header’ before the header, and ‘%**end of header’ after it. Each string must appear entirely on one line, but there may be other text on the line before or after. The lines containing the two strings are included in the header. If ‘%**start of header’ does not appear within the first 100 lines of the buffer, C-c C-r assumes that there is no header.

In LaTeX mode, the header begins with ‘\documentclass’ or ‘\documentstyle’ and ends with ‘\begin{document}’. These are commands that LaTeX requires you to use in any case, so nothing special needs to be done to identify the header.

The commands (tex-buffer) and (tex-region) do all of their work in a temporary directory, and do not have available any of the auxiliary files needed by TeX for cross-references; these commands are generally not suitable for running the final copy in which all of the cross-references need to be correct.

When you want the auxiliary files for cross references, use C-c C-f (tex-file) which runs TeX on the current buffer’s file, in that file’s directory. Before running TeX, it offers to save any modified buffers. Generally, you need to use (tex-file) twice to get the cross-references right.

The value of the variable tex-start-options specifies options for the TeX run.

The value of the variable tex-start-commands specifies TeX commands for starting TeX. The default value causes TeX to run in nonstop mode. To run TeX interactively, set the variable to "".

Large TeX documents are often split into several files—one main file, plus subfiles. Running TeX on a subfile typically does not work; you have to run it on the main file. In order to make tex-file useful when you are editing a subfile, you can set the variable tex-main-file to the name of the main file. Then tex-file runs TeX on that file.

The most convenient way to use tex-main-file is to specify it in a local variable list in each of the subfiles. See Local Variables in Files.

For LaTeX files, you can use BibTeX to process the auxiliary file for the current buffer’s file. BibTeX looks up bibliographic citations in a data base and prepares the cited references for the bibliography section. The command C-c TAB (tex-bibtex-file) runs the shell command (tex-bibtex-command) to produce a ‘.bbl’ file for the current buffer’s file. Generally, you need to do C-c C-f (tex-file) once to generate the ‘.aux’ file, then do C-c TAB (tex-bibtex-file), and then repeat C-c C-f (tex-file) twice more to get the cross-references correct.

To invoke some other compilation program on the current TeX buffer, type C-c C-c (tex-compile). This command knows how to pass arguments to many common programs, including pdflatex, yap, xdvi, and dvips. You can select your desired compilation program using the standard completion keys (see Completion).


**** TeX Mode Miscellany

Entering any variant of TeX mode runs the hooks text-mode-hook and tex-mode-hook. Then it runs either plain-tex-mode-hook, doctex-mode-hook, latex-mode-hook, or slitex-mode-hook, whichever is appropriate. Starting the TeX shell runs the hook tex-shell-hook. See Hooks.

The commands M-x iso-iso2tex, M-x iso-tex2iso, M-x iso-iso2gtex and M-x iso-gtex2iso can be used to convert between Latin-1 encoded files and TeX-encoded equivalents.


*** SGML and HTML Modes

The major modes for SGML and HTML provide indentation support and commands for operating on tags.

HTML consists of two modes—one, a basic mode called html-mode is a slightly customized variant of SGML mode. The other, which is used by default for HTML files, is called mhtml-mode, and attempts to properly handle Javascript enclosed in a <script> element and CSS embedded in a <style> element.

C-c C-n ¶
Interactively specify a special character and insert the SGML ‘&’-command for that character (sgml-name-char).

C-c C-t ¶
Interactively specify a tag and its attributes (sgml-tag). This command asks you for a tag name and for the attribute values, then inserts both the opening tag and the closing tag, leaving point between them.

With a prefix argument n, the command puts the tag around the n words already present in the buffer after point. Whenever a region is active, it puts the tag around the region (when Transient Mark mode is off, it does this when a numeric argument of −1 is supplied.)

C-c C-a ¶
Interactively insert attribute values for the current tag (sgml-attributes).

C-c C-f ¶
Skip across a balanced tag group (which extends from an opening tag through its corresponding closing tag) (sgml-skip-tag-forward). A numeric argument acts as a repeat count.

C-c C-b ¶
Skip backward across a balanced tag group (which extends from an opening tag through its corresponding closing tag) (sgml-skip-tag-backward). A numeric argument acts as a repeat count.

C-c C-d ¶
Delete the tag at or after point, and delete the matching tag too (sgml-delete-tag). If the tag at or after point is an opening tag, delete the closing tag too; if it is a closing tag, delete the opening tag too.

C-c ? tag RET ¶
Display a description of the meaning of tag tag (sgml-tag-help). If the argument tag is empty, describe the tag at point.

C-c / ¶
Insert a close tag for the innermost unterminated tag (sgml-close-tag). If called within a tag or a comment, close it instead of inserting a close tag.

C-c 8 ¶
Toggle a minor mode in which Latin-1 characters insert the corresponding SGML commands that stand for them, instead of the characters themselves (sgml-name-8bit-mode).

C-c C-v ¶
Run a shell command (which you must specify) to validate the current buffer as SGML (sgml-validate). (In HTML mode this key sequence runs a different command.)

C-c TAB ¶
Toggle the visibility of existing tags in the buffer. This can be used as a cheap preview (sgml-tags-invisible).

The major mode for editing XML documents is called nXML mode. This is a powerful major mode that can recognize many existing XML schemas and use them to provide completion of XML elements via M-TAB, as well as on-the-fly XML validation with error highlighting. To enable nXML mode in an existing buffer, type M-x nxml-mode, or, equivalently, M-x xml-mode. Emacs uses nXML mode for files which have the extension .xml. For XHTML files, which have the extension .xhtml, Emacs uses HTML mode by default; you can make it use nXML mode by customizing the variable auto-mode-alist (see Choosing File Modes). nXML mode is described in an Info manual, which is distributed with Emacs.

You may choose to use the less powerful SGML mode for editing XML, since XML is a strict subset of SGML. To enable SGML mode in an existing buffer, type M-x sgml-mode. On enabling SGML mode, Emacs examines the buffer to determine whether it is XML; if so, it sets the variable sgml-xml-mode to a non-nil value. This causes SGML mode’s tag insertion commands, described above, to always insert explicit closing tags as well.


*** Nroff Mode

Nroff mode, a major mode derived from Text mode, is specialized for editing nroff files (e.g., Unix man pages). Type M-x nroff-mode to enter this mode. Entering Nroff mode runs the hook text-mode-hook, then nroff-mode-hook (see Hooks).

In Nroff mode, nroff command lines are treated as paragraph separators, pages are separated by ‘.bp’ commands, and comments start with backslash-doublequote. It also defines these commands:

M-n
Move to the beginning of the next line that isn’t an nroff command (nroff-forward-text-line). An argument is a repeat count.

M-p
Like M-n but move up (nroff-backward-text-line).

M-?
Displays in the echo area the number of text lines (lines that are not nroff commands) in the region (nroff-count-text-lines).

Electric Nroff mode is a buffer-local minor mode that can be used with Nroff mode. To toggle this minor mode, type M-x nroff-electric-mode (see Minor Modes). When the mode is on, each time you type RET to end a line containing an nroff command that opens a kind of grouping, the nroff command to close that grouping is automatically inserted on the following line.

If you use Outline minor mode with Nroff mode (see Outline Mode), heading lines are lines of the form ‘.H’ followed by a number (the header level).


*** Enriched Text

Enriched mode is a minor mode for editing formatted text files in a WYSIWYG (What You See Is What You Get) fashion. When Enriched mode is enabled, you can apply various formatting properties to the text in the buffer, such as fonts and colors; upon saving the buffer, those properties are saved together with the text, using the MIME ‘text/enriched’ file format.

Enriched mode is typically used with Text mode (see Text Mode). It is not compatible with Font Lock mode, which is used by many major modes, including most programming language modes, for syntax highlighting (see Font Lock mode). Unlike Enriched mode, Font Lock mode assigns text properties automatically, based on the current buffer contents; those properties are not saved to disk.

The file enriched.txt in Emacs’s data-directory serves as an example of the features of Enriched mode.

**** Enriched Mode

Enriched mode is a buffer-local minor mode (see Minor Modes). When you visit a file that has been saved in the ‘text/enriched’ format, Emacs automatically enables Enriched mode, and applies the formatting information in the file to the buffer text. When you save a buffer with Enriched mode enabled, it is saved using the ‘text/enriched’ format, including the formatting information.

To create a new file of formatted text, visit the nonexistent file and type M-x enriched-mode. This command actually toggles Enriched mode. With a prefix argument, it enables Enriched mode if the argument is positive, and disables Enriched mode otherwise. If you disable Enriched mode, Emacs no longer saves the buffer using the ‘text/enriched’ format; any formatting properties that have been added to the buffer remain in the buffer, but they are not saved to disk.

Enriched mode does not save all Emacs text properties, only those specified in the variable enriched-translations. These include properties for fonts, colors, indentation, and justification.

If you visit a file and Emacs fails to recognize that it is in the ‘text/enriched’ format, type M-x format-decode-buffer. This command prompts for a file format, and re-reads the file in that format. Specifying the ‘text/enriched’ format automatically enables Enriched mode.

To view a ‘text/enriched’ file in raw form (as plain text with markup tags rather than formatted text), use M-x find-file-literally (see Visiting Files).

See Format Conversion in the Emacs Lisp Reference Manual, for details of how Emacs recognizes and converts file formats like ‘text/enriched’. See Text Properties in the Emacs Lisp Reference Manual, for more information about text properties.


**** Hard and Soft Newlines

In Enriched mode, Emacs distinguishes between two different kinds of newlines, hard newlines and soft newlines. You can also enable or disable this feature in other buffers, by typing M-x use-hard-newlines.

Hard newlines are used to separate paragraphs, or anywhere there needs to be a line break regardless of how the text is filled; soft newlines are used for filling. The RET (newline) and C-o (open-line) commands insert hard newlines. The fill commands, including Auto Fill (see Auto Fill Mode), insert only soft newlines and delete only soft newlines, leaving hard newlines alone.

Thus, when editing with Enriched mode, you should not use RET or C-o to break lines in the middle of filled paragraphs. Use Auto Fill mode or explicit fill commands (see Explicit Fill Commands) instead. Use RET or C-o where line breaks should always remain, such as in tables and lists. For such lines, you may also want to set the justification style to unfilled (see Justification in Enriched Text).


**** Editing Format Information

The easiest way to alter properties is with the ‘Text Properties’ menu. You can get to this menu from the ‘Edit’ menu in the menu bar (see The Menu Bar), or with C-mouse-2 (see Mouse Clicks for Menus). Some of the commands in the ‘Text Properties’ menu are listed below (you can also invoke them with M-x):

Remove Face Properties
Remove face properties from the region (facemenu-remove-face-props).

Remove Text Properties
Remove all text properties from the region, including face properties (facemenu-remove-all).

Describe Properties
List all text properties and other information about the character following point (describe-text-properties).

Display Faces
Display a list of defined faces (list-faces-display). See Text Faces.

Display Colors
Display a list of defined colors (list-colors-display). See Colors for Faces.

The other menu entries are described in the following sections.


**** Faces in Enriched Text

The following commands can be used to add or remove faces (see Text Faces). Each applies to the text in the region if the mark is active, and to the next self-inserting character if the mark is inactive. With a prefix argument, each command applies to the next self-inserting character even if the region is active.

M-o d
Remove all face properties (facemenu-set-default).

M-o b
Apply the bold face (facemenu-set-bold).

M-o i
Apply the italic face (facemenu-set-italic).

M-o l
Apply the bold-italic face (facemenu-set-bold-italic).

M-o u
Apply the underline face (facemenu-set-underline).

M-o o face RET
Apply the face face (facemenu-set-face).

M-x facemenu-set-foreground
Prompt for a color (see Colors for Faces), and apply it as a foreground color.

M-x facemenu-set-background
Prompt for a color, and apply it as a background color.

These commands are also available via the Text Properties menu.

A self-inserting character normally inherits the face properties (and most other text properties) from the preceding character in the buffer. If you use one of the above commands to specify the face for the next self-inserting character, that character will not inherit the faces properties from the preceding character, but it will still inherit other text properties.

Enriched mode defines two additional faces: excerpt and fixed. These correspond to codes used in the text/enriched file format. The excerpt face is intended for quotations; by default, it appears the same as italic. The fixed face specifies fixed-width text; by default, it appears the same as bold.


**** Indentation in Enriched Text

In Enriched mode, you can specify different amounts of indentation for the right or left margin of a paragraph or a part of a paragraph. These margins also affect fill commands such as M-q (see Filling Text).

The Indentation submenu of Text Properties offers commands for specifying indentation:

Indent More
Indent the region by 4 columns (increase-left-margin). In Enriched mode, this command is also available on C-x TAB; if you supply a numeric argument, that says how many columns to add to the margin (a negative argument reduces the number of columns).

Indent Less
Remove 4 columns of indentation from the region.

Indent Right More
Make the text narrower by indenting 4 columns at the right margin.

Indent Right Less
Remove 4 columns of indentation from the right margin.

The variable standard-indent specifies how many columns these commands should add to or subtract from the indentation. The default value is 4. The default right margin for Enriched mode is controlled by the variable fill-column, as usual.

You can also type C-c [ (set-left-margin) and C-c ] (set-right-margin) to set the left and right margins. You can specify the margin width with a numeric argument; otherwise these commands prompt for a value via the minibuffer.

The fill prefix, if any, works in addition to the specified paragraph indentation: C-x . does not include the specified indentation’s whitespace in the new value for the fill prefix, and the fill commands look for the fill prefix after the indentation on each line. See The Fill Prefix.


**** Justification in Enriched Text

In Enriched mode, you can use the following commands to specify various justification styles for filling. These commands apply to the paragraph containing point, or, if the region is active, to all paragraphs overlapping the region.

M-j l
Align lines to the left margin (set-justification-left).

M-j r
Align lines to the right margin (set-justification-right).

M-j b
Align lines to both margins, inserting spaces in the middle of the line to achieve this (set-justification-full).

M-j c
M-S
Center lines between the margins (set-justification-center).

M-j u
Turn off filling entirely (set-justification-none). The fill commands do nothing on text with this setting. You can, however, still indent the left margin.

You can also specify justification styles using the Justification submenu in the Text Properties menu. The default justification style is specified by the per-buffer variable default-justification. Its value should be one of the symbols left, right, full, center, or none; their meanings correspond to the commands above.


**** Justification in Enriched Text

In Enriched mode, you can use the following commands to specify various justification styles for filling. These commands apply to the paragraph containing point, or, if the region is active, to all paragraphs overlapping the region.

M-j l
Align lines to the left margin (set-justification-left).

M-j r
Align lines to the right margin (set-justification-right).

M-j b
Align lines to both margins, inserting spaces in the middle of the line to achieve this (set-justification-full).

M-j c
M-S
Center lines between the margins (set-justification-center).

M-j u
Turn off filling entirely (set-justification-none). The fill commands do nothing on text with this setting. You can, however, still indent the left margin.

You can also specify justification styles using the Justification submenu in the Text Properties menu. The default justification style is specified by the per-buffer variable default-justification. Its value should be one of the symbols left, right, full, center, or none; their meanings correspond to the commands above.


*** Editing Text-based Tables

The table package provides commands to easily edit text-based tables. Here is an example of what such a table looks like:

+-----------------+--------------------------------+-----------------+
|     Command     |          Description           |   Key Binding   |
+-----------------+--------------------------------+-----------------+
|  forward-char   |Move point right N characters   |       C-f       |
|                 |(left if N is negative).        |                 |
|                 |                                |                 |
+-----------------+--------------------------------+-----------------+
|  backward-char  |Move point left N characters    |       C-b       |
|                 |(right if N is negative).       |                 |
|                 |                                |                 |
+-----------------+--------------------------------+-----------------+
When Emacs recognizes such a stretch of text as a table (see Table Recognition), editing the contents of each table cell will automatically resize the table, whenever the contents become too large to fit in the cell. You can use the commands defined in the following sections for navigating and editing the table layout.

Type M-x table-fixed-width-mode to toggle the automatic table resizing feature.

**** What is a Text-based Table?

A table consists of a rectangular text area which is divided into cells. Each cell must be at least one character wide and one character high, not counting its border lines. A cell can be subdivided into more cells, but they cannot overlap.

Cell border lines are drawn with three special characters, specified by the following variables:

table-cell-vertical-char
The character used for vertical lines. The default is ‘|’.

table-cell-horizontal-chars
The characters used for horizontal lines. The default is ‘"-="’.

table-cell-intersection-char
The character used for the intersection of horizontal and vertical lines. The default is ‘+’.

The following are examples of invalid tables:

   +-----+       +--+    +-++--+
   |     |       |  |    | ||  |
   |     |       |  |    | ||  |
   +--+  |    +--+--+    +-++--+
   |  |  |    |  |  |    +-++--+
   |  |  |    |  |  |    | ||  |
   +--+--+    +--+--+    +-++--+
      a          b          c
From left to right:

Overlapped cells or non-rectangular cells are not allowed.
The border must be rectangular.
Cells must have a minimum width/height of one character.


**** Creating a Table

To create a text-based table from scratch, type M-x table-insert. This command prompts for the number of table columns, the number of table rows, cell width and cell height. The cell width and cell height do not include the cell borders; each can be specified as a single integer (which means each cell is given the same width/height), or as a sequence of integers separated by spaces or commas (which specify the width/height of the individual table columns/rows, counting from left to right for table columns and from top to bottom for table rows). The specified table is then inserted at point.

The table inserted by M-x table-insert contains special text properties, which tell Emacs to treat it specially as a text-based table. If you save the buffer to a file and visit it again later, those properties are lost, and the table appears to Emacs as an ordinary piece of text. See the next section, for how to convert it back into a table.


**** Table Recognition

Existing text-based tables in a buffer, which lack the special text properties applied by M-x table-insert, are not treated specially as tables. To apply those text properties, type M-x table-recognize. This command scans the current buffer, recognizes valid table cells, and applies the relevant text properties. Conversely, type M-x table-unrecognize to unrecognize all tables in the current buffer, removing the special text properties and converting tables back to plain text.

You can also use the following commands to selectively recognize or unrecognize tables:

M-x table-recognize-region
Recognize tables within the current region.

M-x table-unrecognize-region
Unrecognize tables within the current region.

M-x table-recognize-table
Recognize the table at point and activate it.

M-x table-unrecognize-table
Deactivate the table at point.

M-x table-recognize-cell
Recognize the cell at point and activate it.

M-x table-unrecognize-cell
Deactivate the cell at point.

See Converting Between Plain Text and Tables, for another way to recognize a table.


**** Commands for Table Cells

The commands M-x table-forward-cell and M-x table-backward-cell move point from the current cell to an adjacent cell. The order is cyclic: when point is in the last cell of a table, M-x table-forward-cell moves to the first cell. Likewise, when point is on the first cell, M-x table-backward-cell moves to the last cell.

M-x table-span-cell prompts for a direction—right, left, above, or below—and merges the current cell with the adjacent cell in that direction. This command signals an error if the merge would result in an illegitimate cell layout.

M-x table-split-cell splits the current cell vertically or horizontally, prompting for the direction with the minibuffer. To split in a specific direction, use M-x table-split-cell-vertically and M-x table-split-cell-horizontally. When splitting vertically, the old cell contents are automatically split between the two new cells. When splitting horizontally, you are prompted for how to divide the cell contents, if the cell is non-empty; the options are ‘split’ (divide the contents at point), ‘left’ (put all the contents in the left cell), and ‘right’ (put all the contents in the right cell).

The following commands enlarge or shrink a cell. By default, they resize by one row or column; if a numeric argument is supplied, that specifies the number of rows or columns to resize by.

M-x table-heighten-cell
Enlarge the current cell vertically.

M-x table-shorten-cell
Shrink the current cell vertically.

M-x table-widen-cell
Enlarge the current cell horizontally.

M-x table-narrow-cell
Shrink the current cell horizontally.


**** Cell Justification

The command M-x table-justify imposes justification on one or more cells in a text-based table. Justification determines how the text in the cell is aligned, relative to the edges of the cell. Each cell in a table can be separately justified.

M-x table-justify first prompts for what to justify; the options are ‘cell’ (just the current cell), ‘column’ (all cells in the current table column) and ‘row’ (all cells in the current table row). The command then prompts for the justification style; the options are left, center, right, top, middle, bottom, or none (meaning no vertical justification).

Horizontal and vertical justification styles are specified independently, and both types can be in effect simultaneously; for instance, you can call M-x table-justify twice, once to specify right justification and once to specify bottom justification, to align the contents of a cell to the bottom right.

The justification style is stored in the buffer as a text property, and is lost when you kill the buffer or exit Emacs. However, the table recognition commands, such as M-x table-recognize (see Table Recognition), attempt to determine and re-apply each cell’s justification style, by examining its contents. To disable this feature, change the variable table-detect-cell-alignment to nil.


**** Table Rows and Columns

M-x table-insert-row inserts a row of cells before the current table row. The current row, together with point, is pushed down past the new row. To insert a row after the last row at the bottom of a table, invoke this command with point below the table, just below the bottom edge. You can insert more than one row at a time by using a numeric prefix argument.

Similarly, M-x table-insert-column inserts a column of cells to the left of the current table column. To insert a column to the right side of the rightmost column, invoke this command with point to the right of the rightmost column, outside the table. A numeric prefix argument specifies the number of columns to insert.

M-x table-delete-column deletes the column of cells at point. Similarly, M-x table-delete-row deletes the row of cells at point. A numeric prefix argument to either command specifies the number of columns or rows to delete.


**** Converting Between Plain Text and Tables

The command M-x table-capture captures plain text in a region and turns it into a table. Unlike M-x table-recognize (see Table Recognition), the original text does not need to have a table appearance; it only needs to have a logical table-like structure.

For example, suppose we have the following numbers, which are divided into three lines and separated horizontally by commas:

1, 2, 3, 4
5, 6, 7, 8
, 9, 10
Invoking M-x table-capture on that text produces this table:

+-----+-----+-----+-----+
|1    |2    |3    |4    |
+-----+-----+-----+-----+
|5    |6    |7    |8    |
+-----+-----+-----+-----+
|     |9    |10   |     |
+-----+-----+-----+-----+
M-x table-release does the opposite: it converts a table back to plain text, removing its cell borders.

One application of this pair of commands is to edit a text in layout. Look at the following three paragraphs:

table-capture is a powerful command.
Here are some things it can do:

Parse Cell Items   Using row and column delimiter regexps,
                   it parses the specified text area and
                   extracts cell items into a table.
Applying table-capture to a region containing the above text, with empty strings for the column and row delimiter regexps, creates a table with a single cell like the following one.

+----------------------------------------------------------+
|table-capture is a powerful command.                      |
|Here are some things it can do:                           |
|                                                          |
|Parse Cell Items   Using row and column delimiter regexps,|
|                   it parses the specified text area and  |
|                   extracts cell items into a table.      |
+----------------------------------------------------------+
We can then use the cell splitting commands (see Commands for Table Cells) to subdivide the table so that each paragraph occupies a cell:

+----------------------------------------------------------+
|table-capture is a powerful command.                      |
|Here are some things it can do:                           |
+-----------------+----------------------------------------+
|Parse Cell Items | Using row and column delimiter regexps,|
|                 | it parses the specified text area and  |
|                 | extracts cell items into a table.      |
+-----------------+----------------------------------------+
Each cell can now be edited independently without affecting the layout of other cells. When finished, we can invoke M-x table-release to convert the table back to plain text.


**** Table Miscellany

The command table-query-dimension reports the layout of the table and table cell at point. Here is an example of its output:

Cell: (21w, 6h), Table: (67w, 16h), Dim: (2c, 3r), Total Cells: 5
This indicates that the current cell is 21 characters wide and 6 lines high, the table is 67 characters wide and 16 lines high with 2 columns and 3 rows, and a total of 5 cells.

M-x table-insert-sequence traverses the cells of a table inserting a sequence of text strings into each cell as it goes. It asks for the base string of the sequence, and then produces the sequence by “incrementing” the base string, either numerically (if the base string ends in numerical characters) or in the ASCII order. In addition to the base string, the command prompts for the number of elements in the sequence, the increment, the cell interval, and the justification of the text in each cell.

M-x table-generate-source generates a table formatted for a specific markup language. It asks for a language (which must be one of html, latex, cals, wiki or mediawiki), a destination buffer in which to put the result, and a table caption, and then inserts the generated table into the specified buffer. The default destination buffer is table.lang, where lang is the language you specified.


*** Two-Column Editing

Two-column mode lets you conveniently edit two side-by-side columns of text. It uses two side-by-side windows, each showing its own buffer. There are three ways to enter two-column mode:

F2 2 or C-x 6 2 ¶
Enter two-column mode with the current buffer on the left, and on the right, a buffer whose name is based on the current buffer’s name (2C-two-columns). If the right-hand buffer doesn’t already exist, it starts out empty; the current buffer’s contents are not changed.

This command is appropriate when the current buffer is empty or contains just one column and you want to add another column.

F2 s or C-x 6 s ¶
Split the current buffer, which contains two-column text, into two buffers, and display them side by side (2C-split). The current buffer becomes the left-hand buffer, but the text in the right-hand column is moved into the right-hand buffer. The current column specifies the split point. Splitting starts with the current line and continues to the end of the buffer.

This command is appropriate when you have a buffer that already contains two-column text, and you wish to separate the columns temporarily.

F2 b buffer RET ¶
C-x 6 b buffer RET
Enter two-column mode using the current buffer as the left-hand buffer, and using buffer buffer as the right-hand buffer (2C-associate-buffer).

F2 s or C-x 6 s looks for a column separator, which is a string that appears on each line between the two columns. You can specify the width of the separator with a numeric argument to F2 s; that many characters, before point, constitute the separator string. By default, the width is 1, so the column separator is the character before point.

When a line has the separator at the proper place, F2 s puts the text after the separator into the right-hand buffer, and deletes the separator. Lines that don’t have the column separator at the proper place remain unsplit; they stay in the left-hand buffer, and the right-hand buffer gets an empty line to correspond. (This is the way to write a line that spans both columns while in two-column mode: write it in the left-hand buffer, and put an empty line in the right-hand buffer.)

The command F2 RET or C-x 6 RET (2C-newline) inserts a newline in each of the two buffers at corresponding positions. This is the easiest way to add a new line to the two-column text while editing it in split buffers.

When you have edited both buffers as you wish, merge them with F2 1 or C-x 6 1 (2C-merge). This copies the text from the right-hand buffer as a second column in the other buffer. To go back to two-column editing, use F2 s.

Use F2 d or C-x 6 d to dissociate the two buffers, leaving each as it stands (2C-dissociate). If the other buffer, the one not current when you type F2 d, is empty, F2 d kills it.


** File Handling ( Look at shadowing files( its inside saving files !!! )) 

The operating system stores data permanently in named files, so most of the text you edit with Emacs comes from a file and is ultimately stored in a file.

To edit a file, you must tell Emacs to read the file and prepare a buffer containing a copy of the file’s text. This is called visiting the file. Editing commands apply directly to text in the buffer; that is, to the copy inside Emacs. Your changes appear in the file itself only when you save the buffer back into the file.

In addition to visiting and saving files, Emacs can delete, copy, rename, and append to files, keep multiple versions of them, and operate on file directories.


*** File Names

Many Emacs commands that operate on a file require you to specify the file name, using the minibuffer (see Minibuffers for File Names).

While in the minibuffer, you can use the usual completion and history commands (see The Minibuffer). Note that file name completion ignores file names whose extensions appear in the variable completion-ignored-extensions (see Completion Options). Note also that most commands use permissive completion with confirmation for reading file names: you are allowed to submit a nonexistent file name, but if you type RET immediately after completing up to a nonexistent file name, Emacs prints ‘[Confirm]’ and you must type a second RET to confirm. See Completion Exit, for details.

Minibuffer history commands offer some special features for reading file names, see Minibuffer History.

Each buffer has a default directory, stored in the buffer-local variable default-directory. Whenever Emacs reads a file name using the minibuffer, it usually inserts the default directory into the minibuffer as the initial contents. You can inhibit this insertion by changing the variable insert-default-directory to nil (see Minibuffers for File Names). Regardless, Emacs always assumes that any relative file name is relative to the default directory, e.g., entering a file name without a directory specifies a file in the default directory.

When you visit a file, Emacs sets default-directory in the visiting buffer to the directory of its file. When you create a new buffer that is not visiting a file, via a command like C-x b, its default directory is usually copied from the buffer that was current at the time (see Creating and Selecting Buffers). You can use the command M-x pwd to see the value of default-directory in the current buffer. The command M-x cd prompts for a directory’s name, and sets the buffer’s default-directory to that directory (doing this does not change the buffer’s file name, if any).

As an example, when you visit the file /u/rms/gnu/gnu.tasks, the default directory is set to /u/rms/gnu/. If you invoke a command that reads a file name, entering just ‘foo’ in the minibuffer, with a directory omitted, specifies the file /u/rms/gnu/foo; entering ‘../.login’ specifies /u/rms/.login; and entering ‘new/foo’ specifies /u/rms/gnu/new/foo.

When typing a file name into the minibuffer, you can make use of a couple of shortcuts: a double slash ignores everything before the second slash in the pair, and ‘~/’ is your home directory. See Minibuffers for File Names.

The character ‘$’ is used to substitute an environment variable into a file name. The name of the environment variable consists of all the alphanumeric characters after the ‘$’; alternatively, it can be enclosed in braces after the ‘$’. For example, if you have used the shell command export FOO=rms/hacks to set up an environment variable named FOO, then both /u/$FOO/test.c and /u/${FOO}/test.c are abbreviations for /u/rms/hacks/test.c. If the environment variable is not defined, no substitution occurs, so that the character ‘$’ stands for itself. Note that environment variables set outside Emacs affect Emacs only if they are applied before Emacs is started.

To access a file with ‘$’ in its name, if the ‘$’ causes expansion, type ‘$$’. This pair is converted to a single ‘$’ at the same time that variable substitution is performed for a single ‘$’. Alternatively, quote the whole file name with ‘/:’ (see Quoted File Names). File names which begin with a literal ‘~’ should also be quoted with ‘/:’.

You can include non-ASCII characters in file names. See Coding Systems for File Names.


*** Visiting Files

C-x C-f
Visit a file (find-file).

C-x C-r
Visit a file for viewing, without allowing changes to it (find-file-read-only).

C-x C-v
Visit a different file instead of the one visited last (find-alternate-file).

C-x 4 f
Visit a file, in another window (find-file-other-window). Don’t alter what is displayed in the selected window.

C-x 5 f
Visit a file, in a new frame (find-file-other-frame). Don’t alter what is displayed in the selected frame.

M-x find-file-literally
Visit a file with no conversion of the contents.

Visiting a file means reading its contents into an Emacs buffer so you can edit them. Emacs makes a new buffer for each file that you visit.

To visit a file, type C-x C-f (find-file) and use the minibuffer to enter the name of the desired file. While in the minibuffer, you can abort the command by typing C-g. See File Names, for details about entering file names into minibuffers.

If the specified file exists but the system does not allow you to read it, an error message is displayed in the echo area (on GNU and Unix systems you might be able to visit such a file using the ‘su’ or ‘sudo’ methods; see Remote Files). Otherwise, you can tell that C-x C-f has completed successfully by the appearance of new text on the screen, and by the buffer name shown in the mode line (see The Mode Line). Emacs normally constructs the buffer name from the file name, omitting the directory name. For example, a file named /usr/rms/emacs.tex is visited in a buffer named ‘emacs.tex’. If there is already a buffer with that name, Emacs constructs a unique name; the normal method is to add a suffix based on the directory name (e.g., ‘<rms>’, ‘<tmp>’, and so on), but you can select other methods. See Making Buffer Names Unique.

To create a new file, just visit it using the same command, C-x C-f. Emacs displays ‘(New file)’ in the echo area, but in other respects behaves as if you had visited an existing empty file.

After visiting a file, the changes you make with editing commands are made in the Emacs buffer. They do not take effect in the visited file, until you save the buffer (see Saving Files). If a buffer contains changes that have not been saved, we say the buffer is modified. This implies that some changes will be lost if the buffer is not saved. The mode line displays two stars near the left margin to indicate that the buffer is modified.

If you visit a file that is already in Emacs, C-x C-f switches to the existing buffer instead of making another copy. Before doing so, it checks whether the file has changed since you last visited or saved it. If the file has changed, Emacs offers to reread it.

If you try to visit a file larger than large-file-warning-threshold (the default is 10000000, which is about 10 megabytes), Emacs asks you for confirmation first. You can answer y to proceed with visiting the file or l to visit the file literally (see below). Visiting large files literally speeds up navigation and editing of such files, because various potentially-expensive features are turned off. Note, however, that Emacs cannot visit files that are larger than the maximum Emacs buffer size, which is limited by the amount of memory Emacs can allocate and by the integers that Emacs can represent (see Using Multiple Buffers). If you try, Emacs displays an error message saying that the maximum buffer size has been exceeded.

If you try to visit a file whose major mode (see Major Modes) uses the tree-sitter parsing library, Emacs will display a warning if the file’s size in bytes is larger than the value of the variable treesit-max-buffer-size. The default value is 40 megabytes for 64-bit Emacs and 15 megabytes for 32-bit Emacs. This avoids the danger of having Emacs run out of memory by preventing the activation of major modes based on tree-sitter in such large buffers, because a typical tree-sitter parser needs about 10 times as much memory as the text it parses.

If the file name you specify contains shell-style wildcard characters, Emacs visits all the files that match it. (On case-insensitive filesystems, Emacs matches the wildcards disregarding the letter case.) Wildcards include ‘?’, ‘*’, and ‘[…]’ sequences. To enter the wild card ‘?’ in a file name in the minibuffer, you need to type C-q ?. See Quoted File Names, for information on how to visit a file whose name actually contains wildcard characters. You can disable the wildcard feature by customizing find-file-wildcards.

If you’re asking to visit a file that’s already visited in a buffer, but the file has changed externally, Emacs normally asks you whether you want to re-read the file from disk. But if you set query-about-changed-file to nil, Emacs won’t query you, but will instead just display the buffer’s contents before the changes, and show an echo-area message telling you how to revert the buffer from the file.

If you visit the wrong file unintentionally by typing its name incorrectly, type C-x C-v (find-alternate-file) to visit the file you really wanted. C-x C-v is similar to C-x C-f, but it kills the current buffer (after first offering to save it if it is modified). When C-x C-v reads the file name to visit, it inserts the entire default file name in the buffer, with point just after the directory part; this is convenient if you made a slight error in typing the name.

If you visit a file that is actually a directory, Emacs invokes Dired, the Emacs directory browser. See Dired, the Directory Editor. You can disable this behavior by setting the variable find-file-run-dired to nil; in that case, it is an error to try to visit a directory.

Files which are actually collections of other files, or file archives, are visited in special modes which invoke a Dired-like environment to allow operations on archive members. See File Archives, for more about these features.

If you visit a file that the operating system won’t let you modify, or that is marked read-only, Emacs makes the buffer read-only too, so that you won’t go ahead and make changes that you’ll have trouble saving afterward. You can make the buffer writable with C-x C-q (read-only-mode). See Miscellaneous Buffer Operations.

If you want to visit a file as read-only in order to protect yourself from entering changes accidentally, visit it with the command C-x C-r (find-file-read-only) instead of C-x C-f.

C-x 4 f (find-file-other-window) is like C-x C-f except that the buffer containing the specified file is selected in another window. The window that was selected before C-x 4 f continues to show the same buffer it was already showing. If this command is used when only one window is being displayed, that window is split in two, with one window showing the same buffer as before, and the other one showing the newly requested file. See Multiple Windows.

C-x 5 f (find-file-other-frame) is similar, but opens a new frame, or selects any existing frame showing the specified file. See Frames and Graphical Displays.

On graphical displays, there are two additional methods for visiting files. Firstly, when Emacs is built with a suitable GUI toolkit, commands invoked with the mouse (by clicking on the menu bar or tool bar) use the toolkit’s standard file selection dialog instead of prompting for the file name in the minibuffer. On GNU/Linux and Unix platforms, Emacs does this when built with GTK+, LessTif, and Motif toolkits; on MS-Windows and Mac, the GUI version does that by default. For information on how to customize this, see Using Dialog Boxes.

Secondly, Emacs supports drag and drop: dropping a file into an ordinary Emacs window visits the file using that window. As an exception, dropping a file into a window displaying a Dired buffer moves or copies the file into the displayed directory. For details, see Drag and Drop, and Other Dired Features.

On text-mode terminals and on graphical displays when Emacs was built without a GUI toolkit, you can visit files via the menu-bar ‘File’ menu, which has the ‘Visit New File’ and the ‘Open File’ items.

Each time you visit a file, Emacs automatically scans its contents to detect what character encoding and end-of-line convention it uses, and converts these to Emacs’s internal encoding and end-of-line convention within the buffer. When you save the buffer, Emacs performs the inverse conversion, writing the file to disk with its original encoding and end-of-line convention. See Coding Systems.

If you wish to edit a file as a sequence of ASCII characters with no special encoding or conversion, use the M-x find-file-literally command. This visits a file, like C-x C-f, but does not do format conversion (see Format Conversion in the Emacs Lisp Reference Manual), character code conversion (see Coding Systems), or automatic uncompression (see Accessing Compressed Files), and does not add a final newline because of require-final-newline (see Customizing Saving of Files). If you have already visited the same file in the usual (non-literal) manner, this command asks you whether to visit it literally instead.

Files are sometimes (loosely) tied to other files, and you could call these files sibling files. For instance, when editing C files, if you have a file called ‘"foo.c"’, you often also have a file called ‘"foo.h"’, and that could be its sibling file. Or you may have different versions of a file, for instance ‘"src/emacs/emacs-27/lisp/allout.el"’ and ‘"src/emacs/emacs-28/lisp/allout.el"’ might be considered siblings. Emacs provides the find-sibling-file command to jump between sibling files, but it’s impossible to guess at which files a user might want to be considered siblings, so Emacs lets you configure this freely by altering the find-sibling-rules user option. This is a list of match/expansion elements.

For instance, to do the ‘".c"’ to ‘".h"’ mapping, you could say:

(setq find-sibling-rules
'(("\\([^/]+\\)\\.c\\'" "\\1.h")))
      
(ff-find-related-file offers similar functionality especially geared towards C files, see Other Commands for C Mode.)

Or, if you want to consider all files under ‘"src/emacs/DIR/file-name"’ to be siblings of other dirs, you could say:

(setq find-sibling-rules
'(("src/emacs/[^/]+/\\(.*\\)\\'" "src/emacs/.*/\\1")))
      
As you can see, this is a list of (MATCH EXPANSION...) elements. The match is a regular expression that matches the visited file name, and each expansion may refer to match groups by using ‘\\1’ and so on. The resulting expansion string is then applied to the file system to see if any files match this expansion (interpreted as a regexp).

Two special hook variables allow extensions to modify the operation of visiting files. Visiting a file that does not exist runs the functions in find-file-not-found-functions; this variable holds a list of functions, which are called one by one (with no arguments) until one of them returns non-nil. This is not a normal hook, and the name ends in ‘-functions’ rather than ‘-hook’ to indicate that fact.

Successful visiting of any file, whether existing or not, calls the functions in find-file-hook, with no arguments. This variable is a normal hook. In the case of a nonexistent file, the find-file-not-found-functions are run first. See Hooks.

There are several ways to specify automatically the major mode for editing the file (see Choosing File Modes), and to specify local variables defined for that file (see Local Variables in Files).


*** Saving Files ( Look at shadowing files !!! ) 

Saving a buffer in Emacs means writing its contents back into the file that was visited in the buffer.

**** Commands for Saving Files

These are the commands that relate to saving and writing files.

C-x C-s
Save the current buffer to its file (save-buffer).

C-x s
Save any or all buffers to their files (save-some-buffers).

M-~
Forget that the current buffer has been changed (not-modified). With prefix argument (C-u), mark the current buffer as changed.

C-x C-w
Save the current buffer with a specified file name (write-file).

M-x set-visited-file-name
Change the file name under which the current buffer will be saved.

M-x rename-visited-file
The same as M-x set-visited-file-name, but also rename the file the buffer is visiting (if any).

When you wish to save the file and make your changes permanent, type C-x C-s (save-buffer). After saving is finished, C-x C-s displays a message like this:

Wrote /u/rms/gnu/gnu.tasks
If the current buffer is not modified (no changes have been made in it since the buffer was created or last saved), saving is not really done, because it would have no effect. Instead, C-x C-s displays a message like this in the echo area:

(No changes need to be saved)
With a prefix argument, C-u C-x C-s, Emacs also marks the buffer to be backed up when the next save is done. See Backup Files.

The command C-x s (save-some-buffers) offers to save any or all modified buffers. It asks you what to do with each buffer. The possible responses are analogous to those of query-replace:

y
SPC
Save this buffer and ask about the rest of the buffers.

n
DEL
Don’t save this buffer, but ask about the rest of the buffers.

!
Save this buffer and all the rest with no more questions.

q
RET
Terminate save-some-buffers without any more saving.

.
Save this buffer, then exit save-some-buffers without even asking about other buffers.

C-r
View the buffer that you are currently being asked about. When you exit View mode, you get back to save-some-buffers, which asks the question again.

C-f
Exit save-some-buffers and visit the buffer that you are currently being asked about.

d
Diff the buffer against its corresponding file, so you can see what changes you would be saving. This calls the command diff-buffer-with-file (see Comparing Files).

C-h
Display a help message about these options.

You can customize the value of save-some-buffers-default-predicate to control which buffers Emacs will ask about.

C-x C-c, the key sequence to exit Emacs, invokes save-some-buffers and therefore asks the same questions.

If you have changed a buffer but do not wish to save the changes, you should take some action to prevent it. Otherwise, each time you use C-x s or C-x C-c, you are liable to save this buffer by mistake. One thing you can do is type M-~ (not-modified), which clears out the indication that the buffer is modified. If you do this, none of the save commands will believe that the buffer needs to be saved. (‘~’ is often used as a mathematical symbol for “not”; thus M-~ is “not”, metafied.) Alternatively, you can cancel all the changes made since the file was visited or saved, by reading the text from the file again. This is called reverting. See Reverting a Buffer. (You could also undo all the changes by repeating the undo command C-x u until you have undone all the changes; but reverting is easier.)

M-x set-visited-file-name alters the name of the file that the current buffer is visiting. It reads the new file name using the minibuffer. Then it marks the buffer as visiting that file name, and changes the buffer name correspondingly. set-visited-file-name does not save the buffer in the newly visited file; it just alters the records inside Emacs in case you do save later. It also marks the buffer as modified so that C-x C-s in that buffer will save.

If you wish to mark the buffer as visiting a different file and save it right away, use C-x C-w (write-file). This is equivalent to set-visited-file-name followed by C-x C-s, except that C-x C-w asks for confirmation if the file exists. C-x C-s used on a buffer that is not visiting a file has the same effect as C-x C-w; that is, it reads a file name, marks the buffer as visiting that file, and saves it there. The default file name in a buffer that is not visiting a file is made by combining the buffer name with the buffer’s default directory (see File Names).

If the new file name implies a major mode, then C-x C-w switches to that major mode, in most cases. The command set-visited-file-name also does this. See Choosing File Modes.

If you wish to save the current buffer to a different file without visiting that file, use mark-whole-buffer (C-x h), then M-x write-region (see Miscellaneous File Operations).

If Emacs is about to save a file and sees that the date of the latest version on disk does not match what Emacs last read or wrote, Emacs notifies you of this fact, because it probably indicates a problem caused by simultaneous editing and requires your immediate attention. See Simultaneous Editing.


**** Backup Files

On most operating systems, rewriting a file automatically destroys all record of what the file used to contain. Thus, saving a file from Emacs throws away the old contents of the file—or it would, except that Emacs carefully copies the old contents to another file, called the backup file, before actually saving.

Emacs makes a backup for a file only the first time the file is saved from a buffer. No matter how many times you subsequently save the file, its backup remains unchanged. However, if you kill the buffer and then visit the file again, a new backup file will be made.

For most files, the variable make-backup-files determines whether to make backup files. On most operating systems, its default value is t, so that Emacs does write backup files.

For files managed by a version control system (see Version Control), the variable vc-make-backup-files determines whether to make backup files. By default it is nil, since backup files are redundant when you store all the previous versions in a version control system. See General Options.

At your option, Emacs can keep either a single backup for each file, or make a series of numbered backup files for each file that you edit. See Single or Numbered Backups.

The default value of the backup-enable-predicate variable prevents backup files being written for files in the directories used for temporary files, specified by temporary-file-directory or small-temporary-file-directory.

You can explicitly tell Emacs to make another backup file from a buffer, even though that buffer has been saved before. If you save the buffer with C-u C-x C-s, the version thus saved will be made into a backup file if you save the buffer again. C-u C-u C-x C-s saves the buffer, but first makes the previous file contents into a new backup file. C-u C-u C-u C-x C-s does both things: it makes a backup from the previous contents, and arranges to make another from the newly saved contents if you save again.

You can customize the variable backup-directory-alist to specify that files matching certain patterns should be backed up in specific directories. A typical use is to add an element ("." . dir) to make all backups in the directory with absolute name dir. Emacs modifies the backup file names to avoid clashes between files with the same names originating in different directories. Alternatively, adding, ("." . ".~") would make backups in the invisible subdirectory .~ of the original file’s directory. Emacs creates the directory, if necessary, to make the backup.


***** Single or Numbered Backups

When Emacs makes a backup file, its name is normally constructed by appending ‘~’ to the file name being edited; thus, the backup file for eval.c would be eval.c~.

If access control stops Emacs from writing backup files under the usual names, it writes the backup file as ~/.emacs.d/%backup%~. Only one such file can exist, so only the most recently made such backup is available.

Emacs can also make numbered backup files. Numbered backup file names contain ‘.~’, the number, and another ‘~’ after the original file name. Thus, the backup files of eval.c would be called eval.c.~1~, eval.c.~2~, and so on, all the way through names like eval.c.~259~ and beyond.

The variable version-control determines whether to make single backup files or multiple numbered backup files. Its possible values are:

nil
Make numbered backups for files that have numbered backups already. Otherwise, make single backups. This is the default.

t
Make numbered backups.

never
Never make numbered backups; always make single backups.

The usual way to set this variable is globally, through your init file or the customization buffer. However, you can set version-control locally in an individual buffer to control the making of backups for that buffer’s file (see Local Variables). Some modes, such as Rmail mode, set this variable. You can also have Emacs set version-control locally whenever you visit a given file (see Local Variables in Files).

If you set the environment variable VERSION_CONTROL, to tell various GNU utilities what to do with backup files, Emacs also obeys the environment variable by setting the Lisp variable version-control accordingly at startup. If the environment variable’s value is ‘t’ or ‘numbered’, then version-control becomes t; if the value is ‘nil’ or ‘existing’, then version-control becomes nil; if it is ‘never’ or ‘simple’, then version-control becomes never.

If you set the variable make-backup-file-name-function to a suitable Lisp function, you can override the usual way Emacs constructs backup file names.


***** Automatic Deletion of Backups

To prevent excessive consumption of disk space, Emacs can delete numbered backup versions automatically. Generally Emacs keeps the first few backups and the latest few backups, deleting any in between. This happens every time a new backup is made.

The two variables kept-old-versions and kept-new-versions control this deletion. Their values are, respectively, the number of oldest (lowest-numbered) backups to keep and the number of newest (highest-numbered) ones to keep, each time a new backup is made. The backups in the middle (excluding those oldest and newest) are the excess middle versions—those backups are deleted. These variables’ values are used when it is time to delete excess versions, just after a new backup version is made; the newly made backup is included in the count in kept-new-versions. By default, both variables are 2.

If delete-old-versions is t, Emacs deletes the excess backup files silently. If it is nil, the default, Emacs asks you whether it should delete the excess backup versions. If it has any other value, then Emacs never automatically deletes backups.

Dired’s . (Period) command can also be used to delete old versions. See Flagging Many Files at Once.


***** Copying vs. Renaming

Backup files can be made by copying the old file or by renaming it. This makes a difference when the old file has multiple names (hard links). If the old file is renamed into the backup file, then the alternate names become names for the backup file. If the old file is copied instead, then the alternate names remain names for the file that you are editing, and the contents accessed by those names will be the new contents.

The method of making a backup file may also affect the file’s owner and group. If copying is used, these do not change. If renaming is used, you become the file’s owner, and the file’s group becomes the default (different operating systems have different defaults for the group).

The choice of renaming or copying is made as follows:

If the variable backup-by-copying is non-nil (the default is nil), use copying.
Otherwise, if the variable backup-by-copying-when-linked is non-nil (the default is nil), and the file has multiple names, use copying.
Otherwise, if the variable backup-by-copying-when-mismatch is non-nil (the default is t), and renaming would change the file’s owner or group, use copying.
If you change backup-by-copying-when-mismatch to nil, Emacs checks the numeric user-id of the file’s owner and the numeric group-id of the file’s group. If either is no greater than backup-by-copying-when-privileged-mismatch, then it behaves as though backup-by-copying-when-mismatch is non-nil anyway.

Otherwise, renaming is the default choice.
When a file is managed with a version control system (see Version Control), Emacs does not normally make backups in the usual way for that file. But committing (a.k.a. checking in, see Concepts of Version Control) new versions of files is similar in some ways to making backups. One unfortunate similarity is that these operations typically break hard links, disconnecting the file name you visited from any alternate names for the same file. This has nothing to do with Emacs—the version control system does it.


**** Customizing Saving of Files

If the value of the variable require-final-newline is t, saving or writing a file silently puts a newline at the end if there isn’t already one there. If the value is visit, Emacs adds a newline at the end of any file that doesn’t have one, just after it visits the file. (This marks the buffer as modified, and you can undo it.) If the value is visit-save, Emacs adds such newlines both on visiting and on saving. If the value is nil, Emacs leaves the end of the file unchanged; any other non-nil value means Emacs asks you whether to add a newline. The default is nil.

Some major modes are designed for specific kinds of files that are always supposed to end in newlines. Such major modes set the variable require-final-newline to the value of mode-require-final-newline, which defaults to t. By setting the latter variable, you can control how these modes handle final newlines.

If this option is non-nil and you’re visiting a file via a symbolic link, Emacs will break the symbolic link upon saving the buffer, and will write the buffer to a file with the same name as the symbolic link, if the value of file-precious-flag is non-nil (see file-precious-flag in The Emacs Lisp Reference Manual). If you want Emacs to save the buffer to the file the symbolic link points to (thereby preserving the link) in these cases, customize the variable file-preserve-symlinks-on-save to t.

Normally, when a program writes a file, the operating system briefly caches the file’s data in main memory before committing the data to disk. This can greatly improve performance; for example, when running on laptops, it can avoid a disk spin-up each time a file is written. However, it risks data loss if the operating system crashes before committing the cache to disk.

To lessen this risk, Emacs can invoke the fsync system call after saving a file. Using fsync does not eliminate the risk of data loss, partly because many systems do not implement fsync properly, and partly because Emacs’s file-saving procedure typically relies also on directory updates that might not survive a crash even if fsync works properly.

The write-region-inhibit-fsync variable controls whether Emacs invokes fsync after saving a file. The variable’s default value is nil when Emacs is interactive, and t when Emacs runs in batch mode (see Batch Mode).

Emacs never uses fsync when writing auto-save files, as these files might lose data anyway.


**** Protection against Simultaneous Editing

Simultaneous editing occurs when two users visit the same file, both make changes, and then both save them. If nobody is informed that this is happening, whichever user saves first would later find that their changes were lost.

On some systems, Emacs notices immediately when the second user starts to change the file, and issues an immediate warning. On all systems, Emacs checks when you save the file, and warns if you are about to overwrite another user’s changes. You can prevent loss of the other user’s work by taking the proper corrective action instead of saving the file.

When you make the first modification in an Emacs buffer that is visiting a file, Emacs records that the file is locked by you. (It does this by creating a specially-named symbolic link7 with special contents in the same directory. See (elisp)File Locks, for more details.) Emacs removes the lock when you save the changes. The idea is that the file is locked whenever an Emacs buffer visiting it has unsaved changes.

You can prevent the creation of lock files by setting the variable create-lockfiles to nil. Caution: by doing so you will lose the benefits that this feature provides. You can also control where lock files are written by using the lock-file-name-transforms variable.

If you begin to modify the buffer while the visited file is locked by someone else, this constitutes a collision. When Emacs detects a collision, it asks you what to do, by calling the Lisp function ask-user-about-lock. You can redefine this function for the sake of customization. The standard definition of this function asks you a question and accepts three possible answers:

s
Steal the lock. Whoever was already changing the file loses the lock, and you gain the lock.

p
Proceed. Go ahead and edit the file despite its being locked by someone else.

q
Quit. This causes an error (file-locked), and the buffer contents remain unchanged—the modification you were trying to make does not actually take place.

If Emacs or the operating system crashes, this may leave behind lock files which are stale, so you may occasionally get warnings about spurious collisions. When you determine that the collision is spurious, just use p to tell Emacs to go ahead anyway.

Note that locking works on the basis of a file name; if a file has multiple names, Emacs does not prevent two users from editing it simultaneously under different names.

A lock file cannot be written in some circumstances, e.g., if Emacs lacks the system permissions or cannot create lock files for some other reason. In these cases, Emacs can still detect the collision when you try to save a file, by checking the file’s last-modification date. If the file has changed since the last time Emacs visited or saved it, that implies that changes have been made in some other way, and will be lost if Emacs proceeds with saving. Emacs then displays a warning message and asks for confirmation before saving; answer yes to save, and no or C-g cancel the save.

If you are notified that simultaneous editing has already taken place, one way to compare the buffer to its file is the M-x diff-buffer-with-file command. See Comparing Files.

You can prevent the creation of remote lock files by setting the variable remote-file-name-inhibit-locks to t.

The minor mode lock-file-mode, called interactively, toggles the local value of create-lockfiles in the current buffer.

Footnotes
(7)
If your file system does not support symbolic links, a regular file is used.


**** Shadowing Files ✓✓✓✓✓✓ 

You can arrange to keep identical shadow copies of certain files in more than one place—possibly on different machines. To do this, first you must set up a shadow file group, which is a set of identically-named files shared between a list of sites. The file group is permanent and applies to further Emacs sessions as well as the current one. Once the group is set up, every time you exit Emacs, it will copy the file you edited to the other files in its group. You can also do the copying without exiting Emacs, by typing M-x shadow-copy-files.

A shadow cluster is a group of hosts that share directories, so that copying to or from one of them is sufficient to update the file on all of them. Each shadow cluster has a name, and specifies the network address of a primary host (the one we copy files to), and a regular expression that matches the host names of all the other hosts in the cluster. You can define a shadow cluster with M-x shadow-define-cluster.

M-x shadow-initialize
Set up file shadowing.

M-x shadow-define-literal-group
Declare a single file to be shared between sites.

M-x shadow-define-regexp-group
Make all files that match each of a group of files be shared between hosts.

M-x shadow-define-cluster RET name RET
Define a shadow file cluster name.

M-x shadow-copy-files
Copy all pending shadow files.

M-x shadow-cancel
Cancel the instruction to shadow some files.

To set up a shadow file group, use M-x shadow-define-literal-group or M-x shadow-define-regexp-group. See their documentation strings for further information.

Before copying a file to its shadows, Emacs asks for confirmation. You can answer “no” to bypass copying of this file, this time. If you want to cancel the shadowing permanently for a certain file, use M-x shadow-cancel to eliminate or change the shadow file group.

File Shadowing is not available on MS Windows.


**** Updating Time Stamps Automatically

You can arrange to put a time stamp in a file, so that it is updated automatically each time you edit and save the file. The time stamp must be in the first eight lines of the file, and you should insert it like this:

Time-stamp: <>
or like this:

Time-stamp: " "
Then add the function time-stamp to the hook before-save-hook (see Hooks). When you save the file, this function then automatically updates the time stamp with the current date and time. You can also use the command M-x time-stamp to update the time stamp manually. By default the time stamp is formatted according to your locale setting (see Environment Variables) and time zone (see Time of Day in The Emacs Lisp Reference Manual). For customizations, see the Custom group time-stamp.


*** Reverting a Buffer

If you have made extensive changes to a file-visiting buffer and then change your mind, you can revert the changes and go back to the saved version of the file. To do this, type C-x x g. Since reverting unintentionally could lose a lot of work, Emacs asks for confirmation first if the buffer is modified.

The revert-buffer command tries to position point in such a way that, if the file was edited only slightly, you will be at approximately the same part of the text as before. But if you have made major changes, point may end up in a totally different location.

Reverting marks the buffer as not modified. However, it adds the reverted changes as a single modification to the buffer’s undo history (see Undo). Thus, after reverting, you can type C-/ or its aliases to bring the reverted changes back, if you happen to change your mind.

To revert a buffer more conservatively, you can use the command revert-buffer-with-fine-grain. This command acts like revert-buffer, but it tries to be as non-destructive as possible, making an effort to preserve all markers, properties and overlays in the buffer. Since reverting this way can be very slow when you have made a large number of changes, you can modify the variable revert-buffer-with-fine-grain-max-seconds to specify a maximum amount of seconds that replacing the buffer contents this way should take. Note that it is not ensured that the whole execution of revert-buffer-with-fine-grain won’t take longer than this.

Some kinds of buffers that are not associated with files, such as Dired buffers, can also be reverted. For them, reverting means recalculating their contents. Buffers created explicitly with C-x b cannot be reverted; revert-buffer reports an error if you try.

When you edit a file that changes automatically and frequently—for example, a log of output from a process that continues to run—it may be useful for Emacs to revert the file without querying you. To request this behavior, set the variable revert-without-query to a list of regular expressions. When a file name matches one of these regular expressions, find-file and revert-buffer will revert it automatically if it has changed—provided the buffer itself is not modified. (If you have edited the text, it would be wrong to discard your changes.)

The C-x x g keystroke is bound to the revert-buffer-quick command. This is like the revert-buffer command, but prompts less. Unlike revert-buffer, it will not prompt if the current buffer visits a file, and the buffer is not modified. It also respects the revert-buffer-quick-short-answers user option. If this option is non-nil, use a shorter y/n query instead of a longer yes/no query.

You can also tell Emacs to revert buffers automatically when their visited files change on disk; see Auto Revert: Keeping buffers automatically up-to-date.


*** Auto Revert: Keeping buffers automatically up-to-date

A buffer can get out of sync with respect to its visited file on disk if that file is changed by another program. To keep it up to date, you can enable Auto Revert mode by typing M-x auto-revert-mode. This automatically reverts the buffer when its visited file changes on disk. To do the same for all file buffers, type M-x global-auto-revert-mode to enable Global Auto Revert mode.

Auto Revert will not revert a buffer if it has unsaved changes, or if its file on disk is deleted or renamed.

One use of Auto Revert mode is to “tail” a file such as a system log, so that changes made to that file by other programs are continuously displayed. To do this, just move the point to the end of the buffer, and it will stay there as the file contents change. However, if you are sure that the file will only change by growing at the end, use Auto Revert Tail mode instead (auto-revert-tail-mode). It is more efficient for this. Auto Revert Tail mode also works for remote files.

When a buffer is auto-reverted, a message is generated. This can be suppressed by setting auto-revert-verbose to nil.

The Auto Revert modes do not check or revert remote files, because that is usually too slow. This behavior can be changed by setting the variable auto-revert-remote-files to non-nil.

By default, Auto Revert mode works using file notifications, whereby changes in the filesystem are reported to Emacs by the OS. You can disable use of file notifications by customizing the variable auto-revert-use-notify to a nil value, then Emacs will check for file changes by polling every five seconds. You can change the polling interval through the variable auto-revert-interval.

Not all systems support file notifications; where they are not supported, auto-revert-use-notify will be nil by default.

By default, Auto Revert mode will poll files for changes periodically even when file notifications are used. Polling is unnecessary in many cases, and turning it off may save power by relying on notifications only. To do so, set the variable auto-revert-avoid-polling to non-nil. However, notification is ineffective on certain file systems; mainly network file system on Unix-like machines, where files can be altered from other machines. For such file systems, polling may be necessary. To force polling when auto-revert-avoid-polling is non-nil, set auto-revert-notify-exclude-dir-regexp to match files that should be excluded from using notification.

In Dired buffers (see Dired, the Directory Editor), Auto Revert mode refreshes the buffer when a file is created or deleted in the buffer’s directory.

See Undoing Version Control Actions, for commands to revert to earlier versions of files under version control. See Version Control and the Mode Line, for Auto Revert peculiarities when visiting files under version control.


**** Auto Reverting Non-File Buffers

Global Auto Revert Mode normally only reverts file buffers. There are two ways to auto-revert certain non-file buffers: by enabling Auto Revert Mode in those buffers (using M-x auto-revert-mode); and by setting global-auto-revert-non-file-buffers to a non-nil value. The latter enables Auto Reverting for all types of buffers for which it is implemented (listed in the menu below).

Like file buffers, non-file buffers should normally not revert while you are working on them, or while they contain information that might get lost after reverting. Therefore, they do not revert if they are modified. This can get tricky, because deciding when a non-file buffer should be marked modified is usually more difficult than for file buffers.

Another tricky detail is that, for efficiency reasons, Auto Revert often does not try to detect all possible changes in the buffer, only changes that are major or easy to detect. Hence, enabling auto-reverting for a non-file buffer does not always guarantee that all information in the buffer is up-to-date, and does not necessarily make manual reverts useless.

At the other extreme, certain buffers automatically revert every auto-revert-interval seconds. (This currently only applies to the Buffer Menu.) In this case, Auto Revert does not print any messages while reverting, even when auto-revert-verbose is non-nil.

Some non-file buffers can be updated reliably by file notification on their default directory; Dired buffers is an example. The major mode can indicate this by setting buffer-auto-revert-by-notification to a non-nil value in that buffer, allowing Auto Revert to avoid periodic polling. Such notification does not include changes to files in that directory, only to the directory itself.

The details depend on the particular types of buffers and are explained in the corresponding sections.



***** Auto Reverting the Buffer Menu

If auto-reverting of non-file buffers is enabled, the Buffer Menu (see Operating on Several Buffers) automatically reverts every auto-revert-interval seconds, whether there is a need for it or not. (It would probably take longer to check whether there is a need than to actually revert.)

If the Buffer Menu inappropriately gets marked modified, just revert it manually using g and auto-reverting will resume. However, if you marked certain buffers to get deleted or to be displayed, you have to be careful, because reverting erases all marks. The fact that adding marks sets the buffer’s modified flag prevents Auto Revert from automatically erasing the marks.


***** Auto Reverting Dired buffers

Dired buffers only auto-revert when the file list of the buffer’s main directory changes (e.g., when a new file is added or deleted). They do not auto-revert when information about a particular file changes (e.g., when the size changes) or when inserted subdirectories change. To be sure that all listed information is up to date, you have to manually revert using g, even if auto-reverting is enabled in the Dired buffer. Sometimes, you might get the impression that modifying or saving files listed in the main directory actually does cause auto-reverting. This is because making changes to a file, or saving it, very often causes changes in the directory itself; for instance, through backup files or auto-save files. However, this is not guaranteed.

If the Dired buffer is marked modified and there are no changes you want to protect, then most of the time you can make auto-reverting resume by manually reverting the buffer using g. There is one exception. If you flag or mark files, you can safely revert the buffer. This will not erase the flags or marks (unless the marked file has been deleted, of course). However, the buffer will stay modified, even after reverting, and auto-reverting will not resume. This is because, if you flag or mark files, you may be working on the buffer and you might not want the buffer to change without warning. If you want auto-reverting to resume in the presence of marks and flags, mark the buffer non-modified using M-~. However, adding, deleting or changing marks or flags will mark it modified again.

Remote Dired buffers are currently not auto-reverted. Neither are Dired buffers for which you used shell wildcards or file arguments to list only some of the files. *Find* and *Locate* buffers do not auto-revert either.

Note that auto-reverting Dired buffers may not work satisfactorily on some systems.


*** Auto-Saving: Protection Against Disasters

From time to time, Emacs automatically saves each visited file in a separate file, without altering the file you actually use. This is called auto-saving. It prevents you from losing more than a limited amount of work if the system crashes.

When Emacs determines that it is time for auto-saving, it considers each buffer, and each is auto-saved if auto-saving is enabled for it and it has been changed since the last time it was auto-saved. When the auto-save-no-message variable is set to nil (the default), the message ‘Auto-saving...’ is displayed in the echo area during auto-saving, if any files are actually auto-saved; to disable these messages, customize the variable to a non-nil value. Errors occurring during auto-saving are caught so that they do not interfere with the execution of commands you have been typing.

**** Auto-Save Files

Auto-saving does not normally save in the files that you visited, because it can be very undesirable to save a change that you did not want to make permanent. Instead, auto-saving is done in a different file called the auto-save file, and the visited file is changed only when you request saving explicitly (such as with C-x C-s).

Normally, the auto-save file name is made by appending ‘#’ to the front and rear of the visited file name. Thus, a buffer visiting file foo.c is auto-saved in a file #foo.c#. Most buffers that are not visiting files are auto-saved only if you request it explicitly; when they are auto-saved, the auto-save file name is made by appending ‘#’ to the front and rear of buffer name, then adding digits and letters at the end for uniqueness. For example, the *mail* buffer in which you compose messages to be sent might be auto-saved in a file named #*mail*#704juu. Auto-save file names are made this way unless you reprogram parts of Emacs to do something different (the functions make-auto-save-file-name and auto-save-file-name-p). The file name to be used for auto-saving in a buffer is calculated when auto-saving is turned on in that buffer.

The variable auto-save-file-name-transforms allows a degree of control over the auto-save file name. It lets you specify a series of regular expressions and replacements to transform the auto save file name. The default value puts the auto-save files for remote files (see Remote Files) into the temporary file directory on the local machine.

When you delete a substantial part of the text in a large buffer, auto save turns off temporarily in that buffer. This is because if you deleted the text unintentionally, you might find the auto-save file more useful if it contains the deleted text. To reenable auto-saving after this happens, save the buffer with C-x C-s, or use C-u 1 M-x auto-save-mode.

If you want auto-saving to be done in the visited file rather than in a separate auto-save file, enable the global minor mode auto-save-visited-mode. In this mode, auto-saving is identical to explicit saving. Note that this mode is orthogonal to the auto-save mode described above; you can enable both at the same time. However, if auto-save mode is active in some buffer and the obsolete auto-save-visited-file-name variable is set to a non-nil value, that buffer won’t be affected by auto-save-visited-mode.

You can use the variable auto-save-visited-interval to customize the interval between auto-save operations in auto-save-visited-mode; by default it’s five seconds. auto-save-interval and auto-save-timeout have no effect on auto-save-visited-mode. See Controlling Auto-Saving, for details on these variables.

A buffer’s auto-save file is deleted when you save the buffer in its visited file. (You can inhibit this by setting the variable delete-auto-save-files to nil.) Changing the visited file name with C-x C-w or set-visited-file-name renames any auto-save file to go with the new visited name.

Killing a buffer, by default, doesn’t remove the buffer’s auto-save file. If kill-buffer-delete-auto-save-files is non-nil, killing a buffer that has an auto-save file will make Emacs prompt the user for whether the auto-save file should be deleted. (This is inhibited if delete-auto-save-files is nil.)


**** Controlling Auto-Saving

Each time you visit a file, auto-saving is turned on for that file’s buffer if the variable auto-save-default is non-nil (but not in batch mode; see Initial Options). The default for this variable is t, so auto-saving is the usual practice for file-visiting buffers. To toggle auto-saving in the current buffer, type M-x auto-save-mode. Auto Save mode acts as a buffer-local minor mode (see Minor Modes).

Emacs auto-saves periodically based on how many characters you have typed since the last auto-save. The variable auto-save-interval specifies how many characters there are between auto-saves. By default, it is 300. Emacs doesn’t accept values that are too small: if you customize auto-save-interval to a value less than 20, Emacs will behave as if the value is 20.

Auto-saving also takes place when you stop typing for a while. By default, it does this after 30 seconds of idleness (at this time, Emacs may also perform garbage collection; see Garbage Collection in The Emacs Lisp Reference Manual). To change this interval, customize the variable auto-save-timeout. The actual time period is longer if the current buffer is long; this is a heuristic which aims to keep out of your way when you are editing long buffers, in which auto-save takes an appreciable amount of time. Auto-saving during idle periods accomplishes two things: first, it makes sure all your work is saved if you go away from the terminal for a while; second, it may avoid some auto-saving while you are actually typing.

When auto-save-visited-mode is enabled, Emacs will auto-save file-visiting buffers after five seconds of idle time. You can customize the variable auto-save-visited-interval to change the idle time interval.

Emacs also does auto-saving whenever it gets a fatal error. This includes killing the Emacs job with a shell command such as ‘kill %emacs’, or disconnecting a phone line or network connection.

You can perform an auto-save explicitly with the command M-x do-auto-save.


**** Recovering Data from Auto-Saves

You can use the contents of an auto-save file to recover from a loss of data with the command M-x recover-file RET file RET. This visits file and then (after your confirmation) restores the contents from its auto-save file #file#. You can then save with C-x C-s to put the recovered text into file itself. For example, to recover file foo.c from its auto-save file #foo.c#, do:

M-x recover-file RET foo.c RET
yes RET
C-x C-s
Before asking for confirmation, M-x recover-file displays a directory listing describing the specified file and the auto-save file, so you can compare their sizes and dates. If the auto-save file is older, M-x recover-file does not offer to read it.

If Emacs or the computer crashes, you can recover all the files you were editing from their auto save files with the command M-x recover-session. This first shows you a list of recorded interrupted sessions. Move point to the one you choose, and type C-c C-c.

Then recover-session asks about each of the files that were being edited during that session, asking whether to recover that file. If you answer y, it calls recover-file, which works in its normal fashion. It shows the dates of the original file and its auto-save file, and asks once again whether to recover that file.

When recover-session is done, the files you’ve chosen to recover are present in Emacs buffers. You should then save them. Only this—saving them—updates the files themselves.

Emacs records information about interrupted sessions in files named .saves-pid-hostname~ in the directory ~/.emacs.d/auto-save-list/. This directory is determined by the variable auto-save-list-file-prefix. If you set auto-save-list-file-prefix to nil, sessions are not recorded for recovery.


*** File Name Aliases

Symbolic links and hard links both make it possible for several file names to refer to the same file. Hard links are alternate names that refer directly to the file; all the names are equally valid, and no one of them is preferred. By contrast, a symbolic link is a kind of defined alias: when foo is a symbolic link to bar, you can use either name to refer to the file, but bar is the real name, while foo is just an alias. More complex cases occur when symbolic links point to directories.

Normally, if you visit a file which Emacs is already visiting under a different name, Emacs displays a message in the echo area and uses the existing buffer visiting that file. This can happen on systems that support hard or symbolic links, or if you use a long file name on a system that truncates long file names, or on a case-insensitive file system. You can suppress the message by setting the variable find-file-suppress-same-file-warnings to a non-nil value. You can disable this feature entirely by setting the variable find-file-existing-other-name to nil: then if you visit the same file under two different names, you get a separate buffer for each file name.

If the variable find-file-visit-truename is non-nil, then the file name recorded for a buffer is the file’s truename (made by replacing all symbolic links with their target names), rather than the name you specify. Setting find-file-visit-truename also implies the effect of find-file-existing-other-name.

Sometimes, a directory is ordinarily accessed through a symbolic link, and you may want Emacs to preferentially show its linked name. To do this, customize directory-abbrev-alist. Each element in this list should have the form (from . to), which means to replace from with to whenever from appears in a directory name. The from string is a regular expression (see Syntax of Regular Expressions). It is matched against directory names anchored at the first character, and should start with ‘\`’ (to support directory names with embedded newlines, which would defeat ‘^’). The to string should be an ordinary absolute directory name pointing to the same directory. Do not use ‘~’ to stand for a home directory in the to string; Emacs performs these substitutions separately. Here’s an example, from a system on which /home/fsf is normally accessed through a symbolic link named /fsf:

(("\\`/home/fsf" . "/fsf"))


*** File Directories

The file system groups files into directories. A directory listing is a list of all the files in a directory. Emacs provides commands to create and delete directories, and to make directory listings in brief format (file names only) and verbose format (sizes, dates, and other attributes included). Emacs also includes a directory browser feature called Dired, which you can invoke with C-x d; see Dired, the Directory Editor.

C-x C-d dir-or-pattern RET
Display a brief directory listing (list-directory).

C-u C-x C-d dir-or-pattern RET
Display a verbose directory listing.

M-x make-directory RET dirname RET
Create a new directory named dirname.

M-x delete-directory RET dirname RET
Delete the directory named dirname. If it isn’t empty, you will be asked whether you want to delete it recursively.

The command to display a directory listing is C-x C-d (list-directory). It reads using the minibuffer a file name which is either a directory to be listed or a wildcard-containing pattern for the files to be listed. For example,

C-x C-d /u2/emacs/etc RET
lists all the files in directory /u2/emacs/etc. Here is an example of specifying a file name pattern:

C-x C-d /u2/emacs/src/*.c RET
Normally, C-x C-d displays a brief directory listing containing just file names. A numeric argument (regardless of value) tells it to make a verbose listing including sizes, dates, and owners (like ‘ls -l’).

The text of a directory listing is mostly obtained by running ls in an inferior process. Two Emacs variables control the switches passed to ls: list-directory-brief-switches is a string giving the switches to use in brief listings ("-CF" by default), and list-directory-verbose-switches is a string giving the switches to use in a verbose listing ("-l" by default).

In verbose directory listings, Emacs adds information about the amount of free space on the disk that contains the directory.

The command M-x delete-directory prompts for a directory’s name using the minibuffer, and deletes the directory if it is empty. If the directory is not empty, you will be asked whether you want to delete it recursively. On systems that have a “Trash” (or “Recycle Bin”) feature, you can make this command move the specified directory to the Trash instead of deleting it outright, by changing the variable delete-by-moving-to-trash to t. See Miscellaneous File Operations, for more information about using the Trash.


*** Comparing Files

The command M-x diff prompts for two file names, using the minibuffer, and displays the differences between the two files in a buffer named *diff*. This works by running the diff program, using options taken from the variable diff-switches. The value of diff-switches should be a string; the default is "-u" to specify a unified context diff. See Diff in Comparing and Merging Files, for more information about the diff program.

The output of the diff command is shown using a major mode called Diff mode. See Diff Mode.

A (much more sophisticated) alternative is M-x ediff (see Ediff in The Ediff Manual).

The command M-x diff-backup compares a specified file with its most recent backup. If you specify the name of a backup file, diff-backup compares it with the source file that it is a backup of. In all other respects, this behaves like M-x diff.

The command M-x diff-buffer-with-file compares a specified buffer with its corresponding file. This shows you what changes you would make to the file if you save the buffer.

The command M-x diff-buffers compares the contents of two specified buffers.

The command M-x compare-windows compares the text in the current window with that in the window that was the selected window before you selected the current one. (For more information about windows in Emacs, see Multiple Windows.) Comparison starts at point in each window, after pushing each initial point value on the mark ring (see The Mark Ring) in its respective buffer. Then it moves point forward in each window, one character at a time, until it reaches characters that don’t match. Then the command exits.

If point in the two windows is followed by non-matching text when the command starts, M-x compare-windows tries heuristically to advance up to matching text in the two windows, and then exits. So if you use M-x compare-windows repeatedly (see Repeating a Command), each time it either skips one matching range or finds the start of another.

With a numeric argument, compare-windows ignores changes in whitespace. If the variable compare-ignore-case is non-nil, the comparison ignores differences in case as well. If the variable compare-ignore-whitespace is non-nil, compare-windows by default ignores changes in whitespace, but a prefix argument turns that off for that single invocation of the command.

You can use M-x smerge-mode to turn on Smerge mode, a minor mode for editing output from the diff3 program. This is typically the result of a failed merge from a version control system update outside VC, due to conflicting changes to a file. Smerge mode provides commands to resolve conflicts by selecting specific changes.

See Merging Files with Emerge, for the Emerge facility, which provides a powerful interface for merging files.


*** Diff Mode

Diff mode is a major mode used for the output of M-x diff and other similar commands. This kind of output is called a patch, because it can be passed to the patch command to automatically apply the specified changes. To select Diff mode manually, type M-x diff-mode.

The changes specified in a patch are grouped into hunks, which are contiguous chunks of text that contain one or more changed lines. Hunks usually also include unchanged lines to provide context for the changes. Each hunk is preceded by a hunk header, which specifies the old and new line numbers where the hunk’s changes occur. Diff mode highlights each hunk header, to distinguish it from the actual contents of the hunk.

The first hunk in a patch is preceded by a file header, which shows the names of the new and the old versions of the file, and their time stamps. If a patch shows changes for more than one file, each file has such a header before the first hunk of that file’s changes.

You can edit a Diff mode buffer like any other buffer. (If it is read-only, you need to make it writable first; see Miscellaneous Buffer Operations.) Whenever you edit a hunk, Diff mode attempts to automatically correct the line numbers in the hunk headers, to ensure that the patch remains correct, and could still be applied by patch. To disable automatic line number correction, change the variable diff-update-on-the-fly to nil.

Diff mode arranges for hunks to be treated as compiler error messages by M-g M-n and other commands that handle error messages (see Compilation Mode). Thus, you can use the compilation-mode commands to visit the corresponding source locations.

In addition, Diff mode provides the following commands to navigate, manipulate and apply parts of patches:

M-n ¶
Move to the next hunk-start (diff-hunk-next). With prefix argument n, move forward to the nth next hunk.

By default, Diff mode refines hunks as Emacs displays them, highlighting their changes with better granularity. Alternatively, if you set diff-refine to the symbol navigation, Diff mode only refines the hunk you move to with this command or with diff-hunk-prev.

M-p ¶
Move to the previous hunk-start (diff-hunk-prev). With prefix argument n, move back to the nth previous hunk. Like M-n, this command refines the hunk you move to if you set diff-refine to the symbol navigation.

M-} ¶
Move to the next file-start, in a multi-file patch (diff-file-next). With prefix argument n, move forward to the start of the nth next file.

M-{ ¶
Move to the previous file-start, in a multi-file patch (diff-file-prev). With prefix argument n, move back to the start of the nth previous file.

M-k ¶
Kill the hunk at point (diff-hunk-kill).

M-K ¶
In a multi-file patch, kill the current file part. (diff-file-kill).

C-c C-a ¶
Apply this hunk to its target file (diff-apply-hunk). With a prefix argument of C-u, revert this hunk, i.e. apply the reverse of the hunk, which changes the “new” version into the “old” version. If diff-jump-to-old-file is non-nil, apply the hunk to the “old” version of the file instead.

C-c C-b ¶
Highlight the changes of the hunk at point with a finer granularity (diff-refine-hunk). This allows you to see exactly which parts of each changed line were actually changed.

By default, Diff mode refines hunks as Emacs displays them, so you may find this command useful if you customize diff-refine to a non-default value.

C-c C-c ¶
Go to the source file and line corresponding to this hunk (diff-goto-source). By default, this jumps to the “new” version of the file, the one shown first on the file header. With a prefix argument, jump to the “old” version instead. If diff-jump-to-old-file is non-nil, this command by default jumps to the “old” file, and the meaning of the prefix argument is reversed. If the prefix argument is a number greater than 8 (e.g., if you type C-u C-u C-c C-c), then this command also sets diff-jump-to-old-file for the next invocation. If the source file is under version control (see Version Control), this jumps to the work file by default. With a prefix argument, jump to the “old” revision of the file (see Examining And Comparing Old Revisions), when point is on the old line, or otherwise jump to the “new” revision.

C-c C-e ¶
Start an Ediff session with the patch (diff-ediff-patch). See Ediff in The Ediff Manual.

C-c C-n ¶
Restrict the view to the current hunk (diff-restrict-view). See Narrowing. With a prefix argument, restrict the view to the current file of a multiple-file patch. To widen again, use C-x n w (widen).

C-c C-r ¶
Reverse the direction of comparison for the entire buffer (diff-reverse-direction). With a prefix argument, reverse the direction only inside the current region (see The Mark and the Region). Reversing the direction means changing the hunks and the file-start headers to produce a patch that would change the “new” version into the “old” one.

C-c C-s ¶
Split the hunk at point (diff-split-hunk) into two separate hunks. This inserts a hunk header and modifies the header of the current hunk. This command is useful for manually editing patches, and only works with the unified diff format produced by the -u or --unified options to the diff program. If you need to split a hunk in the context diff format produced by the -c or --context options to diff, first convert the buffer to the unified diff format with C-c C-u.

C-c C-d ¶
Convert the entire buffer to the context diff format (diff-unified->context). With a prefix argument, convert only the hunks within the region.

C-c C-u ¶
Convert the entire buffer to unified diff format (diff-context->unified). With a prefix argument, convert unified format to context format. When the mark is active, convert only the hunks within the region.

C-c C-l ¶
Re-generate the current hunk (diff-refresh-hunk).

C-c C-w ¶
Re-generate the current hunk, disregarding changes in whitespace (diff-ignore-whitespace-hunk).

C-x 4 A ¶
Generate a ChangeLog entry, like C-x 4 a does (see Change Logs), for each one of the hunks (diff-add-change-log-entries-other-window). This creates a skeleton of the log of changes that you can later fill with the actual descriptions of the changes. C-x 4 a itself in Diff mode operates on behalf of the current hunk’s file, but gets the function name from the patch itself. This is useful for making log entries for functions that are deleted by the patch.

Patches sometimes include trailing whitespace on modified lines, as an unintentional and undesired change. There are two ways to deal with this problem. Firstly, if you enable Whitespace mode in a Diff buffer (see Useless Whitespace), it automatically highlights trailing whitespace in modified lines. Secondly, you can use the command M-x diff-delete-trailing-whitespace, which searches for trailing whitespace in the lines modified by the patch, and removes that whitespace in both the patch and the patched source file(s). This command does not save the modifications that it makes, so you can decide whether to save the changes (the list of modified files is displayed in the echo area). With a prefix argument, it tries to modify the original (“old”) source files rather than the patched (“new”) source files.

If diff-font-lock-syntax is non-nil, fragments of source in hunks are highlighted according to the appropriate major mode.


*** Copying, Naming and Renaming Files

Emacs has several commands for copying, naming, and renaming files. All of them read two file names, old (or target) and new, using the minibuffer, and then copy or adjust a file’s name accordingly; they do not accept wildcard file names.

In all these commands, if the argument new is just a directory name (see Directory Names in the Emacs Lisp Reference Manual), the real new name is in that directory, with the same non-directory component as old. For example, the command M-x rename-file RET ~/foo RET /tmp/ RET renames ~/foo to /tmp/foo. On GNU and other POSIX-like systems, directory names end in ‘/’.

All these commands ask for confirmation when the new file name already exists.

M-x copy-file copies the contents of the file old to the file new.

M-x copy-directory copies directories, similar to the cp -r shell command. If new is a directory name, it creates a copy of the old directory and puts it in new. Otherwise it copies all the contents of old into a new directory named new. If copy-directory-create-symlink is non-nil and old is a symbolic link, this command will copy the symbolic link. If nil, this command will follow the link and copy the contents instead. (This is the default.)

M-x rename-file renames file old as new. If the file name new already exists, you must confirm with yes or renaming is not done; this is because renaming causes the old meaning of the name new to be lost. If old and new are on different file systems, the file old is copied and deleted.

If a file is under version control (see Version Control), you should rename it using M-x vc-rename-file instead of M-x rename-file. See Deleting and Renaming Version-Controlled Files.

M-x add-name-to-file adds an additional name to an existing file without removing the old name. The new name is created as a hard link to the existing file. The new name must belong on the same file system that the file is on. On MS-Windows, this command works only if the file resides in an NTFS file system. On MS-DOS, and some remote system types, it works by copying the file.

M-x make-symbolic-link creates a symbolic link named new, which points at target. The effect is that future attempts to open file new will refer to whatever file is named target at the time the opening is done, or will get an error if the name target is nonexistent at that time. This command does not expand the argument target, so that it allows you to specify a relative name as the target of the link. However, this command does expand leading ‘~’ in target so that you can easily specify home directories, and strips leading ‘/:’ so that you can specify relative names beginning with literal ‘~’ or ‘/:’. See Quoted File Names. On MS-Windows, this command works only on MS Windows Vista and later. When new is remote, it works depending on the system type.


*** Miscellaneous File Operations

Emacs has commands for performing many other operations on files. All operate on one file; they do not accept wildcard file names.

M-x delete-file prompts for a file and deletes it. If you are deleting many files in one directory, it may be more convenient to use Dired rather than delete-file. See Deleting Files with Dired.

M-x move-file-to-trash moves a file into the system Trash (or Recycle Bin). This is a facility available on most operating systems; files that are moved into the Trash can be brought back later if you change your mind. (The way to restore trashed files is system-dependent.)

By default, Emacs deletion commands do not use the Trash. To use the Trash (when it is available) for common deletion commands, change the variable delete-by-moving-to-trash to t. This affects the commands M-x delete-file and M-x delete-directory (see File Directories), as well as the deletion commands in Dired (see Deleting Files with Dired). Supplying a prefix argument to M-x delete-file or M-x delete-directory makes them delete outright, instead of using the Trash, regardless of delete-by-moving-to-trash.

If you have delete-by-moving-to-trash set, and you want to delete files manually in Emacs from the Trash directory, using commands like D (dired-do-delete) doesn’t work well in the Trash directory (it’ll just give the file a new name, but won’t delete anything). If you want to be able to do this, you should create a .dir-locals.el file containing something like the following in the Trash directory:

((dired-mode . ((delete-by-moving-to-trash . nil))))
Note, however, if you use the system “empty trash” command, it’s liable to also delete this .dir-locals.el file, so this should only be done if you delete files from the Trash directory manually.

If a file is under version control (see Version Control), you should delete it using M-x vc-delete-file instead of M-x delete-file. See Deleting and Renaming Version-Controlled Files.

M-x insert-file (also C-x i) inserts a copy of the contents of the specified file into the current buffer at point, leaving point unchanged before the contents. The position after the inserted contents is added to the mark ring, without activating the mark (see The Mark Ring).

M-x insert-file-literally is like M-x insert-file, except the file is inserted literally: it is treated as a sequence of ASCII characters with no special encoding or conversion, similar to the M-x find-file-literally command (see Visiting Files).

M-x write-region is the inverse of M-x insert-file; it copies the contents of the region into the specified file. M-x append-to-file adds the text of the region to the end of the specified file. See Accumulating Text. The variable write-region-inhibit-fsync applies to these commands, as well as saving files; see Customizing Saving of Files.

M-x set-file-modes reads a file name followed by a file mode, and applies that file mode to the specified file. File modes, also called file permissions, determine whether a file can be read, written to, or executed, and by whom. This command reads file modes using the same symbolic or octal format accepted by the chmod command; for instance, ‘u+x’ means to add execution permission for the user who owns the file. It has no effect on operating systems that do not support file modes. chmod is a convenience alias for this function.


*** Accessing Compressed Files

Emacs automatically uncompresses compressed files when you visit them, and automatically recompresses them if you alter them and save them. Emacs recognizes compressed files by their file names. File names ending in ‘.gz’ indicate a file compressed with gzip. Other endings indicate other compression programs.

Automatic uncompression and compression apply to all the operations in which Emacs uses the contents of a file. This includes visiting it, saving it, inserting its contents into a buffer, loading it, and byte compiling it.

To disable this feature, type the command M-x auto-compression-mode. You can disable it permanently by customizing the variable auto-compression-mode.


*** File Archives

A file whose name ends in ‘.tar’ is normally an archive made by the tar program. Emacs views these files in a special mode called Tar mode which provides a Dired-like list of the contents (see Dired, the Directory Editor). You can move around through the list just as you would in Dired, and visit the subfiles contained in the archive. However, not all Dired commands are available in Tar mode.

If Auto Compression mode is enabled (see Accessing Compressed Files), then Tar mode is used also for compressed archives—files with extensions ‘.tgz’, .tar.Z and .tar.gz.

The keys e, f and RET all extract a component file into its own buffer. You can edit it there, and if you save the buffer, the edited version will replace the version in the Tar buffer. Clicking with the mouse on the file name in the Tar buffer does likewise. v extracts a file into a buffer in View mode (see View Mode). o extracts the file and displays it in another window, so you could edit the file and operate on the archive simultaneously.

The I key adds a new (regular) file to the archive. The file is initially empty, but can readily be edited using the commands above. The command inserts the new file before the current one, so that using it on the topmost line of the Tar buffer makes the new file the first one in the archive, and using it at the end of the buffer makes it the last one.

d marks a file for deletion when you later use x, and u unmarks a file, as in Dired. C copies a file from the archive to disk and R renames a file within the archive. g reverts the buffer from the archive on disk. The keys M, G, and O change the file’s permission bits, group, and owner, respectively.

Saving the Tar buffer writes a new version of the archive to disk with the changes you made to the components.

You don’t need the tar program to use Tar mode—Emacs reads the archives directly. However, accessing compressed archives requires the appropriate uncompression program.

A separate but similar Archive mode is used for arc, jar, lzh, zip, rar, 7z, and zoo archives, as well as exe files that are self-extracting executables.

The key bindings of Archive mode are similar to those in Tar mode, with the addition of the m key which marks a file for subsequent operations, and M-DEL which unmarks all the marked files. Also, the a key toggles the display of detailed file information, for those archive types where it won’t fit in a single line. Operations such as renaming a subfile, or changing its mode or owner, are supported only for some of the archive formats.

Unlike Tar mode, Archive mode runs the archiving programs to unpack and repack archives. However, you don’t need these programs to look at the archive table of contents, only to extract or manipulate the subfiles in the archive. Details of the program names and their options can be set in the ‘Archive’ Customize group (see Customization Groups).


*** Remote Files

You can refer to files on other machines using a special file name syntax:

/method:host:filename
/method:user@host:filename
/method:user@host#port:filename
To carry out this request, Emacs uses a remote-login program such as ssh. You must always specify in the file name which method to use—for example, /ssh:user@host:filename uses ssh. When you specify the pseudo method ‘-’ in the file name, Emacs chooses the method as follows:

If the host name starts with ‘ftp.’ (with dot), Emacs uses FTP.
If the user name is ‘ftp’ or ‘anonymous’, Emacs uses FTP.
If the variable tramp-default-method is set to ‘ftp’, Emacs uses FTP.
If ssh-agent is running, Emacs uses scp.
Otherwise, Emacs uses ssh.
You can entirely turn off the remote file name feature by setting the variable tramp-mode to nil. You can turn off the feature in individual cases by quoting the file name with ‘/:’ (see Quoted File Names).

Remote file access through FTP is handled by the Ange-FTP package, which is documented in the following. Remote file access through the other methods is handled by the Tramp package, which has its own manual. See The Tramp Manual in The Tramp Manual.

When the Ange-FTP package is used, Emacs logs in through FTP using the name user, if that is specified in the remote file name. If user is unspecified, Emacs logs in using your user name on the local system; but if you set the variable ange-ftp-default-user to a string, that string is used instead. When logging in, Emacs may also ask for a password.

For performance reasons, Emacs does not make backup files for files accessed via FTP by default. To make it do so, change the variable ange-ftp-make-backup-files to a non-nil value.

By default, auto-save files for remote files are made in the temporary file directory on the local machine, as specified by the variable auto-save-file-name-transforms. See Auto-Save Files.

To visit files accessible by anonymous FTP, you use special user names ‘anonymous’ or ‘ftp’. Passwords for these user names are handled specially. The variable ange-ftp-generate-anonymous-password controls what happens: if the value of this variable is a string, then that string is used as the password; if non-nil (the default), then the value of user-mail-address is used; if nil, then Emacs prompts you for a password as usual (see Entering passwords).

Sometimes you may be unable to access files on a remote machine because a firewall in between blocks the connection for security reasons. If you can log in on a gateway machine from which the target files are accessible, and whose FTP server supports gatewaying features, you can still use remote file names; all you have to do is specify the name of the gateway machine by setting the variable ange-ftp-gateway-host, and set ange-ftp-smart-gateway to t. Otherwise you may be able to make remote file names work, but the procedure is complex. You can read the instructions by typing M-x finder-commentary RET ange-ftp RET.


*** Quoted File Names

You can quote an absolute file name to prevent special characters and syntax in it from having their special effects. The way to do this is to add ‘/:’ at the beginning.

For example, you can quote a local file name which appears remote, to prevent it from being treated as a remote file name. Thus, if you have a directory named /foo: and a file named bar in it, you can refer to that file in Emacs as ‘/:/foo:/bar’.

If you want to quote only special characters in the local part of a remote file name, you can quote just the local part. ‘/ssh:baz:/:/foo:/bar’ refers to the file bar of directory /foo: on the host baz.

‘/:’ can also prevent ‘~’ from being treated as a special character for a user’s home directory. For example, /:/tmp/~hack refers to a file whose name is ~hack in directory /tmp.

Quoting with ‘/:’ is also a way to enter in the minibuffer a file name that contains ‘$’. In order for this to work, the ‘/:’ must be at the beginning of the minibuffer contents. (You can also double each ‘$’; see File Names with $.)

You can also quote wildcard characters with ‘/:’, for visiting. For example, /:/tmp/foo*bar visits the file /tmp/foo*bar.

Another method of getting the same result is to enter /tmp/foo[*]bar, which is a wildcard specification that matches only /tmp/foo*bar. However, in many cases there is no need to quote the wildcard characters because even unquoted they give the right result. For example, if the only file name in /tmp that starts with ‘foo’ and ends with ‘bar’ is foo*bar, then specifying /tmp/foo*bar will visit only /tmp/foo*bar.


*** File Name Cache

You can use the file name cache to make it easy to locate a file by name, without having to remember exactly where it is located. When typing a file name in the minibuffer, C-TAB (file-cache-minibuffer-complete) completes it using the file name cache. If you repeat C-TAB, that cycles through the possible completions of what you had originally typed. (However, note that the C-TAB character cannot be typed on most text terminals.)

The file name cache does not fill up automatically. Instead, you load file names into the cache using these commands:

M-x file-cache-add-directory RET directory RET
Add each file name in directory to the file name cache.

M-x file-cache-add-directory-using-find RET directory RET
Add each file name in directory and all of its nested subdirectories to the file name cache.

M-x file-cache-add-directory-using-locate RET directory RET
Add each file name in directory and all of its nested subdirectories to the file name cache, using locate to find them all.

M-x file-cache-add-directory-list RET variable RET
Add each file name in each directory listed in variable to the file name cache. variable should be a Lisp variable whose value is a list of directories, like load-path.

M-x file-cache-clear-cache RET
Clear the cache; that is, remove all file names from it.

The file name cache is not persistent: it is kept and maintained only for the duration of the Emacs session. You can view the contents of the cache with the file-cache-display command.


*** Convenience Features for Finding Files

In this section, we introduce some convenient facilities for finding recently-opened files, reading file names from a buffer.

If you enable Recentf mode, with M-x recentf-mode, Emacs maintains a list of recently opened files. To open a file from this list, use the M-x recentf-open command. When this mode is enabled, the ‘File’ menu will include a submenu that you can use to visit one of these files. M-x recentf-save-list saves the current recentf-list to a file, and M-x recentf-edit-list edits it.

The M-x ffap command generalizes find-file with more powerful heuristic defaults (see Finding Files and URLs at Point), often based on the text at point. Partial Completion mode offers other features extending find-file, which can be used with ffap. See Completion Options.


*** Viewing Image Files

Visiting image files automatically selects Image mode. In this major mode, you can type C-c C-c (image-toggle-display) to toggle between displaying the file as an image in the Emacs buffer, and displaying its underlying text (or raw byte) representation. Additionally you can type C-c C-x (image-toggle-hex-display) to toggle between displaying the file as an image in the Emacs buffer, and displaying it in hex representation. Displaying the file as an image works only if Emacs is compiled with support for displaying such images.

If the displayed image is wider or taller than the window in which it is displayed, the usual point motion keys (C-f, C-p, and so forth) cause different parts of the image to be displayed. However, by default images are resized automatically to fit the window, so this is only necessary if you customize the default behavior by using the options image-auto-resize and image-auto-resize-on-window-resize.

To resize the image manually you can use the command image-transform-fit-to-window bound to s w that fits the image to both the window height and width. To scale the image to a percentage of its original size, use the command image-transform-set-percent bound to s p. To scale the image specifying a scale factor, use the command image-transform-set-scale bound to s s. To reset all transformations to the initial state, use image-transform-reset-to-initial bound to s 0, or image-transform-reset-to-original bound to s o.

You can press n (image-next-file) and p (image-previous-file) to visit the next image file and the previous image file in the same directory, respectively. These commands will consult the “parent” dired buffer to determine what the next/previous image file is. These commands also work when opening a file from archive files (like zip or tar files), and will then instead consult the archive mode buffer. If neither an archive nor a dired “parent” buffer can be found, a dired buffer is opened.

When looking through images, it’s sometimes convenient to be able to mark the files for later processing (for instance, if you want to select a group of images to copy somewhere else). The m (image-mode-mark-file) command will mark the current file in any Dired buffer(s) that display the current file’s directory. If no such buffer is open, the directory is opened in a new buffer. To unmark files, use the u (image-mode-mark-file) command. Finally, if you just want to copy the current buffers file name to the kill ring, you can use the w (image-mode-copy-file-name-as-kill) command.

If the image can be animated, the command RET (image-toggle-animation) starts or stops the animation. Animation plays once, unless the option image-animate-loop is non-nil. With f (image-next-frame) and b (image-previous-frame) you can step through the individual frames. Both commands accept a numeric prefix to step through several frames at once. You can go to a specific frame with F (image-goto-frame). Frames are indexed from 1. Typing a + (image-increase-speed) increases the speed of the animation, a - (image-decrease-speed) decreases it, and a r (image-reverse-speed) reverses it. The command a 0 (image-reset-speed) resets the speed to the original value.

In addition to the above key bindings, which are specific to Image mode, images shown in any Emacs buffer have special key bindings when point is at or inside the image:

i +
Increase the image size (image-increase-size) by 20%. Prefix numeric argument controls the increment; the value of n means to multiply the size by the factor of 1 + n / 10, so C-u 5 i + means to increase the size by 50%.

i -
Decrease the image size (image-increase-size) by 20%. Prefix numeric argument controls the decrement; the value of n means to multiply the size by the factor of 1 - n / 10, so C-u 3 i - means to decrease the size by 30%.

i r
Rotate the image by 90 degrees clockwise (image-rotate). With the prefix argument, rotate by 90 degrees counter-clockwise instead. Note that this command is not available for sliced images.

i h
Flip the image horizontally (image-flip-horizontally). This presents the image as if reflected in a vertical mirror. Note that this command is not available for sliced images.

i v
Flip the image vertically (image-flip-vertically). This presents the image as if reflected in a horizontal mirror. Note that this command is not available for sliced images.

i o
Save the image to a file (image-save). This command prompts you for the name of the file to save the image.

i c
Crop the image (image-crop). This command is available only if your system has an external program installed that can be used for cropping and cutting of images; the user option image-crop-crop-command determines what program to use, and defaults to the ImageMagick’s convert program. The command displays the image with a rectangular frame superimposed on it, and lets you use the mouse to move and resize the frame. Type m to cause mouse movements to move the frame instead of resizing it; type s to move a square frame instead. When you are satisfied with the position and size of the cropping frame, type RET to actually crop the part under the frame; or type q to exit without cropping. You can then save the cropped image using i o or M-x image-save.

i x
Cut a rectangle from the image (image-cut). This works the same as image-crop (and also requires an external program, defined by the variable image-crop-cut-command, to perform the image cut), but instead of cropping the image, it removes the part inside the frame and fills that part with the color specified by image-cut-color. With prefix argument, the command prompts for the color to use.

The size and rotation commands are “repeating”, which means that you can continue adjusting the image without using the i prefix.

If Emacs was compiled with support for the ImageMagick library, it can use ImageMagick to render a wide variety of images. The variable imagemagick-enabled-types lists the image types that Emacs may render using ImageMagick; each element in the list should be an internal ImageMagick name for an image type, as a symbol or an equivalent string (e.g., BMP for .bmp images). To enable ImageMagick for all possible image types, change imagemagick-enabled-types to t. The variable imagemagick-types-inhibit lists the image types which should never be rendered using ImageMagick, regardless of the value of imagemagick-enabled-types (the default list includes types like C and HTML, which ImageMagick can render as an image but Emacs should not). To disable ImageMagick entirely, change imagemagick-types-inhibit to t.

If Emacs doesn’t have native support for the image format in question, and image-use-external-converter is non-nil, Emacs will try to determine whether there are external utilities that can be used to transform the image in question to PNG before displaying. GraphicsMagick, ImageMagick and ffmpeg are currently supported for image conversions.

In addition, you may wish to add special handlers for certain image formats. These can be added with the image-converter-add-handler function. For instance, to allow viewing Krita files as simple images, you could say something like:

(image-converter-add-handler
"kra"
(lambda (file data-p)
(if data-p
(error "Can't decode non-files")
(call-process "unzip" nil t nil
"-qq" "-c" "-x" file "mergedimage.png"))))
The function takes two parameters, where the first is a file name suffix, and the second is a function to do the “conversion”. This function takes two parameters, where the first is the file name or a string with the data, and the second says whether the first parameter is data or not, and should output an image in image-convert-to-format format in the current buffer.

The Image-Dired package can also be used to view images as thumbnails. See Viewing Image Thumbnails in Dired.


*** Filesets

If you regularly edit a certain group of files, you can define them as a fileset. This lets you perform certain operations, such as visiting, query-replace, and shell commands on all the files at once. To make use of filesets, you must first add the expression (filesets-init) to your init file (see The Emacs Initialization File). This adds a ‘Filesets’ sub-menu to the menu bar’s ‘File’ menu.

The simplest way to define a fileset is by adding files to it one at a time. To add a file to fileset name, visit the file and type M-x filesets-add-buffer RET name RET. If there is no fileset name, this creates a new one, which initially contains only the current file. The command M-x filesets-remove-buffer removes the current file from a fileset.

You can also edit the list of filesets directly, with M-x filesets-edit (or by choosing ‘Edit Filesets’ from the ‘Filesets’ menu). The editing is performed in a Customize buffer (see Easy Customization Interface). Normally, a fileset is a simple list of files, but you can also define a fileset as a regular expression matching file names. Some examples of these more complicated filesets are shown in the Customize buffer. Remember to select ‘Save for future sessions’ if you want to use the same filesets in future Emacs sessions.

You can use the command M-x filesets-open to visit all the files in a fileset, and M-x filesets-close to close them. Use M-x filesets-run-cmd to run a shell command on all the files in a fileset. These commands are also available from the ‘Filesets’ menu, where each existing fileset is represented by a submenu.

See Version Control, for a different concept of filesets: groups of files bundled together for version control operations. Filesets of that type are unnamed, and do not persist across Emacs sessions.



** Dired 

Dired makes an Emacs buffer containing a listing of a directory, and optionally some of its subdirectories as well. You can use the normal Emacs commands to move around in this buffer, and special Dired commands to operate on the listed files. Dired works with both local and remote directories.

The Dired buffer is normally read-only, and inserting text in it is not allowed (however, the Wdired mode allows that, see Editing the Dired Buffer). Ordinary printing characters such as d and x are redefined for special Dired commands. Some Dired commands mark or flag the current file (that is, the file on the current line); other commands operate on the marked files or on the flagged files. You first mark certain files in order to operate on all of them with one command.

The Dired-X package provides various extra features for Dired mode. See Dired-X in Dired Extra User’s Manual.

You can also view a list of files in a directory with C-x C-d (list-directory). Unlike Dired, this command does not allow you to operate on the listed files. See File Directories.


*** Entering Dired

To invoke Dired, type C-x d (dired). This reads a directory’s name using the minibuffer, and opens a Dired buffer listing the files in that directory. You can also supply a wildcard file name pattern as the minibuffer argument, in which case the Dired buffer lists all files matching that pattern. A wildcard may appear in the directory part as well. For instance,

C-x d  ~/foo/*.el  RET
C-x d  ~/foo/*/*.el  RET
The former lists all the files with extension ‘.el’ in directory ‘foo’. The latter lists the files with extension ‘.el’ in all the subdirectories of ‘foo’.

On Posix systems, when the system shell supports globstar, a recursive globbing feature, and that support is enabled, you can use recursive globbing in Dired:

C-x d  ~/foo/**/*.el  RET
This command produces a directory listing with all the files with extension ‘.el’, descending recursively in all the subdirectories of ‘foo’. Note that there are small differences in the implementation of globstar between different shells. Check your shell manual to know the expected behavior.

If the shell supports globstar, but that support is disabled by default, you can still let Dired use this feature by customizing dired-maybe-use-globstar to a non-nil value; then Dired will enable globstar for those shells for which it knows how (see dired-enable-globstar-in-shell for the list of those shells).

The usual history and completion commands can be used in the minibuffer; in particular, M-n puts the name of the visited file (if any) in the minibuffer (see Minibuffer History).

You can also invoke Dired by giving C-x C-f (find-file) a directory’s name.

You can ask Emacs to invoke Dired on the default-directory (see default-directory) of any buffer, by typing C-x C-j (dired-jump). If the buffer visits a file, this command will move point to that file’s line in the Dired buffer it shows; otherwise, point will end up on the first file in the directory listing. As an exception, if you type C-x C-j in a Dired buffer, Emacs displays the directory listing of the parent directory and places point on the line that corresponds to the directory where you invoked dired-jump. Typing C-x 4 C-j (dired-jump-other-window) has the same effect, but displays the Dired buffer in a new window.

The variable dired-listing-switches specifies the options to give to ls for listing the directory; this string must contain ‘-l’. If you use a prefix argument with the dired command, you can specify the ls switches with the minibuffer before you enter the directory specification. No matter how they are specified, the ls switches can include short options (that is, single characters) requiring no arguments, and long options (starting with ‘--’) whose arguments are specified with ‘=’.

Dired does not handle files that have names with embedded newline characters well. If you have many such files, you may consider adding ‘-b’ to dired-listing-switches. This will quote all special characters and allow Dired to handle them better. (You can also use the C-u C-x d command to add ‘-b’ temporarily.)

Dired displays in the mode line an indication of what were the switches used to invoke ls. By default, Dired will try to determine whether the switches indicate sorting by name or date, and will say so in the mode line. If the dired-switches-in-mode-line variable is as-is, the switches will be shown verbatim. If this variable’s value is an integer, the switch display will be truncated to that length. This variable can also be a function, which will be called with dired-actual-switches as the only parameter, and should return a string to display in the mode line.

If your ls program supports the ‘--dired’ option, Dired automatically passes it that option; this causes ls to emit special escape sequences for certain unusual file names, without which Dired will not be able to parse those names. The first time you run Dired in an Emacs session, it checks whether ls supports the ‘--dired’ option by calling it once with that option. If the exit code is 0, Dired will subsequently use the ‘--dired’ option; otherwise it will not. You can inhibit this check by customizing the variable dired-use-ls-dired. The value unspecified (the default) means to perform the check; any other non-nil value means to use the ‘--dired’ option; and nil means not to use the ‘--dired’ option.

On MS-Windows and MS-DOS systems, and also on some remote systems, Emacs emulates ls. See Emulation of ls on MS-Windows, for options and peculiarities of this emulation.

To display the Dired buffer in another window, use C-x 4 d (dired-other-window). C-x 5 d (dired-other-frame) displays the Dired buffer in a separate frame.

Typing q (quit-window) buries the Dired buffer, and deletes its window if the window was created just for that buffer.


*** Navigation in the Dired Buffer

All the usual Emacs cursor motion commands are available in Dired buffers. The keys C-n and C-p are redefined to run dired-next-line and dired-previous-line, respectively, and they put the cursor at the beginning of the file name on the line, rather than at the beginning of the line.

For extra convenience, SPC and n in Dired are equivalent to C-n. p is equivalent to C-p. (Moving by lines is so common in Dired that it deserves to be easy to type.) DEL (move up and unflag) is also often useful simply for moving up (see Deleting Files with Dired).

j (dired-goto-file) prompts for a file name using the minibuffer, and moves point to the line in the Dired buffer describing that file.

M-s f C-s (dired-isearch-filenames) performs a forward incremental search in the Dired buffer, looking for matches only amongst the file names and ignoring the rest of the text in the buffer. M-s f M-C-s (dired-isearch-filenames-regexp) does the same, using a regular expression search. If you change the variable dired-isearch-filenames to t, then the usual search commands also limit themselves to the file names; for instance, C-s behaves like M-s f C-s. If the value is dwim, then search commands match the file names only when point was on a file name initially. See Searching and Replacement, for information about incremental search.

Some additional navigation commands are available when the Dired buffer includes several directories. See Moving Over Subdirectories.


*** Deleting Files with Dired

One of the most frequent uses of Dired is to first flag files for deletion, then delete the files that were flagged.

d
Flag this file for deletion (dired-flag-file-deletion).

u
Remove the deletion flag (dired-unmark).

DEL
Move point to previous line and remove the deletion flag on that line (dired-unmark-backward).

x
Delete files flagged for deletion (dired-do-flagged-delete).

You can flag a file for deletion by moving to the line describing the file and typing d (dired-flag-file-deletion). The deletion flag is visible as a ‘D’ at the beginning of the line. This command moves point to the next line, so that repeated d commands flag successive files. A numeric prefix argument serves as a repeat count; a negative count means to flag preceding files.

If the region is active, the d command flags all files in the region for deletion; in this case, the command does not move point, and ignores any prefix argument.

The reason for flagging files for deletion, rather than deleting files immediately, is to reduce the danger of deleting a file accidentally. Until you direct Dired to delete the flagged files, you can remove deletion flags using the commands u and DEL. u (dired-unmark) works just like d, but removes flags rather than making flags. DEL (dired-unmark-backward) moves upward, removing flags; it is like u with argument −1. A numeric prefix argument to either command serves as a repeat count, with a negative count meaning to unflag in the opposite direction. If the region is active, these commands instead unflag all files in the region, without moving point.

To delete flagged files, type x (dired-do-flagged-delete). This command displays a list of all the file names flagged for deletion, and requests confirmation with yes. If you confirm, Dired deletes the flagged files, then deletes their lines from the text of the Dired buffer. The Dired buffer, with somewhat fewer lines, remains selected.

If you answer no or quit with C-g when asked to confirm, you return immediately to Dired, with the deletion flags still present in the buffer, and no files actually deleted.

You can delete empty directories just like other files, but normally Dired cannot delete directories that are nonempty. However, if the variable dired-recursive-deletes is non-nil, then Dired is allowed to delete nonempty directories including all their contents. That can be somewhat risky. If the value of the variable is always, Dired will delete nonempty directories recursively, which is even more risky.

Even if you have set dired-recursive-deletes to nil, you might want sometimes to delete directories recursively without being asked for confirmation for all of them. For example, you may want that when you have marked many directories for deletion and you are very sure that all of them can safely be deleted. For every nonempty directory you are asked for confirmation to delete, if you answer all, then all the remaining directories will be deleted without any further questions.

If you change the variable delete-by-moving-to-trash to t, the above deletion commands will move the affected files or directories into the operating system’s Trash, instead of deleting them outright. See Miscellaneous File Operations.

An alternative way of deleting files is to mark them with m and delete with D, see Operating on Files.


*** Flagging Many Files at Once

The #, ~, ., % &, and % d commands flag many files for deletion, based on their file names:

#
Flag all auto-save files (files whose names start and end with ‘#’) for deletion (see Auto-Saving: Protection Against Disasters).

~
Flag all backup files (files whose names end with ‘~’) for deletion (see Backup Files).

. (Period)
Flag excess numeric backup files for deletion. The oldest and newest few backup files of any one file are exempt; the middle ones are flagged.

% &
Flag for deletion all files with certain kinds of names which suggest you could easily create those files again.

% d regexp RET
Flag for deletion all files whose names match the regular expression regexp.

# (dired-flag-auto-save-files) flags all files whose names look like auto-save files—that is, files whose names begin and end with ‘#’. See Auto-Saving: Protection Against Disasters.

~ (dired-flag-backup-files) flags all files whose names say they are backup files—that is, files whose names end in ‘~’. See Backup Files.

. (period, dired-clean-directory) flags just some of the backup files for deletion: all but the oldest few and newest few backups of any one file. Normally, the number of newest versions kept for each file is given by the variable dired-kept-versions (not kept-new-versions; that applies only when saving). The number of oldest versions to keep is given by the variable kept-old-versions.

Period with a positive numeric argument, as in C-u 3 ., specifies the number of newest versions to keep, overriding dired-kept-versions. A negative numeric argument overrides kept-old-versions, using minus the value of the argument to specify the number of oldest versions of each file to keep.

% & (dired-flag-garbage-files) flags files whose names match the regular expression specified by the variable dired-garbage-files-regexp. By default, this matches certain files produced by TeX, ‘.bak’ files, and the ‘.orig’ and ‘.rej’ files produced by patch.

% d flags all files whose names match a specified regular expression (dired-flag-files-regexp). Only the non-directory part of the file name is used in matching. You can use ‘^’ and ‘$’ to anchor matches. You can exclude certain subdirectories from marking by hiding them while you use % d. See Hiding Subdirectories.


*** Visiting Files in Dired

There are several Dired commands for visiting or examining the files listed in the Dired buffer. All of them apply to the current line’s file; if that file is really a directory, these commands invoke Dired on that subdirectory (making a separate Dired buffer).

f ¶
Visit the file described on the current line, like typing C-x C-f and supplying that file name (dired-find-file). See Visiting Files.

RET ¶
e
Equivalent to f.

o ¶
Like f, but uses another window to display the file’s buffer (dired-find-file-other-window). The Dired buffer remains visible in the first window. This is like using C-x 4 C-f to visit the file. See Multiple Windows.

C-o ¶
Visit the file described on the current line, and display the buffer in another window, but do not select that window (dired-display-file).

mouse-1 ¶
mouse-2
Visit the file whose name you clicked on (dired-mouse-find-file-other-window). This uses another window to display the file, like the o command.

v ¶
View the file described on the current line, with View mode (dired-view-file). View mode provides convenient commands to navigate the buffer but forbids changing it; See View Mode.

^ ¶
Visit the parent directory of the current directory (dired-up-directory). This is equivalent to moving to the line for .. and typing f there.

User Option: dired-kill-when-opening-new-dired-buffer ¶
When visiting a new sub-directory in Dired, Emacs will (by default) open a new buffer to display this new directory, and leave the old Dired buffer as is. If this user option is non-nil, the old Dired buffer will be killed after selecting the new directory. This means that if you’re traversing a directory structure in Dired, you won’t end up with more than a single Dired buffer.


*** Dired Marks vs. Flags

Instead of flagging a file with ‘D’, you can mark the file with some other character (usually ‘*’). Most Dired commands to operate on files use the files marked with ‘*’. The only command that operates on flagged files is x, which deletes them.

Here are some commands for marking with ‘*’, for unmarking, and for operating on marks. (See Deleting Files with Dired, for commands to flag and unflag files.)

m ¶
 m
Mark the current file with ‘*’ (dired-mark). If the region is active, mark all files in the region instead; otherwise, if a numeric argument n is supplied, mark the next n files instead, starting with the current file (if n is negative, mark the previous −n files). If invoked on a subdirectory header line (see Subdirectories in Dired), this command marks all the files in that subdirectory.

 N ¶
Report what the number and size of the marked files are (dired-number-of-marked-files).

 * ¶
Mark all executable files with ‘*’ (dired-mark-executables). With a numeric argument, unmark all those files.

 @ ¶
Mark all symbolic links with ‘*’ (dired-mark-symlinks). With a numeric argument, unmark all those files.

 / ¶
Mark with ‘*’ all files which are directories, except for . and .. (dired-mark-directories). With a numeric argument, unmark all those files.

 s ¶
Mark all the files in the current subdirectory, aside from . and .. (dired-mark-subdir-files).

u ¶
 u
Remove any mark on this line (dired-unmark). If the region is active, unmark all files in the region instead; otherwise, if a numeric argument n is supplied, unmark the next n files instead, starting with the current file (if n is negative, unmark the previous −n files).

DEL ¶
 DEL
Move point to previous line and remove any mark on that line (dired-unmark-backward). If the region is active, unmark all files in the region instead; otherwise, if a numeric argument n is supplied, unmark the n preceding files instead, starting with the current file (if n is negative, unmark the next −n files).

! ¶
U
Remove all marks from all the files in this Dired buffer (dired-unmark-all-marks).

 ? markchar ¶
M-DEL
Remove all marks that use the character markchar (dired-unmark-all-files). If invoked with M-DEL, the command prompts for markchar. That markchar is a single character—do not use RET to terminate it. See the description of the * c command below, which lets you replace one mark character with another.

With a numeric argument, this command queries about each marked file, asking whether to remove its mark. You can answer y meaning yes, n meaning no, or ! to remove the marks from the remaining files without asking about them.

 C-n ¶
M-}
Move down to the next marked file (dired-next-marked-file). A file is “marked” if it has any kind of mark.

 C-p ¶
M-{
Move up to the previous marked file (dired-prev-marked-file).

t ¶
 t
Toggle all marks (dired-toggle-marks): files marked with ‘*’ become unmarked, and unmarked files are marked with ‘*’. Files marked in any other way are not affected.

c old-markchar new-markchar ¶
Replace all marks that use the character old-markchar with marks that use the character new-markchar (dired-change-marks). This command is the primary way to create or use marks other than ‘*’ or ‘D’. The arguments are single characters—do not use RET to terminate them.

You can use almost any character as a mark character by means of this command, to distinguish various classes of files. If old-markchar is a space (‘ ’), then the command operates on all unmarked files; if new-markchar is a space, then the command unmarks the files it acts on.

To illustrate the power of this command, here is how to put ‘D’ flags on all the files that have no marks, while unflagging all those that already have ‘D’ flags:

 c D t  * c SPC D  * c t SPC
This assumes that no files were already marked with ‘t’.

% m regexp RET ¶
 % regexp RET
Mark (with ‘*’) all files whose names match the regular expression regexp (dired-mark-files-regexp). This command is like % d, except that it marks files with ‘*’ instead of flagging with ‘D’.

Only the non-directory part of the file name is used in matching. Use ‘^’ and ‘$’ to anchor matches. You can exclude subdirectories by temporarily hiding them (see Hiding Subdirectories).

% g regexp RET ¶
Mark (with ‘*’) all files whose contents contain a match for the regular expression regexp (dired-mark-files-containing-regexp). This command is like % m, except that it searches the file contents instead of the file name. Note that if a file is visited in an Emacs buffer, and dired-always-read-filesystem is nil (the default), this command will look in the buffer without revisiting the file, so the results might be inconsistent with the file on disk if its contents have changed since it was last visited. If you don’t want this, you may wish to revert the files you have visited in your buffers, or to turn on Auto-Revert mode in those buffers, before invoking this command. See Reverting a Buffer. If you prefer that this command should always revisit the file, without you having to revert the file or enable Auto-Revert mode, you might want to set dired-always-read-filesystem to non-nil.

C-/ ¶
C-x u
C-_
Undo changes in the Dired buffer, such as adding or removing marks (dired-undo). This command does not revert the actual file operations, nor recover lost files! It just undoes changes in the buffer itself.

In some cases, using this after commands that operate on files can cause trouble. For example, after renaming one or more files, dired-undo restores the original names in the Dired buffer, which gets the Dired buffer out of sync with the actual contents of the directory.


*** Operating on Files

This section describes the basic Dired commands to operate on one file or several files. All of these commands are capital letters; all of them use the minibuffer, either to read an argument or to ask for confirmation, before they act. All of them let you specify the files to manipulate in these ways:

If you give the command a numeric prefix argument n, it operates on the next n files, starting with the current file. (If n is negative, the command operates on the −n files preceding the current line.)
Otherwise, if some files are marked with ‘*’, the command operates on all those files.
Otherwise, the command operates on the current file only.
Certain other Dired commands, such as ! and the ‘%’ commands, use the same conventions to decide which files to work on.

In addition to Dired commands described here, you can also invoke Version Control (VC) commands on one or more files shown in a Dired buffer. See Version Control.

Commands which ask for a destination directory, such as those which copy and rename files or create links for them, try to guess the default target directory for the operation. Normally, they suggest the Dired buffer’s default directory, but if the option dired-dwim-target is non-nil, and if there is another Dired buffer displayed in some window, that other buffer’s directory is suggested instead. You can customize dired-dwim-target to prefer either the next window with a Dired buffer, or the most recently used window with a Dired buffer, or to use any other function. When the value is a function, it will be called with no arguments and is expected to return a list of directories which will be used as defaults (i.e. default target and “future history”).

Here are the file-manipulating Dired commands that operate on files.

C new RET
Copy the specified files (dired-do-copy). The argument new is the directory to copy into, or (if copying a single file) the new name. This is like the shell command cp.

The option dired-create-destination-dirs controls whether Dired should create non-existent directories in the destination while copying/renaming files. The default value nil means Dired never creates such missing directories; the value always, means Dired automatically creates them; the value ask means Dired asks you for confirmation before creating them.

If the option dired-create-destination-dirs-on-trailing-dirsep is non-nil in addition to dired-create-destination-dirs, a trailing directory separator at the destination directory is treated specially. In that case, when copying to ‘test/’ and no directory ‘test’ exists already, it will be created and the specified source files or directories are copied into the newly created directory.

If dired-copy-preserve-time is non-nil, then copying with this command preserves the modification time of the old file in the copy, like ‘cp -p’.

The variable dired-recursive-copies controls whether to copy directories recursively (like ‘cp -r’). The default is top, which means to ask before recursively copying a directory.

The variable dired-copy-dereference controls whether to copy symbolic links as links or after dereferencing (like ‘cp -L’). The default is nil, which means that the symbolic links are copied by creating new ones.

The dired-keep-marker-copy user option controls how this command handles file marking. The default is to mark all new copies of files with a ‘C’ mark.

D ¶
Delete the specified files (dired-do-delete). This is like the shell command rm.

Like the other commands in this section, this command operates on the marked files, or the next n files. By contrast, x (dired-do-flagged-delete) deletes all flagged files.

R new RET
Rename the specified files (dired-do-rename). If you rename a single file, the argument new is the new name of the file. If you rename several files, the argument new is the directory into which to move the files (this is like the shell command mv).

The option dired-create-destination-dirs controls whether Dired should create non-existent directories in new.

The option dired-create-destination-dirs-on-trailing-dirsep, when set in addition to dired-create-destination-dirs, controls whether a trailing directory separator at the destination is treated specially. In that case, when renaming a directory ‘old’ to ‘new/’ and no directory ‘new’ exists already, it will be created and ‘old’ is moved into the newly created directory. Otherwise, ‘old’ is renamed to ‘new’.

Dired automatically changes the visited file name of buffers associated with renamed files so that they refer to the new names.

If the value of the variable dired-vc-rename-file is non-nil, files are renamed using the commands of the underlying VCS, via vc-rename-file (see Deleting and Renaming Version-Controlled Files).

H new RET
Make hard links to the specified files (dired-do-hardlink). This is like the shell command ln. The argument new is the directory to make the links in, or (if making just one link) the name to give the link.

S new RET
Make symbolic links to the specified files (dired-do-symlink). This is like ‘ln -s’. The argument new is the directory to make the links in, or (if making just one link) the name to give the link.

Y new RET
Make relative symbolic links to the specified files (dired-do-relsymlink). The argument new is the directory to make the links in, or (if making just one link) the name to give the link. This is like dired-do-symlink but creates relative symbolic links. For example:

    foo -> ../bar/foo
It does not create absolute ones like:

    foo -> /path/that/may/change/any/day/bar/foo
M modespec RET
Change the mode (also called permission bits) of the specified files (dired-do-chmod). modespec can be in octal or symbolic notation, like arguments handled by the chmod program. This command does not follow symbolic links, so it reports an error if you try to change the mode of a symbolic link on a platform where such modes are immutable.

G newgroup RET
Change the group of the specified files to newgroup (dired-do-chgrp).

O newowner RET
Change the owner of the specified files to newowner (dired-do-chown). (On most systems, only the superuser can do this.)

The variable dired-chown-program specifies the name of the program to use to do the work. (This variable is necessary because different systems put chown in different places).

T timestamp RET
Touch the specified files (dired-do-touch). This means updating their modification times to timestamp, which defaults to the present time. This is like the shell command touch.

P command RET
Print the specified files (dired-do-print). You must specify the command to print them with, but the minibuffer starts out with a suitable guess made using the variables lpr-command and lpr-switches (the same variables that lpr-buffer uses; see Printing Hard Copies).

Z
Compress the specified files (dired-do-compress). If the file appears to be a compressed file already, uncompress it instead. Each marked file is compressed into its own archive; this uses the gzip program if it is available, otherwise it uses compress.

On a directory name, this command produces a compressed archive depending on the dired-compress-directory-default-suffix user option. The default is a .tar.gz archive containing all of the directory’s files, by running the tar command with output piped to gzip. To allow decompression of compressed directories, typing Z on a .tar.gz or .tgz archive file unpacks all the files in the archive into a directory whose name is the archive name with the extension removed.

c
Compress the specified files (dired-do-compress-to) into a single archive anywhere on the file system. The default archive is controlled by the dired-compress-directory-default-suffix user option. Also see dired-compress-files-alist.

:d
Decrypt the specified files (epa-dired-do-decrypt). See Dired integration in EasyPG Assistant User’s Manual.

:v
Verify digital signatures on the specified files (epa-dired-do-verify). See Dired integration in EasyPG Assistant User’s Manual.

:s
Digitally sign the specified files (epa-dired-do-sign). See Dired integration in EasyPG Assistant User’s Manual.

:e
Encrypt the specified files (epa-dired-do-encrypt). See Dired integration in EasyPG Assistant User’s Manual.

L
Load the specified Emacs Lisp files (dired-do-load). See Libraries of Lisp Code for Emacs.

B
Byte compile the specified Emacs Lisp files (dired-do-byte-compile). See Byte Compilation in The Emacs Lisp Reference Manual.

I
Run Info on this file (assumed to be a file in Info format).

N
Run man on this file (assumed to be a file in nroff format).

A regexp RET
Search all the specified files for the regular expression regexp (dired-do-find-regexp).

This command is a variant of xref-find-references (see Searching and Replacing with Identifiers), it displays the *xref* buffer, where you can navigate between matches and display them as needed using the commands described in Commands Available in the *xref* Buffer.

If any of the marked files are directories, then this command searches all of the files in those directories, and any of their subdirectories, recursively, except files whose names match grep-find-ignored-files and subdirectories whose names match grep-find-ignored-directories.

Q regexp RET to RET
Perform query-replace-regexp on each of the specified files, replacing matches for regexp with the string to (dired-do-find-regexp-and-replace).

This command is a variant of xref-query-replace-in-results. It presents an *xref* buffer that lists all the matches of regexp, and you can use the special commands in that buffer (see Commands Available in the *xref* Buffer). In particular, if you exit the query replace loop, you can use r in that buffer to replace more matches. See Searching and Replacing with Identifiers.

Like with dired-do-find-regexp, if any of the marked files are directories, this command performs replacements in all of the files in those directories, and in any of their subdirectories, recursively, except for files whose names match grep-find-ignored-files and subdirectories whose names match grep-find-ignored-directories.


*** Shell Commands in Dired

The Dired command ! (dired-do-shell-command) reads a shell command string in the minibuffer, and runs that shell command on one or more files. The files that the shell command operates on are determined in the usual way for Dired commands (see Operating on Files). The command X is a synonym for !.

The command & (dired-do-async-shell-command) does the same, except that it runs the shell command asynchronously. (You can also do this with !, by appending a ‘&’ character to the end of the shell command.) When the command operates on more than one file, it runs multiple parallel copies of the specified shell command, one for each file. As an exception, if the specified shell command ends in ‘;’ or ‘;&’, the shell command is run in the background on each file sequentially; Emacs waits for each invoked shell command to terminate before running the next one.

For both ! and &, the working directory for the shell command is the top-level directory of the Dired buffer.

If you tell ! or & to operate on more than one file, the shell command string determines how those files are passed to the shell command:

If you use ‘*’ surrounded by whitespace in the command string, then the command runs just once, with the list of file names substituted for the ‘*’. The order of file names is the order of appearance in the Dired buffer.
Thus, ! tar cf foo.tar * RET runs tar on the entire list of file names, putting them into one tar file foo.tar.

If you want to use ‘*’ as a shell wildcard with whitespace around it, write ‘*""’. In the shell, this is equivalent to ‘*’; but since the ‘*’ is not surrounded by whitespace, Dired does not treat it specially. Emacs will prompt for confirmation if you do this, unless dired-confirm-shell-command is nil.

Otherwise, if the command string contains ‘?’ surrounded by whitespace or ‘`?`’, Emacs runs the shell command once for each file, substituting the current file name for ‘?’ and ‘`?`’ each time. You can use both ‘?’ and ‘`?`’ more than once in the command; the same file name replaces each occurrence. If you mix them with ‘*’ the command signals an error.
If the command string contains neither ‘*’ nor ‘?’ nor ‘`?`’, Emacs runs the shell command once for each file, adding the file name at the end. For example, ! uudecode RET runs uudecode on each file.
To iterate over the file names in a more complicated fashion, you might prefer to use an explicit shell loop. For example, here is how to uuencode each file, making the output file name by appending ‘.uu’ to the input file name:

for file in * ; do uuencode "$file" "$file" >"$file".uu; done
The same example with ‘`?`’ notation:

uuencode ? ? > `?`.uu
The ! and & commands do not attempt to update the Dired buffer to show new or modified files, because they don’t know what files will be changed. Use the g command to update the Dired buffer (see Updating the Dired Buffer).

See Single Shell Commands, for information about running shell commands outside Dired.


*** Shell Command Guessing

Based upon the name of a file, Dired tries to guess what shell command you might want to apply to it. For example, if you have point on a file named foo.tar and you press !, Dired will guess that you want to run ‘tar xvf’, and suggest that as the default shell command.

You can type M-n to get the default into the minibuffer for editing. If there are several commands for a given file, type M-n several times to see each matching command in order.

Dired only tries to guess a command for a single file, never for a list of marked files.

Variable: dired-guess-shell-alist-default ¶
This variable specifies the predefined rules for guessing shell commands suitable for certain files. Set this to nil to turn guessing off. The elements of dired-guess-shell-alist-user (defined by the user) will override these rules.

Variable: dired-guess-shell-alist-user ¶
If non-nil, this variable specifies the user-defined alist of file regexps and their suggested commands. These rules take precedence over the predefined rules in the variable dired-guess-shell-alist-default when dired-do-shell-command is run). The default is nil.

Each element of the alist looks like

(regexp command…)
where each command can either be a string or a Lisp expression that evaluates to a string. If several commands are given, all of them will temporarily be pushed onto the history.

A ‘*’ in the shell command stands for the file name that matched regexp. When Emacs invokes the command, it replaces each instance of ‘*’ with the matched file name.

To add rules for ‘.foo’ and ‘.bar’ file extensions, add this to your Init file:

(setq dired-guess-shell-alist-user
      (list
       (list "\\.foo$" "foo-command")  ; fixed rule
       ;; possibly more rules...
       (list "\\.bar$"  ; rule with condition test
             '(if condition
                  "bar-command-1"
                "bar-command-2"))))
This will override any predefined rules for the same extensions.

You can find more user options with M-x customize-group RET dired-guess RET.


*** Transforming File Names in Dired

This section describes Dired commands which alter file names in a systematic way. Each command operates on some or all of the marked files, using a new name made by transforming the existing name.

Like the basic Dired file-manipulation commands (see Operating on Files), the commands described here operate either on the next n files, or on all files marked with ‘*’, or on the current file. (To mark files, use the commands described in Dired Marks vs. Flags.)

All of the commands described in this section work interactively: they ask you to confirm the operation for each candidate file. Thus, you can select more files than you actually need to operate on (e.g., with a regexp that matches many files), and then filter the selected names by typing y or n when the command prompts for confirmation.

% u
Rename each of the selected files to an upper-case name (dired-upcase). If the old file names are Foo and bar, the new names are FOO and BAR.

% l ¶
Rename each of the selected files to a lower-case name (dired-downcase). If the old file names are Foo and bar, the new names are foo and bar.

% R from RET to RET ¶
% C from RET to RET
% H from RET to RET
% S from RET to RET
% Y from RET to RET
These five commands rename, copy, make hard links, make soft links, and make relative soft links, in each case computing the new name by regular-expression substitution from the name of the old file.

The four regular-expression substitution commands effectively perform a search-and-replace on the selected file names. They read two arguments: a regular expression from, and a substitution pattern to; they match each old file name against from, and then replace the matching part with to. You can use ‘\&’ and ‘\digit’ in to to refer to all or part of what the pattern matched in the old file name, as in replace-regexp (see Regexp Replacement). If the regular expression matches more than once in a file name, only the first match is replaced.

For example, % R ^.*$ RET x-\& RET renames each selected file by prepending ‘x-’ to its name. The inverse of this, removing ‘x-’ from the front of each file name, is also possible: one method is % R ^x-\(.*\)$ RET \1 RET; another is % R ^x- RET RET. (Use ‘^’ and ‘$’ to anchor matches that should span the whole file name.)

Normally, the replacement process does not consider the files’ directory names; it operates on the file name within the directory. If you specify a numeric argument of zero, then replacement affects the entire absolute file name including directory name. (A non-zero argument specifies the number of files to operate on.)

You may want to select the set of files to operate on using the same regexp from that you will use to operate on them. To do this, mark those files with % m from RET, then use the same regular expression in the command to operate on the files. To make this more convenient, the % commands to operate on files use the last regular expression specified in any % command as a default.


*** File Comparison with Dired

The = (dired-diff) command compares the current file (the file at point) with another file (read using the minibuffer) using the diff program. The file specified with the minibuffer is the first argument of diff, and file at point is the second argument. The output of the diff program is shown in a buffer using Diff mode (see Comparing Files).

If the region is active, the default for the file read using the minibuffer is the file at the mark (i.e., the ordinary Emacs mark, not a Dired mark; see Setting the Mark). Otherwise, if the file at point has a backup file (see Backup Files), that is the default.

You could also compare files using ediff-files, see Major Entry Points in Ediff User’s Manual.


*** Subdirectories in Dired

A Dired buffer usually displays just one directory, but you can optionally include its subdirectories as well.

The simplest way to include multiple directories in one Dired buffer is to specify the options ‘-lR’ for running ls. (If you give a numeric argument when you run Dired, then you can specify these options in the minibuffer.) That produces a recursive directory listing showing all subdirectories at all levels.

More often, you will want to show only specific subdirectories. You can do this with i (dired-maybe-insert-subdir):

i ¶
Insert the contents of a subdirectory later in the buffer.

If you use this command on a line that describes a file which is a directory, it inserts the contents of that directory into the same Dired buffer, and moves there. Inserted subdirectory contents follow the top-level directory of the Dired buffer, just as they do in ‘ls -lR’ output.

If the subdirectory’s contents are already present in the buffer, the i command just moves to it.

In either case, i sets the Emacs mark before moving, so C-u C-SPC returns to your previous position in the Dired buffer (see Setting the Mark). You can also use ‘^’ to return to the parent directory in the same Dired buffer (see Visiting Files in Dired).

Use the l command (dired-do-redisplay) to update the subdirectory’s contents, and use C-u k on the subdirectory header line to remove the subdirectory listing (see Updating the Dired Buffer). You can also hide and show inserted subdirectories (see Hiding Subdirectories).


*** Moving Over Subdirectories

When a Dired buffer lists subdirectories, you can use the page motion commands C-x [ and C-x ] to move by entire directories (see Pages).

The following commands move across, up and down in the tree of directories within one Dired buffer. They move to directory header lines, which are the lines that give a directory’s name, at the beginning of the directory’s contents.

C-M-n
Go to next subdirectory header line, regardless of level (dired-next-subdir).

C-M-p
Go to previous subdirectory header line, regardless of level (dired-prev-subdir).

C-M-u
Go up to the parent directory’s header line (dired-tree-up).

C-M-d
Go down in the directory tree, to the first subdirectory’s header line (dired-tree-down).

<
Move up to the previous directory-file line (dired-prev-dirline). These lines are the ones that describe a directory as a file in its parent directory.

>
Move down to the next directory-file line (dired-next-dirline).

M-G
Prompt for a directory and move to its directory-file line (dired-goto-subdir).


*** Hiding Subdirectories

Hiding a subdirectory means to make it invisible, except for its header line.

$ ¶
Hide or show the subdirectory that point is in, and move point to the next subdirectory (dired-hide-subdir). This is a toggle. A numeric argument serves as a repeat count.

M-$ ¶
Hide all subdirectories in this Dired buffer, leaving only their header lines (dired-hide-all). Or, if any subdirectory is currently hidden, make all subdirectories visible again. You can use this command to get an overview in very deep directory trees or to move quickly to subdirectories far away.

Ordinary Dired commands never consider files inside a hidden subdirectory. For example, the commands to operate on marked files ignore files in hidden directories even if they are marked. Thus you can use hiding to temporarily exclude subdirectories from operations without having to remove the Dired marks on files in those subdirectories.

See Subdirectories in Dired, for how to insert a subdirectory listing, and see Updating the Dired Buffer, for how to delete it.


*** Dired and find

You can select a set of files for display in a Dired buffer more flexibly by using the find utility to choose the files.

To search for files with names matching a wildcard pattern use M-x find-name-dired. It reads arguments directory and pattern, and chooses all the files in directory or its subdirectories whose individual names match pattern.

The files thus chosen are displayed in a Dired buffer, in which the ordinary Dired commands are available.

If you want to test the contents of files, rather than their names, use M-x find-grep-dired. This command reads two minibuffer arguments, directory and regexp; it chooses all the files in directory or its subdirectories that contain a match for regexp. It works by running the programs find and grep. See also M-x grep-find, in Searching with Grep under Emacs. Remember to write the regular expression for grep, not for Emacs. (An alternative method of showing files whose contents match a given regexp is the % g regexp command, see Dired Marks vs. Flags.)

The most general command in this series is M-x find-dired, which lets you specify any condition that find can test. It takes two minibuffer arguments, directory and find-args; it runs find in directory, passing find-args to tell find what condition to test. To use this command, you need to know how to use find.

The format of listing produced by these commands is controlled by the variable find-ls-option. This is a pair of options; the first specifying how to call find to produce the file listing, and the second telling Dired to parse the output.

The command M-x locate provides a similar interface to the locate program. M-x locate-with-filter is similar, but keeps only files whose names match a given regular expression.

These buffers don’t work entirely like ordinary Dired buffers: file operations work, but do not always automatically update the buffer. Reverting the buffer with g deletes all inserted subdirectories, and erases all flags and marks.


*** Editing the Dired Buffer

Wdired is a special mode that allows you to perform file operations by editing the Dired buffer directly (the “W” in “Wdired” stands for “writable”). To enter Wdired mode, type C-x C-q (dired-toggle-read-only) while in a Dired buffer. Alternatively, use the ‘Immediate / Edit File Names’ menu item.

While in Wdired mode, you can rename files by editing the file names displayed in the Dired buffer. All the ordinary Emacs editing commands, including rectangle operations and query-replace, are available for this. Once you are done editing, type C-c C-c (wdired-finish-edit). This applies your changes and switches back to ordinary Dired mode.

Apart from simply renaming files, you can move a file to another directory by typing in the new file name (either absolute or relative). To mark a file for deletion, delete the entire file name. To change the target of a symbolic link, edit the link target name which appears next to the link name.

If you edit the file names to create a new subdirectory, Wdired will automatically create these new directories. To inhibit this behavior, set wdired-create-parent-directories to nil.

The rest of the text in the buffer, such as the file sizes and modification dates, is marked read-only, so you can’t edit it. However, if you set wdired-allow-to-change-permissions to t, you can edit the file permissions. For example, you can change ‘-rw-r--r--’ to ‘-rw-rw-rw-’ to make a file world-writable. These changes also take effect when you type C-c C-c.


*** Viewing Image Thumbnails in Dired

Image-Dired is a facility for browsing image files. It provides viewing the images either as thumbnails or in full size, either inside Emacs or through an external viewer. This is different from Image mode (see Viewing Image Files) for visiting an image file in the Emacs buffer.

To enter Image-Dired, mark the image files you want to look at in the Dired buffer, using m as usual. Then type C-t d (image-dired-display-thumbs). This creates and switches to a buffer containing Image-Dired, corresponding to the marked files.

You can also enter Image-Dired directly by typing M-x image-dired. This prompts for a directory; specify one that has image files. This creates thumbnails for all the images in that directory, and displays them all in the thumbnail buffer. The thumbnails are generated in the background and are loaded as they become available.

With point in the thumbnail buffer, you can type RET (image-dired-display-this) to display the image in another window. Use the standard Emacs movement key bindings or the arrow keys to move around in the thumbnail buffer. For easy browsing, use SPC (image-dired-display-next) to advance and display the next image. Typing DEL (image-dired-display-previous) backs up to the previous thumbnail and displays that instead.

Type C-RET (image-dired-thumbnail-display-external) to display the image in an external viewer. You must first configure image-dired-external-viewer.

You can delete images through Image-Dired also. Type d (image-dired-flag-thumb-original-file) to flag the image file for deletion in the Dired buffer. Alternatively, you can remove an image’s thumbnail from the thumbnail buffer without flagging the image for deletion, by typing C-d (image-dired-delete-char).

You could also use Image-Dired for “inline” operations (i.e., right into the Dired buffer). Type C-t C-t, and the thumbnails of the selected images in Dired will appear in front of their names (image-dired-dired-toggle-marked-thumbs). C-t i and C-t x will display the image under the point in Emacs or with the external viewer, respectively.

More advanced features include image tags, which are metadata used to categorize image files. The tags are stored in a plain text file configured by image-dired-tags-db-file.

To tag image files, mark them in the Dired buffer (you can also mark files in Dired from the thumbnail buffer by typing m) and type C-t t (image-dired-tag-files). This reads the tag name in the minibuffer. To mark files having a certain tag, type C-t f (image-dired-mark-tagged-files). After marking image files with a certain tag, you can use C-t d to view them.

You can also tag a file directly from the thumbnail buffer by typing t t, and you can remove a tag by typing t r. There is also a special tag called “comment” for each file (it is not a tag in the exact same sense as the other tags, it is handled slightly differently). That is used to enter a comment or description about the image. You comment a file from the thumbnail buffer by typing c. You will be prompted for a comment. Type C-t c to add a comment from Dired (image-dired-dired-comment-files). C-t e will bring a buffer to edit comment and tags (image-dired-dired-edit-comment-and-tags).

Files that are marked in Dired will also be marked in Image-Dired if image-dired-thumb-visible-marks is non-nil (which is the default).

Image-Dired also provides simple image manipulation. In the thumbnail buffer, type L to rotate the original image 90 degrees anti clockwise, and R to rotate it 90 degrees clockwise. This rotation is lossless, and uses an external utility called jpegtran, which you need to install first.


*** Other Dired Features

By default, Dired displays the available space on the directory’s disk on the first line of that directory’s listing, following the directory name. You can control this display by customizing the variable dired-free-space. Its default value is first, which produces the available space after the directory name. If you customize it to the value separate instead, Dired will display the disk space information on a separate line, following the line with the directory name, and will include in that line the space used by the files in the current directory as well as the available disk space. If you set this to nil, the available disk space information will not be displayed at all.

The command + (dired-create-directory) reads a directory’s name, and creates that directory. It signals an error if the directory already exists.

The command (dired-create-empty-file) reads a file name, and creates that file. It signals an error if the file already exists.

The command M-s a C-s (dired-do-isearch) begins a multi-file incremental search on the marked files. If a search fails at the end of a file, typing C-s advances to the next marked file and repeats the search; at the end of the last marked file, the search wraps around to the first marked file. The command M-s a M-C-s (dired-do-isearch-regexp) does the same with a regular expression search. See Repeating Incremental Search, for information about search repetition.

The command w (dired-copy-filename-as-kill) puts the names of the marked (or next n) files into the kill ring, as if you had killed them with C-w. The names are separated by a space.

With a zero prefix argument, this uses the absolute file name of each marked file. With just C-u as the prefix argument, it uses file names relative to the Dired buffer’s default directory. (This can still contain slashes if in a subdirectory.) As a special case, if point is on a directory header line, w gives you the absolute name of that directory. Any prefix argument or marked files are ignored in this case.

The main purpose of this command is so that you can yank the file names into arguments for other Emacs commands. It also displays what it added to the kill ring, so you can use it to display the list of currently marked files in the echo area.

If you have an HTML file in the file listing, it can be useful to view that file with a browser. The W (browse-url-of-dired-file) command will use the standard configured browser to view that file.

The command ( (dired-hide-details-mode) toggles whether details, such as ownership or file permissions, are visible in the current Dired buffer. By default, it also hides the targets of symbolic links, and all lines other than the header line and file/directory listings. To change this, customize the options dired-hide-details-hide-symlink-targets and dired-hide-details-hide-information-lines, respectively.

If the directory you are visiting is under version control (see Version Control), then the normal VC diff and log commands will operate on the selected files.

The command M-x dired-compare-directories is used to compare the current Dired buffer with another directory. It marks all the files that differ between the two directories. It puts these marks in all Dired buffers where these files are listed, which of course includes the current buffer.

The default comparison method (used if you type RET at the prompt) is to compare just the file names—file names differ if they do not appear in the other directory. You can specify more stringent comparisons by entering a Lisp expression, which can refer to the variables size1 and size2, the respective file sizes; mtime1 and mtime2, the last modification times in seconds, as floating point numbers; and fa1 and fa2, the respective file attribute lists (as returned by the function file-attributes). This expression is evaluated for each pair of like-named files, and files differ if the expression’s value is non-nil.

For instance, the sequence M-x dired-compare-directories RET (> mtime1 mtime2) RET marks files newer in this directory than in the other, and marks files older in the other directory than in this one. It also marks files with no counterpart, in both directories, as always.

On the X Window System, Emacs supports the drag and drop protocol. You can drag a file object from another program, and drop it onto a Dired buffer; this either moves, copies, or creates a link to the file in that directory. Precisely which action is taken is determined by the originating program. Dragging files out of a Dired buffer is also supported, by enabling the user option dired-mouse-drag-files, the mouse can be used to drag files onto other programs. When set to link, it will make the other program (typically a file manager) create a symbolic link to the file; when set to move, it will make the other program move the file to a new location, and setting it to any other non-nil value will make the other program open or create a copy of the file. The keyboard modifiers pressed during the drag-and-drop operation can also control what action the other program takes towards the file.



** Sorting Text

Emacs provides several commands for sorting text in the buffer. All operate on the contents of the region. They divide the text of the region into many sort records, identify a sort key for each record, and then reorder the records into the order determined by the sort keys. The records are ordered so that their keys are in alphabetical order, or, for numeric sorting, in numeric order. In alphabetic sorting, all upper-case letters ‘A’ through ‘Z’ come before lower-case ‘a’, in accordance with the ASCII character sequence (but sort-fold-case, described below, can change that).

The various sort commands differ in how they divide the text into sort records and in which part of each record is used as the sort key. Most of the commands make each line a separate sort record, but some commands use paragraphs or pages as sort records. Most of the sort commands use each entire sort record as its own sort key, but some use only a portion of the record as the sort key.

M-x sort-lines
Divide the region into lines, and sort by comparing the entire text of a line. A numeric argument means sort into descending order.

M-x sort-paragraphs
Divide the region into paragraphs, and sort by comparing the entire text of a paragraph (except for leading blank lines). A numeric argument means sort into descending order.

M-x sort-pages
Divide the region into pages, and sort by comparing the entire text of a page (except for leading blank lines). A numeric argument means sort into descending order.

M-x sort-fields
Divide the region into lines, and sort by comparing the contents of one field in each line. Fields are defined as separated by whitespace, so the first run of consecutive non-whitespace characters in a line constitutes field 1, the second such run constitutes field 2, etc.

Specify which field to sort by with a numeric argument: 1 to sort by field 1, etc.; the default is 1. A negative argument means count fields from the right instead of from the left; thus, minus 1 means sort by the last field. If several lines have identical contents in the field being sorted, they keep the same relative order that they had in the original buffer.

M-x sort-numeric-fields
Like M-x sort-fields except the specified field is converted to an integer for each line, and the numbers are compared. ‘10’ comes before ‘2’ when considered as text, but after it when considered as a number. By default, numbers are interpreted according to sort-numeric-base, but numbers beginning with ‘0x’ or ‘0’ are interpreted as hexadecimal and octal, respectively.

M-x sort-columns
Like M-x sort-fields except that the text within each line used for comparison comes from a fixed range of columns. With a prefix argument, sort in reverse order. See below for more details on this command.

M-x reverse-region
Reverse the order of the lines in the region. This is useful for sorting into descending order by fields, since those sort commands do not have a feature for doing that.

For example, if the buffer contains this:

On systems where clash detection (locking of files being edited) is
implemented, Emacs also checks the first time you modify a buffer
whether the file has changed on disk since it was last visited or
saved.  If it has, you are asked to confirm that you want to change
the buffer.
applying M-x sort-lines to the entire buffer produces this:

On systems where clash detection (locking of files being edited) is
implemented, Emacs also checks the first time you modify a buffer
saved.  If it has, you are asked to confirm that you want to change
the buffer.
whether the file has changed on disk since it was last visited or
where the upper-case ‘O’ sorts before all lower-case letters. If you use C-u 2 M-x sort-fields instead, you get this:

implemented, Emacs also checks the first time you modify a buffer
saved.  If it has, you are asked to confirm that you want to change
the buffer.
On systems where clash detection (locking of files being edited) is
whether the file has changed on disk since it was last visited or
where the sort keys were ‘Emacs’, ‘If’, ‘buffer’, ‘systems’ and ‘the’.

M-x sort-columns requires more explanation. You specify the columns by putting point at one of the columns and the mark at the other column. Because this means you cannot put point or the mark at the beginning of the first line of the text you want to sort, this command uses an unusual definition of “region”: all of the line point is in is considered part of the region, and so is all of the line the mark is in, as well as all the lines in between.

For example, to sort a table by information found in columns 10 to 15, you could put the mark on column 10 in the first line of the table, and point on column 15 in the last line of the table, and then run sort-columns. Equivalently, you could run it with the mark on column 15 in the first line and point on column 10 in the last line.

This can be thought of as sorting the rectangle specified by point and the mark, except that the text on each line to the left or right of the rectangle moves along with the text inside the rectangle. See Rectangles.

Many of the sort commands ignore case differences when comparing, if sort-fold-case is non-nil.


** Searching and Replacement

Like other editors, Emacs has commands to search for occurrences of a string. Emacs also has commands to replace occurrences of a string with a different string. There are also commands that do the same thing, but search for patterns instead of fixed strings.

You can also search multiple files under the control of xref (see Searching and Replacing with Identifiers) or through the Dired A command (see Operating on Files), or ask the grep program to do it (see Searching with Grep under Emacs).

*** Incremental Search

The principal search command in Emacs is incremental: it begins searching as soon as you type the first character of the search string. As you type in the search string, Emacs shows you where the string (as you have typed it so far) would be found. When you have typed enough characters to identify the place you want, you can stop. Depending on what you plan to do next, you may or may not need to terminate the search explicitly with RET.

C-s
Incremental search forward (isearch-forward).

C-r
Incremental search backward (isearch-backward).

You can also invoke incremental search from the menu bar’s ‘Edit->Search’ menu.

**** Basics of Incremental Search

C-s
Begin incremental search (isearch-forward).

C-r
Begin reverse incremental search (isearch-backward).

C-s (isearch-forward) starts a forward incremental search. It reads characters from the keyboard, and moves point just past the end of the next occurrence of those characters in the buffer.

For instance, if you type C-s and then F, that puts the cursor after the first ‘F’ that occurs in the buffer after the starting point. If you then type O, the cursor moves to just after the first ‘FO’; the ‘F’ in that ‘FO’ might not be the first ‘F’ previously found. After another O, the cursor moves to just after the first ‘FOO’.

At each step, Emacs highlights the current match—the buffer text that matches the search string—using the isearch face (see Text Faces). See Tailoring Search to Your Needs, for various options that customize this highlighting. The current search string is also displayed in the echo area.

If you make a mistake typing the search string, type DEL (isearch-delete-char). Each DEL cancels the last input item entered during the search. Emacs records a new input item whenever you type a command that changes the search string, the position of point, the success or failure of the search, the direction of the search, the position of the other end of the current search result, or the “wrappedness” of the search. See Errors in Incremental Search, for more about dealing with unsuccessful search.

When you are satisfied with the place you have reached, type RET (isearch-exit). This stops searching, leaving the cursor where the search brought it. Also, any command not specially meaningful in searches stops the searching and is then executed. Thus, typing C-a exits the search and then moves to the beginning of the line; typing one of the arrow keys exits the search and performs the respective movement command; etc. RET is necessary only if the next command you want to type is a printing character, DEL, RET, or another character that is special within searches (C-q, C-w, C-r, C-s, C-y, M-y, M-r, M-c, M-e, and some others described below). You can fine-tune the commands that exit the search; see Not Exiting Incremental Search.

As a special exception, entering RET when the search string is empty launches nonincremental search (see Nonincremental Search). (This can be customized; see Tailoring Search to Your Needs.)

To abandon the search and return to the place where you started, type ESC ESC ESC (isearch-cancel) or C-g C-g (isearch-abort).

When you exit the incremental search, it adds the original value of point to the mark ring, without activating the mark; you can thus use C-u C-SPC or C-x C-x to return to where you were before beginning the search. See The Mark Ring. (Emacs only does this if the mark was not already active; if the mark was active when you started the search, both C-u C-SPC and C-x C-x will go to the mark.)

To search backwards, use C-r (isearch-backward) instead of C-s to start the search. A backward search finds matches that end before the starting point, just as a forward search finds matches that begin after it.


**** Repeating Incremental Search

Suppose you search forward for ‘FOO’ and find a match, but not the one you expected to find: the ‘FOO’ you were aiming for occurs later in the buffer. In this event, type another C-s (isearch-repeat-forward) to move to the next occurrence of the search string, or C-r (isearch-repeat-backward) to move to the previous occurrence. You can repeat these commands any number of times. Alternatively, you can supply a numeric prefix argument of n to C-s and C-r to find the nth next or previous occurrence. If you overshoot, you can cancel some C-s commands with DEL. Similarly, each C-r (isearch-repeat-backward) in a backward incremental search repeats the backward search.

If you pause for a little while during incremental search, Emacs highlights all the other possible matches for the search string that are present on the screen. This helps you anticipate where you can get to by typing C-s or C-r to repeat the search. The other matches are highlighted differently from the current match, using the customizable face lazy-highlight (see Text Faces). If you don’t like this feature, you can disable it by setting isearch-lazy-highlight to nil. For other customizations related to highlighting matches, see Tailoring Search to Your Needs.

After exiting a search, you can search for the same string again by typing just C-s C-s. The first C-s is the key that invokes incremental search, and the second C-s means to search again for the last search string. Similarly, C-r C-r searches backward for the last search string. In determining the last search string, it doesn’t matter whether that string was searched for with C-s or C-r.

If you are searching forward but you realize you were looking for something before the starting point, type C-r to switch to a backward search, leaving the search string unchanged. Similarly, C-s in a backward search switches to a forward search.

When you change the direction of a search, the first command you type will, by default, remain on the same match, and the cursor will move to the other end of the match. To move to another match immediately, customize the variable isearch-repeat-on-direction-change to t.

If a search is failing and you ask to repeat it by typing another C-s, it starts again from the beginning of the buffer. Repeating a failing reverse search with C-r starts again from the end. This is called wrapping around, and ‘Wrapped’ appears in the search prompt once this has happened. If you keep on going past the original starting point of the search, it changes to ‘Overwrapped’, which means that you are revisiting matches that you have already seen.

You can control what happens when there are no more matches by customizing the isearch-wrap-pause user option. If it is t (the default), signal an error. (Repeating the search will wrap around.) If no, issue a ding and wrap immediately after reaching the last match. If no-ding, wrap immediately, but don’t ding. With the values no and no-ding the search will try to wrap around also on typing a character. Finally, if nil, never wrap, but just stop at the last match.

To reuse earlier search strings, use the search ring. The commands M-p (isearch-ring-retreat) and M-n (isearch-ring-advance) move through the ring to pick a search string to reuse. These commands leave the selected search ring element in the minibuffer, where you can edit it. Type C-s/C-r or RET to accept the string and start searching for it. The number of most recently used search strings saved in the search ring is specified by the variable search-ring-max, 16 by default.

To edit the current search string in the minibuffer without replacing it with items from the search ring, type M-e (isearch-edit-string) or click mouse-1 in the minibuffer. Type RET, C-s or C-r to finish editing the string and search for it. Type C-f or RIGHT to add to the search string characters following point from the buffer from which you started the search.


**** Isearch Yanking

In many cases, you will want to use text at or near point as your search string. The commands described in this subsection let you do that conveniently.

C-w (isearch-yank-word-or-char) appends the next character or word at point to the search string. This is an easy way to search for another occurrence of the text at point. (The decision of whether to copy a character or a word is heuristic.) With a prefix numeric argument of n, append the next n characters or words.

C-M-w (isearch-yank-symbol-or-char) appends the next character or symbol at point to the search string. This is an easy way to search for another occurrence of the symbol at point. (The decision of whether to copy a character or a symbol is heuristic.) With a prefix numeric argument of n, append the next n characters or symbols.

M-s C-e (isearch-yank-line) appends the rest of the current line to the search string. If point is already at the end of a line, it appends the next line. With a prefix argument n, it appends the next n lines.

Similarly, C-M-z (isearch-yank-until-char) appends to the search string everything from point until the next occurrence of a specified character (not including that character). This is especially useful for keyboard macros, for example in programming languages or markup languages in which that character marks a token boundary. With a prefix numeric argument of n, the command appends everything from point to the nth occurrence of the specified character.

Within incremental search, C-y (isearch-yank-kill) appends the current kill to the search string. M-y (isearch-yank-pop), if called after C-y during incremental search, replaces that appended text with an earlier kill, similar to the usual M-y (yank-pop) command. Clicking mouse-2 in the echo area appends the current X selection (see Cut and Paste with Other Window Applications) to the search string (isearch-yank-x-selection).

C-M-d (isearch-del-char) deletes the last character from the search string, and C-M-y (isearch-yank-char) appends the character after point to the search string. An alternative method to add the character after point is to enter the minibuffer with M-e (see Repeating Incremental Search) and type C-f or RIGHT at the end of the search string in the minibuffer. Each C-f or RIGHT you type adds another character following point to the search string.

Normally, when the search is case-insensitive, text yanked into the search string is converted to lower case, so that the search remains case-insensitive (see case folding). However, if the value of the variable search-upper-case (see search-upper-case) is other than not-yanks, that disables this down-casing.

To begin a new incremental search with the text near point yanked into the initial search string, type M-s M-. that runs the command isearch-forward-thing-at-point. If the region was active, then it yanks the text from the region into the search string. Otherwise, it tries to yank a URL, a symbol or an expression found near point. What to yank is defined by the user option isearch-forward-thing-at-point.


**** Errors in Incremental Search

If your string is not found at all, the echo area says ‘Failing I-Search’, and the cursor moves past the place where Emacs found as much of your string as it could. Thus, if you search for ‘FOOT’, and there is no ‘FOOT’, you might see the cursor after the ‘FOO’ in ‘FOOL’. In the echo area, the part of the search string that failed to match is highlighted using the face isearch-fail.

At this point, there are several things you can do. If your string was mistyped, use DEL to cancel a previous input item (see Basics of Incremental Search), C-M-d to erase one character at a time, or M-e to edit it. If you like the place you have found, you can type RET to remain there. Or you can type C-g, which removes from the search string the characters that could not be found (the ‘T’ in ‘FOOT’), leaving those that were found (the ‘FOO’ in ‘FOOT’). A second C-g at that point cancels the search entirely, returning point to where it was when the search started.

The quit command, C-g, does special things during searches; just what it does depends on the status of the search. If the search has found what you specified and is waiting for input, C-g cancels the entire search, moving the cursor back to where you started the search. If C-g is typed when there are characters in the search string that have not been found—because Emacs is still searching for them, or because it has failed to find them—then the search string characters which have not been found are discarded from the search string. With them gone, the search is now successful and waiting for more input, so a second C-g will cancel the entire search.


**** Special Input for Incremental Search

In addition to characters described in the previous subsections, some of the other characters you type during incremental search have special effects. They are described here.

To toggle lax space matching (see lax space matching), type M-s SPC.

To toggle case sensitivity of the search, type M-c or M-s c. See case folding. If the search string includes upper-case letters, the search is case-sensitive by default.

To toggle whether or not the search will consider similar and equivalent characters as a match, type M-s '. See character folding. If the search string includes accented characters, that disables character folding during that search.

To toggle whether or not the search will find text made invisible by overlays, type M-s i (isearch-toggle-invisible). See Outline Search. To make all incremental searches find matches inside invisible text, whether due to text properties or overlay properties, customize search-invisible to the value t.

To toggle between non-regexp and regexp incremental search, type M-r or M-s r (isearch-toggle-regexp). See Regular Expression Search.

To toggle symbol mode, type M-s _. See Symbol Search.

To search for a newline character, type C-j as part of the search string.

To search for non-ASCII characters, use one of the following methods during incremental search:

Type C-q (isearch-quote-char), followed by a non-graphic character or a sequence of octal digits. This adds a character to the search string, similar to inserting into a buffer using C-q (see Inserting Text). For example, C-q C-s during incremental search adds the ‘control-S’ character to the search string.
Use an input method (see Input Methods). If an input method is enabled in the current buffer when you start the search, the same method will be active in the minibuffer when you type the search string. While typing the search string, you can toggle the input method with C-\ (isearch-toggle-input-method). You can also turn on a non-default input method with C-^ (isearch-toggle-specified-input-method), which prompts for the name of the input method. When an input method is active during incremental search, the search prompt includes the input method mnemonic, like this:
I-search [im]:
where im is the mnemonic of the active input method. Any input method you enable during incremental search remains enabled in the current buffer afterwards. Finally, you can temporarily enable a transient input method (see transient input method) with C-x \ (isearch-transient-input-method) to insert a single character to the search string using an input method, and automatically disable the input method afterwards.

Type C-x 8 RET (isearch-char-by-name), followed by a Unicode name or code-point in hex. This adds the specified character into the search string, similar to the usual insert-char command (see Inserting Text).
You can also include Emoji sequences in the search string. Type C-x 8 e RET (isearch-emoji-by-name), followed by the Unicode name of an Emoji (for example, smiling face or heart with arrow). This adds the specified Emoji to the search string. If you don’t know the name of the Emoji you want to search for, you can use C-x 8 e l (emoji-list) and C-x 8 e d (emoji-describe) (see Input Methods).

Typing M-s o in incremental search invokes isearch-occur, which runs occur with the current search string. See occur.

Typing M-% (isearch-query-replace) in incremental search invokes query-replace or query-replace-regexp (depending on search mode) with the current search string used as the string to replace. A negative prefix argument means to replace backward. See Query Replace. Typing C-M-% (isearch-query-replace-regexp) invokes query-replace-regexp with the current search string used as the regexp to replace.

Typing M-TAB in incremental search invokes isearch-complete, which attempts to complete the search string using the search ring (the previous search strings you used) as a list of completion alternatives. See Completion. In many operating systems, the M-TAB key sequence is captured by the window manager; you then need to rebind isearch-complete to another key sequence if you want to use it (see Changing Key Bindings Interactively).

You can exit the search while leaving the matches highlighted by typing M-s h r (isearch-highlight-regexp). This runs highlight-regexp (see Interactive Highlighting), passing it the regexp derived from the search string and prompting you for the face to use for highlighting. To highlight whole lines containing matches (rather than just the matches), type M-s h l (isearch-highlight-lines-matching-regexp). In either case, to remove the highlighting, type M-s h u (unhighlight-regexp).

When incremental search is active, you can type C-h C-h (isearch-help-map) to access interactive help options, including a list of special key bindings. These key bindings are part of the keymap isearch-mode-map (see Keymaps).

When incremental search is active, typing M-s M-> will go to the last occurrence of the search string, and M-s M-< will go to the first occurrence. With a prefix numeric argument of n, these commands will go to the nth occurrence of the search string counting from the beginning or end of the buffer, respectively.


**** Not Exiting Incremental Search

This subsection describes how to control whether typing a command not specifically meaningful in searches exits the search before executing the command. It also describes three categories of commands which you can type without exiting the current incremental search, even though they are not themselves part of incremental search.

Normally, typing a command that is not bound by the incremental search exits the search before executing the command. Thus, the command operates on the buffer from which you invoked the search. However, if you customize the variable search-exit-option to append, the characters which you type that are not interpreted by the incremental search are simply appended to the search string. This is so you could include in the search string control characters, such as C-a, that would normally exit the search and invoke the command bound to them on the buffer.

Prefix Arguments ¶
In incremental search, when you type a command that specifies a prefix argument (see Numeric Arguments), by default it will apply either to the next action in the search or to the command that exits the search. In other words, entering a prefix argument will not by itself terminate the search.

In previous versions of Emacs, entering a prefix argument always terminated the search. You can revert to this behavior by setting the variable isearch-allow-prefix to nil.

When isearch-allow-scroll is non-nil (see below), prefix arguments always have the default behavior described above, i.e., they don’t terminate the search, even if isearch-allow-prefix is nil.

Scrolling Commands ¶
Normally, scrolling commands exit incremental search. But if you change the variable isearch-allow-scroll to a non-nil value, that enables the use of the scroll-bar, as well as keyboard scrolling commands like C-v, M-v, and C-l (see Scrolling), which have a non-nil scroll-command property, without exiting the search. This applies only to calling these commands via their bound key sequences—typing M-x will still exit the search. You can give prefix arguments to these commands in the usual way. This feature normally won’t let you scroll the current match out of visibility; but if you customize isearch-allow-scroll to the special value unlimited, that restriction is lifted.

The isearch-allow-scroll feature also affects some other commands, such as C-x 2 (split-window-below) and C-x ^ (enlarge-window), which don’t exactly scroll but do affect where the text appears on the screen. In fact, it affects any command that has a non-nil isearch-scroll property. So you can control which commands are affected by changing these properties.

For example, to make C-h l usable within an incremental search in all future Emacs sessions, use C-h c to find what command it runs (see Documentation for a Key), which is view-lossage. Then you can put the following line in your init file (see The Emacs Initialization File):

(put 'view-lossage 'isearch-scroll t)
This feature can be applied to any command that doesn’t permanently change point, the buffer contents, the match data, the current buffer, or the selected window and frame. The command must not itself attempt an incremental search. This feature is disabled if isearch-allow-scroll is nil (which it is by default).

Likewise, if you change the variable isearch-allow-motion to a non-nil value, this enables the use of the keyboard motion commands M-<, M->, C-v and M-v, to move respectively to the first occurrence of the current search string in the buffer, the last one, the first one after the current window, and the last one before the current window. The search direction does not change when these motion commands are used, unless you change the variable isearch-motion-changes-direction to a non-nil value, in which case the search direction is forward after M-< and C-v, and backward after M-> and M-v.

Motion Commands ¶
When isearch-yank-on-move is customized to shift, you can extend the search string by holding down the shift key while typing cursor motion commands. It will yank text that ends at the new position after moving point in the current buffer.

When isearch-yank-on-move is t, you can extend the search string without using the shift key for cursor motion commands, but it applies only for certain motion command that have the isearch-move property on their symbols.


**** Searching the Minibuffer

If you start an incremental search while the minibuffer is active, Emacs searches the contents of the minibuffer. Unlike searching an ordinary buffer, the search string is not shown in the echo area, because that is used to display the minibuffer.

If an incremental search fails in the minibuffer, it tries searching the minibuffer history. See Minibuffer History. You can visualize the minibuffer and its history as a series of pages, with the earliest history element on the first page and the current minibuffer on the last page. A forward search, C-s, searches forward to later pages; a reverse search, C-r, searches backwards to earlier pages. Like in ordinary buffer search, a failing search can wrap around, going from the last page to the first page or vice versa.

When the current match is on a history element, that history element is pulled into the minibuffer. If you exit the incremental search normally (e.g., by typing RET), it remains in the minibuffer afterwards. Canceling the search, with C-g, restores the contents of the minibuffer when you began the search.


*** Nonincremental Search

Emacs also has conventional nonincremental search commands, which require you to type the entire search string before searching begins.

C-s RET string RET
Search for string.

C-r RET string RET
Search backward for string.

To start a nonincremental search, first type C-s RET. This enters the minibuffer to read the search string; terminate the string with RET, and then the search takes place. If the string is not found, the search command signals an error.

When you type C-s RET, the C-s invokes incremental search as usual. That command is specially programmed to invoke the command for nonincremental search, if the string you specify is empty. (Such an empty argument would otherwise be useless.) C-r RET does likewise, invoking the nonincremental backward-searching command.

Nonincremental search can also be invoked from the menu bar’s ‘Edit->Search’ menu.

You can also use two simpler commands, M-x search-forward and M-x search-backward. These commands look for the literal strings you specify, and don’t support any of the lax-search features (see Lax Matching During Searching) except case folding.


*** Word Search

A word search finds a sequence of words without regard to the type of punctuation between them. For instance, if you enter a search string that consists of two words separated by a single space, the search matches any sequence of those two words separated by one or more spaces, newlines, or other punctuation characters. This is particularly useful for searching text documents, because you don’t have to worry whether the words you are looking for are separated by newlines or spaces. Note that major modes for programming languages or other specialized modes can modify the definition of a word to suit their syntactic needs.

M-s w
If incremental search is active, toggle word search mode (isearch-toggle-word); otherwise, begin an incremental forward word search (isearch-forward-word).

M-s w RET words RET
Search for words, using a forward nonincremental word search.

M-s w C-r RET words RET
Search backward for words, using a nonincremental word search.

M-s M-w
Search the Web for the text in region.

To begin a forward incremental word search, type M-s w. If incremental search is not already active, this runs the command isearch-forward-word. If incremental search is already active (whether a forward or backward search), M-s w runs the command isearch-toggle-word, which switches to a word search while keeping the direction of the search and the current search string unchanged. You can toggle word search back off by typing M-s w again.

To begin a nonincremental word search, type M-s w RET for a forward search, or M-s w C-r RET for a backward search. These run the commands word-search-forward and word-search-backward respectively.

Incremental and nonincremental word searches differ slightly in the way they find a match. In a nonincremental word search, each word in the search string must exactly match a whole word. In an incremental word search, the matching is more lax: while you are typing the search string, its first and last words need not match whole words. This is so that the matching can proceed incrementally as you type. This additional laxity does not apply to the lazy highlight (see Incremental Search), which always matches whole words. While you are typing the search string, ‘Pending’ appears in the search prompt until you use a search repeating key like C-s.

The word search commands don’t perform character folding, and toggling lax whitespace matching (see lax space matching) has no effect on them.

To search the Web for the text in region, type M-s M-w. This command performs an Internet search for the words in region using the search engine whose URL is specified by the variable eww-search-prefix (see EWW in The Emacs Web Wowser Manual). If the region is not active, or doesn’t contain any words, this command prompts the user for a URL or keywords to search.


*** Symbol Search

A symbol search is much like an ordinary search, except that the boundaries of the search must match the boundaries of a symbol. The meaning of symbol in this context depends on the major mode, and usually refers to a source code token, such as a Lisp symbol in Emacs Lisp mode. For instance, if you perform an incremental symbol search for the Lisp symbol forward-word, it would not match isearch-forward-word. This feature is thus mainly useful for searching source code.

M-s _ ¶
If incremental search is active, toggle symbol search mode (isearch-toggle-symbol); otherwise, begin an incremental forward symbol search (isearch-forward-symbol).

M-s .
Start a symbol incremental search forward with the symbol found near point added to the search string initially.

M-s _ RET symbol RET
Search forward for symbol, nonincrementally.

M-s _ C-r RET symbol RET
Search backward for symbol, nonincrementally.

To begin a forward incremental symbol search, type M-s _ (or M-s . if the symbol to search is near point). If incremental search is not already active, M-s _ runs the command isearch-forward-symbol and M-s . runs the command isearch-forward-symbol-at-point. With a numeric prefix argument of n, M-s . will search for the nthe next occurrence of the symbol at point; negative values of n search backwards. If incremental search is already active, M-s _ switches to a symbol search, preserving the direction of the search and the current search string; you can disable symbol search by typing M-s _ again. In incremental symbol search, while you are typing the search string, only the beginning of the search string is required to match the beginning of a symbol, and ‘Pending’ appears in the search prompt until you use a search repeating key like C-s.

To begin a nonincremental symbol search, type M-s _ RET for a forward search, or M-s _ C-r RET or a backward search. In nonincremental symbol searches, the beginning and end of the search string are required to match the beginning and end of a symbol, respectively.

The symbol search commands don’t perform character folding, and toggling lax whitespace matching (see lax space matching) has no effect on them.


*** Regular Expression Search

A regular expression (or regexp for short) is a pattern that denotes a class of alternative strings to match. Emacs provides both incremental and nonincremental ways to search for a match for a regexp. The syntax of regular expressions is explained in the next section.

C-M-s
Begin incremental regexp search (isearch-forward-regexp).

C-M-r
Begin reverse incremental regexp search (isearch-backward-regexp).

Incremental search for a regexp is done by typing C-M-s (isearch-forward-regexp), by invoking C-s with a prefix argument (whose value does not matter), or by typing M-r within a forward incremental search. This command reads a search string incrementally just like C-s, but it treats the search string as a regexp rather than looking for an exact match against the text in the buffer. Each time you add text to the search string, you make the regexp longer, and the new regexp is searched for. To search backward for a regexp, use C-M-r (isearch-backward-regexp), C-r with a prefix argument, or M-r within a backward incremental search.

All of the special key sequences in an ordinary incremental search (see Special Input for Incremental Search) do similar things in an incremental regexp search. For instance, typing C-s immediately after starting the search retrieves the last incremental search regexp used and searches forward for it. Incremental regexp and non-regexp searches have independent defaults. They also have separate search rings, which you can access with M-p and M-n. The maximum number of search regexps saved in the search ring is determined by the value of regexp-search-ring-max, 16 by default.

Unlike ordinary incremental search, incremental regexp search does not use lax space matching by default. To toggle this feature use M-s SPC (isearch-toggle-lax-whitespace). Then any SPC typed in incremental regexp search will match any sequence of one or more whitespace characters. The variable search-whitespace-regexp specifies the regexp for the lax space matching. See Special Input for Incremental Search.

Also unlike ordinary incremental search, incremental regexp search cannot use character folding (see Lax Matching During Searching). (If you toggle character folding during incremental regexp search with M-s ', the search becomes a non-regexp search and the search pattern you typed is interpreted as a literal string.)

In some cases, adding characters to the regexp in an incremental regexp search can make the cursor move back and start again. For example, if you have searched for ‘foo’ and you add ‘\|bar’, the cursor backs up in case the first ‘bar’ precedes the first ‘foo’. (The prompt will change to say “Pending” to notify the user that this recalculation has happened.) See Syntax of Regular Expressions.

Forward and backward regexp search are not symmetrical, because regexp matching in Emacs always operates forward, starting with the beginning of the regexp. Thus, forward regexp search scans forward, trying a forward match at each possible starting position. Backward regexp search scans backward, trying a forward match at each possible starting position. These search methods are not mirror images.

Nonincremental search for a regexp is done with the commands re-search-forward and re-search-backward. You can invoke these with M-x, or by way of incremental regexp search with C-M-s RET and C-M-r RET. When you invoke these commands with M-x, they search for the exact regexp you specify, and thus don’t support any lax-search features (see Lax Matching During Searching) except case folding.

If you use the incremental regexp search commands with a prefix argument, they perform ordinary string search, like isearch-forward and isearch-backward. See Incremental Search.


*** Syntax of Regular Expressions

This section (and this manual in general) describes regular expression features that users typically use. See Regular Expressions in The Emacs Lisp Reference Manual, for additional features used mainly in Lisp programs.

Regular expressions have a syntax in which a few characters are special constructs and the rest are ordinary. An ordinary character matches that same character and nothing else. The special characters are ‘$^.*+?[\’. The character ‘]’ is special if it ends a character alternative (see below). The character ‘-’ is special inside a character alternative. Any other character appearing in a regular expression is ordinary, unless a ‘\’ precedes it. (When you use regular expressions in a Lisp program, each ‘\’ must be doubled, see the example near the end of this section.)

For example, ‘f’ is not a special character, so it is ordinary, and therefore ‘f’ is a regular expression that matches the string ‘f’ and no other string. (It does not match the string ‘ff’.) Likewise, ‘o’ is a regular expression that matches only ‘o’. (When case distinctions are being ignored, these regexps also match ‘F’ and ‘O’, but we consider this a generalization of “the same string”, rather than an exception.)

Any two regular expressions a and b can be concatenated. The result is a regular expression which matches a string if a matches some amount of the beginning of that string and b matches the rest of the string. As a trivial example, concatenating the regular expressions ‘f’ and ‘o’ gives the regular expression ‘fo’, which matches only the string ‘fo’. To do something less trivial, you need to use one of the special characters. Here is a list of them.

. (Period)
is a special character that matches any single character except a newline. For example, the regular expressions ‘a.b’ matches any three-character string that begins with ‘a’ and ends with ‘b’.

*
is not a construct by itself; it is a postfix operator that means to match the preceding regular expression repetitively any number of times, as many times as possible. Thus, ‘o*’ matches any number of ‘o’s, including no ‘o’s.

‘*’ always applies to the smallest possible preceding expression. Thus, ‘fo*’ has a repeating ‘o’, not a repeating ‘fo’. It matches ‘f’, ‘fo’, ‘foo’, and so on.

The matcher processes a ‘*’ construct by matching, immediately, as many repetitions as can be found. Then it continues with the rest of the pattern. If that fails, backtracking occurs, discarding some of the matches of the ‘*’-modified construct in case that makes it possible to match the rest of the pattern. For example, in matching ‘ca*ar’ against the string ‘caaar’, the ‘a*’ first tries to match all three ‘a’s; but the rest of the pattern is ‘ar’ and there is only ‘r’ left to match, so this try fails. The next alternative is for ‘a*’ to match only two ‘a’s. With this choice, the rest of the regexp matches successfully.

+
is a postfix operator, similar to ‘*’ except that it must match the preceding expression at least once. Thus, ‘ca+r’ matches the strings ‘car’ and ‘caaaar’ but not the string ‘cr’, whereas ‘ca*r’ matches all three strings.

?
is a postfix operator, similar to ‘*’ except that it can match the preceding expression either once or not at all. Thus, ‘ca?r’ matches ‘car’ or ‘cr’, and nothing else.

*?, +?, ?? ¶
are non-greedy variants of the operators above. The normal operators ‘*’, ‘+’, ‘?’ match as much as they can, as long as the overall regexp can still match. With a following ‘?’, they will match as little as possible.

Thus, both ‘ab*’ and ‘ab*?’ can match the string ‘a’ and the string ‘abbbb’; but if you try to match them both against the text ‘abbb’, ‘ab*’ will match it all (the longest valid match), while ‘ab*?’ will match just ‘a’ (the shortest valid match).

Non-greedy operators match the shortest possible string starting at a given starting point; in a forward search, though, the earliest possible starting point for match is always the one chosen. Thus, if you search for ‘a.*?$’ against the text ‘abbab’ followed by a newline, it matches the whole string. Since it can match starting at the first ‘a’, it does.

[ … ]
is a set of alternative characters, or a character set, beginning with ‘[’ and terminated by ‘]’.

In the simplest case, the characters between the two brackets are what this set can match. Thus, ‘[ad]’ matches either one ‘a’ or one ‘d’, and ‘[ad]*’ matches any string composed of just ‘a’s and ‘d’s (including the empty string). It follows that ‘c[ad]*r’ matches ‘cr’, ‘car’, ‘cdr’, ‘caddaar’, etc.

You can also include character ranges in a character set, by writing the starting and ending characters with a ‘-’ between them. Thus, ‘[a-z]’ matches any lower-case ASCII letter. Ranges may be intermixed freely with individual characters, as in ‘[a-z$%.]’, which matches any lower-case ASCII letter or ‘$’, ‘%’ or period. As another example, ‘[α-ωί]’ matches all lower-case Greek letters.

You can also include certain special character classes in a character set. A ‘[:’ and balancing ‘:]’ enclose a character class inside a set of alternative characters. For instance, ‘[[:alnum:]]’ matches any letter or digit. See Char Classes in The Emacs Lisp Reference Manual, for a list of character classes.

To include a ‘]’ in a character set, you must make it the first character. For example, ‘[]a]’ matches ‘]’ or ‘a’. To include a ‘-’, write ‘-’ as the last character of the set, tho you can also put it first or after a range. Thus, ‘[]-]’ matches both ‘]’ and ‘-’.

To include ‘^’ in a set, put it anywhere but at the beginning of the set. (At the beginning, it complements the set—see below.)

When you use a range in case-insensitive search, you should write both ends of the range in upper case, or both in lower case, or both should be non-letters. The behavior of a mixed-case range such as ‘A-z’ is somewhat ill-defined, and it may change in future Emacs versions.

[^ … ]
‘[^’ begins a complemented character set, which matches any character except the ones specified. Thus, ‘[^a-z0-9A-Z]’ matches all characters except ASCII letters and digits.

‘^’ is not special in a character set unless it is the first character. The character following the ‘^’ is treated as if it were first (in other words, ‘-’ and ‘]’ are not special there).

A complemented character set can match a newline, unless newline is mentioned as one of the characters not to match. This is in contrast to the handling of regexps in programs such as grep.

^
is a special character that matches the empty string, but only at the beginning of a line in the text being matched. Otherwise it fails to match anything. Thus, ‘^foo’ matches a ‘foo’ that occurs at the beginning of a line.

For historical compatibility reasons, ‘^’ can be used with this meaning only at the beginning of the regular expression, or after ‘\(’ or ‘\|’.

$
is similar to ‘^’ but matches only at the end of a line. Thus, ‘x+$’ matches a string of one ‘x’ or more at the end of a line.

For historical compatibility reasons, ‘$’ can be used with this meaning only at the end of the regular expression, or before ‘\)’ or ‘\|’.

\
has two functions: it quotes the special characters (including ‘\’), and it introduces additional special constructs.

Because ‘\’ quotes special characters, ‘\$’ is a regular expression that matches only ‘$’, and ‘\[’ is a regular expression that matches only ‘[’, and so on.

See the following section for the special constructs that begin with ‘\’.

Note: for historical compatibility, special characters are treated as ordinary ones if they are in contexts where their special meanings make no sense. For example, ‘*foo’ treats ‘*’ as ordinary since there is no preceding expression on which the ‘*’ can act. It is poor practice to depend on this behavior; it is better to quote the special character anyway, regardless of where it appears.

As a ‘\’ is not special inside a set of alternative characters, it can never remove the special meaning of ‘-’, ‘^’ or ‘]’. You should not quote these characters when they have no special meaning. This would not clarify anything, since backslashes can legitimately precede these characters where they have special meaning, as in ‘[^\]’ ("[^\\]" for Lisp string syntax), which matches any single character except a backslash.


*** Backslash in Regular Expressions

For the most part, ‘\’ followed by any character matches only that character. However, there are several exceptions: two-character sequences starting with ‘\’ that have special meanings. The second character in the sequence is always an ordinary character when used on its own. Here is a table of ‘\’ constructs.

\|
specifies an alternative. Two regular expressions a and b with ‘\|’ in between form an expression that matches some text if either a matches it or b matches it. It works by trying to match a, and if that fails, by trying to match b.

Thus, ‘foo\|bar’ matches either ‘foo’ or ‘bar’ but no other string.

‘\|’ applies to the largest possible surrounding expressions. Only a surrounding ‘\( … \)’ grouping can limit the grouping power of ‘\|’.

Full backtracking capability exists to handle multiple uses of ‘\|’.

\( … \)
is a grouping construct that serves three purposes:

To enclose a set of ‘\|’ alternatives for other operations. Thus, ‘\(foo\|bar\)x’ matches either ‘foox’ or ‘barx’.
To enclose a complicated expression for the postfix operators ‘*’, ‘+’ and ‘?’ to operate on. Thus, ‘ba\(na\)*’ matches ‘bananana’, etc., with any (zero or more) number of ‘na’ strings.
To record a matched substring for future reference.
This last application is not a consequence of the idea of a parenthetical grouping; it is a separate feature that is assigned as a second meaning to the same ‘\( … \)’ construct. In practice there is usually no conflict between the two meanings; when there is a conflict, you can use a shy group, described below.

\(?: … \) ¶
specifies a shy group that does not record the matched substring; you can’t refer back to it with ‘\d’ (see below). This is useful in mechanically combining regular expressions, so that you can add groups for syntactic purposes without interfering with the numbering of the groups that are meant to be referred to.

\d ¶
matches the same text that matched the dth occurrence of a ‘\( … \)’ construct. This is called a back reference.

After the end of a ‘\( … \)’ construct, the matcher remembers the beginning and end of the text matched by that construct. Then, later on in the regular expression, you can use ‘\’ followed by the digit d to mean “match the same text matched the dth ‘\( … \)’ construct”.

The strings matching the first nine ‘\( … \)’ constructs appearing in a regular expression are assigned numbers 1 through 9 in the order that the open-parentheses appear in the regular expression. So you can use ‘\1’ through ‘\9’ to refer to the text matched by the corresponding ‘\( … \)’ constructs.

For example, ‘\(.*\)\1’ matches any newline-free string that is composed of two identical halves. The ‘\(.*\)’ matches the first half, which may be anything, but the ‘\1’ that follows must match the same exact text.

If a particular ‘\( … \)’ construct matches more than once (which can easily happen if it is followed by ‘*’), only the last match is recorded.

\{m\}
is a postfix operator specifying m repetitions—that is, the preceding regular expression must match exactly m times in a row. For example, ‘x\{4\}’ matches the string ‘xxxx’ and nothing else.

\{m,n\}
is a postfix operator specifying between m and n repetitions—that is, the preceding regular expression must match at least m times, but no more than n times. If n is omitted, then there is no upper limit, but the preceding regular expression must match at least m times.
‘\{0,1\}’ is equivalent to ‘?’.
‘\{0,\}’ is equivalent to ‘*’.
‘\{1,\}’ is equivalent to ‘+’.

\`
matches the empty string, but only at the beginning of the string or buffer (or its accessible portion) being matched against.

\'
matches the empty string, but only at the end of the string or buffer (or its accessible portion) being matched against.

\=
matches the empty string, but only at point.

\b
matches the empty string, but only at the beginning or end of a word. Thus, ‘\bfoo\b’ matches any occurrence of ‘foo’ as a separate word. ‘\bballs?\b’ matches ‘ball’ or ‘balls’ as a separate word.

‘\b’ matches at the beginning or end of the buffer regardless of what text appears next to it.

\B
matches the empty string, but not at the beginning or end of a word.

\<
matches the empty string, but only at the beginning of a word. ‘\<’ matches at the beginning of the buffer only if a word-constituent character follows.

\>
matches the empty string, but only at the end of a word. ‘\>’ matches at the end of the buffer only if the contents end with a word-constituent character.

\w
matches any word-constituent character. The syntax table determines which characters these are. See Syntax Tables in The Emacs Lisp Reference Manual.

\W
matches any character that is not a word-constituent.

\_<
matches the empty string, but only at the beginning of a symbol. A symbol is a sequence of one or more symbol-constituent characters. A symbol-constituent character is a character whose syntax is either ‘w’ or ‘_’. ‘\_<’ matches at the beginning of the buffer only if a symbol-constituent character follows. As with words, the syntax table determines which characters are symbol-constituent.

\_>
matches the empty string, but only at the end of a symbol. ‘\_>’ matches at the end of the buffer only if the contents end with a symbol-constituent character.

\sc
matches any character whose syntax is c. Here c is a character that designates a particular syntax class: thus, ‘w’ for word constituent, ‘-’ or ‘ ’ for whitespace, ‘.’ for ordinary punctuation, etc. See Syntax Class Table in The Emacs Lisp Reference Manual.

\Sc
matches any character whose syntax is not c.

\cc
matches any character that belongs to the category c. For example, ‘\cc’ matches Chinese characters, ‘\cg’ matches Greek characters, etc. For the description of the known categories, type M-x describe-categories RET.

\Cc
matches any character that does not belong to category c.

The constructs that pertain to words and syntax are controlled by the setting of the syntax table. See Syntax Tables in The Emacs Lisp Reference Manual.


*** Regular Expression Example
Here is an example of a regexp—similar to the regexp that Emacs uses, by default, to recognize the end of a sentence, not including the following space (i.e., the variable sentence-end-base):

[.?!][]\"')}]*
This contains two parts in succession: a character set matching period, ‘?’, or ‘!’, and a character set matching close-brackets, quotes, or parentheses, repeated zero or more times.


*** Lax Matching During Searching

Normally, you’d want search commands to disregard certain minor differences between the search string you type and the text being searched. For example, sequences of whitespace characters of different length are usually perceived as equivalent; letter-case differences usually don’t matter; etc. This is known as character equivalence.

This section describes the Emacs lax search features, and how to tailor them to your needs.

By default, search commands perform lax space matching: each space, or sequence of spaces, matches any sequence of one or more whitespace characters in the text. More precisely, Emacs matches each sequence of space characters in the search string to a regular expression specified by the user option search-whitespace-regexp. The default value of this option considers any sequence of spaces and tab characters as whitespace. Hence, ‘foo bar’ matches ‘foo bar’, ‘foo  bar’, ‘foo   bar’, and so on (but not ‘foobar’). If you want to make spaces match sequences of newlines as well as spaces and tabs, customize the option to make its value be the regular expression ‘[ \t\n]+’. (The default behavior of the incremental regexp search is different; see Regular Expression Search.)

If you want whitespace characters to match exactly, you can turn lax space matching off by typing M-s SPC (isearch-toggle-lax-whitespace) within an incremental search. Another M-s SPC turns lax space matching back on. To disable lax whitespace matching for all searches, change search-whitespace-regexp to nil; then each space in the search string matches exactly one space.

Searches in Emacs by default ignore the case of the text they are searching through, if you specify the search string in lower case. Thus, if you specify searching for ‘foo’, then ‘Foo’ and ‘fOO’ also match. Regexps, and in particular character sets, behave likewise: ‘[ab]’ matches ‘a’ or ‘A’ or ‘b’ or ‘B’. This feature is known as case folding, and it is supported in both incremental and non-incremental search modes.

An upper-case letter anywhere in the search string makes the search case-sensitive. Thus, searching for ‘Foo’ does not find ‘foo’ or ‘FOO’. This applies to regular expression search as well as to literal string search. The effect ceases if you delete the upper-case letter from the search string. The variable search-upper-case controls this: if it is non-nil, an upper-case character in the search string makes the search case-sensitive; setting it to nil disables this effect of upper-case characters. The default value of this variable is not-yanks, which makes search case-sensitive if there are upper-case letters in the search string, and also causes text yanked into the search string (see Isearch Yanking) to be down-cased, so that such searches are case-insensitive by default.

If you set the variable case-fold-search to nil, then all letters must match exactly, including case. This is a per-buffer variable; altering the variable normally affects only the current buffer, unless you change its default value. See Local Variables. This variable applies to nonincremental searches also, including those performed by the replace commands (see Replacement Commands) and the minibuffer history matching commands (see Minibuffer History).

Typing M-c or M-s c (isearch-toggle-case-fold) within an incremental search toggles the case sensitivity of that search. The effect does not extend beyond the current incremental search, but it does override the effect of adding or removing an upper-case letter in the current search.

Several related variables control case-sensitivity of searching and matching for specific commands or activities. For instance, tags-case-fold-search controls case sensitivity for find-tag. To find these variables, do M-x apropos-variable RET case-fold-search RET.

Case folding disregards case distinctions among characters, making upper-case characters match lower-case variants, and vice versa. A generalization of case folding is character folding, which disregards wider classes of distinctions among similar characters. For instance, under character folding the letter a matches all of its accented cousins like ä and á, i.e., the match disregards the diacritics that distinguish these variants. In addition, a matches other characters that resemble it, or have it as part of their graphical representation, such as U+00AA FEMININE ORDINAL INDICATOR and U+24D0 CIRCLED LATIN SMALL LETTER A (which looks like a small a inside a circle). Similarly, the ASCII double-quote character " matches all the other variants of double quotes defined by the Unicode standard. Finally, character folding can make a sequence of one or more characters match another sequence of a different length: for example, the sequence of two characters ff matches U+FB00 LATIN SMALL LIGATURE FF and the sequence (a) matches U+249C PARENTHESIZED LATIN SMALL LETTER A. Character sequences that are not identical, but match under character folding are known as equivalent character sequences.

Generally, search commands in Emacs do not by default perform character folding in order to match equivalent character sequences. You can enable this behavior by customizing the variable search-default-mode to char-fold-to-regexp. See Tailoring Search to Your Needs. Within an incremental search, typing M-s ' (isearch-toggle-char-fold) toggles character folding, but only for that search. (Replace commands have a different default, controlled by a separate option; see Replace Commands and Lax Matches.)

By default, typing an explicit variant of a character, such as ä, as part of the search string doesn’t match its base character, such as a. But if you customize the variable char-fold-symmetric to t, then search commands treat equivalent characters the same and use of any of a set of equivalent characters in a search string finds any of them in the text being searched, so typing an accented character ä matches the letter a as well as all the other variants like á.

You can add new foldings using the customizable variable char-fold-include, or remove the existing ones using the customizable variable char-fold-exclude. You can also customize char-fold-override to t to disable all the character equivalences except those you add yourself using char-fold-include.


*** Replacement Commands

Emacs provides several commands for performing search-and-replace operations. In addition to the simple M-x replace-string command, there is M-% (query-replace), which presents each occurrence of the search pattern and asks you whether to replace it.

The replace commands normally operate on the text from point to the end of the buffer. When the region is active, they operate on it instead (see The Mark and the Region). The basic replace commands replace one search string (or regexp) with one replacement string. It is possible to perform several replacements in parallel, using the command expand-region-abbrevs (see Controlling Abbrev Expansion).

**** Unconditional Replacement

M-x replace-string RET string RET newstring RET
Replace every occurrence of string with newstring.

To replace every instance of ‘foo’ after point with ‘bar’, use the command M-x replace-string with the two arguments ‘foo’ and ‘bar’. Replacement happens only in the text after point, so if you want to cover the whole buffer you must go to the beginning first. All occurrences up to the end of the buffer are replaced; to limit replacement to part of the buffer, activate the region around that part. When the region is active, replacement is limited to the region (see The Mark and the Region).

When replace-string exits, it leaves point at the last occurrence replaced. It adds the prior position of point (where the replace-string command was issued) to the mark ring, without activating the mark; use C-u C-SPC to move back there. See The Mark Ring.

A prefix argument restricts replacement to matches that are surrounded by word boundaries.

See Replace Commands and Lax Matches, for details about case-sensitivity and character folding in replace commands.


**** Regexp Replacement

The M-x replace-string command replaces exact matches for a single string. The similar command M-x replace-regexp replaces any match for a specified regular expression pattern (see Syntax of Regular Expressions).

M-x replace-regexp RET regexp RET newstring RET
Replace every match for regexp with newstring.

In replace-regexp, the newstring need not be constant: it can refer to all or part of what is matched by the regexp. ‘\&’ in newstring stands for the entire match being replaced. ‘\d’ in newstring, where d is a digit starting from 1, stands for whatever matched the dth parenthesized grouping in regexp. (This is called a “back reference”.) ‘\#’ refers to the count of replacements already made in this command, as a decimal number. In the first replacement, ‘\#’ stands for ‘0’; in the second, for ‘1’; and so on. For example,

M-x replace-regexp RET c[ad]+r RET \&-safe RET
replaces (for example) ‘cadr’ with ‘cadr-safe’ and ‘cddr’ with ‘cddr-safe’.

M-x replace-regexp RET \(c[ad]+r\)-safe RET \1 RET
performs the inverse transformation. To include a ‘\’ in the text to replace with, you must enter ‘\\’.

If you want to enter part of the replacement string by hand each time, use ‘\?’ in the replacement string. Each replacement will ask you to edit the replacement string in the minibuffer, putting point where the ‘\?’ was.

The remainder of this subsection is intended for specialized tasks and requires knowledge of Lisp. Most readers can skip it.

You can use Lisp expressions to calculate parts of the replacement string. To do this, write ‘\,’ followed by the expression in the replacement string. Each replacement calculates the value of the expression and converts it to text without quoting (if it’s a string, this means using the string’s contents), and uses it in the replacement string in place of the expression itself. If the expression is a symbol, one space in the replacement string after the symbol name goes with the symbol name, so the value replaces them both.

Inside such an expression, you can use some special sequences. ‘\&’ and ‘\d’ refer here, as usual, to the entire match as a string, and to a submatch as a string. d may be multiple digits, and the value of ‘\d’ is nil if the d’th parenthesized grouping did not match. You can also use ‘\#&’ and ‘\#d’ to refer to those matches as numbers (this is valid when the match or submatch has the form of a numeral). ‘\#’ here too stands for the number of already-completed replacements.

For example, we can exchange ‘x’ and ‘y’ this way:

M-x replace-regexp RET \(x\)\|y RET
\,(if \1 "y" "x") RET
For computing replacement strings for ‘\,’, the format function is often useful (see Formatting Strings in The Emacs Lisp Reference Manual). For example, to add consecutively numbered strings like ‘ABC00042’ to columns 73 to 80 (unless they are already occupied), you can use

M-x replace-regexp RET ^.\{0,72\}$ RET
\,(format "%-72sABC%05d" \& \#) RET


**** Replace Commands and Lax Matches

This subsection describes the behavior of replace commands with respect to lax matches (see Lax Matching During Searching) and how to customize it. In general, replace commands mostly default to stricter matching than their search counterparts.

Unlike incremental search, the replacement commands do not use lax space matching (see lax space matching) by default. To enable lax space matching for replacement, change the variable replace-lax-whitespace to non-nil. (This only affects how Emacs finds the text to replace, not the replacement text.)

A companion variable replace-regexp-lax-whitespace controls whether query-replace-regexp uses lax whitespace matching when searching for patterns.

If the first argument of a replace command is all lower case, the command ignores case while searching for occurrences to replace—provided case-fold-search is non-nil and search-upper-case is also non-nil. If search-upper-case (see search-upper-case) is nil, whether searching ignores case is determined by case-fold-search alone, regardless of letter-case of the command’s first argument. If case-fold-search is set to nil, case is always significant in all searches.

In addition, when the second argument of a replace command is all or partly lower case, replacement commands try to preserve the case pattern of each occurrence. Thus, the command

M-x replace-string RET foo RET bar RET
replaces a lower case ‘foo’ with a lower case ‘bar’, an all-caps ‘FOO’ with ‘BAR’, and a capitalized ‘Foo’ with ‘Bar’. (These three alternatives—lower case, all caps, and capitalized, are the only ones that replace-string can distinguish.) Note that Emacs decides whether to up-case or capitalize the replacement text by analyzing each word in the text being replaced, and will preserve the letter-case of the replaced text only if all of its words use the same letter-case. Thus, the command

M-x replace-string RET foo bar RET baz quux RET
replaces ‘Foo Bar’ with ‘Baz Quux’ because both words in ‘Foo Bar’ are capitalized. By contrast, the same command replaces ‘Foo bar’ with ‘baz quux’, i.e. it leaves the letter-case of the replacement text unchanged, since the two words in ‘Foo bar’ use different capitalization. What exactly is considered a “word” depends on the syntax tables that are in effect in the current buffer (see Syntax Tables in The Emacs Lisp Reference Manual); thus, ‘Foo_Bar’ is two words in Text mode, but could be a single word in some major mode that supports a programming language.

If upper-case letters are used in the replacement string, they remain upper case every time that text is inserted. If upper-case letters are used in the first argument, the second argument is always substituted exactly as given, with no case conversion. Likewise, if either case-replace or case-fold-search is set to nil, replacement is done without case conversion.

The replacement commands by default do not use character folding (see character folding) when looking for the text to replace. To enable character folding for matching in query-replace and replace-string, set the variable replace-char-fold to a non-nil value. (This setting does not affect the replacement text, only how Emacs finds the text to replace. It also doesn’t affect replace-regexp.)


**** Query Replace

M-% string RET newstring RET
Replace some occurrences of string with newstring.

C-M-% regexp RET newstring RET
Replace some matches for regexp with newstring.

If you want to change only some of the occurrences of ‘foo’ to ‘bar’, not all of them, use M-% (query-replace). This command finds occurrences of ‘foo’ one by one, displays each occurrence and asks you whether to replace it. Aside from querying, query-replace works just like replace-string (see Unconditional Replacement). In particular, it preserves case provided that case-replace is non-nil, as it normally is (see Replace Commands and Lax Matches). A numeric argument means to consider only occurrences that are bounded by word-delimiter characters. A negative prefix argument replaces backward.

C-M-% performs regexp search and replace (query-replace-regexp). It works like replace-regexp except that it queries like query-replace.

You can reuse earlier replacements with these commands. When query-replace or query-replace-regexp prompts for the search string, use M-p and M-n to show previous replacements in the form ‘from -> to’, where from is the search pattern, to is its replacement, and the separator between them is determined by the value of the variable query-replace-from-to-separator. Type RET to select the desired replacement. If the value of this variable is nil, replacements are not added to the command history, and cannot be reused.

These commands highlight the current match using the face query-replace. You can disable this highlight by setting the variable query-replace-highlight to nil. They highlight other matches using lazy-highlight just like incremental search (see Incremental Search); this can be disabled by setting query-replace-lazy-highlight to nil. By default, query-replace-regexp will show the substituted replacement string for the current match in the minibuffer. If you want to keep special sequences ‘\&’ and ‘\n’ unexpanded, customize query-replace-show-replacement variable. Like search-highlight-submatches highlights subexpressions in incremental search (see Tailoring Search to Your Needs), the variable query-replace-highlight-submatches defines whether to highlight subexpressions in the regexp replacement commands.

The variable query-replace-skip-read-only, if set non-nil, will cause replacement commands to ignore matches in read-only text. The default is not to ignore them.

The characters you can type when you are shown a match for the string or regexp are:

SPC
y
to replace the occurrence with newstring.

DEL
Delete
BACKSPACE
n
to skip to the next occurrence without replacing this one.

, (Comma)
to replace this occurrence and display the result. You are then asked for another input character to say what to do next. Since the replacement has already been made, DEL and SPC are equivalent in this situation; both move to the next occurrence.

You can type C-r at this point (see below) to alter the replaced text. You can also undo the replacement with the undo command (e.g., type C-x u; see Undo); this exits the query-replace, so if you want to do further replacement you must use C-x ESC ESC RET to restart (see Repeating Minibuffer Commands).

RET
q
to exit without doing any more replacements.

. (Period)
to replace this occurrence and then exit without searching for more occurrences.

!
to replace all remaining occurrences without asking again.

^
to go back to the position of the previous occurrence (or what used to be an occurrence), in case you changed it by mistake or want to reexamine it.

u
to undo the last replacement and go back to where that replacement was made.

U
to undo all the replacements and go back to where the first replacement was made.

C-r
to enter a recursive editing level, in case the occurrence needs to be edited rather than just replaced with newstring. When you are done, exit the recursive editing level with C-M-c to proceed to the next occurrence. See Recursive Editing Levels.

C-w
to delete the occurrence, and then enter a recursive editing level as in C-r. Use the recursive edit to insert text to replace the deleted occurrence of string. When done, exit the recursive editing level with C-M-c to proceed to the next occurrence.

e
to edit the replacement string in the minibuffer. When you exit the minibuffer by typing RET, the minibuffer contents replace the current occurrence of the pattern. They also become the new replacement string for any further occurrences.

E
is like e, but the next replacement will be done with exact case. I.e., if you have a query-replace from ‘foo’ to ‘bar’, a text like ‘Foo’ will be normally be replaced with ‘Bar’. Use this command to do the current replacement with exact case.

C-l
to redisplay the screen. Then you must type another character to specify what to do with this occurrence.

Y (Upper-case)
to replace all remaining occurrences in all remaining buffers in multi-buffer replacements (like the Dired Q command that performs query replace on selected files). It answers this question and all subsequent questions in the series with “yes”, without further user interaction.

N (Upper-case)
to skip to the next buffer in multi-buffer replacements without replacing remaining occurrences in the current buffer. It answers this question “no”, gives up on the questions for the current buffer, and continues to the next buffer in the sequence.

C-h
?
F1
to display a message summarizing these options. Then you must type another character to specify what to do with this occurrence.

Aside from this, any other character exits the query-replace, and is then reread as part of a key sequence. Thus, if you type C-k, it exits the query-replace and then kills to end of line. In particular, C-g simply exits the query-replace.

To restart a query-replace once it is exited, use C-x ESC ESC, which repeats the query-replace because it used the minibuffer to read its arguments. See C-x ESC ESC.

The option search-invisible determines how query-replace treats invisible text. See Outline Search.

See Operating on Files, for the Dired Q command which performs query replace on selected files. See also Transforming File Names in Dired, for Dired commands to rename, copy, or link files by replacing regexp matches in file names.


*** Other Search-and-Loop Commands

Here are some other commands that find matches for regular expressions. They all ignore case in matching, if the pattern contains no upper-case letters and case-fold-search is non-nil. Aside from multi-occur and multi-occur-in-matching-buffers, which always search the whole buffer, all of the commands operate on the text from point to the end of the buffer, or on the region if it is active.

M-x multi-isearch-buffers
Prompt for one or more buffer names, ending with RET; then, begin a multi-buffer incremental search in those buffers. (If the search fails in one buffer, the next C-s tries searching the next specified buffer, and so forth.) With a prefix argument, prompt for a regexp and begin a multi-buffer incremental search in buffers matching that regexp.

M-x multi-isearch-buffers-regexp
This command is just like multi-isearch-buffers, except it performs an incremental regexp search.

M-x multi-isearch-files
Prompt for one or more file names, ending with RET; then, begin a multi-file incremental search in those files. (If the search fails in one file, the next C-s tries searching the next specified file, and so forth.) With a prefix argument, prompt for a regexp and begin a multi-file incremental search in files matching that regexp.

M-x multi-isearch-files-regexp
This command is just like multi-isearch-files, except it performs an incremental regexp search.

In some modes that set the buffer-local variable multi-isearch-next-buffer-function (e.g., in Change Log mode) a multi-file incremental search is activated automatically.

M-x occur
M-s o
Prompt for a regexp, and display a list showing each line in the buffer that contains a match for it. If you type M-n at the prompt, you can reuse search strings from previous incremental searches. The text that matched is highlighted using the match face. A numeric argument n specifies that n lines of context are to be displayed before and after each matching line.

The default number of context lines is specified by the variable list-matching-lines-default-context-lines. When list-matching-lines-jump-to-current-line is non-nil the current line is shown highlighted with face list-matching-lines-current-line-face and the point is set at the first match after such line.

You can also run M-s o when an incremental search is active; this uses the current search string.

Note that matches for the regexp you type are extended to include complete lines, and a match that starts before the previous match ends is not considered a match.

The *Occur* buffer uses the Occur mode as its major mode. You can use the n and p keys to move to the next or previous match; with prefix numeric argument, these commands move that many matches. Digit keys are bound to digit-argument, so 5 n moves to the fifth next match (you don’t have to type C-u). SPC and DEL scroll the *Occur* buffer up and down. Clicking on a match or moving point there and typing RET visits the corresponding position in the original buffer that was searched. o and C-o display the match in another window; C-o does not select that window. Alternatively, you can use the M-g M-n (next-error) command to visit the occurrences one by one (see Compilation Mode). Finally, q quits the window showing the *Occur* buffer and buries the buffer.

Typing e in the *Occur* buffer makes the buffer writable and enters the Occur Edit mode, in which you can edit the matching lines and have those edits reflected in the text in the originating buffer. Type C-c C-c to leave the Occur Edit mode and return to the Occur mode.

The command M-x list-matching-lines is a synonym for M-x occur.

M-x multi-occur
This command is just like occur, except it is able to search through multiple buffers. It asks you to specify the buffer names one by one.

M-x multi-occur-in-matching-buffers
This command is similar to multi-occur, except the buffers to search are specified by a regular expression that matches visited file names. With a prefix argument, it uses the regular expression to match buffer names instead.

M-x how-many
Prompt for a regexp, and print the number of matches for it in the buffer after point. If the region is active, this operates on the region instead.

M-x flush-lines
Prompt for a regexp, and delete each line that contains a match for it, operating on the text after point. When the command finishes, it prints the number of deleted matching lines.

This command deletes the current line if it contains a match starting after point. If the region is active, it operates on the region instead; if a line partially contained in the region contains a match entirely contained in the region, it is deleted.

If a match is split across lines, flush-lines deletes all those lines. It deletes the lines before starting to look for the next match; hence, it ignores a match starting on the same line at which another match ended.

M-x keep-lines
Prompt for a regexp, and delete each line that does not contain a match for it, operating on the text after point. If point is not at the beginning of a line, this command always keeps the current line. If the region is active, the command operates on the region instead; it never deletes lines that are only partially contained in the region (a newline that ends a line counts as part of that line).

If a match is split across lines, this command keeps all those lines.

M-x kill-matching-lines
Like flush-lines, but also add the matching lines to the kill ring. The command adds the matching lines to the kill ring as a single string, including the newlines that separated the lines.

M-x copy-matching-lines
Like kill-matching-lines, but the matching lines are not removed from the buffer.


*** Tailoring Search to Your Needs

This section describes miscellaneous search-related customizations not described elsewhere.

The default search mode for the incremental search is specified by the variable search-default-mode. It can be nil, t, or a function. If it is nil, the default mode is to do literal searches without character folding, but with case folding and lax-whitespace matches as determined by case-fold-search and search-whitespace-regexp, respectively (see Lax Matching During Searching). If the value is t, incremental search defaults to regexp searches. The default value specifies a function that only performs case folding and lax-whitespace matching.

The current match of an on-going incremental search is highlighted using the isearch face. This highlighting can be disabled by setting the variable search-highlight to nil.

When searching for regular expressions (with C-M-s, for instance), subexpressions receive special highlighting depending on the search-highlight-submatches variable. If this variable’s value is nil, no special highlighting is done, but if the value is non-nil, text that matches ‘\( … \)’ constructs (a.k.a. “subexpressions”) in the regular expression will be highlighted with distinct faces. By default, two distinct faces are defined, named isearch-group-1 and isearch-group-2. With these two faces, odd-numbered subexpressions will be highlighted using the isearch-group-1 face and even-numbered subexpressions will be highlighted using the isearch-group-2 face. For instance, when searching for ‘foo-\([0-9]+\)\([a-z]+\)’, the part matched by ‘[0-9]+’ will be highlighted with the isearch-group-1 face, and the part matched by ‘[a-z]+’ will be highlighted using isearch-group-2. If you define additional faces using the same numbering scheme, i.e. isearch-group-3, isearch-group-4, …, then the face isearch-group-M will be used to highlight the M’th, N+M’th, 2N+M’th, … subexpressions, where N is the total number of faces of the form isearch-group-M.

The other matches for the search string that are visible on display are highlighted using the lazy-highlight face. Setting the variable isearch-lazy-highlight to nil disables this highlighting. Here are some other variables that customize the lazy highlighting:

lazy-highlight-initial-delay ¶
Time in seconds to wait before highlighting visible matches. Applies only if the search string is less than lazy-highlight-no-delay-length characters long.

lazy-highlight-no-delay-length ¶
For search strings at least as long as the value of this variable, lazy highlighting of matches starts immediately.

lazy-highlight-interval ¶
Time in seconds between highlighting successive matches.

lazy-highlight-max-at-a-time ¶
The maximum number of matches to highlight before checking for input. A large number can take some time to highlight, so if you want to continue searching and type C-s or C-r during that time, Emacs will not respond until it finishes highlighting all those matches. Thus, smaller values make Emacs more responsive.

isearch-lazy-count ¶
Show the current match number and the total number of matches in the search prompt.

lazy-count-prefix-format ¶
lazy-count-suffix-format
These two variables determine the format of showing the current and the total number of matches for isearch-lazy-count.

Normally, entering RET within incremental search when the search string is empty launches a nonincremental search. (Actually, it lets you edit the search string, and the next RET does the search.) However, if you customize the variable search-nonincremental-instead to nil, typing RET will always exit the incremental search, even if the search string is empty.

By default, incremental search and query-replace commands match invisible text, but hide any such matches as soon as the current match moves off the invisible text. If you customize the variable isearch-hide-immediately to nil, any invisible text where matches were found stays on display until the search or the replace command exits.

Searching incrementally on slow terminals, such as displays connected to remote machines over slow connection, could be annoying due to the need to redraw large portions of the display as the search proceeds. Emacs provides a special display mode for slow terminals, whereby search pops up a separate small window and displays the text surrounding the match in that window. Small windows display faster, so the annoying effect of slow speed is alleviated. The variable search-slow-speed determines the baud rate threshold below which Emacs will use this display mode. The variable search-slow-window-lines controls the number of lines in the window Emacs pops up for displaying the search results; the default is 1 line. Normally, this window will pop up at the bottom of the window that displays the buffer where you start searching, but if the value of search-slow-window-lines is negative, that means to put the window at the top and give it the number of lines that is the absolute value of search-slow-window-lines.



** Commands for Fixing Typos

In this chapter we describe commands that are useful when you catch a mistake while editing. The most fundamental of these commands is the undo command C-/ (also bound to C-x u and C-_). This undoes a single command, or a part of a command (as in the case of query-replace), or several consecutive character insertions. Consecutive repetitions of C-/ undo earlier and earlier changes, back to the limit of the undo information available.

Aside from the commands described here, you can erase text using deletion commands such as DEL (delete-backward-char). These were described earlier in this manual. See Erasing Text.

*** Undo

The undo command reverses recent changes in the buffer’s text. Each buffer records changes individually, and the undo command always applies to the current buffer. You can undo all the changes in a buffer for as far back as the buffer’s records go. Usually, each editing command makes a separate entry in the undo records, but some commands such as query-replace divide their changes into multiple entries for flexibility in undoing. Consecutive character insertion commands are usually grouped together into a single undo record, to make undoing less tedious.

C-/
C-x u
C-_

Undo one entry in the current buffer’s undo records (undo).

To begin to undo, type C-/ (or its aliases, C-_ or C-x u)6. This undoes the most recent change in the buffer, and moves point back to where it was before that change. Consecutive repetitions of C-/ (or its aliases) undo earlier and earlier changes in the current buffer. If all the recorded changes have already been undone, the undo command signals an error.

Any command other than an undo command breaks the sequence of undo commands. Starting from that moment, the entire sequence of undo commands that you have just performed are themselves placed into the undo record. Therefore, to re-apply changes you have undone, type C-f or any other command that harmlessly breaks the sequence of undoing; then type C-/ one or more times to undo some of the undo commands.

Alternatively, if you want to resume undoing, without redoing previous undo commands, use M-x undo-only. This is like undo, but will not redo changes you have just undone. To complement it, M-x undo-redo will undo previous undo commands (and will not record itself as an undoable command).

If you notice that a buffer has been modified accidentally, the easiest way to recover is to type C-/ repeatedly until the stars disappear from the front of the mode line (see The Mode Line). Whenever an undo command makes the stars disappear from the mode line, it means that the buffer contents are the same as they were when the file was last read in or saved. If you do not remember whether you changed the buffer deliberately, type C-/ once. When you see the last change you made undone, you will see whether it was an intentional change. If it was an accident, leave it undone. If it was deliberate, redo the change as described above.

Alternatively, you can discard all the changes since the buffer was last visited or saved with M-x revert-buffer (see Reverting a Buffer).

When there is an active region, any use of undo performs selective undo: it undoes the most recent change within the region, instead of the entire buffer. However, when Transient Mark mode is off (see Disabling Transient Mark Mode), C-/ always operates on the entire buffer, ignoring the region. In this case, you can perform selective undo by supplying a prefix argument to the undo command: C-u C-/. To undo further changes in the same region, repeat the undo command (no prefix argument is needed).

Some specialized buffers do not make undo records. Buffers whose names start with spaces never do; these buffers are used internally by Emacs to hold text that users don’t normally look at or edit.

When the undo information for a buffer becomes too large, Emacs discards the oldest records from time to time (during garbage collection). You can specify how much undo information to keep by setting the variables undo-limit, undo-strong-limit, and undo-outer-limit. Their values are expressed in bytes.

The variable undo-limit sets a soft limit: Emacs keeps undo data for enough commands to reach this size, and perhaps exceed it, but does not keep data for any earlier commands beyond that. Its default value is 160000. The variable undo-strong-limit sets a stricter limit: any previous command (though not the most recent one) that pushes the size past this amount is forgotten. The default value of undo-strong-limit is 240000.

Regardless of the values of those variables, the most recent change is never discarded unless it gets bigger than undo-outer-limit (normally 24,000,000). At that point, Emacs discards the undo data and warns you about it. This is the only situation in which you cannot undo the last command. If this happens, you can increase the value of undo-outer-limit to make it even less likely to happen in the future. But if you didn’t expect the command to create such large undo data, then it is probably a bug and you should report it. See Reporting Bugs.

Footnotes
(6)
Aside from C-/, the undo command is also bound to C-x u because that is more straightforward for beginners to remember: ‘u’ stands for “undo”. It is also bound to C-_ because typing C-/ on some text terminals actually enters C-_.


*** Transposing Text

C-t
Transpose two characters (transpose-chars).

M-t
Transpose two words (transpose-words).

C-M-t
Transpose two balanced expressions (transpose-sexps).

C-x C-t
Transpose two lines (transpose-lines).

M-x transpose-sentences
Transpose two sentences (transpose-sentences).

M-x transpose-paragraphs
Transpose two paragraphs (transpose-paragraphs).

M-x transpose-regions
Transpose two regions.

The common error of transposing two characters can be fixed, when they are adjacent, with the C-t command (transpose-chars). Normally, C-t transposes the two characters on either side of point. When given at the end of a line, rather than transposing the last character of the line with the newline, which would be useless, C-t transposes the last two characters on the line. So, if you catch your transposition error right away, you can fix it with just a C-t. If you don’t catch it so fast, you must move the cursor back between the two transposed characters before you type C-t. If you transposed a space with the last character of the word before it, the word motion commands (M-f, M-b, etc.) are a good way of getting there. Otherwise, a reverse search (C-r) is often the best way. See Searching and Replacement.

M-t transposes the word before point with the word after point (transpose-words). It moves point forward over a word, dragging the word preceding or containing point forward as well. The punctuation characters between the words do not move. For example, ‘FOO, BAR’ transposes into ‘BAR, FOO’ rather than ‘BAR FOO,’. When point is at the end of the line, it will transpose the word before point with the first word on the next line.

C-M-t (transpose-sexps) is a similar command for transposing two expressions (see Expressions with Balanced Parentheses), and C-x C-t (transpose-lines) exchanges lines. M-x transpose-sentences and M-x transpose-paragraphs transpose sentences and paragraphs, respectively. These commands work like M-t except as regards the units of text they transpose.

A numeric argument to a transpose command serves as a repeat count: it tells the transpose command to move the character (or word or expression or line) before or containing point across several other characters (or words or expressions or lines). For example, C-u 3 C-t moves the character before point forward across three other characters. It would change ‘f∗oobar’ into ‘oobf∗ar’. This is equivalent to repeating C-t three times. C-u - 4 M-t moves the word before point backward across four words. C-u - C-M-t would cancel the effect of plain C-M-t.

A numeric argument of zero is assigned a special meaning (because otherwise a command with a repeat count of zero would do nothing): to transpose the character (or word or expression or line) ending after point with the one ending after the mark.

M-x transpose-regions transposes the text between point and mark with the text between the last two marks pushed to the mark ring (see Setting the Mark). With a numeric prefix argument, it transposes the text between point and mark with the text between two successive marks that many entries back in the mark ring. This command is best used for transposing multiple characters (or words or sentences or paragraphs) in one go.


*** Case Conversion

M-- M-l
Convert last word to lower case. Note Meta-- is Meta-minus.

M-- M-u
Convert last word to all upper case.

M-- M-c
Convert last word to lower case With capital initial.

A very common error is to type words in the wrong case. Because of this, the word case-conversion commands M-l, M-u, and M-c have a special feature when used with a negative argument: they do not move the cursor. As soon as you see you have mistyped the last word, you can simply case-convert it and go on typing. See Case Conversion Commands.


*** Checking and Correcting Spelling

This section describes the commands to check the spelling of a single word or of a portion of a buffer. These commands only work if a spelling checker program, one of Hunspell, Aspell, Ispell or Enchant, is installed. These programs are not part of Emacs, but one of them is usually installed on GNU/Linux and other free operating systems. See Aspell in The Aspell Manual.

If you have only one of the spelling checker programs installed, Emacs will find it when you invoke for the first time one of the commands described here. If you have more than one of them installed, you can control which one is used by customizing the variable ispell-program-name.

M-$
Check and correct spelling of the word at point (ispell-word). If the region is active, do it for all words in the region instead.

C-u M-$
If a previous spelling operation was interrupted, continue that operation (ispell-continue).

M-x ispell
Check and correct spelling of all words in the buffer. If the region is active, do it for all words in the region instead.

M-x ispell-buffer
Check and correct spelling in the buffer.

M-x ispell-region
Check and correct spelling in the region.

M-x ispell-message
Check and correct spelling in a draft mail message, excluding cited material.

M-x ispell-comments-and-strings
Check and correct spelling of comments and strings in the buffer or region.

M-x ispell-comment-or-string-at-point
Check the comment or string at point.

M-x ispell-change-dictionary RET dict RET
Restart the spell-checker process, using dict as the dictionary.

M-x ispell-kill-ispell
Kill the spell-checker subprocess.

M-TAB
ESC TAB
C-M-i
Complete the word before point based on the spelling dictionary (ispell-complete-word).

M-x flyspell-mode
Enable Flyspell mode, which highlights all misspelled words.

M-x flyspell-prog-mode
Enable Flyspell mode for comments and strings only.

To check the spelling of the word around or before point, and optionally correct it as well, type M-$ (ispell-word). If a region is active, M-$ checks the spelling of all words within the region. See The Mark and the Region. (When Transient Mark mode is off, M-$ always acts on the word around or before point, ignoring the region; see Disabling Transient Mark Mode.) When invoked with a prefix argument, C-u M-$, this calls ispell-continue, which continues the spelling operation, if any, which was interrupted with X or C-g.

Similarly, the command M-x ispell performs spell-checking in the region if one is active, or in the entire buffer otherwise. The commands M-x ispell-buffer and M-x ispell-region explicitly perform spell-checking on the entire buffer or the region respectively. To check spelling in an email message you are writing, use M-x ispell-message; that command checks the whole buffer, except for material that is indented or appears to be cited from other messages. See Sending Mail. When dealing with source code, you can use M-x ispell-comments-and-strings or M-x ispell-comment-or-string-at-point to check only comments or string literals.

When one of these commands encounters what appears to be an incorrect word, it asks you what to do. It usually displays a list of numbered near-misses—words that are close to the incorrect word. Then you must type a single-character response. Here are the valid responses:

digit
Replace the word, just this time, with one of the displayed near-misses. Each near-miss is listed with a digit; type that digit to select it.

SPC
Skip this word—continue to consider it incorrect, but don’t change it here.

r new RET
Replace the word, just this time, with new. (The replacement string will be rescanned for more spelling errors.)

R new RET
Replace the word with new, and do a query-replace so you can replace it elsewhere in the buffer if you wish. (The replacements will be rescanned for more spelling errors.)

a
Accept the incorrect word—treat it as correct, but only in this editing session.

A
Accept the incorrect word—treat it as correct, but only in this editing session and for this buffer.

i
Insert this word in your private dictionary file so that it will be considered correct from now on, even in future sessions.

m
Like i, but you can also specify dictionary completion information.

u
Insert the lower-case version of this word in your private dictionary file.

l word RET
Look in the dictionary for words that match word. These words become the new list of near-misses; you can select one of them as the replacement by typing a digit. You can use ‘*’ in word as a wildcard.

C-g
X
Interrupt the interactive spell-checking, leaving point at the word that was being checked. You can restart checking again afterward with C-u M-$.

x
Quit interactive spell-checking and move point back to where it was when you started spell-checking.

q
Quit interactive spell-checking and kill the spell-checker subprocess.

C-r
Enter recursive-edit (see Recursive Editing Levels). When you exit recursive-edit with C-M-c, the interactive spell-checking will resume. This allows you to consult the buffer text without interrupting the spell-checking. Do not modify the buffer in the recursive editing, and especially don’t modify the misspelled word, as the edits will be undone when you exit recursive-edit. If you need to edit the misspelled word, use r or R instead, or use X, edit the buffer, then resume with C-u M-$.

C-z
Suspend Emacs or iconify the selected frame.

?
Show the list of options.

In Text mode and related modes, M-TAB (ispell-complete-word) performs in-buffer completion based on spelling correction. Insert the beginning of a word, and then type M-TAB; this shows a list of completions. (If your window manager intercepts M-TAB, type ESC TAB or C-M-i.) Each completion is listed with a digit or character; type that digit or character to choose it.

Once started, the spell-checker subprocess continues to run, waiting for something to do, so that subsequent spell-checking commands complete more quickly. If you want to get rid of the process, use M-x ispell-kill-ispell. This is not usually necessary, since the process uses no processor time except when you do spelling correction.

Spell-checkers look up spelling in two dictionaries: the standard dictionary and your personal dictionary. The standard dictionary is specified by the variable ispell-local-dictionary or, if that is nil, by the variable ispell-dictionary. If both are nil, the spelling program’s default dictionary is used. The command M-x ispell-change-dictionary sets the standard dictionary for the buffer and then restarts the subprocess, so that it will use a different standard dictionary. Your personal dictionary is specified by the variable ispell-personal-dictionary. If that is nil, the spelling program looks for a personal dictionary in a default location, which is specific to each spell-checker.

A separate dictionary is used for word completion. The variable ispell-complete-word-dict specifies the file name of this dictionary. The completion dictionary must be different because it cannot use the information about roots and affixes of the words, which spell-checking uses to detect variations of words. For some languages, there is a spell-checking dictionary but no word completion dictionary.

Flyspell mode is a minor mode that performs automatic spell-checking of the text you type as you type it. When it finds a word that it does not recognize, it highlights that word. Type M-x flyspell-mode to toggle Flyspell mode in the current buffer. To enable Flyspell mode in all text mode buffers, add flyspell-mode to text-mode-hook. See Hooks. Note that, as Flyspell mode needs to check each word across which you move, it will slow down cursor motion and scrolling commands. It also doesn’t automatically check the text you didn’t type or move across; use flyspell-region or flyspell-buffer for that.

When Flyspell mode highlights a word as misspelled, you can click on it with mouse-2 (flyspell-correct-word) to display a menu of possible corrections and actions. If you want this menu on mouse-3 instead, enable context-menu-mode. In addition, C-. or ESC TAB (flyspell-auto-correct-word) will propose various successive corrections for the word at point, and C-c $ (flyspell-correct-word-before-point) will pop up a menu of possible corrections. Of course, you can always correct the misspelled word by editing it manually in any way you like.

Flyspell Prog mode works just like ordinary Flyspell mode, except that it only checks words in comments and string constants. This feature is useful for editing programs. Type M-x flyspell-prog-mode to enable or disable this mode in the current buffer. To enable this mode in all programming mode buffers, add flyspell-prog-mode to prog-mode-hook (see Hooks).



** The Mark and the Region ✓✓✓ {IMPORTANT !!!}

Emacs, like many other applications, lets you select some arbitrary part of the buffer text and invoke commands that operate on such selected text. In Emacs, we call the selected text the region; its handling is very similar to that of selected text in other programs, but there are also important differences.

The region is the portion of the buffer between the mark and the current point. You define a region by setting the mark somewhere (with, for instance, the C-SPC command), and then moving point to where you want the region to end. (Or you can use the mouse to define a region.)

The region always extends between point and the mark, no matter which of them comes earlier in the text; each time you move point, the region changes.

Setting the mark at a position in the text activates it. When the mark is active, we say also that the region is active; Emacs indicates its extent by highlighting the text within it, using the region face (see Customizing Faces).

After certain non-motion commands, including any command that changes the text in the buffer, Emacs automatically deactivates the mark; this turns off the highlighting. You can also explicitly deactivate the mark at any time, by typing C-g (see Quitting and Aborting).

Many commands limit the text on which they operate to the active region. For instance, the M-% command (which replaces matching text) normally works on the entire accessible portion of the buffer, but if you have an active region, it’ll work only on that region instead.

The mark is useful even if it is not active. For example, you can move to previous mark locations using the mark ring. See The Mark Ring. Additionally, some commands will have an effect even on an inactive region (for example upcase-region). You can also reactivate the region with commands like C-x C-x.

The above behavior, which is the default in interactive sessions, is known as Transient Mark mode. Disabling Transient Mark mode switches Emacs to an alternative behavior, in which the region is usually not highlighted. See Disabling Transient Mark Mode.

Setting the mark in one buffer has no effect on the marks in other buffers. When you return to a buffer with an active mark, the mark is at the same place as before. When multiple windows show the same buffer, they can have different values of point, and thus different regions, but they all share one common mark position. See Multiple Windows. Ordinarily, only the selected window highlights its region; however, if the variable highlight-nonselected-windows is non-nil, each window highlights its own region.

There is another kind of region: the rectangular region. See Rectangles.


*** Setting the Mark
Here are some commands for setting the mark:

C-SPC
Set the mark at point, and activate it (set-mark-command).

C-@
The same.

C-x C-x
Set the mark at point, and activate it; then move point where the mark used to be (exchange-point-and-mark).

Drag-mouse-1
Set point and the mark around the text you drag across.

mouse-3
Set the mark at point, then move point to where you click (mouse-save-then-kill).

Shifted cursor motion keys
Set the mark at point if the mark is inactive, then move point. See Shift Selection.

The most common way to set the mark is with C-SPC (set-mark-command)5. This sets the mark where point is, and activates it. You can then move point away, leaving the mark behind.

For example, suppose you wish to convert part of the buffer to upper case. To accomplish this, go to one end of the desired text, type C-SPC, and move point until the desired portion of text is highlighted. Now type C-x C-u (upcase-region). This converts the text in the region to upper case, and then deactivates the mark.

Whenever the mark is active, you can deactivate it by typing C-g (see Quitting and Aborting). Most commands that operate on the region also automatically deactivate the mark, like C-x C-u in the above example.

Instead of setting the mark in order to operate on a region, you can also use it to remember a position in the buffer (by typing C-SPC C-SPC), and later jump back there (by typing C-u C-SPC). See The Mark Ring, for details.

The command C-x C-x (exchange-point-and-mark) exchanges the positions of point and the mark. C-x C-x is useful when you are satisfied with the position of point but want to move the other end of the region (where the mark is). Using C-x C-x a second time, if necessary, puts the mark at the new position with point back at its original position. Normally, if the mark is inactive, this command first reactivates the mark wherever it was last set, to ensure that the region is left highlighted. However, if you call it with a prefix argument, it leaves the mark inactive and the region unhighlighted; you can use this to jump to the mark in a manner similar to C-u C-SPC.

You can also set the mark with the mouse. If you press the left mouse button (down-mouse-1) and drag the mouse across a range of text, this sets the mark where you first pressed the mouse button and puts point where you release it. Alternatively, clicking the right mouse button (mouse-3) sets the mark at point and then moves point to where you clicked. See Mouse Commands for Editing, for a more detailed description of these mouse commands.

Finally, you can set the mark by holding down the shift key while typing certain cursor motion commands (such as S-RIGHT, S-C-f, S-C-n, etc.). This is called shift-selection. It sets the mark at point before moving point, but only if there is no active mark set via a previous shift-selection or mouse commands. The mark set by mouse commands and by shift-selection behaves slightly differently from the usual mark: any subsequent unshifted cursor motion command deactivates it automatically. For details, see Shift Selection.

Many commands that insert text, such as C-y (yank), set the mark at the other end of the inserted text, without activating it. This lets you easily return to that position (see The Mark Ring). You can tell that a command does this when it shows ‘Mark set’ in the echo area.

Under X, every time the active region changes, Emacs saves the text in the region to the primary selection. This lets you insert that text into other X applications with mouse-2 clicks. See Cut and Paste with Other Window Applications.

Footnotes
(5)
There is no C-SPC character in ASCII; usually, typing C-SPC on a text terminal gives the character C-@. This key is also bound to set-mark-command, so unless you are unlucky enough to have a text terminal that behaves differently, you might as well think of C-@ as C-SPC.


*** Commands to Mark Textual Objects ✓✓✓ { IMPORTANT !!! } 

Here are commands for placing point and the mark around a textual object such as a word, list, paragraph or page:

M-@
Set mark at the end of the next word (mark-word). This does not move point.

C-M-@
Set mark after end of following balanced expression (mark-sexp). This does not move point.

M-h
Move point to the beginning of the current paragraph, and set mark at the end (mark-paragraph).

C-M-h
Move point to the beginning of the current defun, and set mark at the end (mark-defun).

C-x C-p
Move point to the beginning of the current page, and set mark at the end (mark-page).

C-x h
Move point to the beginning of the buffer, and set mark at the end (mark-whole-buffer).

M-@ (mark-word) sets the mark at the end of the next word (see Words, for information about words). Repeated invocations of this command extend the region by advancing the mark one word at a time. As an exception, if the mark is active and located before point, M-@ moves the mark backwards from its current position one word at a time.

This command also accepts a numeric argument n, which tells it to advance the mark by n words. A negative argument −n moves the mark back by n words.

Similarly, C-M-@ (mark-sexp) puts the mark at the end of the next balanced expression (see Expressions with Balanced Parentheses). Repeated invocations extend the region to subsequent expressions, while positive or negative numeric arguments move the mark forward or backward by the specified number of expressions.

The other commands in the above list set both point and mark, so as to delimit an object in the buffer. M-h (mark-paragraph) marks paragraphs (see Paragraphs), C-M-h (mark-defun) marks top-level definitions (see Moving by Defuns), and C-x C-p (mark-page) marks pages (see Pages). Repeated invocations again play the same role, extending the region to consecutive objects; similarly, numeric arguments specify how many objects to move the mark by.

C-x h (mark-whole-buffer) sets up the entire buffer as the region, by putting point at the beginning and the mark at the end.


*** Operating on the Region

Once you have a region, here are some of the ways you can operate on it:

Kill it with C-w (see Killing and Moving Text).
Copy it to the kill ring with M-w (see Yanking).
Convert case with C-x C-l or C-x C-u (see Case Conversion Commands).
Undo changes within it using C-u C-/ (see Undo).
Replace text within it using M-% (see Query Replace).
Indent it with C-x TAB or C-M-\ (see Indentation).
Fill it as text with M-x fill-region (see Filling Text).
Check the spelling of words within it with M-$ (see Checking and Correcting Spelling).
Evaluate it as Lisp code with M-x eval-region (see Evaluating Emacs Lisp Expressions).
Save it in a register with C-x r s (see Registers).
Save it in a buffer or a file (see Accumulating Text).
Some commands have a default behavior when the mark is inactive, but operate on the region if the mark is active. For example, M-$ (ispell-word) normally checks the spelling of the word at point, but it checks the text in the region if the mark is active (see Checking and Correcting Spelling). Normally, such commands use their default behavior if the region is empty (i.e., if mark and point are at the same position). If you want them to operate on the empty region, change the variable use-empty-active-region to t.

As described in Erasing Text, the DEL (backward-delete-char) and Delete (delete-forward-char) commands also act this way. If the mark is active, they delete the text in the region. (As an exception, if you supply a numeric argument n, where n is not one, these commands delete n characters regardless of whether the mark is active). If you change the variable delete-active-region to nil, then these commands don’t act differently when the mark is active. If you change the value to kill, these commands kill the region instead of deleting it (see Killing and Moving Text).

Other commands always operate on the region, and have no default behavior. Such commands usually have the word region in their names, like C-w (kill-region) and C-x C-u (upcase-region). If the mark is inactive, they operate on the inactive region—that is, on the text between point and the position at which the mark was last set (see The Mark Ring). To disable this behavior, change the variable mark-even-if-inactive to nil. Then these commands will instead signal an error if the mark is inactive.

By default, text insertion occurs normally even if the mark is active—for example, typing "a" inserts the character ‘a’, then deactivates the mark. Delete Selection mode, a minor mode, modifies this behavior: if you enable that mode, then inserting text while the mark is active causes the text in the region to be deleted first. However, you can tune this behavior by customizing the delete-selection-temporary-region option. Its default value is nil, but you can set it to t, in which case only temporarily-active regions will be replaced: those which are set by dragging the mouse (see Setting the Mark) or by shift-selection (see Shift Selection), as well as by C-u C-x C-x when Transient Mark Mode is disabled. You can further tune the behavior by setting delete-selection-temporary-region to selection: then temporary regions by C-u C-x C-x won’t be replaced, only the ones activated by dragging the mouse or shift-selection. To toggle Delete Selection mode on or off, type M-x delete-selection-mode.


*** The Mark Ring

Each buffer remembers previous locations of the mark, in the mark ring. Commands that set the mark also push the old mark onto this ring. One of the uses of the mark ring is to remember spots that you may want to go back to.

C-SPC C-SPC
Set the mark, pushing it onto the mark ring, without activating it.

C-u C-SPC
Move point to where the mark was, and restore the mark from the ring of former marks.

The command C-SPC C-SPC is handy when you want to use the mark to remember a position to which you may wish to return. It pushes the current point onto the mark ring, without activating the mark (which would cause Emacs to highlight the region). This is actually two consecutive invocations of C-SPC (set-mark-command); the first C-SPC sets the mark, and the second C-SPC deactivates it. (When Transient Mark mode is off, C-SPC C-SPC instead activates Transient Mark mode temporarily; see Disabling Transient Mark Mode.)

To return to a marked position, use set-mark-command with a prefix argument: C-u C-SPC. This moves point to where the mark was, and deactivates the mark if it was active. Each subsequent C-u C-SPC jumps to a prior position stored in the mark ring. The positions you move through in this way are not lost; they go to the end of the ring.

If you set set-mark-command-repeat-pop to non-nil, then immediately after you type C-u C-SPC, you can type C-SPC instead of C-u C-SPC to cycle through the mark ring. By default, set-mark-command-repeat-pop is nil.

Each buffer has its own mark ring. All editing commands use the current buffer’s mark ring. In particular, C-u C-SPC always stays in the same buffer.

The variable mark-ring-max specifies the maximum number of entries to keep in the mark ring. This defaults to 16 entries. If that many entries exist and another one is pushed, the earliest one in the list is discarded. Repeating C-u C-SPC cycles through the positions currently in the ring.

If you want to move back to the same place over and over, the mark ring may not be convenient enough. If so, you can record the position in a register for later retrieval (see Saving Positions in Registers).


*** The Global Mark Ring

In addition to the ordinary mark ring that belongs to each buffer, Emacs has a single global mark ring. Each time you set a mark, this is recorded in the global mark ring in addition to the current buffer’s own mark ring, if you have switched buffers since the previous mark setting. Hence, the global mark ring records a sequence of buffers that you have been in, and, for each buffer, a place where you set the mark. The length of the global mark ring is controlled by global-mark-ring-max, and is 16 by default.

The command C-x C-SPC (pop-global-mark) jumps to the buffer and position of the latest entry in the global ring. It also rotates the ring, so that successive uses of C-x C-SPC take you to earlier buffers and mark positions.


*** Shift Selection

If you hold down the shift key while typing a cursor motion command, this sets the mark before moving point, so that the region extends from the original position of point to its new position. This feature is referred to as shift-selection. It is similar to the way text is selected in other editors.

The mark set via shift-selection behaves a little differently from what we have described above. Firstly, in addition to the usual ways of deactivating the mark (such as changing the buffer text or typing C-g), the mark is deactivated by any unshifted cursor motion command. Secondly, any subsequent shifted cursor motion command avoids setting the mark anew. Therefore, a series of shifted cursor motion commands will continuously adjust the region.

Shift-selection only works if the shifted cursor motion key is not already bound to a separate command (see Customization). For example, if you bind S-C-f to another command, typing S-C-f runs that command instead of performing a shift-selected version of C-f (forward-char).

A mark set via mouse commands behaves the same as a mark set via shift-selection (see Setting the Mark). For example, if you specify a region by dragging the mouse, you can continue to extend the region using shifted cursor motion commands. In either case, any unshifted cursor motion command deactivates the mark.

To turn off shift-selection, set shift-select-mode to nil. Doing so does not disable setting the mark via mouse commands. If you set shift-select-mode to the value permanent, cursor motion keys that were not shift-translated will not deactivate the mark, so, for example, the region set by prior commands can be extended by shift-selection, and unshifted cursor motion keys will extend the region set by shift-selection.


*** Disabling Transient Mark Mode

The default behavior of the mark and region, in which setting the mark activates it and highlights the region, is called Transient Mark mode. This is a minor mode that is enabled by default in interactive sessions. It can be toggled with M-x transient-mark-mode, or with the ‘Highlight Active Region’ menu item in the ‘Options’ menu. Turning it off switches Emacs to an alternative mode of operation:

Setting the mark, with commands like C-SPC or C-x C-x, does not highlight the region. Therefore, you can’t tell by looking where the mark is located; you have to remember.
The usual solution to this problem is to set the mark and then use it soon, before you forget where it is. You can also check where the mark is by using C-x C-x, which exchanges the positions of the point and the mark (see Setting the Mark).

Some commands, which ordinarily act on the region when the mark is active, no longer do so. For example, normally M-% (query-replace) performs replacements within the region, if the mark is active. When Transient Mark mode is off, it always operates from point to the end of the buffer. Commands that act this way are identified in their own documentation.
While Transient Mark mode is off, you can activate it temporarily using C-SPC C-SPC or C-u C-x C-x.

C-SPC C-SPC ¶
Set the mark at point (like plain C-SPC) and enable Transient Mark mode just once, until the mark is deactivated. (This is not really a separate command; you are using the C-SPC command twice.)

C-u C-x C-x ¶
Exchange point and mark, activate the mark and enable Transient Mark mode temporarily, until the mark is next deactivated. (This is the C-x C-x command, exchange-point-and-mark, with a prefix argument.)

These commands set or activate the mark, and enable Transient Mark mode only until the mark is deactivated. One reason you may want to use them is that some commands operate on the entire buffer instead of the region when Transient Mark mode is off. Enabling Transient Mark mode momentarily gives you a way to use these commands on the region.

When you specify a region with the mouse (see Setting the Mark), or with shift-selection (see Shift Selection), this likewise activates Transient Mark mode temporarily and highlights the region.


** Killing and Moving Text

In Emacs, killing means erasing text and copying it into the kill ring. Yanking means bringing text from the kill ring back into the buffer. (Some applications use the terms “cutting” and “pasting” for similar operations.) The kill ring is so-named because it can be visualized as a set of blocks of text arranged in a ring, which you can access in cyclic order. See The Kill Ring.

Killing and yanking are the most common way to move or copy text within Emacs. It is very versatile, because there are commands for killing many different types of syntactic units.

*** Deletion and Killing

Most commands which erase text from the buffer save it in the kill ring (see The Kill Ring). These are known as kill commands, and their names normally contain the word ‘kill’ (e.g., kill-line). The kill ring stores several recent kills, not just the last one, so killing is a very safe operation: you don’t have to worry much about losing text that you previously killed. The kill ring is shared by all buffers, so text that is killed in one buffer can be yanked into another buffer.

When you use C-/ (undo) to undo a kill command (see Undo), that brings the killed text back into the buffer, but does not remove it from the kill ring.

On graphical displays, killing text also copies it to the system clipboard. See “Cut and Paste” Operations on Graphical Displays.

Commands that erase text but do not save it in the kill ring are known as delete commands; their names usually contain the word ‘delete’. These include C-d (delete-char) and DEL (delete-backward-char), which delete only one character at a time, and those commands that delete only spaces or newlines. Commands that can erase significant amounts of nontrivial data generally do a kill operation instead.

You can also use the mouse to kill and yank. See “Cut and Paste” Operations on Graphical Displays.

**** Deletion

Deletion means erasing text and not saving it in the kill ring. For the most part, the Emacs commands that delete text are those that erase just one character or only whitespace.

DEL
BACKSPACE
Delete the previous character, or the text in the region if it is active (delete-backward-char).

Delete
Delete the next character, or the text in the region if it is active (delete-forward-char).

C-d
Delete the next character (delete-char).

M-\
Delete spaces and tabs around point (delete-horizontal-space).

M-SPC
Delete spaces and tabs around point, leaving one space (just-one-space).

C-x C-o
Delete blank lines around the current line (delete-blank-lines).

M-^
Join two lines by deleting the intervening newline, along with any indentation following it (delete-indentation).

We have already described the basic deletion commands DEL (delete-backward-char), delete (delete-forward-char), and C-d (delete-char). See Erasing Text. With a numeric argument, they delete the specified number of characters. If the numeric argument is omitted or one, DEL and delete delete all the text in the region if it is active (see Operating on the Region).

The other delete commands are those that delete only whitespace characters: spaces, tabs and newlines. M-\ (delete-horizontal-space) deletes all the spaces and tab characters before and after point. With a prefix argument, this only deletes spaces and tab characters before point.

just-one-space does likewise but leaves a single space before point, regardless of the number of spaces that existed previously (even if there were none before). With a numeric argument n, it leaves n spaces before point if n is positive; if n is negative, it deletes newlines in addition to spaces and tabs, leaving −n spaces before point.

The command cycle-spacing (M-SPC) acts like a more flexible version of just-one-space. It performs different space cleanup actions defined by cycle-spacing-actions, in a cyclic manner, if you call it repeatedly in succession.

C-x C-o (delete-blank-lines) deletes all blank lines after the current line. If the current line is blank, it deletes all blank lines preceding the current line as well (leaving one blank line, the current line). On a solitary blank line, it deletes that line.

M-^ (delete-indentation) joins the current line and the previous line, by deleting a newline and all surrounding spaces, usually leaving a single space. See M-^.

The command delete-duplicate-lines searches the region for identical lines, and removes all but one copy of each. Normally it keeps the first instance of each repeated line, but with a C-u prefix argument it keeps the last. With a C-u C-u prefix argument, it only searches for adjacent identical lines. This is a more efficient mode of operation, useful when the lines have already been sorted. With a C-u C-u C-u prefix argument, it retains repeated blank lines.


**** Killing by Lines

C-k
Kill rest of line or one or more lines (kill-line).

C-S-backspace
Kill an entire line at once (kill-whole-line)

The simplest kill command is C-k (kill-line). If used at the end of a line, it kills the line-ending newline character, merging the next line into the current one (thus, a blank line is entirely removed). Otherwise, C-k kills all the text from point up to the end of the line; if point was originally at the beginning of the line, this leaves the line blank.

Spaces and tabs at the end of the line are ignored when deciding which case applies. As long as point is after the last non-whitespace character in the line, you can be sure that C-k will kill the newline. To kill an entire non-blank line, go to the beginning and type C-k twice.

In this context, “line” means a logical text line, not a screen line (see Continuation Lines).

When C-k is given a positive argument n, it kills n lines and the newlines that follow them (text on the current line before point is not killed). With a negative argument −n, it kills n lines preceding the current line, together with the text on the current line before point. C-k with an argument of zero kills the text before point on the current line.

If the variable kill-whole-line is non-nil, C-k at the very beginning of a line kills the entire line including the following newline. This variable is normally nil.

C-S-backspace (kill-whole-line) kills a whole line including its newline, regardless of the position of point within the line. Note that many text terminals will prevent you from typing the key sequence C-S-backspace.


**** Other Kill Commands

C-w
Kill the region (kill-region).

M-w
Copy the region into the kill ring (kill-ring-save).

M-d
Kill the next word (kill-word). See Words.

M-DEL
Kill one word backwards (backward-kill-word).

C-x DEL
Kill back to beginning of sentence (backward-kill-sentence). See Sentences.

M-k
Kill to the end of the sentence (kill-sentence).

C-M-k
Kill the following balanced expression (kill-sexp). See Expressions with Balanced Parentheses.

M-z char
Kill through the next occurrence of char (zap-to-char).

M-x zap-up-to-char char
Kill up to, but not including, the next occurrence of char.

One of the commonly-used kill commands is C-w (kill-region), which kills the text in the region (see The Mark and the Region). Similarly, M-w (kill-ring-save) copies the text in the region into the kill ring without removing it from the buffer. If the mark is inactive when you type C-w or M-w, the command acts on the text between point and where you last set the mark (see Operating on the Region).

Emacs also provides commands to kill specific syntactic units: words, with M-DEL and M-d (see Words); balanced expressions, with C-M-k (see Expressions with Balanced Parentheses); and sentences, with C-x DEL and M-k (see Sentences).

The command M-z (zap-to-char) combines killing with searching: it reads a character and kills from point up to (and including) the next occurrence of that character in the buffer. A numeric argument acts as a repeat count; a negative argument means to search backward and kill text before point. A history of previously used characters is maintained and can be accessed via the M-p/M-n keystrokes. This is mainly useful if the character to be used has to be entered via a complicated input method. A similar command zap-up-to-char kills from point up to, but not including the next occurrence of a character, with numeric argument acting as a repeat count.


**** Options for Killing

Some specialized buffers contain read-only text, which cannot be modified and therefore cannot be killed. The kill commands work specially in a read-only buffer: they move over text and copy it to the kill ring, without actually deleting it from the buffer. Normally, they also beep and display an error message when this happens. But if you set the variable kill-read-only-ok to a non-nil value, they just print a message in the echo area to explain why the text has not been erased.

Before saving the kill to the kill ring, you can transform the string using kill-transform-function. It’s called with the string to be killed, and it should return the string you want to be saved. It can also return nil, in which case the string won’t be saved to the kill ring. For instance, if you never want to save a pure white space string to the kill ring, you can say:

(setq kill-transform-function
(lambda (string)
(and (not (string-blank-p string))
string)))
If you change the variable kill-do-not-save-duplicates to a non-nil value, identical subsequent kills yield a single kill-ring entry, without duplication.


*** Yanking

Yanking means reinserting text previously killed. The usual way to move or copy text is to kill it and then yank it elsewhere.

C-y
Yank the last kill into the buffer, at point (yank).

M-y
Either replace the text just yanked with an earlier batch of killed text (yank-pop), or allow to select from the list of previously-killed batches of text. See Yanking Earlier Kills.

C-M-w
Cause the following command, if it is a kill command, to append to the previous kill (append-next-kill). See Appending Kills.

The basic yanking command is C-y (yank). It inserts the most recent kill, leaving the cursor at the end of the inserted text. It also sets the mark at the beginning of the inserted text, without activating the mark; this lets you jump easily to that position, if you wish, with C-u C-SPC (see The Mark Ring).

With a plain prefix argument (C-u C-y), the command instead leaves the cursor in front of the inserted text, and sets the mark at the end. Using any other prefix argument specifies an earlier kill; e.g., C-u 4 C-y reinserts the fourth most recent kill. See Yanking Earlier Kills.

On graphical displays and on capable text-mode displays, C-y first checks if another application has placed any text in the system clipboard more recently than the last Emacs kill. If so, it inserts the clipboard’s text instead. Thus, Emacs effectively treats “cut” or “copy” clipboard operations performed in other applications like Emacs kills, except that they are not recorded in the kill ring. See “Cut and Paste” Operations on Graphical Displays, for details.

**** The Kill Ring

The kill ring is a list of blocks of text that were previously killed. There is only one kill ring, shared by all buffers, so you can kill text in one buffer and yank it in another buffer. This is the usual way to move text from one buffer to another. (There are several other methods: for instance, you could store the text in a register; see Registers. See Accumulating Text, for some other ways to move text around.)

The maximum number of entries in the kill ring is controlled by the variable kill-ring-max. The default is 120. If you make a new kill when this limit has been reached, Emacs makes room by deleting the oldest entry in the kill ring.

The actual contents of the kill ring are stored in a variable named kill-ring; you can view the entire contents of the kill ring with C-h v kill-ring.


**** Yanking Earlier Kills

As explained in Yanking, you can use a numeric argument to C-y to yank text that is no longer the most recent kill. This is useful if you remember which kill ring entry you want. If you don’t, you can use the M-y (yank-pop) command to cycle through the possibilities or to select one of the earlier kills.

If the previous command was a yank command, M-y takes the text that was yanked and replaces it with the text from an earlier kill. So, to recover the text of the next-to-the-last kill, first use C-y to yank the last kill, and then use M-y to replace it with the previous kill. This works only after a C-y or another M-y. (If M-y is invoked after some other command, it works differently, see below.)

You can understand this operation mode of M-y in terms of a last-yank pointer which points at an entry in the kill ring. Each time you kill, the last-yank pointer moves to the newly made entry at the front of the ring. C-y yanks the entry which the last-yank pointer points to. M-y after a C-y or another M-y moves the last-yank pointer to the previous entry, and the text in the buffer changes to match. Enough M-y commands one after another can move the pointer to any entry in the ring, so you can get any entry into the buffer. Eventually the pointer reaches the end of the ring; the next M-y loops back around to the first entry again.

M-y moves the last-yank pointer around the ring, but it does not change the order of the entries in the ring, which always runs from the most recent kill at the front to the oldest one still remembered.

When used after C-y or M-y, M-y can take a numeric argument, which tells it how many entries to advance the last-yank pointer by. A negative argument moves the pointer toward the front of the ring; from the front of the ring, it moves around to the last entry and continues forward from there.

Once the text you are looking for is brought into the buffer, you can stop doing M-y commands and the last yanked text will stay there. It’s just a copy of the kill ring entry, so editing it in the buffer does not change what’s in the ring. As long as no new killing is done, the last-yank pointer remains at the same place in the kill ring, so repeating C-y will yank another copy of the same previous kill.

When you call C-y with a numeric argument, that also sets the last-yank pointer to the entry that it yanks.

You can also invoke M-y after a command that is not a yank command. In that case, M-y prompts you in the minibuffer for one of the previous kills. You can use the minibuffer history commands (see Minibuffer History) to navigate or search through the entries in the kill ring until you find the one you want to reinsert. Or you can use completion commands (see Completion Commands) to complete on an entry from the list of entries in the kill ring or pop up the *Completions* buffer with the candidate entries from which you can choose. After selecting the kill-ring entry, you can optionally edit it in the minibuffer. Finally, type RET to exit the minibuffer and insert the text of the selected kill-ring entry. Like in case of M-y after another yank command, the last-yank pointer is left pointing at the text you just yanked, whether it is one of the previous kills or an entry from the kill-ring that you edited before inserting it. (In the latter case, the edited entry is added to the front of the kill-ring.) So here, too, typing C-y will yank another copy of the text just inserted.

When invoked with a plain prefix argument (C-u M-y) after a command that is not a yank command, M-y leaves the cursor in front of the inserted text, and sets the mark at the end, like C-y does.


**** Appending Kills

Normally, each kill command pushes a new entry onto the kill ring. However, two or more kill commands in a row combine their text into a single entry, so that a single C-y yanks all the text as a unit, just as it was before it was killed.

Thus, if you want to yank text as a unit, you need not kill all of it with one command; you can keep killing line after line, or word after word, until you have killed it all, and you can still get it all back at once.

Commands that kill forward from point add onto the end of the previous killed text. Commands that kill backward from point add text onto the beginning. This way, any sequence of mixed forward and backward kill commands puts all the killed text into one entry without rearrangement. Numeric arguments do not break the sequence of appending kills. For example, suppose the buffer contains this text:

This is a line ∗of sample text.
with point shown by ∗. If you type M-d M-DEL M-d M-DEL, killing alternately forward and backward, you end up with ‘a line of sample’ as one entry in the kill ring, and ‘This is  text.’ in the buffer. (Note the double space between ‘is’ and ‘text’, which you can clean up with M-SPC or M-q.)

Another way to kill the same text is to move back two words with M-b M-b, then kill all four words forward with C-u M-d. This produces exactly the same results in the buffer and in the kill ring. M-f M-f C-u M-DEL kills the same text, all going backward; once again, the result is the same. The text in the kill ring entry always has the same order that it had in the buffer before you killed it.

If a kill command is separated from the last kill command by other commands (not just numeric arguments), it starts a new entry on the kill ring. But you can force it to combine with the last killed text, by typing C-M-w (append-next-kill) right beforehand. The C-M-w tells its following command, if it is a kill command, to treat the kill as part of the sequence of previous kills. As usual, the kill is appended to the previous killed text if the command kills forward, and prepended if the command kills backward. In this way, you can kill several separated pieces of text and accumulate them to be yanked back in one place.

A kill command following M-w (kill-ring-save) does not append to the text that M-w copied into the kill ring.


*** “Cut and Paste” Operations on Graphical Displays

In most graphical desktop environments, you can transfer data (usually text) between different applications using a system facility called the clipboard. On X, two other similar facilities are available: the primary selection and the secondary selection. When Emacs is run on a graphical display, its kill and yank commands integrate with these facilities, so that you can easily transfer text between Emacs and other graphical applications.

By default, Emacs uses UTF-8 as the coding system for inter-program text transfers. If you find that the pasted text is not what you expected, you can specify another coding system by typing C-x RET x or C-x RET X. You can also request a different data type by customizing x-select-request-type. See Coding Systems for Interprocess Communication.

**** Using the Clipboard

The clipboard is the facility that most graphical applications use for “cutting and pasting”. When the clipboard exists, the kill and yank commands in Emacs make use of it.

When you kill some text with a command such as C-w (kill-region), or copy it to the kill ring with a command such as M-w (kill-ring-save), that text is also put in the clipboard.

When an Emacs kill command puts text in the clipboard, the existing clipboard contents are normally lost. Optionally, Emacs can save the existing clipboard contents to the kill ring, preventing you from losing the old clipboard data. If save-interprogram-paste-before-kill has been set to a number, then the data is copied over if it’s smaller (in characters) than this number. If this variable is any other non-nil value, the data is always copied over—at the risk of high memory consumption if that data turns out to be large.

Yank commands, such as C-y (yank), also use the clipboard. If another application “owns” the clipboard—i.e., if you cut or copied text there more recently than your last kill command in Emacs—then Emacs yanks from the clipboard instead of the kill ring.

Normally, rotating the kill ring with M-y (yank-pop) does not alter the clipboard. However, if you change yank-pop-change-selection to t, then M-y saves the new yank to the clipboard.

To prevent kill and yank commands from accessing the clipboard, change the variable select-enable-clipboard to nil.

Programs can put other things than plain text on the clipboard. For instance, a web browser will usually let you choose “Copy Image” on images, and this image will be put on the clipboard. On capable platforms, Emacs can yank these objects with the yank-media command—but only in modes that have support for it (see Yanking Media in The Emacs Lisp Reference Manual).

Many X desktop environments support a feature called the clipboard manager. If you exit Emacs while it is the current “owner” of the clipboard data, and there is a clipboard manager running, Emacs transfers the clipboard data to the clipboard manager so that it is not lost. In some circumstances, this may cause a delay when exiting Emacs; if you wish to prevent Emacs from transferring data to the clipboard manager, change the variable x-select-enable-clipboard-manager to nil.

Since strings containing NUL bytes are usually truncated when passed through the clipboard, Emacs replaces such characters with “\0” before transferring them to the system’s clipboard.

Prior to Emacs 24, the kill and yank commands used the primary selection (see Cut and Paste with Other Window Applications), not the clipboard. If you prefer this behavior, change select-enable-clipboard to nil, select-enable-primary to t, and mouse-drag-copy-region to t. In this case, you can use the following commands to act explicitly on the clipboard: clipboard-kill-region kills the region and saves it to the clipboard; clipboard-kill-ring-save copies the region to the kill ring and saves it to the clipboard; and clipboard-yank yanks the contents of the clipboard at point.


**** Cut and Paste with Other Window Applications

Under the X Window System, PGTK and Haiku, there exists a primary selection containing the last stretch of text selected in an X application (usually by dragging the mouse). Typically, this text can be inserted into other X applications by mouse-2 clicks. The primary selection is separate from the clipboard. Its contents are more fragile; they are overwritten each time you select text with the mouse, whereas the clipboard is only overwritten by explicit cut or copy commands.

Under X, whenever the region is active (see The Mark and the Region), the text in the region is saved in the primary selection. This applies regardless of whether the region was made by dragging or clicking the mouse (see Mouse Commands for Editing), or by keyboard commands (e.g., by typing C-SPC and moving point; see Setting the Mark).

If you change the variable select-active-regions to only, Emacs saves only temporarily active regions to the primary selection, i.e., those made with the mouse or with shift selection (see Shift Selection). If you change select-active-regions to nil, Emacs avoids saving active regions to the primary selection entirely.

To insert the primary selection into an Emacs buffer, click mouse-2 (mouse-yank-primary) where you want to insert it. See Mouse Commands for Editing. You can also use the normal Emacs yank command (C-y) to insert this text if select-enable-primary is set (see Using the Clipboard).

By default, Emacs keeps the region active even after text is selected in another program; this is contrary to typical X behavior. To make Emacs deactivate the region after another program places data in the primary selection, enable the global minor mode lost-selection-mode.

MS-Windows provides no primary selection, but Emacs emulates it within a single Emacs session by storing the selected text internally. Therefore, all the features and commands related to the primary selection work on Windows as they do on X, for cutting and pasting within the same session, but not across Emacs sessions or with other applications.


**** Secondary Selection

In addition to the primary selection, the X Window System provides a second similar facility known as the secondary selection. Nowadays, few X applications make use of the secondary selection, but you can access it using the following Emacs commands:

M-Drag-mouse-1
Set the secondary selection, with one end at the place where you press down the button, and the other end at the place where you release it (mouse-set-secondary). The selected text is highlighted, using the secondary-selection face, as you drag. The window scrolls automatically if you drag the mouse off the top or bottom of the window, just like mouse-set-region (see Mouse Commands for Editing).

This command does not alter the kill ring.

M-mouse-1
Set one endpoint for the secondary selection (mouse-start-secondary); use M-mouse-3 to set the other end and complete the selection. This command cancels any existing secondary selection, when it starts a new one.

M-mouse-3
Set the secondary selection (mouse-secondary-save-then-kill), with one end at the position you click M-mouse-3, and the other at the position specified previously with M-mouse-1. This also puts the selected text in the kill ring. A second M-mouse-3 at the same place kills the text selected by the secondary selection just made.

M-mouse-2
Insert the secondary selection where you click, placing point at the end of the yanked text (mouse-yank-secondary).

Double or triple clicking of M-mouse-1 operates on words and lines, much like mouse-1.

If mouse-yank-at-point is non-nil, M-mouse-2 yanks at point. Then it does not matter precisely where you click, or even which of the frame’s windows you click on. See Mouse Commands for Editing. This user option also effects interactive search: if it is non-nil, yanking with the mouse anywhere in the frame will add the text to the search string.


*** Accumulating Text

Usually we copy or move text by killing it and yanking it, but there are other convenient methods for copying one block of text in many places, or for copying many scattered blocks of text into one place. Here we describe the commands to accumulate scattered pieces of text into a buffer or into a file.

M-x append-to-buffer
Append region to the contents of a specified buffer.

M-x prepend-to-buffer
Prepend region to the contents of a specified buffer.

M-x copy-to-buffer
Copy region into a specified buffer, deleting that buffer’s old contents.

M-x insert-buffer
Insert the contents of a specified buffer into current buffer at point.

M-x append-to-file
Append region to the contents of a specified file, at the end.

To accumulate text into a buffer, use M-x append-to-buffer. This reads a buffer name, then inserts a copy of the region into the buffer specified. If you specify a nonexistent buffer, append-to-buffer creates the buffer. The text is inserted wherever point is in that buffer. If you have been using the buffer for editing, the copied text goes into the middle of the text of the buffer, starting from wherever point happens to be at that moment.

Point in that buffer is left at the end of the copied text, so successive uses of append-to-buffer accumulate the text in the specified buffer in the same order as they were copied. Strictly speaking, append-to-buffer does not always append to the text already in the buffer—it appends only if point in that buffer is at the end. However, if append-to-buffer is the only command you use to alter a buffer, then point is always at the end.

M-x prepend-to-buffer is just like append-to-buffer except that point in the other buffer is left before the copied text, so successive uses of this command add text in reverse order. M-x copy-to-buffer is similar, except that any existing text in the other buffer is deleted, so the buffer is left containing just the text newly copied into it.

The command C-x x i (insert-buffer) can be used to retrieve the accumulated text from another buffer. This prompts for the name of a buffer, and inserts a copy of all the text in that buffer into the current buffer at point, leaving point at the beginning of the inserted text. It also adds the position of the end of the inserted text to the mark ring, without activating the mark. See Using Multiple Buffers, for background information on buffers.

Instead of accumulating text in a buffer, you can append text directly into a file with M-x append-to-file. This prompts for a filename, and adds the text of the region to the end of the specified file. The file is changed immediately on disk.

You should use append-to-file only with files that are not being visited in Emacs. Using it on a file that you are editing in Emacs would change the file behind Emacs’s back, which can lead to losing some of your editing.

Another way to move text around is to store it in a register. See Registers.


*** Rectangles

Rectangle commands operate on rectangular areas of the text: all the characters between a certain pair of columns, in a certain range of lines. Emacs has commands to kill rectangles, yank killed rectangles, clear them out, fill them with blanks or text, or delete them. Rectangle commands are useful with text in multicolumn formats, and for changing text into or out of such formats.

To specify a rectangle for a command to work on, set the mark at one corner and point at the opposite corner. The rectangle thus specified is called the region-rectangle. If point and the mark are in the same column, the region-rectangle is empty. If they are in the same line, the region-rectangle is one line high.

The region-rectangle is controlled in much the same way as the region is controlled. But remember that a given combination of point and mark values can be interpreted either as a region or as a rectangle, depending on the command that uses them.

A rectangular region can also be marked using the mouse: click and drag C-M-mouse-1 from one corner of the rectangle to the opposite.

C-x r k
Kill the text of the region-rectangle, saving its contents as the last killed rectangle (kill-rectangle).

C-x r M-w
Save the text of the region-rectangle as the last killed rectangle (copy-rectangle-as-kill).

C-x r d
Delete the text of the region-rectangle (delete-rectangle).

C-x r y
Yank the last killed rectangle with its upper left corner at point (yank-rectangle).

C-x r o
Insert blank space to fill the space of the region-rectangle (open-rectangle). This pushes the previous contents of the region-rectangle to the right.

C-x r N
Insert line numbers along the left edge of the region-rectangle (rectangle-number-lines). This pushes the previous contents of the region-rectangle to the right.

C-x r c
Clear the region-rectangle by replacing all of its contents with spaces (clear-rectangle).

M-x delete-whitespace-rectangle
Delete whitespace in each of the lines on the specified rectangle, starting from the left edge column of the rectangle.

C-x r t string RET
Replace rectangle contents with string on each line (string-rectangle).

M-x string-insert-rectangle RET string RET
Insert string on each line of the rectangle.

C-x SPC
Toggle Rectangle Mark mode (rectangle-mark-mode). When this mode is active, the region-rectangle is highlighted and can be shrunk/grown, and the standard kill and yank commands operate on it.

The rectangle operations fall into two classes: commands to erase or insert rectangles, and commands to make blank rectangles.

There are two ways to erase the text in a rectangle: C-x r d (delete-rectangle) to delete the text outright, or C-x r k (kill-rectangle) to remove the text and save it as the last killed rectangle. In both cases, erasing the region-rectangle is like erasing the specified text on each line of the rectangle; if there is any following text on the line, it moves backwards to fill the gap.

Killing a rectangle is not killing in the usual sense; the rectangle is not stored in the kill ring, but in a special place that only records the most recent rectangle killed. This is because yanking a rectangle is so different from yanking linear text that different yank commands have to be used. Yank-popping is not defined for rectangles.

C-x r M-w (copy-rectangle-as-kill) is the equivalent of M-w for rectangles: it records the rectangle as the last killed rectangle, without deleting the text from the buffer.

To yank the last killed rectangle, type C-x r y (yank-rectangle). The rectangle’s first line is inserted at point, the rectangle’s second line is inserted at the same horizontal position one line vertically below, and so on. The number of lines affected is determined by the height of the saved rectangle.

For example, you can convert two single-column lists into a double-column list by killing one of the single-column lists as a rectangle, and then yanking it beside the other list.

You can also copy rectangles into and out of registers with C-x r r r and C-x r i r. See Saving Rectangles in Registers.

There are two commands you can use for making blank rectangles: C-x r c (clear-rectangle) blanks out existing text in the region-rectangle, and C-x r o (open-rectangle) inserts a blank rectangle.

M-x delete-whitespace-rectangle deletes horizontal whitespace starting from a particular column. This applies to each of the lines in the rectangle, and the column is specified by the left edge of the rectangle. The right edge of the rectangle does not make any difference to this command.

The command C-x r N (rectangle-number-lines) inserts line numbers along the left edge of the region-rectangle. Normally, the numbering begins from 1 (for the first line of the rectangle). With a prefix argument, the command prompts for a number to begin from, and for a format string with which to print the numbers (see Formatting Strings in The Emacs Lisp Reference Manual).

The command C-x r t (string-rectangle) replaces the contents of a region-rectangle with a string on each line. The string’s width need not be the same as the width of the rectangle. If the string’s width is less, the text after the rectangle shifts left; if the string is wider than the rectangle, the text after the rectangle shifts right.

The command M-x string-insert-rectangle is similar to string-rectangle, but inserts the string on each line, shifting the original text to the right.

The command C-x SPC (rectangle-mark-mode) toggles whether the region-rectangle or the standard region is highlighted (first activating the region if necessary). When this mode is enabled, commands that resize the region (C-f, C-n etc.) do so in a rectangular fashion, and killing and yanking operate on the rectangle. See Killing and Moving Text. The mode persists only as long as the region is active.

The region-rectangle works only when the mark is active. In particular, when Transient Mark mode is off (see Disabling Transient Mark Mode), in addition to typing C-x SPC you will need to activate the mark.

Unlike the standard region, the region-rectangle can have its corners extended past the end of buffer, or inside stretches of white space that point normally cannot enter, like in the middle of a TAB character.

When the region is active (see The Mark and the Region) and in rectangle-mark-mode, C-x C-x runs the command rectangle-exchange-point-and-mark, which cycles between the four corners of the region-rectangle. This comes in handy if you want to modify the dimensions of the region-rectangle before invoking an operation on the marked text.


*** CUA Bindings

The command M-x cua-mode sets up key bindings that are compatible with the Common User Access (CUA) system used in many other applications.

When CUA mode is enabled, the keys C-x, C-c, C-v, and C-z invoke commands that cut (kill), copy, paste (yank), and undo respectively. The C-x and C-c keys perform cut and copy only if the region is active. Otherwise, they still act as prefix keys, so that standard Emacs commands like C-x C-c still work. Note that this means the variable mark-even-if-inactive has no effect for C-x and C-c (see Operating on the Region).

To enter an Emacs command like C-x C-f while the mark is active, use one of the following methods: either hold Shift together with the prefix key, e.g., S-C-x C-f, or quickly type the prefix key twice, e.g., C-x C-x C-f.

To disable the overriding of standard Emacs binding by CUA mode, while retaining the other features of CUA mode described below, set the variable cua-enable-cua-keys to nil.

CUA mode by default activates Delete-Selection mode (see Mouse Commands for Editing) so that typed text replaces the active region. To use CUA without this behavior, set the variable cua-delete-selection to nil.

CUA mode provides enhanced rectangle support with visible rectangle highlighting. Use C-RET to start a rectangle, extend it using the movement commands, and cut or copy it using C-x or C-c. RET moves the cursor to the next (clockwise) corner of the rectangle, so you can easily expand it in any direction. Normal text you type is inserted to the left or right of each line in the rectangle (on the same side as the cursor).

You can use this rectangle support without activating CUA by calling the cua-rectangle-mark-mode command. There’s also the standard command rectangle-mark-mode, see Rectangles.

With CUA you can easily copy text and rectangles into and out of registers by providing a one-digit numeric prefix to the kill, copy, and yank commands, e.g., C-1 C-c copies the region into register 1, and C-2 C-v yanks the contents of register 2.

CUA mode also has a global mark feature which allows easy moving and copying of text between buffers. Use C-S-SPC to toggle the global mark on and off. When the global mark is on, all text that you kill or copy is automatically inserted at the global mark, and text you type is inserted at the global mark rather than at the current position.

For example, to copy words from various buffers into a word list in a given buffer, set the global mark in the target buffer, then navigate to each of the words you want in the list, mark it (e.g., with S-M-f), copy it to the list with C-c or M-w, and insert a newline after the word in the target list by pressing RET.


** Keyboard Macros

In this chapter we describe how to record a sequence of editing commands so you can repeat it conveniently later.

A keyboard macro is a command defined by an Emacs user to stand for another sequence of keys. For example, if you discover that you are about to type C-n M-d C-d forty times, you can speed your work by defining a keyboard macro to do C-n M-d C-d, and then executing it 39 more times.

You define a keyboard macro by executing and recording the commands which are its definition. Put differently, as you define a keyboard macro, the definition is being executed for the first time. This way, you can see the effects of your commands, so that you don’t have to figure them out in your head. When you close the definition, the keyboard macro is defined and also has been, in effect, executed once. You can then do the whole thing over again by invoking the macro.

Keyboard macros differ from ordinary Emacs commands in that they are written in the Emacs command language rather than in Lisp. This makes it easier for the novice to write them, and makes them more convenient as temporary hacks. However, the Emacs command language is not powerful enough as a programming language to be useful for writing anything intelligent or general. For such things, Lisp must be used.


*** Basic Use

F3
Start defining a keyboard macro (kmacro-start-macro-or-insert-counter).

F4
If a keyboard macro is being defined, end the definition; otherwise, execute the most recent keyboard macro (kmacro-end-or-call-macro).

C-u F3
Re-execute last keyboard macro, then append keys to its definition.

C-u C-u F3
Append keys to the last keyboard macro without re-executing it.

C-x C-k r
Run the last keyboard macro on each line that begins in the region (apply-macro-to-region-lines).

C-x (
Start defining a keyboard macro (old style) (kmacro-start-macro); with a prefix argument, append keys to the last macro.

C-x )
End a macro definition (old style) (kmacro-end-macro); prefix argument serves as the repeat count for executing the macro.

C-x e
Execute the most recently defined keyboard macro (kmacro-end-and-call-macro); prefix argument serves as repeat count.

To start defining a keyboard macro, type F3. From then on, your keys continue to be executed, but also become part of the definition of the macro. ‘Def’ appears in the mode line to remind you of what is going on. When you are finished, type F4 (kmacro-end-or-call-macro) to terminate the definition. For example,

F3 M-f foo F4
defines a macro to move forward a word and then insert ‘foo’. Note that F3 and F4 do not become part of the macro.

After defining the macro, you can call it with F4. For the above example, this has the same effect as typing M-f foo again. (Note the two roles of the F4 command: it ends the macro if you are in the process of defining one, or calls the last macro otherwise.) You can also supply F4 with a numeric prefix argument ‘n’, which means to invoke the macro ‘n’ times. An argument of zero repeats the macro indefinitely, until it gets an error or you type C-g (or, on MS-DOS, C-Break).

The above example demonstrates a handy trick that you can employ with keyboard macros: if you wish to repeat an operation at regularly spaced places in the text, include a motion command as part of the macro. In this case, repeating the macro inserts the string ‘foo’ after each successive word.

After terminating the definition of a keyboard macro, you can append more keystrokes to its definition by typing C-u F3. This is equivalent to plain F3 followed by retyping the whole definition so far. As a consequence, it re-executes the macro as previously defined. If you change the variable kmacro-execute-before-append to nil, the existing macro will not be re-executed before appending to it (the default is t). You can also add to the end of the definition of the last keyboard macro without re-executing it by typing C-u C-u F3.

When a command reads an argument with the minibuffer, your minibuffer input becomes part of the macro along with the command. So when you replay the macro, the command gets the same argument as when you entered the macro. For example,

F3 C-a C-k C-x b foo RET C-y C-x b RET F4
defines a macro that kills the current line, yanks it into the buffer ‘foo’, then returns to the original buffer.

Most keyboard commands work as usual in a keyboard macro definition, with some exceptions. Typing C-g (keyboard-quit) quits the keyboard macro definition. Typing C-M-c (exit-recursive-edit) can be unreliable: it works as you’d expect if exiting a recursive edit that started within the macro, but if it exits a recursive edit that started before you invoked the keyboard macro, it also necessarily exits the keyboard macro too. Mouse events are also unreliable, even though you can use them in a keyboard macro: when the macro replays the mouse event, it uses the original mouse position of that event, the position that the mouse had while you were defining the macro. The effect of this may be hard to predict.

The command C-x C-k r (apply-macro-to-region-lines) repeats the last defined keyboard macro on each line that begins in the region. It does this line by line, by moving point to the beginning of the line and then executing the macro.

In addition to the F3 and F4 commands described above, Emacs also supports an older set of key bindings for defining and executing keyboard macros. To begin a macro definition, type C-x ( (kmacro-start-macro); as with F3, a prefix argument appends this definition to the last keyboard macro. To end a macro definition, type C-x ) (kmacro-end-macro). To execute the most recent macro, type C-x e (kmacro-end-and-call-macro). If you enter C-x e while defining a macro, the macro is terminated and executed immediately. Immediately after typing C-x e, you can type e repeatedly to immediately repeat the macro one or more times. You can also give C-x e a repeat argument, just like F4 (when it is used to execute a macro).

C-x ) can be given a repeat count as an argument. This means to repeat the macro right after defining it. The macro definition itself counts as the first repetition, since it is executed as you define it, so C-u 4 C-x ) executes the macro immediately 3 additional times.

While executing a long-running keyboard macro, it can sometimes be useful to trigger a redisplay (to show how far we’ve gotten). The C-x C-k d command can be used for this. As a not very useful example, C-x ( M-f C-x C-k d C-x ) will create a macro that will redisplay once per iteration when saying C-u 42 C-x e.


*** The Keyboard Macro Ring

All defined keyboard macros are recorded in the keyboard macro ring. There is only one keyboard macro ring, shared by all buffers.

C-x C-k C-k
Execute the keyboard macro at the head of the ring (kmacro-end-or-call-macro-repeat).

C-x C-k C-n
Rotate the keyboard macro ring to the next macro (defined earlier) (kmacro-cycle-ring-next).

C-x C-k C-p
Rotate the keyboard macro ring to the previous macro (defined later) (kmacro-cycle-ring-previous).

All commands which operate on the keyboard macro ring use the same C-x C-k prefix. Most of these commands can be executed and repeated immediately after each other without repeating the C-x C-k prefix. For example,

C-x C-k C-p C-p C-k C-k C-k C-n C-n C-k C-p C-k C-d
will rotate the keyboard macro ring to the second-previous macro, execute the resulting head macro three times, rotate back to the original head macro, execute that once, rotate to the previous macro, execute that, and finally delete it from the macro ring.

The command C-x C-k C-k (kmacro-end-or-call-macro-repeat) executes the keyboard macro at the head of the macro ring. You can repeat the macro immediately by typing another C-k, or you can rotate the macro ring immediately by typing C-n or C-p.

When a keyboard macro is being defined, C-x C-k C-k behaves like F4 except that, immediately afterward, you can use most key bindings of this section without the C-x C-k prefix. For instance, another C-k will re-execute the macro.

The commands C-x C-k C-n (kmacro-cycle-ring-next) and C-x C-k C-p (kmacro-cycle-ring-previous) rotate the macro ring, bringing the next or previous keyboard macro to the head of the macro ring. The definition of the new head macro is displayed in the echo area. You can continue to rotate the macro ring immediately by repeating just C-n and C-p until the desired macro is at the head of the ring. To execute the new macro ring head immediately, just type C-k.

Note that Emacs treats the head of the macro ring as the last defined keyboard macro. For instance, F4 will execute that macro, and C-x C-k n will give it a name.

The maximum number of macros stored in the keyboard macro ring is determined by the customizable variable kmacro-ring-max.


*** The Keyboard Macro Counter

Each keyboard macro has an associated counter, which is initialized to 0 when you start defining the macro. This current counter allows you to insert a number into the buffer that depends on the number of times the macro has been called. The counter is normally incremented each time its value is inserted into the buffer.

In addition to the current counter, keyboard macros also maintain the previous counter, which records the value the current counter had last time it was incremented or set. Note that incrementing the current counter by zero, e.g., with C-u 0 C-x C-k C-i, also records the value of the current counter as the previous counter value.

F3
In a keyboard macro definition, insert the keyboard macro counter value in the buffer (kmacro-start-macro-or-insert-counter).

C-x C-k C-i
Insert the keyboard macro counter value in the buffer (kmacro-insert-counter).

C-x C-k C-c
Set the keyboard macro counter (kmacro-set-counter).

C-x C-k C-a
Add the prefix arg to the keyboard macro counter (kmacro-add-counter).

C-x C-k C-f
Specify the format for inserting the keyboard macro counter (kmacro-set-format).

When you are defining a keyboard macro, the command F3 (kmacro-start-macro-or-insert-counter) inserts the current value of the keyboard macro’s counter into the buffer, and increments the counter by 1. (If you are not defining a macro, F3 begins a macro definition instead. See Basic Use.) You can use a numeric prefix argument to specify a different increment. If you just specify a C-u prefix, that inserts the previous counter value, and doesn’t change the current value.

As an example, let us show how the keyboard macro counter can be used to build a numbered list. Consider the following key sequence:

F3 C-a F3 . SPC F4
As part of this keyboard macro definition, the string ‘0. ’ was inserted into the beginning of the current line. If you now move somewhere else in the buffer and type F4 to invoke the macro, the string ‘1. ’ is inserted at the beginning of that line. Subsequent invocations insert ‘2. ’, ‘3. ’, and so forth.

The command C-x C-k C-i (kmacro-insert-counter) does the same thing as F3, but it can be used outside a keyboard macro definition. When no keyboard macro is being defined or executed, it inserts and increments the counter of the macro at the head of the keyboard macro ring.

The command C-x C-k C-c (kmacro-set-counter) sets the current macro counter to the value of the numeric argument. If you use it inside the macro, it operates on each repetition of the macro. If you specify just C-u as the prefix, while executing the macro, that resets the counter to the value it had at the beginning of the current repetition of the macro (undoing any increments so far in this repetition).

The command C-x C-k C-a (kmacro-add-counter) adds the prefix argument to the current macro counter. With just C-u as argument, it resets the counter to the last value inserted by any keyboard macro. (Normally, when you use this, the last insertion will be in the same macro and it will be the same counter.)

The command C-x C-k C-f (kmacro-set-format) prompts for the format to use when inserting the macro counter. The default format is ‘%d’, which means to insert the number in decimal without any padding. You can exit with empty minibuffer to reset the format to this default. You can specify any format string that the format function accepts and that makes sense with a single integer extra argument (see Formatting Strings in The Emacs Lisp Reference Manual). Do not put the format string inside double quotes when you insert it in the minibuffer.

If you use this command while no keyboard macro is being defined or executed, the new format affects all subsequent macro definitions. Existing macros continue to use the format in effect when they were defined. If you set the format while defining a keyboard macro, this affects the macro being defined from that point on, but it does not affect subsequent macros. Execution of the macro will, at each step, use the format in effect at that step during its definition. Changes to the macro format during execution of a macro, like the corresponding changes during its definition, have no effect on subsequent macros.

The format set by C-x C-k C-f does not affect insertion of numbers stored in registers.

If you use a register as a counter, incrementing it on each repetition of the macro, that accomplishes the same thing as a keyboard macro counter. See Keeping Numbers in Registers. For most purposes, it is simpler to use a keyboard macro counter.


*** Executing Macros with Variations

In a keyboard macro, you can create an effect similar to that of query-replace, in that the macro asks you each time around whether to make a change.

C-x q
When this point is reached during macro execution, ask for confirmation (kbd-macro-query).

While defining the macro, type C-x q at the point where you want the query to occur. During macro definition, the C-x q does nothing, but when you run the macro later, C-x q asks you interactively whether to continue.

The valid responses when C-x q asks are:

SPC (or y)
Continue executing the keyboard macro.

DEL (or n)
Skip the remainder of this repetition of the macro, and start right away with the next repetition.

RET (or q)
Skip the remainder of this repetition and cancel further repetitions.

C-r
Enter a recursive editing level, in which you can perform editing which is not part of the macro. When you exit the recursive edit using C-M-c, you are asked again how to continue with the keyboard macro. If you type a SPC at this time, the rest of the macro definition is executed. It is up to you to leave point and the text in a state such that the rest of the macro will do what you want.

C-u C-x q, which is C-x q with a prefix argument, performs a completely different function. It enters a recursive edit reading input from the keyboard, both when you type it during the definition of the macro, and when it is executed from the macro. During definition, the editing you do inside the recursive edit does not become part of the macro. During macro execution, the recursive edit gives you a chance to do some particularized editing on each repetition. See Recursive Editing Levels.


*** Naming and Saving Keyboard Macros

C-x C-k n
Give a command name (for the duration of the Emacs session) to the most recently defined keyboard macro (kmacro-name-last-macro).

C-x C-k b
Bind the most recently defined keyboard macro to a key sequence (for the duration of the session) (kmacro-bind-to-key).

M-x insert-kbd-macro
Insert in the buffer a keyboard macro’s definition, as Lisp code.

If you wish to save a keyboard macro for later use, you can give it a name using C-x C-k n (kmacro-name-last-macro). This reads a name as an argument using the minibuffer and defines that name to execute the last keyboard macro, in its current form. (If you later add to the definition of this macro, that does not alter the name’s definition as a macro.) The macro name is a Lisp symbol, and defining it in this way makes it a valid command name for calling with M-x or for binding a key to with keymap-global-set (see Keymaps). If you specify a name that has a prior definition other than a keyboard macro, an error message is shown and nothing is changed.

You can also bind the last keyboard macro (in its current form) to a key, using C-x C-k b (kmacro-bind-to-key) followed by the key sequence you want to bind. You can bind to any key sequence in the global keymap, but since most key sequences already have other bindings, you should select the key sequence carefully. If you try to bind to a key sequence with an existing binding (in any keymap), this command asks you for confirmation before replacing the existing binding.

To avoid problems caused by overriding existing bindings, the key sequences C-x C-k 0 through C-x C-k 9 and C-x C-k A through C-x C-k Z are reserved for your own keyboard macro bindings. In fact, to bind to one of these key sequences, you only need to type the digit or letter rather than the whole key sequences. For example,

C-x C-k b 4
will bind the last keyboard macro to the key sequence C-x C-k 4.

Once a macro has a command name, you can save its definition in a file. Then it can be used in another editing session. First, visit the file you want to save the definition in. Then use this command:

M-x insert-kbd-macro RET macroname RET
This inserts some Lisp code that, when executed later, will define the same macro with the same definition it has now. (You don’t need to understand Lisp code to do this, because insert-kbd-macro writes the Lisp code for you.) Then save the file. You can load the file later with load-file (see Libraries of Lisp Code for Emacs). If the file you save in is your init file ~/.emacs (see The Emacs Initialization File) then the macro will be defined each time you run Emacs.

If you give insert-kbd-macro a prefix argument, it makes additional Lisp code to record the keys (if any) that you have bound to macroname, so that the macro will be reassigned the same keys when you load the file.


*** Editing a Keyboard Macro

C-x C-k C-e
Edit the last defined keyboard macro (kmacro-edit-macro).

C-x C-k e name RET
Edit a previously defined keyboard macro name (edit-kbd-macro).

C-x C-k l
Edit the last 300 keystrokes as a keyboard macro (kmacro-edit-lossage).

You can edit the last keyboard macro by typing C-x C-k C-e or C-x C-k RET (kmacro-edit-macro). This formats the macro definition in a buffer and enters a specialized major mode for editing it. Type C-h m once in that buffer to display details of how to edit the macro. When you are finished editing, type C-c C-c.

You can edit a named keyboard macro or a macro bound to a key by typing C-x C-k e (edit-kbd-macro). Follow that with the keyboard input that you would use to invoke the macro—C-x e or M-x name or some other key sequence.

You can edit the last 300 keystrokes as a macro by typing C-x C-k l (kmacro-edit-lossage).


*** Stepwise Editing a Keyboard Macro

You can interactively replay and edit the last keyboard macro, one command at a time, by typing C-x C-k SPC (kmacro-step-edit-macro). Unless you quit the macro using q or C-g, the edited macro replaces the last macro on the macro ring.

This macro editing feature shows the last macro in the minibuffer together with the first (or next) command to be executed, and prompts you for an action. You can enter ? to get a summary of your options. These actions are available:

SPC and y execute the current command, and advance to the next command in the keyboard macro.
n, d, and DEL skip and delete the current command.
f skips the current command in this execution of the keyboard macro, but doesn’t delete it from the macro.
TAB executes the current command, as well as all similar commands immediately following the current command; for example, TAB may be used to insert a sequence of characters (corresponding to a sequence of self-insert-command commands).
c continues execution (without further editing) until the end of the keyboard macro. If execution terminates normally, the edited macro replaces the original keyboard macro.
C-k skips and deletes the rest of the keyboard macro, terminates step-editing, and replaces the original keyboard macro with the edited macro.
q and C-g cancels the step-editing of the keyboard macro; discarding any changes made to the keyboard macro.
i key… C-j reads and executes a series of key sequences (not including the final C-j), and inserts them before the current command in the keyboard macro, without advancing over the current command.
I key… reads one key sequence, executes it, and inserts it before the current command in the keyboard macro, without advancing over the current command.
r key… C-j reads and executes a series of key sequences (not including the final C-j), and replaces the current command in the keyboard macro with them, advancing over the inserted key sequences.
R key… reads one key sequence, executes it, and replaces the current command in the keyboard macro with that key sequence, advancing over the inserted key sequence.
a key… C-j executes the current command, then reads and executes a series of key sequences (not including the final C-j), and inserts them after the current command in the keyboard macro; it then advances over the current command and the inserted key sequences.
A key… C-j executes the rest of the commands in the keyboard macro, then reads and executes a series of key sequences (not including the final C-j), and appends them at the end of the keyboard macro; it then terminates the step-editing and replaces the original keyboard macro with the edited macro.


** Indentation

Indentation refers to inserting or adjusting whitespace characters (space and/or tab characters) at the beginning of a line of text. This chapter documents indentation commands and options which are common to Text mode and related modes, as well as programming language modes. See Indentation for Programs, for additional documentation about indenting in programming modes.

The simplest way to perform indentation is the TAB key. In most major modes, this runs the command indent-for-tab-command. (In C and related modes, TAB runs the command c-indent-line-or-region, which behaves similarly, see Commands for C Indentation).

TAB
Insert whitespace, or indent the current line, in a mode-appropriate way (indent-for-tab-command). If the region is active, indent all the lines within it.

The exact behavior of TAB depends on the major mode. In Text mode and related major modes, TAB normally inserts some combination of space and tab characters to advance point to the next tab stop (see Tab Stops). For this purpose, the position of the first non-whitespace character on the preceding line is treated as an additional tab stop, so you can use TAB to align point with the preceding line. If the region is active (see Operating on the Region), TAB acts specially: it indents each line in the region so that its first non-whitespace character is aligned with the preceding line.

In programming modes, TAB indents the current line of code in a way that makes sense given the code in the preceding lines. If the region is active, all the lines in the region are indented this way. If point was initially within the current line’s indentation, it is repositioned to the first non-whitespace character on the line.

If you just want to insert a tab character in the buffer, type C-q TAB (see Inserting Text).

*** Indentation Commands

Apart from the TAB (indent-for-tab-command) command, Emacs provides a variety of commands to perform indentation in other ways.

C-M-o ¶
Split the current line at point (split-line). The text on the line after point becomes a new line, indented to the same column where point is located. This command first moves point forward over any spaces and tabs. Afterward, point is positioned before the inserted newline.

M-m
Move (forward or back) to the first non-whitespace character on the current line (back-to-indentation). If there are no non-whitespace characters on the line, move to the end of the line.

M-i ¶
Indent whitespace at point, up to the next tab stop (tab-to-tab-stop). See Tab Stops.

M-x indent-relative
Insert whitespace at point, until point is aligned with the first non-whitespace character on the previous line (actually, the last non-blank line). If point is already farther right than that, run tab-to-tab-stop instead—unless called with a numeric argument, in which case do nothing.

M-^ ¶
Merge the previous and the current line (delete-indentation). This joins the two lines cleanly, by replacing any indentation at the front of the current line, together with the line boundary, with a single space.

As a special case (useful for Lisp code), the single space is omitted if the characters to be joined are consecutive opening and closing parentheses, or if the junction follows another newline.

If there is a fill prefix, M-^ deletes the fill prefix if it appears after the newline that is deleted. See The Fill Prefix.

With a prefix argument, join the current line to the following line. If the region is active, and no prefix argument is given, join all lines in the region instead.

C-M-\ ¶
Indent all the lines in the region, as though you had typed TAB at the beginning of each line (indent-region).

If a numeric argument is supplied, indent every line in the region to that column number.

C-x TAB ¶
Indent all lines that begin in the region, moving the affected lines as a rigid unit (indent-rigidly).

If called with no argument, this command activates a transient mode for adjusting the indentation of the affected lines interactively. While this transient mode is active, typing LEFT or RIGHT indents leftward and rightward, respectively, by one space. You can also type S-LEFT or S-RIGHT to indent leftward or rightward to the next tab stop (see Tab Stops). Typing any other key disables the transient mode, and this key is then acted upon as normally.

If called with a prefix argument n, this command indents the lines forward by n spaces (without enabling the transient mode). Negative values of n indent backward, so you can remove all indentation from the lines in the region using a large negative argument, like this:

C-u -999 C-x TAB


*** Tab Stops

Emacs defines certain column numbers to be tab stops. These are used as stopping points by TAB when inserting whitespace in Text mode and related modes (see Indentation), and by commands like M-i (see Indentation Commands). The variable tab-stop-list controls these positions. The default value is nil, which means a tab stop every 8 columns. The value can also be a list of zero-based column numbers (in increasing order) at which to place tab stops. Emacs extends the list forever by repeating the difference between the last and next-to-last elements.

Instead of customizing the variable tab-stop-list directly, a convenient way to view and set tab stops is via the command M-x edit-tab-stops. This switches to a buffer containing a description of the tab stop settings, which looks like this:

        :       :       :       :       :       :
0         1         2         3         4
0123456789012345678901234567890123456789012345678
To install changes, type C-c C-c
The first line contains a colon at each tab stop. The numbers on the next two lines are present just to indicate where the colons are. If the value of tab-stop-list is nil, as it is by default, no colons are displayed initially.

You can edit this buffer to specify different tab stops by placing colons on the desired columns. The buffer uses Overwrite mode (see Minor Modes). Remember that Emacs will extend the list of tab stops forever by repeating the difference between the last two explicit stops that you place. When you are done, type C-c C-c to make the new tab stops take effect. Normally, the new tab stop settings apply to all buffers. However, if you have made the tab-stop-list variable local to the buffer where you called M-x edit-tab-stops (see Local Variables), then the new tab stop settings apply only to that buffer. To save the tab stop settings for future Emacs sessions, use the Customize interface to save the value of tab-stop-list (see Easy Customization Interface).

Note that the tab stops discussed in this section have nothing to do with how tab characters are displayed in the buffer. Tab characters are always displayed as empty spaces extending to the next display tab stop. See How Text Is Displayed.


*** Tabs vs. Spaces

Normally, indentation commands insert (or remove) the shortest possible series of tab and space characters so as to align to the desired column. Tab characters are displayed as a stretch of empty space extending to the next display tab stop. By default, there is one display tab stop every tab-width columns (the default is 8). See How Text Is Displayed.

If you prefer, all indentation can be made from spaces only. To request this, set the buffer-local variable indent-tabs-mode to nil. See Local Variables, for information about setting buffer-local variables. Note, however, that C-q TAB always inserts a tab character, regardless of the value of indent-tabs-mode.

One reason to set indent-tabs-mode to nil is that not all editors display tab characters in the same way. Emacs users, too, may have different customized values of tab-width. By using spaces only, you can make sure that your file always looks the same. If you only care about how it looks within Emacs, another way to tackle this problem is to set the tab-width variable in a file-local variable (see Local Variables in Files).

There are also commands to convert tabs to spaces or vice versa, always preserving the columns of all non-whitespace text. M-x tabify scans the region for sequences of spaces, and converts sequences of at least two spaces to tabs if that can be done without changing indentation. M-x untabify changes all tabs in the region to appropriate numbers of spaces.


*** Convenience Features for Indentation

The variable tab-always-indent tweaks the behavior of the TAB (indent-for-tab-command) command. The default value, t, gives the behavior described in Indentation. If you change the value to the symbol complete, then TAB first tries to indent the current line, and if the line was already indented, it tries to complete the text at point (see Completion for Symbol Names). If the value is nil, then TAB indents the current line only if point is at the left margin or in the line’s indentation; otherwise, it inserts a tab character.

If tab-always-indent is complete, whether to expand or indent can be further customized via the tab-first-completion variable. For instance, if that variable is eol, only complete if point is at the end of a line. See Mode-Specific Indent in The Emacs Lisp Reference Manual, for further details.

Electric Indent mode is a global minor mode that automatically indents the line after every RET you type. This mode is enabled by default. To toggle this minor mode, type M-x electric-indent-mode. To toggle the mode in a single buffer, use M-x electric-indent-local-mode.


*** Code Alignment

Alignment is the process of adjusting whitespace in a sequence of lines in the region such that in all lines certain parts begin at the same column. This is usually something you do to enhance readability of a piece of text or code. The classic example is aligning a series of assignments in C-like programming languages:

int a = 1;
short foo = 2;
double blah = 4;
is commonly aligned to:

int    a    = 1;
short  foo  = 2;
double blah = 4;
You can use the command M-x align to align lines in the current region. This command knows about common alignment patterns across many markup and programming languages. It encodes these patterns as a set of alignment rules, that say how to align different kinds of text in different contexts.

The user option align-rules-list says which alignment rules M-x align should consult. The value of this option is a list with elements describing alignment rules. Each element is a cons cell (title . attributes), where title is the name of the alignment rule as a symbol, and attributes is a list of rule attributes that define when the rule should apply and how it partitions and aligns lines. Each rule attribute is a cons cell (attribute . value), where attribute is the name of attribute and value is its value. The only required attribute is regexp, whose value is a regular expression with sub-expressions matching the parts of each line where M-x align should expand or contract whitespace (see Backslash in Regular Expressions). See the documentation string of align-rules-list (C-h v align-rules-list RET) for a full description of possible alignment rule attributes. By default, this option is set to a long list of alignment rules for many languages that Emacs supports. The default rules use the modes rule attribute to specify major modes in which M-x align should apply them. Major modes can also override align-rules-list by setting the buffer-local variable align-mode-rules-list to a non-nil list of alignment rules. When align-mode-rules-list is non-nil, M-x align consults it instead of align-rules-list.

Besides alignment rules, M-x align uses another kind of rules called exclusion rules. The exclusion rules say which parts in the region M-x align should not align and instead leave them intact. The user option align-exclude-rules-list specifies these exclusion rules. Similarly to align-rules-list, the value of align-exclude-rules-list is also a list of cons cells that describe the exclusion rules. By default, align-exclude-rules-list includes rules that exclude alignment in quoted strings and comments in Lisp, C and other languages. Beyond the default exclusion rules in align-exclude-rules-list, major modes can define bespoke exclusion rules by setting align-mode-exclude-rules-list to a non-nil list of rules, this overrides align-exclude-rules-list just like align-mode-rules-list overrides align-rules-list.

M-x align splits the region into a series of sections, usually sequences of non-blank lines, and aligns each section according to all matching alignment rule by expanding or contracting stretches of whitespace. M-x align consistently aligns all lines inside a single section, but it may align different sections in the region differently. The user option align-region-separate specifies how M-x align separates the region to sections. This option can be one of the symbols entire, group, or a regular expression. If align-region-separate is entire, Emacs aligns the entire region as a single section. If this option is group, Emacs aligns each group of consecutive non-blank lines in the region as a separate section. If align-region-separate is a regular expression, M-x align scans the region for matches to that regular expression and treats them as section separators. By default align-region-separate is set to a regular expression that matches blank lines and lines that contains only whitespace and a single curly brace (‘{’ or ‘}’). For special cases where regular expressions are not accurate enough, you can also set align-region-separate to a function that says how to separate the region to alignment sections. See the documentation string of align-region-separate for more details. Specific alignment rules can override the value of align-region-separate and define their own section separator by specifying the separate rule attribute.

If you call M-x align with a prefix argument (C-u), it enables more alignment rules that are often useful but may sometimes be too intrusive. For example, in a Lisp buffer with the following form:

(set-face-attribute 'mode-line-inactive nil
:box nil
                    :background nil
                    :underline "black")
Typing (C-u M-x align) yields:

(set-face-attribute 'mode-line-inactive nil
                    :box                nil
                    :background         nil
                    :underline          "black")
In most cases, you should try M-x align without a prefix argument first, and if that doesn’t produce the right result you can undo with C-/ and try again with C-u M-x align.

You can use the command M-x align-highlight-rule to visualize the effect of a specific alignment or exclusion rule in the current region. This command prompts you for the title of a rule and highlights the parts on the region that this rule affects. For alignment rules, this command highlights the whitespace that M-x align would expand or contract, and for exclusion this command highlights the parts that M-x align would exclude from alignment. To remove the highlighting that this command creates, type M-x align-unhighlight-rule.

The command M-x align-current is similar to M-x align, except that it operates only on the alignment section that contains point regardless of the current region. This command determines the boundaries of the current section according to the section separators that align-region-separate define. M-x align-entire is another variant of M-x align, that disregards align-region-separate and aligns the entire region as a single alignment section with consistent alignment. If you set align-region-separate to entire, M-x align behaves like M-x align-entire by default. To illustrate the effect of aligning the entire region as a single alignment section, consider the following code:

one = 1;
foobarbaz = 2;

spam = 3;
emacs = 4;
when the region covers all of these lines, typing M-x align yields:

one       = 1;
foobarbaz = 2;

spam  = 3;
emacs = 4;
On the other hand, M-x align-entire aligns all of the lines as a single section, so the ‘=’ appears at the same column in all lines:

one       = 1;
foobarbaz = 2;

spam      = 3;
emacs     = 4;
The command M-x align-regexp lets you align the current region with an alignment rule that you define ad-hoc, instead of using the predefined rules in align-rules-list. M-x align-regexp prompts you for a regular expression and uses that expression as the regexp attribute for an ad-hoc alignment rule that this command uses to align the current region. By default, this command adjusts the whitespace that matches the first sub-expression of the regular expression you specify. If you call M-x align-regexp with a prefix argument, it also prompts you for the sub-expression to use and lets you specify the amount of whitespace to use as padding, as well as whether to apply the rule repeatedly to all matches of the regular expression in each line. See Backslash in Regular Expressions, for more information about regular expressions and their sub-expressions.

If the user option align-indent-before-aligning is non-nil, Emacs indents the region before aligning it with M-x align. See Indentation. By default align-indent-before-aligning is set to nil.

The user option align-to-tab-stop says whether aligned parts should start at a tab stop (see Tab Stops). If this option is nil, M-x align uses just enough whitespace for alignment, disregarding tab stops. If this is a non-nil symbol, M-x align checks the value of that symbol, and if this value is non-nil, M-x align aligns to tab stops. By default, this option is set to indent-tabs-mode, so alignment respects tab stops in buffers that use tabs for indentation. See Tabs vs. Spaces.

The user option align-default-spacing specifies the default amount of whitespace that M-x align and its related commands use for padding between the different parts of each line when aligning it. When align-to-tab-stop is nil, the value of align-default-spacing is the number of spaces to use for padding; when align-to-tab-stop is non-nil, the value of align-default-spacing is instead the number of tab stops to use. Each alignment rule can override the default that align-default-spacing specifies with the spacing attribute rule.








** Registers

Emacs registers are compartments where you can save text, rectangles, positions, and other things for later use. Once you save text or a rectangle in a register, you can copy it into the buffer once or many times; once you save a position in a register, you can jump back to that position once or many times.

Each register has a name that consists of a single character, which we will denote by r; r can be a letter (such as ‘a’) or a number (such as ‘1’); case matters, so register ‘a’ is not the same as register ‘A’. You can also set a register in non-alphanumeric characters, for instance ‘*’ or ‘C-d’. Note, it’s not possible to set a register in ‘C-g’ or ‘ESC’, because these keys are reserved for quitting (see Quitting and Aborting).

A register can store a position, a piece of text, a rectangle, a number, a window or frame configuration, a buffer name, or a file name, but only one thing at any given time. Whatever you store in a register remains there until you store something else in that register. To see what register r contains, use M-x view-register:

M-x view-register RET r
Display a description of what register r contains.

All of the commands that prompt for a register will display a preview window that lists the existing registers (if there are any) after a short delay. To change the length of the delay, customize register-preview-delay. To prevent this display, set that option to nil. You can explicitly request a preview window by pressing C-h or F1.

Bookmarks record files and positions in them, so you can return to those positions when you look at the file again. Bookmarks are similar in spirit to registers, so they are also documented in this chapter.


*** Saving Positions in Registers

C-x r SPC r
Record the position of point and the current buffer in register r (point-to-register).

C-x r j r
Jump to the position and buffer saved in register r (jump-to-register).

Typing C-x r SPC (point-to-register), followed by a character r, saves both the position of point and the current buffer in register r. The register retains this information until you store something else in it.

The command C-x r j r switches to the buffer recorded in register r, pushes a mark, and moves point to the recorded position. (The mark is not pushed if point was already at the recorded position, or in successive calls to the command.) The contents of the register are not changed, so you can jump to the saved position any number of times.

If you use C-x r j to go to a saved position, but the buffer it was saved from has been killed, C-x r j tries to create the buffer again by visiting the same file. Of course, this works only for buffers that were visiting files.


*** Saving Text in Registers

When you want to insert a copy of the same piece of text several times, it may be inconvenient to yank it from the kill ring, since each subsequent kill moves that entry further down the ring. An alternative is to store the text in a register and later retrieve it.

C-x r s r
Copy region into register r (copy-to-register).

C-x r i r
Insert text from register r (insert-register).

M-x append-to-register RET r
Append region to text in register r.

When register r contains text, you can use C-x r + (increment-register) to append to that register. Note that command C-x r + behaves differently if r contains a number. See Keeping Numbers in Registers.

M-x prepend-to-register RET r
Prepend region to text in register r.

C-x r s r stores a copy of the text of the region into the register named r. If the mark is inactive, Emacs first reactivates the mark where it was last set. The mark is deactivated at the end of this command. See The Mark and the Region. C-u C-x r s r, the same command with a prefix argument, copies the text into register r and deletes the text from the buffer as well; you can think of this as moving the region text into the register.

M-x append-to-register RET r appends the copy of the text in the region to the text already stored in the register named r. If invoked with a prefix argument, it deletes the region after appending it to the register. The command prepend-to-register is similar, except that it prepends the region text to the text in the register instead of appending it.

When you are collecting text using append-to-register and prepend-to-register, you may want to separate individual collected pieces using a separator. In that case, configure a register-separator and store the separator text in to that register. For example, to get double newlines as text separator during the collection process, you can use the following setting.

(setq register-separator ?+)
(set-register register-separator "\n\n")
C-x r i r inserts in the buffer the text from register r. Normally it leaves point after the text and sets the mark before, without activating it. With a prefix argument, it instead puts point before the text and the mark


*** Saving Rectangles in Registers

A register can contain a rectangle instead of linear text. See Rectangles, for basic information on how to specify a rectangle in the buffer.

C-x r r r
Copy the region-rectangle into register r (copy-rectangle-to-register). With prefix argument, delete it as well.

C-x r i r
Insert the rectangle stored in register r (if it contains a rectangle) (insert-register).

The C-x r i r (insert-register) command, previously documented in Saving Text in Registers, inserts a rectangle rather than a text string, if the register contains a rectangle.


*** Saving Rectangles in Registers

A register can contain a rectangle instead of linear text. See Rectangles, for basic information on how to specify a rectangle in the buffer.

C-x r r r
Copy the region-rectangle into register r (copy-rectangle-to-register). With prefix argument, delete it as well.

C-x r i r
Insert the rectangle stored in register r (if it contains a rectangle) (insert-register).

The C-x r i r (insert-register) command, previously documented in Saving Text in Registers, inserts a rectangle rather than a text string, if the register contains a rectangle.


*** Keeping Numbers in Registers

There are commands to store a number in a register, to insert the number in the buffer in decimal, and to increment it. These commands can be useful in keyboard macros (see Keyboard Macros).

C-u number C-x r n r ¶
Store number into register r (number-to-register).

C-u number C-x r + r ¶
If r contains a number, increment the number in that register by number. Note that command C-x r + (increment-register) behaves differently if r contains text. See Saving Text in Registers.

C-x r i r
Insert the number from register r into the buffer.

C-x r i is the same command used to insert any other sort of register contents into the buffer. C-x r + with no numeric argument increments the register value by 1; C-x r n with no numeric argument stores zero in the register.


*** Keeping File and Buffer Names in Registers

If you visit certain file names frequently, you can visit them more conveniently if you put their names in registers. Here’s the Lisp code used to put a file name into register r:

(set-register r '(file . name))
For example,

(set-register ?z '(file . "/gd/gnu/emacs/19.0/src/ChangeLog"))
puts the file name shown in register ‘z’.

To visit the file whose name is in register r, type C-x r j r. (This is the same command used to jump to a position or restore a frame configuration.)

Similarly, if there are certain buffers you visit frequently, you can put their names in registers. For instance, if you visit the ‘*Messages*’ buffer often, you can use the following snippet to put that buffer into the ‘m’ register:

(set-register ?m '(buffer . "*Messages*"))
To switch to the buffer whose name is in register r, type C-x r j r.


*** Keyboard Macro Registers

If you need to execute a keyboard macro (see Keyboard Macros) frequently, it is more convenient to put it in a register or save it (see Naming and Saving Keyboard Macros). C-x C-k x r (kmacro-to-register) stores the last keyboard macro in register r.

To execute the keyboard macro in register r, type C-x r j r. (This is the same command used to jump to a position or restore a frameset.)


*** Bookmarks

Bookmarks are somewhat like registers in that they record positions you can jump to. Unlike registers, they have long names, and they persist automatically from one Emacs session to the next. The prototypical use of bookmarks is to record where you were reading in various files.

C-x r m RET
Set the bookmark for the visited file, at point.

C-x r m bookmark RET
Set the bookmark named bookmark at point (bookmark-set).

C-x r M bookmark RET
Like C-x r m, but don’t overwrite an existing bookmark.

C-x r b bookmark RET
Jump to the bookmark named bookmark (bookmark-jump).

C-x r l
List all bookmarks (list-bookmarks).

M-x bookmark-save
Save all the current bookmark values in the default bookmark file.

To record the current position in the visited file, use the command C-x r m, which sets a bookmark using the visited file name as the default for the bookmark name. If you name each bookmark after the file it points to, then you can conveniently revisit any of those files with C-x r b, and move to the position of the bookmark at the same time.

The command C-x r M (bookmark-set-no-overwrite) works like C-x r m, but it signals an error if the specified bookmark already exists, instead of overwriting it.

To display a list of all your bookmarks in a separate buffer, type C-x r l (list-bookmarks). If you switch to that buffer, you can use it to edit your bookmark definitions or annotate the bookmarks. Type C-h m in the bookmark buffer for more information about its special editing commands.

When you kill Emacs, Emacs saves your bookmarks, if you have changed any bookmark values. You can also save the bookmarks at any time with the M-x bookmark-save command. Bookmarks are saved to the file ~/.emacs.d/bookmarks (for compatibility with older versions of Emacs, if you have a file named ~/.emacs.bmk, that is used instead). The bookmark commands load your default bookmark file automatically. This saving and loading is how bookmarks persist from one Emacs session to the next.

If you set the variable bookmark-save-flag to 1, each command that sets a bookmark will also save your bookmarks; this way, you don’t lose any bookmark values even if Emacs crashes. The value, if a number, says how many bookmark modifications should go by between saving. If you set this variable to nil, Emacs only saves bookmarks if you explicitly use M-x bookmark-save.

The variable bookmark-default-file specifies the file in which to save bookmarks by default.

If you set the variable bookmark-use-annotations to t, setting a bookmark will query for an annotation. If a bookmark has an annotation, it is automatically shown in a separate window when you jump to the bookmark.

Bookmark position values are saved with surrounding context, so that bookmark-jump can find the proper position even if the file is modified slightly. The variable bookmark-search-size says how many characters of context to record on each side of the bookmark’s position. (In buffers that are visiting encrypted files, no context is saved in the bookmarks file no matter the value of this variable.)

Here are some additional commands for working with bookmarks:

M-x bookmark-load RET filename RET ¶
Load a file named filename that contains a list of bookmark values. You can use this command, as well as bookmark-write, to work with other files of bookmark values in addition to your default bookmark file.

M-x bookmark-write RET filename RET ¶
Save all the current bookmark values in the file filename.

M-x bookmark-delete RET bookmark RET ¶
Delete the bookmark named bookmark.

M-x bookmark-insert-location RET bookmark RET ¶
Insert in the buffer the name of the file that bookmark bookmark points to.

M-x bookmark-insert RET bookmark RET ¶
Insert in the buffer the contents of the file that bookmark bookmark points to.

** Abbrev

A defined abbrev is a word which expands, if you insert it, into some different text. Abbrevs are defined by the user to expand in specific ways. For example, you might define ‘foo’ as an abbrev expanding to ‘find outer otter’. Then you could insert ‘find outer otter ’ into the buffer by typing f o o SPC.

A second kind of abbreviation facility is called dynamic abbrev expansion. You use dynamic abbrev expansion with an explicit command to expand the letters in the buffer before point by looking for other words in the buffer that start with those letters. See Dynamic Abbrev Expansion.

A third kind, hippie expansion, generalizes abbreviation expansion. See Hippie Expansion in Features for Automatic Typing.

*** Abbrev Concepts

An abbrev is a word that has been defined to expand into a specified expansion. When you insert a word-separator character following the abbrev, that expands the abbrev—replacing the abbrev with its expansion. For example, if ‘foo’ is defined as an abbrev expanding to ‘find outer otter’, then typing f o o . will insert ‘find outer otter.’.

Abbrevs expand only when Abbrev mode, a buffer-local minor mode, is enabled. Disabling Abbrev mode does not cause abbrev definitions to be forgotten, but they do not expand until Abbrev mode is enabled again. The command M-x abbrev-mode toggles Abbrev mode; with a numeric argument, it turns Abbrev mode on if the argument is positive, off otherwise. See Minor Modes.

Abbrevs can have mode-specific definitions, active only in one major mode. Abbrevs can also have global definitions that are active in all major modes. The same abbrev can have a global definition and various mode-specific definitions for different major modes. A mode-specific definition for the current major mode overrides a global definition.

You can define abbrevs interactively during the editing session, irrespective of whether Abbrev mode is enabled. You can also save lists of abbrev definitions in files, which you can then reload for use in later sessions.


*** Defining Abbrevs

C-x a g
Define an abbrev, using one or more words before point as its expansion (add-global-abbrev).

C-x a l
Similar, but define an abbrev specific to the current major mode (add-mode-abbrev).

C-x a i g
Define a word in the buffer as an abbrev (inverse-add-global-abbrev).

C-x a i l
Define a word in the buffer as a mode-specific abbrev (inverse-add-mode-abbrev).

M-x define-global-abbrev RET abbrev RET exp RET
Define abbrev as an abbrev expanding into exp.

M-x define-mode-abbrev RET abbrev RET exp RET
Define abbrev as a mode-specific abbrev expanding into exp.

M-x kill-all-abbrevs
Discard all abbrev definitions, leaving a blank slate.

The usual way to define an abbrev is to enter the text you want the abbrev to expand to, position point after it, and type C-x a g (add-global-abbrev). This reads the abbrev itself using the minibuffer, and then defines it as an abbrev for one or more words before point. Use a numeric argument to say how many words before point should be taken as the expansion. For example, to define the abbrev ‘foo’ as mentioned above, insert the text ‘find outer otter’ and then type C-u 3 C-x a g f o o RET.

If you’re using transient-mark-mode (which is the default), the active region will be used as the expansion of the abbrev being defined. If not, an argument of zero to C-x a g means to use the contents of the region.

The command C-x a l (add-mode-abbrev) is similar, but defines a mode-specific abbrev for the current major mode. The arguments work the same as for C-x a g.

C-x a i g (inverse-add-global-abbrev) and C-x a i l (inverse-add-mode-abbrev) perform the opposite task: if the abbrev text is already in the buffer, you use these commands to define an abbrev by specifying the expansion in the minibuffer. These commands will expand the abbrev text used for the definition.

You can define an abbrev without inserting either the abbrev or its expansion in the buffer using the command define-global-abbrev. It reads two arguments—the abbrev, and its expansion. The command define-mode-abbrev does likewise for a mode-specific abbrev.

To change the definition of an abbrev, just make a new definition. When an abbrev has a prior definition, the abbrev definition commands ask for confirmation before replacing it.

To remove an abbrev definition, give a negative argument to the abbrev definition command: C-u - C-x a g or C-u - C-x a l. The former removes a global definition, while the latter removes a mode-specific definition. M-x kill-all-abbrevs removes all abbrev definitions, both global and local.


*** Controlling Abbrev Expansion

When Abbrev mode is enabled, an abbrev expands whenever it is present in the buffer just before point and you type a self-inserting whitespace or punctuation character (SPC, comma, etc.). More precisely, any character that is not a word constituent expands an abbrev, and any word-constituent character can be part of an abbrev. The most common way to use an abbrev is to insert it and then insert a punctuation or whitespace character to expand it.

Abbrev expansion preserves case: ‘foo’ expands to ‘find outer otter’, and ‘Foo’ to ‘Find outer otter’. ‘FOO’ expands to ‘Find Outer Otter’ by default, but if you change the variable abbrev-all-caps to a non-nil value, it expands to ‘FIND OUTER OTTER’.

These commands are used to control abbrev expansion:

M-'
Separate a prefix from a following abbrev to be expanded (abbrev-prefix-mark).

C-x a e ¶
Expand the abbrev before point (expand-abbrev). This is effective even when Abbrev mode is not enabled.

M-x unexpand-abbrev ¶
Undo the expansion of the last expanded abbrev.

M-x expand-region-abbrevs
Expand some or all abbrevs found in the region.

You may wish to expand an abbrev and attach a prefix to the expansion; for example, if ‘cnst’ expands into ‘construction’, you might want to use it to enter ‘reconstruction’. It does not work to type recnst, because that is not necessarily a defined abbrev. What you can do is use the command M-' (abbrev-prefix-mark) in between the prefix ‘re’ and the abbrev ‘cnst’. First, insert ‘re’. Then type M-'; this inserts a hyphen in the buffer to indicate that it has done its work. Then insert the abbrev ‘cnst’; the buffer now contains ‘re-cnst’. Now insert a non-word character to expand the abbrev ‘cnst’ into ‘construction’. This expansion step also deletes the hyphen that indicated M-' had been used. The result is the desired ‘reconstruction’.

If you actually want the text of the abbrev in the buffer, rather than its expansion, you can accomplish this by inserting the following punctuation with C-q. Thus, foo C-q , leaves ‘foo,’ in the buffer, not expanding it.

If you expand an abbrev by mistake, you can undo the expansion by typing C-/ (undo). See Undo. This undoes the insertion of the abbrev expansion and brings back the abbrev text. If the result you want is the terminating non-word character plus the unexpanded abbrev, you must reinsert the terminating character, quoting it with C-q. You can also use the command M-x unexpand-abbrev to cancel the last expansion without deleting the terminating character.

M-x expand-region-abbrevs searches through the region for defined abbrevs, and for each one found offers to replace it with its expansion. This command is useful if you have typed in text using abbrevs but forgot to turn on Abbrev mode first. It may also be useful together with a special set of abbrev definitions for making several global replacements at once. This command is effective even if Abbrev mode is not enabled.

The function expand-abbrev performs the expansion by calling the function that abbrev-expand-function specifies. By changing this function you can make arbitrary changes to the abbrev expansion. See Abbrev Expansion in The Emacs Lisp Reference Manual.


*** Abbrevs Suggestions

You can get abbrev suggestions when you manually type text for which there is currently an active defined abbrev. For example, if there is an abbrev ‘foo’ with the expansion ‘find outer otter’, and you manually type ‘find outer otter’, Emacs can notice this and show a hint in the echo area when you have stopped typing.

To enable the abbrev suggestion feature, customize the option abbrev-suggest to a non-nil value.

The variable abbrev-suggest-hint-threshold controls when to suggest an abbrev to the user. This variable defines the minimum savings (in terms of the number of characters the user will not have to type) required for Emacs to suggest using an abbrev. For example, if the user types ‘foo bar’ (seven characters) and there is an abbrev ‘fubar’ defined (five characters), the user will not get any suggestion unless the threshold is set to the number 2 or lower. With the default value 3, the user would not get any suggestion in this example, because the savings in using the abbrev are below the threshold. If you always want to get abbrev suggestions, set this variable’s value to zero.

The command abbrev-suggest-show-report displays a buffer with all the abbrev suggestions shown during the current editing session. This can be useful if you get several abbrev suggestions and don’t remember them all.


*** Examining and Editing Abbrevs

M-x list-abbrevs
Display a list of all abbrev definitions. With a numeric argument, list only local abbrevs.

M-x edit-abbrevs
Edit a list of abbrevs; you can add, alter or remove definitions.

The output from M-x list-abbrevs looks like this:

various other tables…
(python-mode-skeleton-abbrev-table)
"class" (sys)	    0 "" python-skeleton-class
(lisp-mode-abbrev-table)
"ks"          0    "keymap-set"
(global-abbrev-table)
"dfn"         0    "definition"
(Some blank lines of no semantic significance, and some other abbrev tables, have been omitted.)

A line containing a name in parentheses is the header for abbrevs in a particular abbrev table; global-abbrev-table contains all the global abbrevs, and the other abbrev tables that are named after major modes contain the mode-specific abbrevs.

Within each abbrev table, each nonblank line defines one abbrev. The word at the beginning of the line is the abbrev. The number that follows is the number of times the abbrev has been expanded. Emacs keeps track of this to help you see which abbrevs you actually use, so that you can eliminate those that you don’t use often. The string at the end of the line is the expansion.

Some abbrevs are marked with ‘(sys)’. These system abbrevs (see Abbrevs in The Emacs Lisp Reference Manual) are pre-defined by various modes, and are not saved to your abbrev file. To disable a system abbrev, define an abbrev of the same name that expands to itself, and save it to your abbrev file. The system abbrevs have an associated hook function, which is called to perform the abbrev expansion; the name of that function follows the abbrev expansion in the buffer shown by list-abbrevs.

M-x edit-abbrevs allows you to add, change or kill abbrev definitions by editing a list of them in an Emacs buffer. The list has the same format described above. The buffer of abbrevs is called *Abbrevs*, and is in Edit-Abbrevs mode. Type C-c C-c in this buffer to install the abbrev definitions as specified in the buffer—and delete any abbrev definitions not listed.

The command edit-abbrevs is actually the same as list-abbrevs except that it selects the buffer *Abbrevs* whereas list-abbrevs merely displays it in another window.


*** Saving Abbrevs

These commands allow you to keep abbrev definitions between editing sessions.

M-x write-abbrev-file RET file RET
Write a file file describing all defined abbrevs.

M-x read-abbrev-file RET file RET
Read the file file and define abbrevs as specified therein.

M-x define-abbrevs
Define abbrevs from definitions in current buffer.

M-x insert-abbrevs
Insert all abbrevs and their expansions into current buffer.

M-x write-abbrev-file reads a file name using the minibuffer and then writes a description of all current abbrev definitions into that file. This is used to save abbrev definitions for use in a later session. The text stored in the file is a series of Lisp expressions that, when executed, define the same abbrevs that you currently have.

M-x read-abbrev-file reads a file name using the minibuffer and then reads the file, defining abbrevs according to the contents of the file. The function quietly-read-abbrev-file is similar except that it does not display a message in the echo area; you cannot invoke it interactively, and it is used primarily in your init file (see The Emacs Initialization File). If either of these functions is called with nil as the argument, it uses the file given by the variable abbrev-file-name, which is ~/.emacs.d/abbrev_defs by default. This is your standard abbrev definition file, and Emacs loads abbrevs from it automatically when it starts up. (As an exception, Emacs does not load the abbrev file when it is started in batch mode. See Initial Options, for a description of batch mode.)

Emacs will offer to save abbrevs automatically if you have changed any of them, whenever it offers to save all files (for C-x s or C-x C-c). It saves them in the file specified by abbrev-file-name. This feature can be inhibited by setting the variable save-abbrevs to nil; setting it to silently will save the abbrevs automatically without asking.

The commands M-x insert-abbrevs and M-x define-abbrevs are similar to the previous commands but work on text in an Emacs buffer. M-x insert-abbrevs inserts text into the current buffer after point, describing all current abbrev definitions; M-x define-abbrevs parses the entire current buffer and defines abbrevs accordingly.


*** Dynamic Abbrev Expansion

The abbrev facility described above operates automatically as you insert text, but all abbrevs must be defined explicitly. By contrast, dynamic abbrevs allow the meanings of abbreviations to be determined automatically from the contents of the buffer, but dynamic abbrev expansion happens only when you request it explicitly.

M-/
Expand the word in the buffer before point as a dynamic abbrev, by searching for words starting with that abbreviation (dabbrev-expand).

C-M-/
Complete the word before point as a dynamic abbrev (dabbrev-completion).

For example, if the buffer contains ‘does this follow ’ and you type f o M-/, the effect is to insert ‘follow’ because that is the last word in the buffer that starts with ‘fo’. A numeric argument to M-/ says to take the second, third, etc. distinct expansion found looking backward from point. Repeating M-/ searches for an alternative expansion by looking farther back. After scanning all the text before point, it searches the text after point. The variable dabbrev-limit, if non-nil, specifies how far away in the buffer to search for an expansion.

After scanning the current buffer, M-/ normally searches other buffers. The variables dabbrev-check-all-buffers and dabbrev-check-other-buffers can be used to determine which other buffers, if any, are searched. Buffers that have major modes derived from any of the modes in dabbrev-ignored-buffer-modes are ignored.

For finer control over which buffers to scan, customize the variables dabbrev-ignored-buffer-names and dabbrev-ignored-buffer-regexps. The value of the former is a list of buffer names to skip. The value of the latter is a list of regular expressions; if a buffer’s name matches any of these regular expressions, dynamic abbrev expansion skips that buffer.

A negative argument to M-/, as in C-u - M-/, says to search first for expansions after point, then other buffers, and consider expansions before point only as a last resort. If you repeat the M-/ to look for another expansion, do not specify an argument. Repeating M-/ cycles through all the expansions after point and then the expansions before point.

After you have expanded a dynamic abbrev, you can copy additional words that follow the expansion in its original context. Simply type SPC M-/ for each additional word you want to copy. The spacing and punctuation between words is copied along with the words.

You can control the way M-/ determines the word to expand and how to expand it, see Customizing Dynamic Abbreviation.

The command C-M-/ (dabbrev-completion) performs completion of a dynamic abbrev. Instead of trying the possible expansions one by one, it finds all of them, then inserts the text that they have in common. If they have nothing in common, C-M-/ displays a list of completions, from which you can select a choice in the usual manner. See Completion.

Dynamic abbrev expansion is completely independent of Abbrev mode; the expansion of a word with M-/ is completely independent of whether it has a definition as an ordinary abbrev.


*** Customizing Dynamic Abbreviation

Normally, dynamic abbrev expansion ignores case when searching for expansions. That is, the expansion need not agree in case with the word you are expanding.

This feature is controlled by the variable dabbrev-case-fold-search. If it is t, case is ignored in this search; if it is nil, the word and the expansion must match in case. If the value is case-fold-search (the default), then the variable case-fold-search controls whether to ignore case while searching for expansions (see Lax Matching During Searching).

Normally, dynamic abbrev expansion preserves the case pattern of the dynamic abbrev you are expanding, by converting the expansion to that case pattern.

The variable dabbrev-case-replace controls whether to preserve the case pattern of the dynamic abbrev. If it is t, the dynamic abbrev’s case pattern is preserved in most cases; if it is nil, the expansion is always copied verbatim. If the value is case-replace (the default), then the variable case-replace controls whether to copy the expansion verbatim (see Replace Commands and Lax Matches).

However, if the expansion contains a complex mixed case pattern, and the dynamic abbrev matches this pattern as far as it goes, then the expansion is always copied verbatim, regardless of those variables. Thus, for example, if the buffer contains variableWithSillyCasePattern, and you type v a M-/, it copies the expansion verbatim including its case pattern.

The variable dabbrev-abbrev-char-regexp, if non-nil, controls which characters are considered part of a word, for dynamic expansion purposes. The regular expression must match just one character, never two or more. The same regular expression also determines which characters are part of an expansion. The (default) value nil has a special meaning: dynamic abbrevs (i.e. the word at point) are made of word characters, but their expansions are looked for as sequences of word and symbol characters. This is generally appropriate for expanding symbols in a program source and also for human-readable text in many languages, but may not be what you want in a text buffer that includes unusual punctuation characters; in that case, the value "\\sw" might produce better results.

In shell scripts and makefiles, a variable name is sometimes prefixed with ‘$’ and sometimes not. Major modes for this kind of text can customize dynamic abbrev expansion to handle optional prefixes by setting the variable dabbrev-abbrev-skip-leading-regexp. Its value should be a regular expression that matches the optional prefix that dynamic abbrev expression should ignore. The default is nil, which means no characters should be skipped.




** Editing Programs ( ams mode ✓✓✓ ) 

This chapter describes Emacs features for facilitating editing programs. Some of the things these features can do are:

Find or move over top-level definitions (see Top-Level Definitions, or Defuns).

Apply the usual indentation conventions of the language (see Indentation for Programs).

Balance parentheses (see Commands for Editing with Parentheses).

Insert, kill or align comments (see Manipulating Comments).

Highlight program syntax (see Font Lock mode).


*** Major Modes for Programming Languages

Emacs has specialized major modes (see Major Modes) for many programming languages. A programming language mode typically specifies the syntax of expressions, the customary rules for indentation, how to do syntax highlighting for the language, and how to find the beginning or end of a function definition. It often has features for compiling and debugging programs as well. The major mode for each language is named after the language; for instance, the major mode for the C programming language is c-mode.

Emacs has programming language modes for Lisp, Scheme, the Scheme-based DSSSL expression language, Ada, ASM, AWK, C, C++, C#, Fortran, Icon, IDL (CORBA), IDLWAVE, Java, Javascript, M4, Makefiles, Metafont (TeX’s companion for font creation), Modula2, Object Pascal, Objective-C, Octave, Pascal, Perl, Pike, PostScript, Prolog, Python, Ruby, Simula, SQL, Tcl, TypeScript, Verilog, and VHDL. An alternative mode for Perl is called CPerl mode. Modes are also available for the scripting languages of the common GNU and Unix shells, and MS-DOS/MS-Windows ‘BAT’ files, JSON, DNS master files, CSS (Cascading Style Sheets), Dockerfiles, CMake files, and various sorts of configuration files.

Ideally, Emacs should have a major mode for each programming language that you might want to edit. If it doesn’t have a mode for your favorite language, the mode might be implemented in a package not distributed with Emacs (see Emacs Lisp Packages); or you can contribute one.

If Emacs has been compiled with the ‘tree-sitter’ library, it offers several optional editing modes based on that library, which utilize the incremental parsing capabilities provided by ‘tree-sitter’. These modes have ‘-ts-’ in their names; for example c-ts-mode, python-ts-mode, etc.

In most programming languages, indentation should vary from line to line to illustrate the structure of the program. Therefore, in most programming language modes, typing TAB updates the indentation of the current line (see Indentation for Programs). Furthermore, DEL is usually bound to backward-delete-char-untabify, which deletes backward treating each tab as if it were the equivalent number of spaces, so that you can delete one column of indentation without worrying whether the whitespace consists of spaces or tabs.

Entering a programming language mode runs the custom Lisp functions specified in the hook variable prog-mode-hook, followed by those specified in the mode’s own mode hook (see Major Modes). For instance, entering C mode runs the hooks prog-mode-hook and c-mode-hook. See Hooks, for information about hooks.

Separate manuals are available for the modes for Ada (see Ada Mode in Ada Mode), C/C++/Objective C/Java/Corba IDL/Pike/AWK (see CC Mode in CC Mode), Octave, VHDL, and IDLWAVE (see IDLWAVE in IDLWAVE User Manual).


*** Top-Level Definitions, or Defuns

In Emacs, a major definition at the top level in the buffer, such as a function, is called a defun. The name comes from Lisp, but in Emacs we use it for all languages.

**** Left Margin Convention

Many programming-language modes have traditionally assumed that any opening parenthesis or brace found at the left margin is the start of a top-level definition, or defun. So, by default, commands which seek the beginning of a defun accept such a delimiter as signifying that position.

If you want to override this convention, you can do so by setting the user option open-paren-in-column-0-is-defun-start to nil. If this option is set to t (the default), commands seeking the start of a defun will stop at opening parentheses or braces at column zero which aren’t in a comment or string. When it is nil, defuns are found by searching for parens or braces at the outermost level. Since low-level Emacs routines no longer depend on this convention, you usually won’t need to change open-paren-in-column-0-is-defun-start from its default.


**** Moving by Defuns

These commands move point or set up the region based on top-level major definitions, also called defuns.

C-M-a
Move to beginning of current or preceding defun (beginning-of-defun).

C-M-e
Move to end of current or following defun (end-of-defun).

C-M-h
Put region around whole current or following defun (mark-defun).

The commands to move to the beginning and end of the current defun are C-M-a (beginning-of-defun) and C-M-e (end-of-defun). If you repeat one of these commands, or use a positive numeric argument, each repetition moves to the next defun in the direction of motion.

C-M-a with a negative argument −n moves forward n times to the next beginning of a defun. This is not exactly the same place that C-M-e with argument n would move to; the end of this defun is not usually exactly the same place as the beginning of the following defun. (Whitespace, comments, and perhaps declarations can separate them.) Likewise, C-M-e with a negative argument moves back to an end of a defun, which is not quite the same as C-M-a with a positive argument.

To operate on the current defun, use C-M-h (mark-defun), which sets the mark at the end of the current defun and puts point at its beginning. See Commands to Mark Textual Objects. This is the easiest way to get ready to kill the defun in order to move it to a different place in the file. If the defun is directly preceded by comments (with no intervening blank lines), they are marked, too. If you use the command while point is between defuns, it uses the following defun. If you use the command while the mark is already active, it extends the end of the region to include one more defun. With a prefix argument, it marks that many defuns or extends the region by the appropriate number of defuns. With negative prefix argument it marks defuns in the opposite direction and also changes the direction of selecting for subsequent uses of mark-defun.

In C mode, C-M-h runs the function c-mark-function, which is almost the same as mark-defun; the difference is that it backs up over the argument declarations, function name and returned data type so that the entire C function is inside the region. This is an example of how major modes adjust the standard key bindings so that they do their standard jobs in a way better fitting a particular language. Other major modes may replace any or all of these key bindings for that purpose.

Some programming languages supported nested defuns, whereby a defun (such as a function or a method or a class) can be defined inside (i.e., as part of the body) of another defun. The commands described above by default find the beginning and the end of the innermost defun around point. Major modes based on the tree-sitter library provide control of this behavior: if the variable treesit-defun-tactic is set to the value top-level, the defun commands will find the outermost defuns instead.


**** Imenu

The Imenu facility offers a way to find the major definitions in a file by name. It is also useful in text formatter major modes, where it treats each chapter, section, etc., as a definition. (See Find Identifier References, for a more powerful feature that handles multiple files together.)

If you type M-g i (imenu), it reads the name of a definition using the minibuffer, then moves point to that definition. You can use completion to specify the name; the command always displays the whole list of valid names.

Alternatively, you can bind the command imenu to a mouse click. Then it displays mouse menus for you to select a definition name. You can also add the buffer’s index to the menu bar by calling imenu-add-menubar-index. If you want to have this menu bar item available for all buffers in a certain major mode, you can do this by adding imenu-add-menubar-index to its mode hook. But if you have done that, you will have to wait a little while each time you visit a file in that mode, while Emacs finds all the definitions in that buffer.

When you change the contents of a buffer, if you add or delete definitions, you can update the buffer’s index based on the new contents by invoking the ‘*Rescan*’ item in the menu. Rescanning happens automatically if you set imenu-auto-rescan to a non-nil value. There is no need to rescan because of small changes in the text.

imenu-auto-rescan will be disabled in buffers that are larger than imenu-auto-rescan-maxout in bytes, and scanning is stopped if it takes more than imenu-max-index-time seconds.

You can customize the way the menus are sorted by setting the variable imenu-sort-function. By default, names are ordered as they occur in the buffer; if you want alphabetic sorting, use the symbol imenu--sort-by-name as the value. You can also define your own comparison function by writing Lisp code.

If Eglot is activated for the current buffer’s project (see Working with Projects) and the current buffer’s major mode, Eglot provides its own facility for producing the buffer’s index based on the analysis of the program source by the language-server which manages the current buffer. See Eglot Features in Eglot: The Emacs LSP Client.

Imenu provides the information to guide Which Function mode (see Which Function Mode). The Speedbar can also use it (see Speedbar Frames).


**** Which Function Mode

Which Function mode is a global minor mode (see Minor Modes) which displays the current function name in the mode line, updating it as you move around in a buffer.

To either enable or disable Which Function mode, use the command M-x which-function-mode. Which Function mode is a global minor mode. By default, it takes effect in all major modes that know how to support it (i.e., all the major modes that support Imenu). You can restrict it to a specific list of major modes by changing the value of the variable which-func-modes from t (which means to support all available major modes) to a list of major mode names.


*** Indentation for Programs

The best way to keep a program properly indented is to use Emacs to reindent it as you change it. Emacs has commands to indent either a single line, a specified number of lines, or all of the lines inside a single parenthetical grouping.

See Indentation, for general information about indentation. This section describes indentation features specific to programming language modes.

Emacs also provides a Lisp pretty-printer in the pp package, which reformats Lisp objects with nice-looking indentation. See pp in The Emacs Lisp Reference Manual.

**** Basic Program Indentation Commands

TAB
Adjust indentation of current line (indent-for-tab-command).

RET
Insert a newline, then adjust indentation of following line (newline).

The basic indentation command is TAB (indent-for-tab-command), which was documented in Indentation. In programming language modes, TAB indents the current line, based on the indentation and syntactic content of the preceding lines; if the region is active, TAB indents each line within the region, not just the current line.

The command RET (newline), which was documented in Inserting Text, does the same as C-j followed by TAB: it inserts a new line, then adjusts the line’s indentation.

When indenting a line that starts within a parenthetical grouping, Emacs usually places the start of the line under the preceding line within the group, or under the text after the parenthesis. If you manually give one of these lines a nonstandard indentation (e.g., for aesthetic purposes), the lines below will follow it.

The indentation commands for most programming language modes assume that an open-parenthesis, open-brace or other opening delimiter at the left margin is the start of a function. If the code you are editing violates this assumption—even if the delimiters occur in strings or comments—you must set open-paren-in-column-0-is-defun-start to nil for indentation to work properly. See Left Margin Convention.


**** Indenting Several Lines

Sometimes, you may want to reindent several lines of code at a time. One way to do this is to use the mark; when the mark is active and the region is non-empty, TAB indents every line in the region. Alternatively, the command C-M-\ (indent-region) indents every line in the region, whether or not the mark is active (see Indentation Commands).

In addition, Emacs provides the following commands for indenting large chunks of code:

C-M-q
Reindent all the lines within one parenthetical grouping.

C-u TAB
Shift an entire parenthetical grouping rigidly sideways so that its first line is properly indented.

M-x indent-code-rigidly
Shift all the lines in the region rigidly sideways, but do not alter lines that start inside comments and strings.

To reindent the contents of a single parenthetical grouping, position point before the beginning of the grouping and type C-M-q. This changes the relative indentation within the grouping, without affecting its overall indentation (i.e., the indentation of the line where the grouping starts). The function that C-M-q runs depends on the major mode; it is indent-pp-sexp in Lisp mode, c-indent-exp in C mode, etc. To correct the overall indentation as well, type TAB first.

If you like the relative indentation within a grouping but not the indentation of its first line, move point to that first line and type C-u TAB. In Lisp, C, and some other major modes, TAB with a numeric argument reindents the current line as usual, then reindents by the same amount all the lines in the parenthetical grouping starting on the current line. It is clever, though, and does not alter lines that start inside strings. Neither does it alter C preprocessor lines when in C mode, but it does reindent any continuation lines that may be attached to them.

The command M-x indent-code-rigidly rigidly shifts all the lines in the region sideways, like indent-rigidly does (see Indentation Commands). It doesn’t alter the indentation of lines that start inside a string, unless the region also starts inside that string. The prefix arg specifies the number of columns to indent.


**** Customizing Lisp Indentation

The indentation pattern for a Lisp expression can depend on the function called by the expression. For each Lisp function, you can choose among several predefined patterns of indentation, or define an arbitrary one with a Lisp program.

The standard pattern of indentation is as follows: the second line of the expression is indented under the first argument, if that is on the same line as the beginning of the expression; otherwise, the second line is indented underneath the function name. Each following line is indented under the previous line whose nesting depth is the same.

If the variable lisp-indent-offset is non-nil, it overrides the usual indentation pattern for the second line of an expression, so that such lines are always indented lisp-indent-offset more columns than the containing list.

Certain functions override the standard pattern. Functions whose names start with def treat the second lines as the start of a body, by indenting the second line lisp-body-indent additional columns beyond the open-parenthesis that starts the expression.

You can override the standard pattern in various ways for individual functions, according to the lisp-indent-function property of the function name. This is normally done for macro definitions, using the declare construct. See Defining Macros in The Emacs Lisp Reference Manual.

In Emacs Lisp, lists are usually indented as if they are function-like forms:

(setq foo '(bar zot
                gazonk))
However, if you add a space after the opening parenthesis, this tells Emacs that it’s a data list instead of a piece of code, and Emacs will then indent it like this:

(setq foo '( bar zot
             gazonk))


**** Commands for C Indentation

Here are special features for indentation in C mode and related modes:

C-c C-q ¶
Reindent the current top-level function definition or aggregate type declaration (c-indent-defun in CC mode, c-ts-mode-indent-defun in c-ts-mode based on tree-sitter).

C-M-q ¶
Reindent each line in the balanced expression (see Expressions with Balanced Parentheses), also known as “sexp”, that follows point. In CC mode, this invokes c-indent-exp; in tree-sitter based c-ts-mode this invokes a more general prog-indent-sexp. A prefix argument inhibits warning messages about invalid syntax.

TAB ¶
Reindent the current line, active region, or block starting on this line (c-indent-line-or-region). With prefix argument, rigidly reindent the balanced expression which starts on the current line, if the current line needs reindentation.

If c-tab-always-indent is t, this command always reindents the current line and does nothing else. This is the default.

If that variable is nil, this command reindents the current line only if point is at the left margin or in the line’s indentation; otherwise, it inserts a tab (or the equivalent number of spaces, if indent-tabs-mode is nil).

Any other value (not nil or t) means always reindent the line, and also insert a tab if within a comment or a string.

To reindent the whole current buffer, type C-x h C-M-\. This first selects the whole buffer as the region, then reindents that region.

To reindent the current block, use C-M-u C-M-q. This moves to the front of the block and then reindents it all.


**** Customizing C Indentation

C mode and related modes use a flexible mechanism for customizing indentation. C mode indents a source line in two steps: first it classifies the line syntactically according to its contents and context; second, it determines the indentation offset associated by your selected style with the syntactic construct and adds this onto the indentation of the anchor statement.

C-c . style RET
Select a predefined style style (c-set-style in CC mode, c-ts-mode-set-style in c-ts-mode based on tree-sitter).

A style is a named collection of customizations that can be used in C mode and the related modes. Styles in The CC Mode Manual, for a complete description. Emacs comes with several predefined styles, including gnu, k&r, bsd, stroustrup, linux, python, java, whitesmith, ellemtel, and awk. Some of these styles are primarily intended for one language, but any of them can be used with any of the languages supported by these modes. To find out what a style looks like, select it and reindent some code, e.g., by typing C-M-q at the start of a function definition.

To choose a style for the current buffer, use the command C-c .. Specify a style name as an argument (case is not significant). This command affects the current buffer only, and it affects only future invocations of the indentation commands; it does not reindent the code already in the buffer. To reindent the whole buffer in the new style, you can type C-x h C-M-\.

When using CC mode, you can also set the variable c-default-style to specify the default style for various major modes. Its value should be either the style’s name (a string) or an alist, in which each element specifies one major mode and which indentation style to use for it. For example,

(setq c-default-style
      '((java-mode . "java")
        (awk-mode . "awk")
        (other . "gnu")))
specifies explicit choices for Java and AWK modes, and the default ‘gnu’ style for the other C-like modes. (These settings are actually the defaults.) This variable takes effect when you select one of the C-like major modes; thus, if you specify a new default style for Java mode, you can make it take effect in an existing Java mode buffer by typing M-x java-mode there.

When using the tree-sitter based c-ts-mode, you can set the default indentation style by customizing the variable c-ts-mode-indent-style.

The gnu style specifies the formatting recommended by the GNU Project for C; it is the default, so as to encourage use of our recommended style.

See Indentation Engine Basics in the CC Mode Manual, and Customizing Indentation in the CC Mode Manual, for more information on customizing indentation for C and related modes, including how to override parts of an existing style and how to define your own styles.

As an alternative to specifying a style, you can tell Emacs to guess a style by typing M-x c-guess in a sample code buffer. You can then apply the guessed style to other buffers with M-x c-guess-install. See Guessing the Style in the CC Mode Manual, for details.


***  Commands for Editing with Parentheses

This section describes the commands and features that take advantage of the parenthesis structure in a program, or help you keep it balanced.

When talking about these facilities, the term “parenthesis” also includes braces, brackets, or whatever delimiters are defined to match in pairs. The major mode controls which delimiters are significant, through the syntax table (see Syntax Tables in The Emacs Lisp Reference Manual). In Lisp, only parentheses count; in C, these commands apply to braces and brackets too.

You can use M-x check-parens to find any unbalanced parentheses and unbalanced string quotes in the buffer.

**** Expressions with Balanced Parentheses

Each programming language mode has its own definition of a balanced expression. Balanced expressions typically include individual symbols, numbers, and string constants, as well as pieces of code enclosed in a matching pair of delimiters. The following commands deal with balanced expressions (in Emacs, such expressions are referred to internally as sexps14).

C-M-f
Move forward over a balanced expression (forward-sexp).

C-M-b
Move backward over a balanced expression (backward-sexp).

C-M-k
Kill balanced expression forward (kill-sexp).

C-M-t
Transpose expressions (transpose-sexps).

C-M-@
C-M-SPC
Put mark after following expression (mark-sexp).

To move forward over a balanced expression, use C-M-f (forward-sexp). If the first significant character after point is an opening delimiter (e.g., ‘(’, ‘[’ or ‘{’ in C), this command moves past the matching closing delimiter. If the character begins a symbol, string, or number, the command moves over that.

The command C-M-b (backward-sexp) moves backward over a balanced expression—like C-M-f, but in the reverse direction. If the expression is preceded by any prefix characters (single-quote, backquote and comma, in Lisp), the command moves back over them as well.

C-M-f or C-M-b with an argument repeats that operation the specified number of times; with a negative argument means to move in the opposite direction. In most modes, these two commands move across comments as if they were whitespace. Note that their keys, C-M-f and C-M-b, are analogous to C-f and C-b, which move by characters (see Changing the Location of Point), and M-f and M-b, which move by words (see Words).

To kill a whole balanced expression, type C-M-k (kill-sexp). This kills the text that C-M-f would move over.

C-M-t (transpose-sexps) switches the positions of the previous balanced expression and the next one. It is analogous to the C-t command, which transposes characters (see Transposing Text). An argument to C-M-t serves as a repeat count, moving the previous expression over that many following ones. A negative argument moves the previous balanced expression backwards across those before it. An argument of zero, rather than doing nothing, transposes the balanced expressions ending at or after point and the mark.

To operate on balanced expressions with a command which acts on the region, type C-M-SPC (mark-sexp). This sets the mark where C-M-f would move to. While the mark is active, each successive call to this command extends the region by shifting the mark by one expression. Positive or negative numeric arguments move the mark forward or backward by the specified number of expressions. The alias C-M-@ is equivalent to C-M-SPC. See Commands to Mark Textual Objects, for more information about this and related commands.

In languages that use infix operators, such as C, it is not possible to recognize all balanced expressions because there can be multiple possibilities at a given position. For example, C mode does not treat ‘foo + bar’ as a single expression, even though it is one C expression; instead, it recognizes ‘foo’ as one expression and ‘bar’ as another, with the ‘+’ as punctuation between them. However, C mode recognizes ‘(foo + bar)’ as a single expression, because of the parentheses.


**** Moving in the Parenthesis Structure

The following commands move over groupings delimited by parentheses (or whatever else serves as delimiters in the language you are working with). They ignore strings and comments, including any parentheses within them, and also ignore parentheses that are quoted with an escape character. These commands are mainly intended for editing programs, but can be useful for editing any text containing parentheses. They are referred to internally as “list commands” because in Lisp these groupings are lists.

These commands assume that the starting point is not inside a string or a comment. If you invoke them from inside a string or comment, the results are unreliable.

C-M-n
Move forward over a parenthetical group (forward-list).

C-M-p
Move backward over a parenthetical group (backward-list).

C-M-u
Move up in parenthesis structure (backward-up-list).

C-M-d
Move down in parenthesis structure (down-list).

The list commands C-M-n (forward-list) and C-M-p (backward-list) move forward or backward over one (or n) parenthetical groupings.

C-M-n and C-M-p try to stay at the same level in the parenthesis structure. To move up one (or n) levels, use C-M-u (backward-up-list). C-M-u moves backward up past one unmatched opening delimiter. A positive argument serves as a repeat count; a negative argument reverses the direction of motion, so that the command moves forward and up one or more levels.

To move down in the parenthesis structure, use C-M-d (down-list). In Lisp mode, where ‘(’ is the only opening delimiter, this is nearly the same as searching for a ‘(’. An argument specifies the number of levels to go down.


**** Matching Parentheses

Emacs has a number of parenthesis matching features, which make it easy to see how and whether parentheses (or other delimiters) match up.

Whenever you type a self-inserting character that is a closing delimiter, Emacs briefly indicates the location of the matching opening delimiter, provided that is on the screen. If it is not on the screen, Emacs displays some of the text near it in the echo area. Either way, you can tell which grouping you are closing off. If the opening delimiter and closing delimiter are mismatched—such as in ‘[x)’—a warning message is displayed in the echo area.

Three variables control the display of matching parentheses:

blink-matching-paren turns the feature on or off: nil disables it, but the default is t to enable it. Set it to jump to make indication work by momentarily moving the cursor to the matching opening delimiter. Set it to jump-offscreen to make the cursor jump, even if the opening delimiter is off screen.
blink-matching-delay says how many seconds to keep indicating the matching opening delimiter. This may be an integer or floating-point number; the default is 1.
blink-matching-paren-distance specifies how many characters back to search to find the matching opening delimiter. If the match is not found in that distance, Emacs stops scanning and nothing is displayed. The default is 102400.
Show Paren mode is a minor mode that provides a more powerful kind of automatic matching. Whenever point is before an opening delimiter or after a closing delimiter, the delimiter, its matching delimiter, and optionally the text between them are highlighted. To toggle Show Paren mode globally, type M-x show-paren-mode. To toggle it only in the current buffer, type M-x show-paren-local-mode.

By default, this mode is switched on in all buffers that are meant for editing, but is not enabled in buffers that show data. This is controlled by the show-paren-predicate user option.

To customize the mode, type M-x customize-group RET paren-showing. The customizable options which control the operation of this mode include:

show-paren-highlight-openparen controls whether to highlight an open paren when point is just before it, and hence its position is marked by the cursor anyway. The default is non-nil (yes).
show-paren-style controls whether just the two parens, or also the text between them get highlighted. The valid options here are parenthesis (show the matching paren), expression (highlight the entire expression enclosed by the parens), and mixed (highlight the matching paren if it is visible in the window, the expression otherwise).
show-paren-when-point-inside-paren, when non-nil, causes highlighting also when point is inside of the parentheses. The default is nil.
show-paren-when-point-in-periphery, when non-nil, causes highlighting also when point is in whitespace at the beginning of a line and there is a paren at the first or last non-whitespace position on the line, or when point is at the end of a line and there is a paren at the last non-whitespace position on the line.
show-paren-context-when-offscreen, when non-nil, shows some context in the echo area when point is in a closing delimiter and the opening delimiter is offscreen. The context is usually the line that contains the opening delimiter, except if the opening delimiter is on its own line, in which case the context includes the previous nonblank line.
Electric Pair mode, a global minor mode, provides a way to easily insert matching delimiters: parentheses, braces, brackets, etc. Whenever you insert an opening delimiter, the matching closing delimiter is automatically inserted as well, leaving point between the two. Conversely, when you insert a closing delimiter over an existing one, no insertion takes places, and that position is simply skipped over. If the region is active (see The Mark and the Region), insertion of a delimiter operates on the region: the characters in the region are enclosed in a pair of matching delimiters, leaving point after the delimiter you typed.

These variables control additional features of Electric Pair mode:

electric-pair-preserve-balance, when non-nil, makes the default pairing logic balance out the number of opening and closing delimiters.
electric-pair-delete-adjacent-pairs, when non-nil, makes backspacing between two adjacent delimiters also automatically delete the closing delimiter.
electric-pair-open-newline-between-pairs, when non-nil, makes inserting a newline between two adjacent pairs also automatically open an extra newline after point.
electric-pair-skip-whitespace, when non-nil, causes the minor mode to skip whitespace forward before deciding whether to skip over the closing delimiter.
To toggle Electric Pair mode, type M-x electric-pair-mode. To toggle the mode in a single buffer, use M-x electric-pair-local-mode.


*** Manipulating Comments

Because comments are such an important part of programming, Emacs provides special commands for editing and inserting comments. It can also do spell checking on comments with Flyspell Prog mode (see Checking and Correcting Spelling).

Some major modes have special rules for indenting different kinds of comments. For example, in Lisp code, comments starting with two semicolons are indented as if they were lines of code, while those starting with three semicolons are supposed to be aligned to the left margin and are often used for sectioning purposes. Emacs understands these conventions; for instance, typing TAB on a comment line will indent the comment to the appropriate position.

;; This function is just an example.
;;; Here either two or three semicolons are appropriate.
(defun foo (x)
;;;  And now, the first part of the function:
  ;; The following line adds one.
  (1+ x))           ; This line adds one.

  
**** Comment Commands

The following commands operate on comments:

M-;
Insert or realign comment on current line; if the region is active, comment or uncomment the region instead (comment-dwim).

C-x C-;
Comment or uncomment the current line (comment-line). If the region is active, comment or uncomment the lines in the region instead.

C-u M-;
Kill comment on current line (comment-kill).

C-x ;
Set comment column (comment-set-column).

C-M-j
M-j
Like RET followed by inserting and aligning a comment (default-indent-new-line). See Multiple Lines of Comments.

M-x comment-region
C-c C-c (in C-like modes)
Add comment delimiters to all the lines in the region.

The command to create or align a comment is M-; (comment-dwim). The word “dwim” is an acronym for “Do What I Mean”; it indicates that this command can be used for many different jobs relating to comments, depending on the situation where you use it.

When a region is active (see The Mark and the Region), M-; either adds comment delimiters to the region, or removes them. If every line in the region is already a comment, it uncomments each of those lines by removing their comment delimiters. Otherwise, it adds comment delimiters to enclose the text in the region.

If you supply a prefix argument to M-; when a region is active, that specifies the number of comment delimiters to add or delete. A positive argument n adds n delimiters, while a negative argument −n removes n delimiters.

If the region is not active, and there is no existing comment on the current line, M-; adds a new comment to the current line. If the line is blank (i.e., empty or containing only whitespace characters), the comment is indented to the same position where TAB would indent to (see Basic Program Indentation Commands). If the line is non-blank, the comment is placed after the last non-whitespace character on the line. Emacs tries to fit the comment between the columns specified by the variables comment-column and comment-fill-column (see Options Controlling Comments), if possible. Otherwise, it will choose some other suitable position, usually separated from the non-comment text by at least one space. In each case, Emacs places point after the comment’s starting delimiter, so that you can start typing the comment text right away.

You can also use M-; to align an existing comment. If a line already contains the comment-start string, M-; realigns it to the conventional alignment and moves point after the comment’s starting delimiter. As an exception, comments starting in column 0 are not moved. Even when an existing comment is properly aligned, M-; is still useful for moving directly to the start of the comment text.

C-x C-; (comment-line) comments or uncomments complete lines. When a region is active (see The Mark and the Region), C-x C-; either comments or uncomments the lines in the region. If the region is not active, this command comments or uncomments the line point is on. With a positive prefix argument n, it operates on n lines starting with the current one; with a negative argument −n, it affects n preceding lines. After invoking this command with a negative argument, successive invocations with a positive argument will operate on preceding lines as if the argument were negated.

C-u M-; (comment-dwim with a prefix argument) when the region is not active kills any comment on the current line, along with the whitespace before it. Since the comment is saved to the kill ring, you can reinsert it on another line by moving to the end of that line, doing C-y, and then M-; to realign the comment. You can achieve the same effect as C-u M-; by typing M-x comment-kill (comment-dwim actually calls comment-kill as a subroutine when it is given a prefix argument). Invoking comment-dwim with a prefix numeric argument, as in C-u n M-;, when there’s no active region, tells comment-kill to kill comments on n lines.

The command M-x comment-region is equivalent to calling M-; on an active region, except that it always acts on the region, even if the mark is inactive. In C mode and related modes, this command is bound to C-c C-c. The command M-x uncomment-region uncomments each line in the region; a numeric prefix argument specifies the number of comment delimiters to remove (negative arguments specify the number of comment delimiters to add).

For C-like modes, you can configure the exact effect of M-; by setting the variables c-indent-comment-alist and c-indent-comments-syntactically-p. For example, on a line ending in a closing brace, M-; puts the comment one space after the brace rather than at comment-column. For full details see Comment Commands in The CC Mode Manual.


**** Multiple Lines of Comments

If you are typing a comment and wish to continue it to another line, type M-j or C-M-j (default-indent-new-line). This breaks the current line, and inserts the necessary comment delimiters and indentation to continue the comment.

For languages with closing comment delimiters (e.g., ‘*/’ in C), the exact behavior of M-j depends on the value of the variable comment-multi-line. If the value is nil, the command closes the comment on the old line and starts a new comment on the new line. Otherwise, it opens a new line within the current comment delimiters.

When Auto Fill mode is on, going past the fill column while typing a comment also continues the comment, in the same way as an explicit invocation of M-j.

To turn existing lines into comment lines, use M-; with the region active, or use M-x comment-region as described in the preceding section.

You can configure C Mode such that when you type a ‘/’ at the start of a line in a multi-line block comment, this closes the comment. Enable the comment-close-slash clean-up for this. See Clean-ups in The CC Mode Manual.


**** Options Controlling Comments

As mentioned in Comment Commands, when the M-j command adds a comment to a line, it tries to place the comment between the columns specified by the buffer-local variables comment-column and comment-fill-column (or if that is nil, then the value of fill-column, see Explicit Fill Commands). You can set either the local value or the default value of these buffer-local variables in the usual way (see Local Variables). Alternatively, you can type C-x ; (comment-set-column) to set the value of comment-column in the current buffer to the column where point is currently located. C-u C-x ; sets the comment column to match the last comment before point in the buffer, and then does a M-; to align the current line’s comment under the previous one.

The comment commands recognize comments based on the regular expression that is the value of the variable comment-start-skip. Make sure this regexp does not match the null string. It may match more than the comment starting delimiter in the strictest sense of the word; for example, in C mode the value of the variable could be "/\\*+[ \t]*\\|//+[ \t]*", which matches extra stars and spaces after the ‘/*’ itself, and accepts C++ style (‘//’) comments also. (Note that ‘\\’ is needed in Lisp syntax to include a ‘\’ in the string, which is needed to deny the first star its special meaning in regexp syntax. See Backslash in Regular Expressions.)

When a comment command makes a new comment, it inserts the value of comment-start as an opening comment delimiter. It also inserts the value of comment-end after point, as a closing comment delimiter. For example, in Lisp mode, comment-start is ‘";"’ and comment-end is "" (the empty string). In C mode, comment-start is "/* " and comment-end is " */".

The variable comment-padding specifies a string that the commenting commands should insert between the comment delimiter(s) and the comment text. The default, ‘" "’, specifies a single space. Alternatively, the value can be a number, which specifies that number of spaces, or nil, which means no spaces at all.

The variable comment-multi-line controls how M-j and Auto Fill mode continue comments over multiple lines. See Multiple Lines of Comments.

The variable comment-indent-function should contain a function that will be called to compute the alignment for a newly inserted comment or for aligning an existing comment. It is set differently by various major modes. The function is called with no arguments, but with point at the beginning of the comment, or at the end of a line if a new comment is to be inserted. It should return the column in which the comment ought to start. For example, the default function bases its decision on how many comment characters begin an existing comment.

Emacs also tries to align comments on adjacent lines. To override this, the function may return a cons of two (possibly equal) integers to indicate an acceptable range of indentation.


*** Documentation Lookup

Emacs provides several features you can use to look up the documentation of functions, variables and commands that you plan to use in your program.

**** Info Documentation Lookup

For major modes that apply to languages which have documentation in Info, you can use C-h S (info-lookup-symbol) to view the Info documentation for a symbol used in the program. You specify the symbol with the minibuffer; the default is the symbol appearing in the buffer at point. For example, in C mode this looks for the symbol in the C Library Manual. The command only works if the appropriate manual’s Info files are installed.

Emacs determines where to look for documentation for the symbol—which Info files to look in, and which indices to search—based on the major mode. You can also use M-x info-lookup-file to look for documentation for a file name.

If you use C-h S in a major mode that does not support it, it asks you to specify the symbol help mode. You should enter a command such as c-mode that would select a major mode which C-h S does support.


**** Man Page Lookup

On Unix, the main form of on-line documentation was the manual page or man page. In the GNU operating system, we aim to replace man pages with better-organized manuals that you can browse with Info (see Other Help Commands). This process is not finished, so it is still useful to read manual pages.

You can read the man page for an operating system command, library function, or system call, with the M-x man command. This prompts for a topic, with completion (see Completion), and runs the man program to format the corresponding man page. If the system permits, it runs man asynchronously, so that you can keep on editing while the page is being formatted. The result goes in a buffer named *Man topic*. These buffers use a special major mode, Man mode, that facilitates scrolling and jumping to other manual pages. For details, type C-h m while in a Man mode buffer.

Each man page belongs to one of ten or more sections, each named by a digit or by a digit and a letter. Sometimes there are man pages with the same name in different sections. To read a man page from a specific section, type ‘topic(section)’ or ‘section topic’ when M-x man prompts for the topic. For example, the man page for the C library function chmod is in section 2, but there is a shell command of the same name, whose man page is in section 1; to view the former, type M-x man RET chmod(2) RET.

If you do not specify a section, M-x man normally displays only the first man page found. On some systems, the man program accepts a ‘-a’ command-line option, which tells it to display all the man pages for the specified topic. To make use of this, change the value of the variable Man-switches to ‘"-a"’. Then, in the Man mode buffer, you can type M-n and M-p to switch between man pages in different sections. The mode line shows how many manual pages are available.

An alternative way of reading manual pages is the M-x woman command. Unlike M-x man, it does not run any external programs to format and display the man pages; the formatting is done by Emacs, so it works on systems such as MS-Windows where the man program may be unavailable. It prompts for a man page, and displays it in a buffer named *WoMan section topic.

M-x woman computes the completion list for manpages the first time you invoke the command. With a numeric argument, it recomputes this list; this is useful if you add or delete manual pages.

If you type a name of a manual page and M-x woman finds that several manual pages by the same name exist in different sections, it pops up a window with possible candidates asking you to choose one of them.

Note that M-x woman doesn’t yet support the latest features of modern man pages, so we recommend using M-x man if that is available on your system.

For more information about setting up and using M-x woman, see the WoMan Info manual, which is distributed with Emacs.


**** Programming Language Documentation Lookup

When editing Emacs Lisp code, you can use the commands C-h f (describe-function) and C-h v (describe-variable) to view the built-in documentation for the Lisp functions and variables that you want to use. See Help by Command or Variable Name.

ElDoc15 is a buffer-local minor mode that helps with looking up documentation of symbols (functions, methods, classes, variables, etc.) in your program. When this mode is enabled, the echo area displays useful information whenever there is a documented symbol at point. For example, in buffers under the Emacs Lisp mode, it shows the argument list of a function at point, and for a Lisp variable it shows the first line of the variable’s documentation string.

To toggle ElDoc mode, type M-x eldoc-mode. There’s also a Global ElDoc mode, which is turned on by default, and turns on the ElDoc mode in buffers whose major mode sets the variables described below. Use M-x global-eldoc-mode to turn it off globally.

Various major modes configure the Global ElDoc mode to use their documentation functions. Examples include Emacs Lisp mode, Python mode, and Cfengine mode. In addition, Emacs features that provide support for several major modes configure ElDoc to use their facilities for retrieving the documentation. Examples include Eglot (see Eglot Features in Eglot: The Emacs LSP Client), which provides documentation based on information from language servers; Semantic’s Idle Summary mode (see Idle Summary Mode in Semantic Manual); and Flymake, which uses ElDoc to show diagnostics at point (see Finding diagnostics in GNU Flymake manual).

The ElDoc mode works by scheduling the display of the available documentation for the symbol at point after Emacs has been idle for some short time. This avoids annoying flickering of documentation messages in the echo area or the mode line when you type quickly and without delay.

You can also trigger the display of documentation for a symbol at point by using the command M-x eldoc-print-current-symbol-info.

The following variables can be used to configure ElDoc mode:

eldoc-idle-delay ¶
The value of this user option controls the amount of idle time before the at-point documentation is displayed. It should be set to the number of seconds to wait; the value of zero means to display without any delay. The default is 0.5 sec.

eldoc-print-after-edit ¶
If this user option is non-nil, ElDoc will show documentation only after some editing command, like inserting or deleting some text. This comes in handy if you want Emacs to display documentation only about symbols that you type, but not about symbols that are already in the buffer (so just reading the source code will not show documentation). The default value is nil. If you change the value, you need to toggle eldoc-mode off and on again.

eldoc-echo-area-use-multiline-p ¶
This user option controls whether and how to truncate documentation text if it is longer than the echo-area can display as a single screen line. If the value is a positive number, it specifies the number of screen lines that ElDoc is allowed to display in the echo area without truncating the documentation. A positive integer specifies the absolute maximum number of screen lines to use; a floating-point number specifies the number of screen lines as a fraction of the frame’s height. The value of t means never truncate the documentation (the echo-area will be resized up to the height allowed by max-mini-window-height, see Editing in the Minibuffer), whereas the value of nil means truncate if the documentation is longer than a single screen line. Finally, the special value truncate-sym-name-if-fit (the default) means to truncate the part of the documentation that represents a symbol’s name if doing that will allow the documentation to fit on a single screen line.

eldoc-echo-area-display-truncation-message ¶
If non-nil (the default), and documentation shown in the echo area is truncated because it’s too long, follow the documentation by instructions about how to view the complete documentation text. If nil, just indicate with ‘…’ that the documentation was truncated.

eldoc-echo-area-prefer-doc-buffer ¶
If the value of this user option is t, ElDoc will not show the documentation in the echo area if the ElDoc buffer with the documentation is already displayed in some window. (You can use the command M-x eldoc-doc-buffer any time to show the ElDoc buffer.) If the value of this option is the symbol maybe, the documentation will not be displayed in the echo area if the ElDoc buffer is shown in some window, and the documentation text has to be truncated if displayed in the echo area. Finally, the value of nil (the default) means always show the documentation in the echo area.

eldoc-documentation-strategy ¶
This customizable variable’s value is the function which is used to retrieve and display documentation for the symbol at point. The documentation is produced by the functions in the hook eldoc-documentation-functions. The default value of eldoc-documentation-strategy specifies that ElDoc should display the first documentation text produced by functions in the eldoc-documentation-functions hook, but you can customize eldoc-documentation-strategy to work in other ways, such as displaying all of the documentation texts concatenated together.

eldoc-documentation-functions ¶
This abnormal hook’s value is a list of functions that can produce documentation for the symbol at point as appropriate for the current buffer’s major-mode. These functions act as a collection of backends for ElDoc. Major modes register their documentation lookup functions with ElDoc by adding their functions to the buffer-local value of this variable.


*** Hideshow minor mode

Hideshow mode is a buffer-local minor mode that allows you to selectively display portions of a program, which are referred to as blocks. Type M-x hs-minor-mode to toggle this minor mode (see Minor Modes).

When you use Hideshow mode to hide a block, the block disappears from the screen, to be replaced by an ellipsis (three periods in a row). Just what constitutes a block depends on the major mode. In C mode and related modes, blocks are delimited by braces, while in Lisp mode they are delimited by parentheses. Multi-line comments also count as blocks.

Hideshow mode provides the following commands:

C-c @ C-h
C-c @ C-d
Hide the current block (hs-hide-block).

C-c @ C-s
Show the current block (hs-show-block).

C-c @ C-c
C-c @ C-e
S-mouse-2
Either hide or show the current block (hs-toggle-hiding).

C-c @ C-M-h
C-c @ C-t
Hide all top-level blocks (hs-hide-all).

C-c @ C-M-s
C-c @ C-a
Show all blocks in the buffer (hs-show-all).

C-u n C-c @ C-l
Hide all blocks n levels below this block (hs-hide-level).

These variables can be used to customize Hideshow mode:

hs-hide-comments-when-hiding-all
If non-nil, C-c @ C-M-h (hs-hide-all) hides comments too.

hs-isearch-open
This variable specifies the conditions under which incremental search should unhide a hidden block when matching text occurs within the block. Its value should be either code (unhide only code blocks), comment (unhide only comments), t (unhide both code blocks and comments), or nil (unhide neither code blocks nor comments). The default value is code.


*** Completion for Symbol Names

Completion is normally done in the minibuffer (see Completion), but you can also complete symbol names in ordinary Emacs buffers.

In most programming language modes, C-M-i (or M-TAB16) invokes the command completion-at-point, which generates the list of possible completions for the symbol at point. This command uses the available support facilities to come up with the completion candidates:

If Eglot is activated for the current buffer’s project (see Working with Projects) and the current buffer’s major mode, the command tries to use the corresponding language server for producing the list of completion candidates. See Eglot Features in Eglot: The Emacs LSP Client.
If Semantic mode is enabled (see Semantic), the command tries to use the Semantic parser data for completion.
If Semantic mode is not enabled or fails at performing completion, the command tries to complete using the selected tags table (see Tags Tables); you need to visit the tags table with M-x visit-tags-table for that to work.
In Emacs Lisp mode, the command performs completion using the function, variable, or property names defined in the current Emacs session.
In all other respects, in-buffer symbol completion behaves like minibuffer completion. For instance, if Emacs cannot complete to a unique symbol, it displays a list of completion alternatives in another window. Then you can use the keys M-DOWN and M-UP to navigate through the completions displayed in the completions buffer without leaving the original buffer, and the key M-RET to insert the currently highlighted completion to the buffer. See Completion.

In Text mode and related modes, M-TAB completes words based on the spell-checker’s dictionary. See Checking and Correcting Spelling.

Footnotes
(16)
On graphical displays, the M-TAB key is usually reserved by the window manager for switching graphical windows, so you should type C-M-i or ESC TAB instead.


*** MixedCase Words

Some programming styles make use of mixed-case (or “CamelCase”) symbols like ‘unReadableSymbol’. (In the GNU project, we recommend using underscores to separate words within an identifier, rather than using case distinctions.) Emacs has various features to make it easier to deal with such symbols.

Glasses mode is a buffer-local minor mode that makes it easier to read such symbols, by altering how they are displayed. By default, it displays extra underscores between each lower-case letter and the following capital letter. This does not alter the buffer text, only how it is displayed.

To toggle Glasses mode, type M-x glasses-mode (see Minor Modes). When Glasses mode is enabled, the minor mode indicator ‘o^o’ appears in the mode line. For more information about Glasses mode, type C-h P glasses RET.

Subword mode is another buffer-local minor mode. In subword mode, Emacs’s word commands recognize upper case letters in ‘StudlyCapsIdentifiers’ as word boundaries. When Subword mode is enabled, the minor mode indicator ‘,’ appears in the mode line. See also the similar superword-mode (see Other Features Useful for Editing Programs).


*** Semantic

Semantic is a package that provides language-aware editing commands based on source code parsers. This section provides a brief description of Semantic; for full details, see Semantic in Semantic.

Most of the language-aware features in Emacs, such as Font Lock mode (see Font Lock mode), rely on rules of thumb17 that usually give good results but are never completely exact. In contrast, the parsers used by Semantic have an exact understanding of programming language syntax. This allows Semantic to provide search, navigation, and completion commands that are powerful and precise.

To begin using Semantic, type M-x semantic-mode or click on the menu item named ‘Source Code Parsers (Semantic)’ in the ‘Tools’ menu. This enables Semantic mode, a global minor mode.

When Semantic mode is enabled, Emacs automatically attempts to parse each file you visit. Currently, Semantic understands C, C++, HTML, Java, Javascript, Make, Python, Scheme, SRecode, and Texinfo. Within each parsed buffer, the following commands are available:

C-c , j ¶
Prompt for the name of a function defined in the current file, and move point there (semantic-complete-jump-local).

C-c , J ¶
Prompt for the name of a function defined in any file Emacs has parsed, and move point there (semantic-complete-jump).

C-c , SPC ¶
Display a list of possible completions for the symbol at point (semantic-complete-analyze-inline). This also activates a set of special key bindings for choosing a completion: RET accepts the current completion, M-n and M-p cycle through possible completions, TAB completes as far as possible and then cycles, and C-g or any other key aborts completion.

C-c , l ¶
Display a list of the possible completions of the symbol at point, in another window (semantic-analyze-possible-completions).

In addition to the above commands, the Semantic package provides a variety of other ways to make use of parser information. For instance, you can use it to display a list of completions when Emacs is idle. See Semantic in Semantic, for details.


*** Other Features Useful for Editing Programs

Some Emacs commands that aren’t designed specifically for editing programs are useful for that nonetheless.

The Emacs commands that operate on words, sentences and paragraphs are useful for editing code. Most symbol names contain words (see Words), while sentences can be found in strings and comments (see Sentences). As for paragraphs, they are defined in most programming language modes to begin and end at blank lines (see Paragraphs). Therefore, judicious use of blank lines to make the program clearer will also provide useful chunks of text for the paragraph commands to work on. Auto Fill mode, if enabled in a programming language major mode, indents the new lines which it creates.

Superword mode is a buffer-local minor mode that causes editing and motion commands to treat symbols (e.g., ‘this_is_a_symbol’) as words. When Superword mode is enabled, the minor mode indicator ‘²’ appears in the mode line. See also the similar subword-mode (see MixedCase Words).

Electric Layout mode (M-x electric-layout-mode) is a global minor mode that automatically inserts newlines when you type certain characters; for example, ‘{’, ‘}’ and ‘;’ in Javascript mode.

Apart from Hideshow mode (see Hideshow minor mode), another way to selectively display parts of a program is to use the selective display feature (see Selective Display). Programming modes often also support Outline minor mode (see Outline Mode), which can be used with the Foldout package (see Folding Editing).

Prettify Symbols mode is a buffer-local minor mode that replaces certain strings with more attractive versions for display purposes. For example, in Emacs Lisp mode, it replaces the string ‘lambda’ with the Greek lambda character ‘λ’. In a TeX buffer, it will replace ‘\alpha’ … ‘\omega’ and other math macros with their Unicode characters. You may wish to use this in non-programming modes as well. You can customize the mode by adding more entries to prettify-symbols-alist. More elaborate customization is available via customizing prettify-symbols-compose-predicate if its default value prettify-symbols-default-compose-p is not appropriate. There is also a global version, global-prettify-symbols-mode, which enables the mode in all buffers that support it.

The symbol at point can be shown in its original form. This is controlled by the variable prettify-symbols-unprettify-at-point: if non-nil, the original form of symbol at point will be restored for as long as point is at it.


*** C and Related Modes

This section gives a brief description of the special features available in C, C++, Objective-C, Java, CORBA IDL, Pike and AWK modes. (These are called “C mode and related modes”.) For more details, see the CC mode Info manual, which is distributed with Emacs.

**** C Mode Motion Commands

This section describes commands for moving point, in C mode and related modes.

C-M-a ¶
C-M-e
Move point to the beginning or end of the current function or top-level definition. In languages with enclosing scopes (such as C++’s classes) the current function is the immediate one, possibly inside a scope. Otherwise it is the one defined by the least enclosing braces. (By contrast, beginning-of-defun and end-of-defun search for braces in column zero.) See Moving by Defuns.

C-c C-u ¶
Move point back to the containing preprocessor conditional, leaving the mark behind. A prefix argument acts as a repeat count. With a negative argument, move point forward to the end of the containing preprocessor conditional.

‘#elif’ is equivalent to ‘#else’ followed by ‘#if’, so the function will stop at a ‘#elif’ when going backward, but not when going forward.

C-c C-p ¶
Move point back over a preprocessor conditional, leaving the mark behind. A prefix argument acts as a repeat count. With a negative argument, move forward.

C-c C-n ¶
Move point forward across a preprocessor conditional, leaving the mark behind. A prefix argument acts as a repeat count. With a negative argument, move backward.

M-a ¶
Move point to the beginning of the innermost C statement (c-beginning-of-statement). If point is already at the beginning of a statement, move to the beginning of the preceding statement. With prefix argument n, move back n − 1 statements.

In comments or in strings which span more than one line, this command moves by sentences instead of statements.

M-e ¶
Move point to the end of the innermost C statement or sentence; like M-a except that it moves in the other direction (c-end-of-statement).


**** Electric C Characters

In C mode and related modes, certain printing characters are electric—in addition to inserting themselves, they also reindent the current line, and optionally also insert newlines. The electric characters are {, }, :, #, ;, ,, <, >, /, *, (, and ).

You might find electric indentation inconvenient if you are editing chaotically indented code. If you are new to CC Mode, you might find it disconcerting. You can toggle electric action with the command C-c C-l; when it is enabled, ‘/cl’ appears in the mode line after the mode name (where c, if present, is ‘*’ or ‘/’, depending on whether the comment style is block or line). See Minor Modes in The CC Mode Manual, for more about mode-line indicators in CC Mode.

C-c C-l ¶
Toggle electric action (c-toggle-electric-state). With a positive prefix argument, this command enables electric action, with a negative one it disables it.

Electric characters insert newlines only when, in addition to the electric state, the auto-newline feature is enabled (indicated by ‘/cla’ in the mode line after the mode name). You can turn this feature on or off with the command C-c C-a:

C-c C-a ¶
Toggle the auto-newline feature (c-toggle-auto-newline). With a prefix argument, this command turns the auto-newline feature on if the argument is positive, and off if it is negative.

Usually the CC Mode style configures the exact circumstances in which Emacs inserts auto-newlines. You can also configure this directly. See Custom Auto-newlines in The CC Mode Manual.


**** Hungry Delete Feature in C

If you want to delete an entire block of whitespace at point, you can use hungry deletion. This deletes all the contiguous whitespace either before point or after point in a single operation. Whitespace here includes tabs and newlines, but not comments or preprocessor commands.

C-c C-DEL ¶
C-c DEL
Delete the entire block of whitespace preceding point (c-hungry-delete-backwards).

C-c C-d ¶
C-c C-Delete
C-c Delete
Delete the entire block of whitespace after point (c-hungry-delete-forward).

As an alternative to the above commands, you can enable hungry delete mode. When this feature is enabled (indicated by ‘h’ after a ‘/’ in the mode line after the mode name), a single DEL deletes all preceding whitespace, not just one space, and a single C-d (but not plain Delete) deletes all following whitespace.

M-x c-toggle-hungry-state ¶
Toggle the hungry-delete feature (c-toggle-hungry-state). With a prefix argument, this command turns the hungry-delete feature on if the argument is positive, and off if it is negative.

The variable c-hungry-delete-key controls whether the hungry-delete feature is enabled.


**** Other Commands for C Mode

M-x c-context-line-break ¶
This command inserts a line break and indents the new line in a manner appropriate to the context. In normal code, it does the work of RET (newline), in a C preprocessor line it additionally inserts a ‘\’ at the line break, and within comments it’s like M-j (c-indent-new-comment-line).

c-context-line-break isn’t bound to a key by default, but it needs a binding to be useful. The following code will bind it to RET. We use c-initialization-hook here to make sure the keymap is loaded before we try to change it.

(defun my-bind-clb ()
  (keymap-set c-mode-base-map "RET"
              'c-context-line-break))
(add-hook 'c-initialization-hook 'my-bind-clb)
C-M-h
Put mark at the end of a function definition, and put point at the beginning (c-mark-function).

M-q ¶
Fill a paragraph, handling C and C++ comments (c-fill-paragraph). If any part of the current line is a comment or within a comment, this command fills the comment or the paragraph of it that point is in, preserving the comment indentation and comment delimiters.

C-c C-e ¶
Run the C preprocessor on the text in the region, and show the result, which includes the expansion of all the macro calls (c-macro-expand). The buffer text before the region is also included in preprocessing, for the sake of macros defined there, but the output from this part isn’t shown.

When you are debugging C code that uses macros, sometimes it is hard to figure out precisely how the macros expand. With this command, you don’t have to figure it out; you can see the expansions.

C-c C-\ ¶
Insert or align ‘\’ characters at the ends of the lines of the region (c-backslash-region). This is useful after writing or editing a C macro definition.

If a line already ends in ‘\’, this command adjusts the amount of whitespace before it. Otherwise, it inserts a new ‘\’. However, the last line in the region is treated specially; no ‘\’ is inserted on that line, and any ‘\’ there is deleted.

M-x cpp-highlight-buffer ¶
Highlight parts of the text according to its preprocessor conditionals. This command displays another buffer named *CPP Edit*, which serves as a graphic menu for selecting how to display particular kinds of conditionals and their contents. After changing various settings, click on ‘[A]pply these settings’ (or go to that buffer and type a) to rehighlight the C mode buffer accordingly.

C-c C-s ¶
Display the syntactic information about the current source line (c-show-syntactic-information). This information directs how the line is indented.

M-x cwarn-mode ¶
M-x global-cwarn-mode
CWarn minor mode highlights certain suspicious C and C++ constructions:

Assignments inside expressions.
Semicolon following immediately after ‘if’, ‘for’, and ‘while’ (except after a ‘do … while’ statement);
C++ functions with reference parameters.
You can enable the mode for one buffer with the command M-x cwarn-mode, or for all suitable buffers with the command M-x global-cwarn-mode or by customizing the variable global-cwarn-mode. You must also enable Font Lock mode to make it work.

M-x hide-ifdef-mode ¶
Hide-ifdef minor mode hides selected code within ‘#if’ and ‘#ifdef’ preprocessor blocks. If you change the variable hide-ifdef-shadow to t, Hide-ifdef minor mode shadows preprocessor blocks by displaying them with a less prominent face, instead of hiding them entirely. See the documentation string of hide-ifdef-mode for more information.

M-x ff-find-related-file ¶
Find a file related in a special way to the file visited by the current buffer. Typically this will be the header file corresponding to a C/C++ source file, or vice versa. The variable ff-related-file-alist specifies how to compute related file names.


*** Asm Mode

Asm mode is a major mode for editing files of assembler code. It defines these commands:

TAB
tab-to-tab-stop.

C-j
Insert a newline and then indent using tab-to-tab-stop.

:
Insert a colon and then remove the indentation from before the label preceding colon. Then do tab-to-tab-stop.

;
Insert or align a comment.

The variable asm-comment-char specifies which character starts comments in assembler syntax.


*** Fortran Mode

Fortran mode is meant for editing fixed form (and also tab format) source code (normally Fortran 77). For editing more modern free-form source code (Fortran 90, 95, 2003, 2008), use F90 mode (f90-mode). Emacs normally uses Fortran mode for files with extension ‘.f’, ‘.F’ or ‘.for’, and F90 mode for the extensions ‘.f90’, ‘.f95’, ‘.f03’ and ‘.f08’. Customize auto-mode-alist to add more extensions. GNU Fortran supports both free and fixed form. This manual mainly documents Fortran mode, but the corresponding F90 mode features are mentioned when relevant.

Fortran mode provides special motion commands for Fortran statements and subprograms, and indentation commands that understand Fortran conventions of nesting, line numbers and continuation statements. Fortran mode has support for Auto Fill mode that breaks long lines into proper Fortran continuation lines. Fortran mode also supports Hideshow minor mode (see Hideshow minor mode), and Imenu (see Imenu).

Special commands for comments are provided because Fortran comments are unlike those of other languages. Built-in abbrevs optionally save typing when you insert Fortran keywords.

Use M-x fortran-mode to switch to this major mode. This command runs the hook fortran-mode-hook. See Hooks.


**** Motion Commands

In addition to the normal commands for moving by and operating on defuns (Fortran subprograms—functions and subroutines, as well as modules for F90 mode, using the commands fortran-end-of-subprogram and fortran-beginning-of-subprogram), Fortran mode provides special commands to move by statements and other program units.

C-c C-n
Move to the beginning of the next statement (fortran-next-statement/f90-next-statement).

C-c C-p
Move to the beginning of the previous statement (fortran-previous-statement/f90-previous-statement). If there is no previous statement (i.e., if called from the first statement in the buffer), move to the start of the buffer.

C-c C-e
Move point forward to the start of the next code block, or the end of the current one, whichever comes first (f90-next-block). A code block is a subroutine, if–endif statement, and so forth. This command exists for F90 mode only, not Fortran mode. With a numeric argument, it moves forward that many blocks.

C-c C-a
Move point backward to the previous block (f90-previous-block). This is like f90-next-block, but moves backwards.

C-M-n
Move to the end of the current code block (fortran-end-of-block/f90-end-of-block). With a numeric argument, move forward that number of blocks. The mark is set before moving point. The F90 mode version of this command checks for consistency of block types and labels (if present), but it does not check the outermost block since that may be incomplete.

C-M-p
Move to the start of the current code block (fortran-beginning-of-block/f90-beginning-of-block). This is like fortran-end-of-block, but moves backwards.

The commands fortran-beginning-of-subprogram and fortran-end-of-subprogram move to the start or end of the current subprogram, respectively. The commands fortran-mark-do and fortran-mark-if mark the end of the current do or if block, and move point to the start.


**** Fortran Indentation

Special commands and features are needed for indenting fixed (or tab) form Fortran code in order to make sure various syntactic entities (line numbers, comment line indicators and continuation line flags) appear in the required columns.

***** Fortran Indentation and Filling Commands

C-M-j
Break the current line at point and set up a continuation line (fortran-split-line).

M-^
Join this line to the previous line (fortran-join-line).

C-M-q
Indent all the lines of the subprogram that point is in (fortran-indent-subprogram).

M-q
Fill a comment block or statement (using fortran-fill-paragraph or fortran-fill-statement).

The key C-M-q runs fortran-indent-subprogram, a command to reindent all the lines of the Fortran subprogram (function or subroutine) containing point.

The key C-M-j runs fortran-split-line, which splits a line in the appropriate fashion for Fortran. In a non-comment line, the second half becomes a continuation line and is indented accordingly. In a comment line, both halves become separate comment lines.

M-^ or C-c C-d run the command fortran-join-line, which joins a continuation line back to the previous line, roughly as the inverse of fortran-split-line. The point must be on a continuation line when this command is invoked.

M-q in Fortran mode fills the comment block or statement that point is in. This removes any excess statement continuations.


***** Continuation Lines

Most Fortran 77 compilers allow two ways of writing continuation lines. If the first non-space character on a line is in column 5, then that line is a continuation of the previous line. We call this fixed form. (In GNU Emacs we always count columns from 0; but note that the Fortran standard counts from 1. You can customize the variable column-number-indicator-zero-based to make the column display Fortran-like; see Optional Mode Line Features.) The variable fortran-continuation-string specifies what character to put in column 5. A line that starts with a tab character followed by any digit except ‘0’ is also a continuation line. We call this style of continuation tab format. (Fortran 90 introduced free-form continuation lines.)

Fortran mode can use either style of continuation line. When you enter Fortran mode, it tries to deduce the proper continuation style automatically from the buffer contents. It does this by scanning up to fortran-analyze-depth (default 100) lines from the start of the buffer. The first line that begins with either a tab character or six spaces determines the choice. If the scan fails (for example, if the buffer is new and therefore empty), the value of fortran-tab-mode-default (nil for fixed form, and non-nil for tab format) is used. ‘/t’ (fortran-tab-mode-string) in the mode line indicates tab format is selected. Fortran mode sets the value of indent-tabs-mode accordingly.

If the text on a line starts with the Fortran continuation marker ‘$’, or if it begins with any non-whitespace character in column 5, Fortran mode treats it as a continuation line. When you indent a continuation line with TAB, it converts the line to the current continuation style. When you split a Fortran statement with C-M-j, the continuation marker on the newline is created according to the continuation style.

The setting of continuation style affects several other aspects of editing in Fortran mode. In fixed form mode, the minimum column number for the body of a statement is 6. Lines inside of Fortran blocks that are indented to larger column numbers must use only the space character for whitespace. In tab format mode, the minimum column number for the statement body is 8, and the whitespace before column 8 must consist of one tab character.


***** Line Numbers

If a number is the first non-whitespace in the line, Fortran indentation assumes it is a line number and moves it to columns 0 through 4. (Columns always count from 0 in Emacs, but setting column-number-indicator-zero-based to nil can change that, see Optional Mode Line Features.)

Line numbers of four digits or less are normally indented one space. The variable fortran-line-number-indent controls this; it specifies the maximum indentation a line number can have. The default value of the variable is 1. Fortran mode tries to prevent line number digits passing column 4, reducing the indentation below the specified maximum if necessary. If fortran-line-number-indent has the value 5, line numbers are right-justified to end in column 4.

Simply inserting a line number is enough to indent it according to these rules. As each digit is inserted, the indentation is recomputed. To turn off this feature, set the variable fortran-electric-line-number to nil.


***** Syntactic Conventions

Fortran mode assumes that you follow certain conventions that simplify the task of understanding a Fortran program well enough to indent it properly:

Two nested ‘do’ loops never share a ‘continue’ statement.
Fortran keywords such as ‘if’, ‘else’, ‘then’, ‘do’ and others are written without embedded whitespace or line breaks.
Fortran compilers generally ignore whitespace outside of string constants, but Fortran mode does not recognize these keywords if they are not contiguous. Constructs such as ‘else if’ or ‘end do’ are acceptable, but the second word should be on the same line as the first and not on a continuation line.

If you fail to follow these conventions, the indentation commands may indent some lines unaesthetically. However, a correct Fortran program retains its meaning when reindented even if the conventions are not followed.


***** Variables for Fortran Indentation

Several additional variables control how Fortran indentation works:

fortran-do-indent
Extra indentation within each level of ‘do’ statement (default 3).

fortran-if-indent
Extra indentation within each level of ‘if’, ‘select case’, or ‘where’ statements (default 3).

fortran-structure-indent
Extra indentation within each level of ‘structure’, ‘union’, ‘map’, or ‘interface’ statements (default 3).

fortran-continuation-indent
Extra indentation for bodies of continuation lines (default 5).

fortran-check-all-num-for-matching-do
In Fortran 77, a numbered ‘do’ statement is terminated by any statement with a matching line number. It is common (but not compulsory) to use a ‘continue’ statement for this purpose. If this variable has a non-nil value, indenting any numbered statement must check for a ‘do’ that ends there. If you always end ‘do’ statements with a ‘continue’ line (or if you use the more modern ‘enddo’), then you can speed up indentation by setting this variable to nil (the default).

fortran-blink-matching-if
If this is t, indenting an ‘endif’ (or ‘enddo’) statement moves the cursor momentarily to the matching ‘if’ (or ‘do’) statement to show where it is. The default is nil.

fortran-minimum-statement-indent-fixed
Minimum indentation for Fortran statements when using fixed form continuation line style. Statement bodies are never indented by less than this. The default is 6.

fortran-minimum-statement-indent-tab
Minimum indentation for Fortran statements for tab format continuation line style. Statement bodies are never indented by less than this. The default is 8.

The following section describes the variables controlling the indentation of comments.


**** Fortran Comments

The usual Emacs comment commands assume that a comment can follow a line of code. In Fortran 77, the standard comment syntax requires an entire line to be just a comment. Therefore, Fortran mode replaces the standard Emacs comment commands and defines some new variables.

Fortran mode can also handle the Fortran 90 comment syntax where comments start with ‘!’ and can follow other text. Because only some Fortran 77 compilers accept this syntax, Fortran mode will not insert such comments unless you have said in advance to do so. To do this, set the variable fortran-comment-line-start to ‘"!"’. If you use an unusual value, you may need to change fortran-comment-line-start-skip.

M-;
Align comment or insert new comment (comment-dwim).

C-x ;
Applies to nonstandard ‘!’ comments only (comment-set-column).

C-c ;
Turn all lines of the region into comments, or (with argument) turn them back into real code (fortran-comment-region).

M-; in Fortran mode runs the standard comment-dwim. This recognizes any kind of existing comment and aligns its text appropriately; if there is no existing comment, a comment is inserted and aligned. Inserting and aligning comments are not the same in Fortran mode as in other modes.

When a new comment must be inserted, if the current line is blank, a full-line comment is inserted. On a non-blank line, a nonstandard ‘!’ comment is inserted if you have said you want to use them. Otherwise, a full-line comment is inserted on a new line before the current line.

Nonstandard ‘!’ comments are aligned like comments in other languages, but full-line comments are different. In a standard full-line comment, the comment delimiter itself must always appear in column zero. What can be aligned is the text within the comment. You can choose from three styles of alignment by setting the variable fortran-comment-indent-style to one of these values:

fixed
Align the text at a fixed column, which is the sum of fortran-comment-line-extra-indent and the minimum statement indentation. This is the default.

The minimum indentation is fortran-minimum-statement-indent-tab for tab format continuation line style and fortran-minimum-statement-indent-fixed for fixed form style.

relative
Align the text as if it were a line of code, but with an additional fortran-comment-line-extra-indent columns of indentation.

nil
Don’t move text in full-line comments automatically.

In addition, you can specify the character to be used to indent within full-line comments by setting the variable fortran-comment-indent-char to the single-character string you want to use.

Compiler directive lines, or preprocessor lines, have much the same appearance as comment lines. It is important, though, that such lines never be indented at all, no matter what the value of fortran-comment-indent-style. The variable fortran-directive-re is a regular expression that specifies which lines are directives. Matching lines are never indented, and receive distinctive font-locking.

The normal Emacs comment command C-x ; (comment-set-column) has not been redefined. If you use ‘!’ comments, this command can be used with them. Otherwise, it is useless in Fortran mode.

The command C-c ; (fortran-comment-region) turns all the lines of the region into comments by inserting the string ‘c$$$’ at the front of each one. With a numeric argument, it turns the region back into live code by deleting ‘c$$$’ from the front of each line in it. The string used for these comments can be controlled by setting the variable fortran-comment-region. Note that here we have an example of a command and a variable with the same name; these two uses of the name never conflict because in Lisp and in Emacs it is always clear from the context which one is meant.


**** Auto Fill in Fortran Mode

Fortran mode has specialized support for Auto Fill mode, which is a minor mode that automatically splits statements as you insert them when they become too wide. Splitting a statement involves making continuation lines using fortran-continuation-string (see Continuation Lines). This splitting happens when you type SPC, RET, or TAB, and also in the Fortran indentation commands. You activate Auto Fill in Fortran mode in the normal way. See Auto Fill Mode.

Auto Fill breaks lines at spaces or delimiters when the lines get longer than the desired width (the value of fill-column). The delimiters (besides whitespace) that Auto Fill can break at are ‘+’, ‘-’, ‘/’, ‘*’, ‘=’, ‘<’, ‘>’, and ‘,’. The line break comes after the delimiter if the variable fortran-break-before-delimiters is nil. Otherwise (and by default), the break comes before the delimiter.

To enable Auto Fill in all Fortran buffers, add auto-fill-mode to fortran-mode-hook. See Hooks.


**** Checking Columns in Fortran

In standard Fortran 77, anything beyond column 72 is ignored. Most compilers provide an option to change this (for example, ‘-ffixed-line-length-N’ in gfortran). Customize the variable fortran-line-length to change the line length in Fortran mode. Anything beyond this point is font-locked as a comment. (Unless it is inside a string: strings that extend beyond fortran-line-length will confuse font-lock.)

C-c C-r
Display a column ruler momentarily above the current line (fortran-column-ruler).

C-c C-w
Split the current window horizontally temporarily so that it is fortran-line-length columns wide (fortran-window-create-momentarily). This may help you avoid making lines longer than the limit imposed by your Fortran compiler.

C-u C-c C-w
Split the current window horizontally so that it is fortran-line-length columns wide (fortran-window-create). You can then continue editing.

M-x fortran-strip-sequence-nos
Delete all text in column fortran-line-length and beyond.

The command C-c C-r (fortran-column-ruler) shows a column ruler momentarily above the current line. The comment ruler is two lines of text that show you the locations of columns with special significance in Fortran programs. Square brackets show the limits of the columns for line numbers, and curly brackets show the limits of the columns for the statement body. Column numbers appear above them.

Note that the column numbers count from zero, as always in GNU Emacs (but customizing column-number-indicator-zero-based can change column display to match that of Fortran; see Optional Mode Line Features.) As a result, the numbers may be one less than those you are familiar with; but the positions they indicate in the line are standard for Fortran.

The text used to display the column ruler depends on the value of the variable indent-tabs-mode. If indent-tabs-mode is nil, then the value of the variable fortran-column-ruler-fixed is used as the column ruler. Otherwise, the value of the variable fortran-column-ruler-tab is displayed. By changing these variables, you can change the column ruler display.

C-c C-w (fortran-window-create-momentarily) temporarily splits the current window horizontally, making a window fortran-line-length columns wide, so you can see any lines that are too long. Type a space to restore the normal width.

You can also split the window horizontally and continue editing with the split in place. To do this, use C-u C-c C-w (M-x fortran-window-create). By editing in this window you can immediately see when you make a line too wide to be correct Fortran.

The command M-x fortran-strip-sequence-nos deletes all text in column fortran-line-length and beyond, on all lines in the current buffer. This is the easiest way to get rid of old sequence numbers.


**** Fortran Keyword Abbrevs

Fortran mode provides many built-in abbrevs for common keywords and declarations. These are the same sort of abbrev that you can define yourself. To use them, you must turn on Abbrev mode. See Abbrevs.

The built-in abbrevs are unusual in one way: they all start with a semicolon. For example, one built-in Fortran abbrev is ‘;c’ for ‘continue’. If you insert ‘;c’ and then insert a punctuation character such as a space or a newline, the ‘;c’ expands automatically to ‘continue’, provided Abbrev mode is enabled.

Type ‘;?’ or ‘;C-h’ to display a list of all the built-in Fortran abbrevs and what they stand for.



** Compiling and Testing Programs

The previous chapter discusses the Emacs commands that are useful for making changes in programs. This chapter deals with commands that assist in the process of compiling and testing programs.

*** Running Compilations under Emacs

Emacs can run compilers for languages such as C and Fortran, feeding the compilation log into an Emacs buffer. It can also parse the error messages and show you where the errors occurred.

M-x compile
Run a compiler asynchronously under Emacs, with error messages going to the *compilation* buffer.

M-x recompile
g (Compilation mode)
Invoke a compiler with the same command as in the last invocation of M-x compile.

M-x kill-compilation
Kill the running compilation subprocess.

To run make or another compilation command, type M-x compile. This reads a shell command line using the minibuffer, and then executes the command by running a shell as a subprocess (or inferior process) of Emacs. The output is inserted in a buffer named *compilation*. The current buffer’s default directory is used as the working directory for the execution of the command, so by default compilation takes place in that directory.

The default compilation command is ‘make -k’, which is usually correct for programs compiled using the make utility (the ‘-k’ flag tells make to continue compiling as much as possible after an error). See Make in GNU Make Manual. If you have done M-x compile before, the command that you specified is automatically stored in the variable compile-command; this is used as the default the next time you type M-x compile. A file can also specify a file-local value for compile-command (see Local Variables in Files).

Starting a compilation displays the *compilation* buffer in another window but does not select it. While the compilation is running, the word ‘run’ is shown in the major mode indicator for the *compilation* buffer, and the word ‘Compiling’ appears in all mode lines. You do not have to keep the *compilation* buffer visible while compilation is running; it continues in any case. When the compilation ends, for whatever reason, the mode line of the *compilation* buffer changes to say ‘exit’ (followed by the exit code: ‘[0]’ for a normal exit), or ‘signal’ (if a signal terminated the process).

If you want to watch the compilation transcript as it appears, switch to the *compilation* buffer and move point to the end of the buffer. When point is at the end, new compilation output is inserted above point, which remains at the end. Otherwise, point remains fixed while compilation output is added at the end of the buffer.

While compilation proceeds, the mode line shows the number of errors, warnings, and informational messages emitted by the compiler so far.

If you change the variable compilation-scroll-output to a non-nil value, the *compilation* buffer scrolls automatically to follow the output. If the value is first-error, scrolling stops when the first error appears, leaving point at that error. For any other non-nil value, scrolling continues until there is no more output.

To rerun the last compilation with the same command, type M-x recompile. This reuses the compilation command from the last invocation of M-x compile. It also reuses the *compilation* buffer and starts the compilation in its default directory, which is the directory in which the previous compilation was started. In *compilation* buffers this command is bound to g.

Starting a new compilation also kills any compilation already running in *compilation*, as the buffer can only handle one compilation at any time. However, M-x compile and M-x recompile ask for confirmation before actually killing a compilation that is running; to always automatically kill the compilation without asking, change the variable compilation-always-kill to t. You can also kill a compilation process with the command M-x kill-compilation.

To run two compilations at once, start the first one, then rename the *compilation* buffer (perhaps using rename-uniquely; see Miscellaneous Buffer Operations), then switch buffers and start the other compilation. This will create a new *compilation* buffer.

You can control the environment passed to the compilation command with the variable compilation-environment. Its value is a list of environment variable settings; each element should be a string of the form "envvarname=value". These environment variable settings override the usual ones.

Displaying extremely long lines in compilation output can slow Emacs down. Lines that are longer than compilation-max-output-line-length will have the portion that’s exceeds that limit hidden behind a button that can be clicked on to reveal the hidden portion. Set this variable to nil to never hide anything.


*** Compilation Mode

The *compilation* buffer uses a major mode called Compilation mode. Compilation mode turns each error message in the buffer into a hyperlink; you can move point to it and type RET, or click on it with the mouse (see Following References with the Mouse), to visit the locus of the error message in a separate window. The locus is the specific position in a file where that error occurred.

The appearance of the *compilation* buffer can be controlled by customizing the faces which are used to highlight parts of the *compilation* buffer, e.g., compilation-error or compilation-warning, for error and warning messages respectively. Note that since those faces inherit from the error and warning faces, it is also possible to customize the parent face directly instead.

Use M-x customize-group RET compilation to see the entire list of customization variables and faces.

If you change the variable compilation-auto-jump-to-first-error to a non-nil value, Emacs automatically visits the locus of the first error message that appears in the *compilation* buffer. (This variable can also have the values if-location-known and first-known, which modify the conditions for automatically visiting the error locus.)

Compilation mode provides the following additional commands. These commands can also be used in *grep* buffers, where the hyperlinks are search matches rather than error messages (see Searching with Grep under Emacs).

M-g M-n
M-g n
C-x `
Visit the locus of the next error message or match (next-error).

M-g M-p
M-g p
Visit the locus of the previous error message or match (previous-error).

M-n
Move point to the next error message or match, without visiting its locus (compilation-next-error).

M-p
Move point to the previous error message or match, without visiting its locus (compilation-previous-error).

M-}
Move point to the next error message or match occurring in a different file (compilation-next-file).

M-{
Move point to the previous error message or match occurring in a different file (compilation-previous-file).

C-c C-f
Toggle Next Error Follow minor mode, which makes cursor motion in the compilation buffer produce automatic source display.

g
Re-run the last command whose output is shown in the *compilation* buffer.

M-x next-error-select-buffer
Select a buffer to be used by next invocation of next-error and previous-error.

To visit errors sequentially, type C-x ` (next-error), or equivalently M-g M-n or M-g n. This command can be invoked from any buffer, not just a Compilation mode buffer. The first time you invoke it after a compilation, it visits the locus of the first error message. Each subsequent M-g M-n visits the next error, in a similar fashion. If you visit a specific error with RET or a mouse click in the *compilation* buffer, subsequent M-g M-n commands advance from there. When M-g M-n finds no more error messages to visit, it signals an error. C-u M-g M-n starts again from the beginning of the compilation buffer, and visits the first locus.

M-g M-p or M-g p (previous-error) iterates through errors in the opposite direction.

The next-error and previous-error commands don’t just act on the errors or matches listed in *compilation* and *grep* buffers; they also know how to iterate through error or match lists produced by other commands, such as M-x occur (see Other Search-and-Loop Commands). If the current buffer contains error messages or matches, these commands will iterate through them; otherwise, Emacs looks for a buffer containing error messages or matches amongst the windows of the selected frame (if the variable next-error-find-buffer-function is customized to the value next-error-buffer-on-selected-frame), then for a buffer used previously by next-error or previous-error, and finally all other buffers. Any buffer these commands iterate through that is not currently displayed in a window will be displayed. You can use the next-error-select-buffer command to switch to a different buffer to be used by the subsequent invocation of next-error.

By default, the next-error and previous-error commands skip less important messages. The variable compilation-skip-threshold controls this. The default value, 1, means to skip anything less important than a warning. A value of 2 means to skip anything less important than an error, while 0 means not to skip any messages.

When Emacs visits the locus of an error message, it momentarily highlights the relevant source line. The duration of this highlight is determined by the variable next-error-highlight for the locus in the selected buffer, and next-error-highlight-no-select for the locus in non-selected buffers. Also you can customize the variable next-error-message-highlight that defines how to highlight the current error message in the buffer that contains messages.

If the *compilation* buffer is shown in a window with a left fringe (see Window Fringes), the locus-visiting commands put an arrow in the fringe, pointing to the current error message. If the window has no left fringe, such as on a text terminal, these commands scroll the window so that the current message is at the top of the window. If you change the variable compilation-context-lines to t, a visible arrow is inserted before column zero instead. If you change the variable to an integer value n, these commands scroll the window so that the current error message is n lines from the top, whether or not there is a fringe; the default value, nil, gives the behavior described above.

Compilation output can sometimes be very verbose, and much of it isn’t of particular interest to a user. The compilation-hidden-output user option should either be a regexp or a list of regexps, and output that matches will be made invisible. For instance, to hide the verbose output from recursive makefiles, you can say something like:

(setq compilation-hidden-output
      '("^make[^\n]+\n"))
To parse messages from the compiler, Compilation mode uses the variable compilation-error-regexp-alist which lists various error message formats and tells Emacs how to extract the locus from each. A similar variable, grep-regexp-alist, tells Emacs how to parse output from a grep command (see Searching with Grep under Emacs).

Compilation mode also defines the keys SPC and DEL to scroll by screenfuls; M-n (compilation-next-error) and M-p (compilation-previous-error) to move to the next or previous error message; and M-{ (compilation-next-file) and M-} (compilation-previous-file) to move to the next or previous error message for a different source file.

You can type C-c C-f to toggle Next Error Follow mode. In this minor mode, ordinary cursor motion in the compilation buffer automatically updates the source buffer, i.e., moving the cursor over an error message causes the locus of that error to be displayed.

The features of Compilation mode are also available in a minor mode called Compilation Minor mode. This lets you parse error messages in any buffer, not just a normal compilation output buffer. Type M-x compilation-minor-mode to enable the minor mode. For instance, in an Rlogin buffer (see Remote Host Shell), Compilation minor mode automatically accesses remote source files by FTP (see File Names).


*** Subshells for Compilation

This section includes various techniques and advice for using a shell and its features in compilation buffers. This material is specific to local compilations, and will most probably not work in (or be irrelevant to) compilation buffers whose default directory is on remote hosts.

The M-x compile command uses a shell to run the compilation command, but specifies the option for a noninteractive shell. This means, in particular, that the shell should start with no prompt. If you find your usual shell prompt making an unsightly appearance in the *compilation* buffer, it means you have made a mistake in your shell’s init file by setting the prompt unconditionally. (This init file may be named .bashrc, .profile, .cshrc, .shrc, etc., depending on what shell you use.) The shell init file should set the prompt only if there already is a prompt. Here’s how to do it in bash:

if [ "${PS1+set}" = set ]
then PS1=…
fi
And here’s how to do it in csh:

if ($?prompt) set prompt = …
If you want to customize the value of the TERM environment variable passed to the compilation subshell, customize the variable comint-terminfo-terminal (see Shell Mode Options).

Emacs does not expect a compiler process to launch asynchronous subprocesses; if it does, and they keep running after the main compiler process has terminated, Emacs may kill them or their output may not arrive in Emacs. To avoid this problem, make the main compilation process wait for its subprocesses to finish. In a shell script, you can do this using ‘$!’ and ‘wait’, like this:

(sleep 10; echo 2nd)& pid=$!  # Record pid of subprocess
echo first message
wait $pid                     # Wait for subprocess
If the background process does not output to the compilation buffer, so you only need to prevent it from being killed when the main compilation process terminates, this is sufficient:

nohup command; sleep 1
On MS-DOS, asynchronous subprocesses are not supported, so M-x compile runs the compilation command synchronously (i.e., you must wait until the command finishes before you can do anything else in Emacs). See Emacs and MS-DOS.


*** Searching with Grep under Emacs

Just as you can run a compiler from Emacs and then visit the lines with compilation errors, you can also run grep and then visit the lines on which matches were found. This works by treating the matches reported by grep as if they were errors. The output buffer uses Grep mode, which is a variant of Compilation mode (see Compilation Mode).

M-x grep
M-x lgrep
Run grep asynchronously under Emacs, listing matching lines in the buffer named *grep*.

M-x grep-find
M-x find-grep
M-x rgrep
Run grep via find, and collect output in the *grep* buffer.

M-x zrgrep
Run zgrep and collect output in the *grep* buffer.

M-x kill-grep
Kill the running grep subprocess.

To run grep, type M-x grep, then enter a command line that specifies how to run grep. Use the same arguments you would give grep when running it normally: a grep-style regexp (usually in single-quotes to quote the shell’s special characters) followed by file names, which may use wildcards. If you specify a prefix argument for M-x grep, it finds the identifier (see Find Identifier References) in the buffer around point, and puts that into the default grep command.

Your command need not simply run grep; you can use any shell command that produces output in the same format. For instance, you can chain grep commands, like this:

grep -nH -e foo *.el | grep bar | grep toto
The output from grep goes in the *grep* buffer. You can find the corresponding lines in the original files using M-g M-n, RET, and so forth, just like compilation errors. See Compilation Mode, for detailed description of commands and key bindings available in the *grep* buffer.

Some grep programs accept a ‘--color’ option to output special markers around matches for the purpose of highlighting. You can make use of this feature by setting grep-highlight-matches to t. When displaying a match in the source buffer, the exact match will be highlighted, instead of the entire source line. Highlighting is provided via matching the ANSI escape sequences emitted by grep. The matching of the sequences is controlled by grep-match-regexp, which can be customized to accommodate different grep programs.

As with compilation commands (see Running Compilations under Emacs), while the grep command runs, the mode line shows the running number of matches found and highlighted so far.

The grep commands will offer to save buffers before running. This is controlled by the grep-save-buffers variable. The possible values are either nil (don’t save), ask (ask before saving), or a function which will be used as a predicate (and is called with the file name as the parameter and should return non-nil if the buffer is to be saved). Any other non-nil value means that all buffers should be saved without asking. The default is ask.

The command M-x grep-find (also available as M-x find-grep) is similar to M-x grep, but it supplies a different initial default for the command—one that runs both find and grep, so as to search every file in a directory tree. See also the find-grep-dired command, in Dired and find.

The commands M-x lgrep (local grep) and M-x rgrep (recursive grep) are more user-friendly versions of grep and grep-find, which prompt separately for the regular expression to match, the files to search, and the base directory for the search. Case sensitivity of the search is controlled by the current value of case-fold-search. The command M-x zrgrep is similar to M-x rgrep, but it calls zgrep instead of grep to search the contents of gzipped files.

These commands build the shell commands based on the variables grep-template (for lgrep) and grep-find-template (for rgrep). The files to search can use aliases defined in the variable grep-files-aliases.

Directories listed in the variable grep-find-ignored-directories are automatically skipped by M-x rgrep. The default value includes the data directories used by various version control systems.

By default, the shell commands constructed for lgrep, rgrep, and zgrep are abbreviated for display by concealing the part that contains a long list of files and directories to ignore. You can reveal the concealed part by clicking on the button with ellipsis, which represents them. You can also interactively toggle viewing the concealed part by typing M-x grep-find-toggle-abbreviation. To disable this abbreviation of the shell commands, customize the option grep-find-abbreviate to a nil value.


*** Finding Syntax Errors On The Fly

Flymake mode is a minor mode that performs on-the-fly syntax checking for many programming and markup languages, including C, C++, Perl, HTML, and TeX/LaTeX. It is somewhat analogous to Flyspell mode, which performs spell checking for ordinary human languages in a similar fashion (see Checking and Correcting Spelling). As you edit a file, Flymake mode runs an appropriate syntax checking tool in the background, using a temporary copy of the buffer. It then parses the error and warning messages, and highlights the erroneous lines in the buffer. The syntax checking tool used depends on the language; for example, for C/C++ files this is usually the C compiler. Flymake can also use build tools such as make for checking complicated projects.

To enable Flymake mode, type M-x flymake-mode. You can jump to the errors that it finds by using M-x flymake-goto-next-error and M-x flymake-goto-prev-error. To display a detailed overview of the diagnostics for the current buffer, use the command M-x flymake-show-buffer-diagnostics; to display a similar overview of diagnostics for the entire project (see Working with Projects), use M-x flymake-show-project-diagnostics.

For more details about using Flymake, see Flymake in The Flymake Manual.


*** Running Debuggers Under Emacs

The GUD (Grand Unified Debugger) library provides an Emacs interface to a wide variety of symbolic debuggers. It can run the GNU Debugger (GDB), as well as DBX, SDB, XDB, Guile REPL debug commands, Perl’s debugging mode, the Python debugger PDB, and the Java Debugger JDB.

Emacs provides a special interface to GDB, which uses extra Emacs windows to display the state of the debugged program. See GDB Graphical Interface.

Emacs also has a built-in debugger for Emacs Lisp programs. See The Lisp Debugger in the Emacs Lisp Reference Manual.

**** Starting GUD

There are several commands for starting a debugger subprocess, each corresponding to a particular debugger program.

M-x gdb ¶
Run GDB as a subprocess, and interact with it via an IDE-like Emacs interface. See GDB Graphical Interface, for more information about this command.

M-x gud-gdb ¶
Run GDB, using a GUD interaction buffer for input and output to the GDB subprocess (see Debugger Operation). If such a buffer already exists, switch to it; otherwise, create the buffer and switch to it.

The other commands in this list do the same, for other debugger programs.

M-x perldb ¶
Run the Perl interpreter in debug mode.

M-x jdb ¶
Run the Java debugger.

M-x pdb ¶
Run the Python debugger.

M-x guiler ¶
Run Guile REPL for debugging Guile Scheme programs.

M-x dbx ¶
Run the DBX debugger.

M-x xdb ¶
Run the XDB debugger.

M-x sdb ¶
Run the SDB debugger.

Each of these commands reads a command line to invoke the debugger, using the minibuffer. The minibuffer’s initial contents contain the standard executable name and options for the debugger, and sometimes also a guess for the name of the executable file you want to debug. Shell wildcards and variables are not allowed in this command line. Emacs assumes that the first command argument which does not start with a ‘-’ is the executable file name.

Tramp provides a facility for remote debugging, whereby both the debugger and the program being debugged are on the same remote host. See Running a debugger on a remote host in The Tramp Manual, for details. This is separate from GDB’s remote debugging feature, where the program and the debugger run on different machines (see Debugging Remote Programs in The GNU debugger).


**** Debugger Operation

The GUD interaction buffer is an Emacs buffer which is used to send text commands to a debugger subprocess, and record its output. This is the basic interface for interacting with a debugger, used by M-x gud-gdb and other commands listed in Starting GUD. The M-x gdb command extends this interface with additional specialized buffers for controlling breakpoints, stack frames, and other aspects of the debugger state (see GDB Graphical Interface).

The GUD interaction buffer uses a variant of Shell mode, so the Emacs commands defined by Shell mode are available (see Shell Mode). Completion is available for most debugger commands (see Completion), and you can use the usual Shell mode history commands to repeat them. See Commands of GUD, for special commands that can be used in the GUD interaction buffer.

As you debug a program, Emacs displays the relevant source files by visiting them in Emacs buffers, with an arrow in the left fringe indicating the current execution line. (On a text terminal, the arrow appears as ‘=>’, overlaid on the first two text columns.) Moving point in such a buffer does not move the arrow. You are free to edit these source files, but note that inserting or deleting lines will throw off the arrow’s positioning, as Emacs has no way to figure out which edited source line corresponds to the line reported by the debugger subprocess. To update this information, you typically have to recompile and restart the program.

GUD Tooltip mode is a global minor mode that adds tooltip support to GUD. To toggle this mode, type M-x gud-tooltip-mode. It is disabled by default. If enabled, you can move the mouse pointer over a variable, a function, or a macro (collectively called identifiers) to show their values in tooltips (see Tooltips). If just placing the mouse pointer over an expression doesn’t show the value of the expression you had in mind, you can tell Emacs more explicitly what expression to evaluate by dragging the mouse over the expression, then leaving the mouse inside the marked area. The GUD Tooltip mode takes effect in the GUD interaction buffer, and in all source buffers with major modes listed in the variable gud-tooltip-modes. If you turned off the tooltip mode, values are shown in the echo area instead of a tooltip.

When using GUD Tooltip mode with M-x gud-gdb, displaying an expression’s value in GDB can sometimes expand a macro, potentially causing side effects in the debugged program. For that reason, using tooltips in gud-gdb is disabled. If you use the M-x gdb interface, this problem does not occur, as there is special code to avoid side-effects; furthermore, you can display macro definitions associated with an identifier when the program is not executing.


**** Commands of GUD

GUD provides commands for setting and clearing breakpoints, selecting stack frames, and stepping through the program.

C-x C-a C-b ¶
Set a breakpoint on the source line that point is on.

C-x C-a C-b (gud-break), when called in a source buffer, sets a debugger breakpoint on the current source line. This command is available only after starting GUD. If you call it in a buffer that is not associated with any debugger subprocess, it signals an error.

The following commands are available both in the GUD interaction buffer and globally, but with different key bindings. The keys starting with C-c are available only in the GUD interaction buffer, while those starting with C-x C-a are available globally. Some of these commands are also available via the tool bar; some are not supported by certain debuggers.

C-c C-l ¶
C-x C-a C-l
Display, in another window, the last source line referred to in the GUD interaction buffer (gud-refresh).

C-c C-s ¶
C-x C-a C-s
Execute the next single line of code (gud-step). If the line contains a function call, execution stops after entering the called function.

C-c C-n ¶
C-x C-a C-n
Execute the next single line of code, stepping across function calls without stopping inside the functions (gud-next).

C-c C-i ¶
C-x C-a C-i
Execute a single machine instruction (gud-stepi).

C-c C-p ¶
C-x C-a C-p
Evaluate the expression at point (gud-print). If Emacs does not print the exact expression that you want, mark it as a region first.

C-c C-r ¶
C-x C-a C-r
Continue execution without specifying any stopping point. The program will run until it hits a breakpoint, terminates, or gets a signal that the debugger is checking for (gud-cont).

C-c C-d ¶
C-x C-a C-d
Delete the breakpoint(s) on the current source line, if any (gud-remove). If you use this command in the GUD interaction buffer, it applies to the line where the program last stopped.

C-c C-t ¶
C-x C-a C-t
Set a temporary breakpoint on the current source line, if any (gud-tbreak). If you use this command in the GUD interaction buffer, it applies to the line where the program last stopped.

C-c < ¶
C-x C-a <
Select the next enclosing stack frame (gud-up). This is equivalent to the GDB command ‘up’.

C-c > ¶
C-x C-a >
Select the next inner stack frame (gud-down). This is equivalent to the GDB command ‘down’.

C-c C-u ¶
C-x C-a C-u
Continue execution to the current line (gud-until). The program will run until it hits a breakpoint, terminates, gets a signal that the debugger is checking for, or reaches the line on which the cursor currently sits.

C-c C-f ¶
C-x C-a C-f
Run the program until the selected stack frame returns or stops for some other reason (gud-finish).

If you are using GDB, these additional key bindings are available:

C-x C-a C-j ¶
Only useful in a source buffer, gud-jump transfers the program’s execution point to the current line. In other words, the next line that the program executes will be the one where you gave the command. If the new execution line is in a different function from the previously one, GDB prompts for confirmation since the results may be bizarre. See the GDB manual entry regarding jump for details.

TAB ¶
With GDB, complete a symbol name (gud-gdb-complete-command). This key is available only in the GUD interaction buffer.

These commands interpret a numeric argument as a repeat count, when that makes sense.

Because TAB serves as a completion command, you can’t use it to enter a tab as input to the program you are debugging with GDB. Instead, type C-q TAB to enter a tab.


**** GUD Customization

On startup, GUD runs one of the following hooks: gdb-mode-hook, if you are using GDB; dbx-mode-hook, if you are using DBX; sdb-mode-hook, if you are using SDB; xdb-mode-hook, if you are using XDB; guiler-mode-hook for Guile REPL debugging; perldb-mode-hook, for Perl debugging mode; pdb-mode-hook, for PDB; jdb-mode-hook, for JDB. See Hooks.

The gud-def Lisp macro (see Defining Macros in the Emacs Lisp Reference Manual) provides a convenient way to define an Emacs command that sends a particular command string to the debugger, and set up a key binding for in the GUD interaction buffer:

(gud-def function cmdstring binding docstring)
This defines a command named function which sends cmdstring to the debugger process, and gives it the documentation string docstring. You can then use the command function in any buffer. If binding is non-nil, gud-def also binds the command to C-c binding in the GUD buffer’s mode and to C-x C-a binding generally.

The command string cmdstring may contain certain ‘%’-sequences that stand for data to be filled in at the time function is called:

‘%f’
The name of the current source file. If the current buffer is the GUD buffer, then the current source file is the file that the program stopped in.

‘%l’
The number of the current source line. If the current buffer is the GUD buffer, then the current source line is the line that the program stopped in.

‘%e’
In transient-mark-mode the text in the region, if it is active. Otherwise the text of the C lvalue or function-call expression at or adjacent to point.

‘%a’
The text of the hexadecimal address at or adjacent to point.

‘%p’
The numeric argument of the called function, as a decimal number. If the command is used without a numeric argument, ‘%p’ stands for the empty string.

If you don’t use ‘%p’ in the command string, the command you define ignores any numeric argument.

‘%d’
The name of the directory of the current source file.

‘%c’
Fully qualified class name derived from the expression surrounding point (jdb only).


**** GDB Graphical Interface

The command M-x gdb starts GDB in an IDE-like interface, with specialized buffers for controlling breakpoints, stack frames, and other aspects of the debugger state. It also provides additional ways to control the debugging session with the mouse, such as clicking in the fringe of a source buffer to set a breakpoint there.

To run GDB using just the GUD interaction buffer interface, without these additional features, use M-x gud-gdb (see Starting GUD).

Internally, M-x gdb informs GDB that its screen size is unlimited; for correct operation, you must not change GDB’s screen height and width values during the debugging session.

***** GDB User Interface Layout

If the variable gdb-many-windows is nil (the default), M-x gdb normally displays only the GUD interaction buffer. However, if the variable gdb-show-main is also non-nil, it starts with two windows: one displaying the GUD interaction buffer, and the other showing the source for the main function of the program you are debugging.

If gdb-many-windows is non-nil, then M-x gdb displays the following frame layout:

+--------------------------------+--------------------------------+
|   GUD interaction buffer       |   Locals/Registers buffer      |
|--------------------------------+--------------------------------+
|   Primary Source buffer        |   I/O buffer for debugged pgm  |
|--------------------------------+--------------------------------+
|   Stack buffer                 |   Breakpoints/Threads buffer   |
+--------------------------------+--------------------------------+
You can customize the window layout based on the one above and save that layout to a file using gdb-save-window-configuration. Then you can later load this layout back using gdb-load-window-configuration. (Internally, Emacs uses the term window configuration instead of window layout.) You can set your custom layout as the default one used by gdb-many-windows by customizing gdb-default-window-configuration-file. If it is not an absolute file name, GDB looks under gdb-window-configuration-directory for the file. gdb-window-configuration-directory defaults to user-emacs-directory (see How Emacs Finds Your Init File).

If you ever change the window layout, you can restore the default layout by typing M-x gdb-restore-windows. To toggle between the many windows layout and a simple layout with just the GUD interaction buffer and a source file, type M-x gdb-many-windows.

If you have an elaborate window setup, and don’t want gdb-many-windows to disrupt that, it is better to invoke M-x gdb in a separate frame to begin with, then the arrangement of windows on your original frame will not be affected. A separate frame for GDB sessions can come in especially handy if you work on a text-mode terminal, where the screen estate for windows could be at a premium. If you choose to start GDB in the same frame, consider setting gdb-restore-window-configuration-after-quit to a non-nil value. Your original layout will then be restored after GDB quits. Use t to always restore; use if-gdb-many-windows to restore only when gdb-many-windows is non-nil; use if-gdb-show-main to restore only when gdb-show-main is non-nil.

You may also specify additional GDB-related buffers to display, either in the same frame or a different one. Select the buffers you want by typing M-x gdb-display-buffertype-buffer or M-x gdb-frame-buffertype-buffer, where buffertype is the relevant buffer type, such as ‘breakpoints’ or ‘io’. You can do the same from the menu bar, with the ‘GDB-Windows’ and ‘GDB-Frames’ sub-menus of the ‘GUD’ menu.

By default, GDB uses at most one window to display the source file. You can make it use more windows by customizing gdb-max-source-window-count. You can also customize gdb-display-source-buffer-action to control how GDB displays source files.

When you finish debugging, kill the GUD interaction buffer with C-x k, which will also kill all the buffers associated with the session. However you need not do this if, after editing and re-compiling your source code within Emacs, you wish to continue debugging. When you restart execution, GDB automatically finds the new executable. Keeping the GUD interaction buffer has the advantage of keeping the shell history as well as GDB’s breakpoints. You do need to check that the breakpoints in recently edited source files are still in the right places.


***** Source Buffers

mouse-1 (in fringe)
Set or clear a breakpoint on that line (gdb-mouse-set-clear-breakpoint).

C-mouse-1 (in fringe)
Enable or disable a breakpoint on that line (gdb-mouse-toggle-breakpoint-margin).

mouse-3 (in fringe)
Continue execution to that line (gdb-mouse-until).

C-mouse-3 (in fringe)
Jump to that line (gdb-mouse-jump).

On a graphical display, you can click mouse-1 in the fringe of a source buffer, to set a breakpoint on that line (see Window Fringes). A red dot appears in the fringe, where you clicked. If a breakpoint already exists there, the click removes it. A C-mouse-1 click enables or disables an existing breakpoint; a breakpoint that is disabled, but not unset, is indicated by a gray dot.

On a text terminal, or when fringes are disabled, enabled breakpoints are indicated with a ‘B’ character in the left margin of the window. Disabled breakpoints are indicated with ‘b’. (The margin is only displayed if a breakpoint is present.)

A solid arrow in the left fringe of a source buffer indicates the line of the innermost frame where the debugged program has stopped. A hollow arrow indicates the current execution line of a higher-level frame. If you drag the arrow in the fringe with mouse-1, that causes execution to advance to the line where you release the button. Alternatively, you can click mouse-3 in the fringe to advance to that line. You can click C-mouse-3 in the fringe to jump to that line without executing the intermediate lines. This command allows you to go backwards, which can be useful for running through code that has already executed, in order to examine its execution in more detail.

By default, source file names and non-ASCII strings in the program being debugged are decoded using the default coding-system. If you prefer a different decoding, perhaps because the program being debugged uses a different character encoding, set the variable gdb-mi-decode-strings to the appropriate coding-system, or to nil to leave non-ASCII characters as undecoded octal escapes.


***** Breakpoints Buffer

The GDB Breakpoints buffer shows the breakpoints, watchpoints and catchpoints in the debugger session. See Breakpoints in The GNU debugger. It provides the following commands, which mostly apply to the current breakpoint (the breakpoint which point is on):

SPC ¶
Enable/disable current breakpoint (gdb-toggle-breakpoint). On a graphical display, this changes the color of the dot in the fringe of the source buffer at that line. The dot is red when the breakpoint is enabled, and gray when it is disabled.

D ¶
Delete the current breakpoint (gdb-delete-breakpoint).

RET ¶
Visit the source line for the current breakpoint (gdb-goto-breakpoint).

mouse-2 ¶
Visit the source line for the breakpoint you click on (gdb-goto-breakpoint).

When gdb-many-windows is non-nil, the GDB Breakpoints buffer shares its window with the GDB Threads buffer. To switch from one to the other click with mouse-1 on the relevant button in the header line. If gdb-show-threads-by-default is non-nil, the GDB Threads buffer is the one shown by default.


***** Threads Buffer

The GDB Threads buffer displays a summary of the threads in the debugged program. See Debugging programs with multiple threads in The GNU debugger. To select a thread, move point there and press RET (gdb-select-thread), or click on it with mouse-2. This also displays the associated source buffer, and updates the contents of the other GDB buffers.

You can customize variables in the gdb-buffers group to select fields included in GDB Threads buffer.

gdb-thread-buffer-verbose-names ¶
Show long thread names like ‘Thread 0x4e2ab70 (LWP 1983)’.

gdb-thread-buffer-arguments ¶
Show arguments of thread top frames.

gdb-thread-buffer-locations ¶
Show file information or library names.

gdb-thread-buffer-addresses ¶
Show addresses for thread frames in threads buffer.

To view information for several threads simultaneously, use the following commands from the GDB Threads buffer.

d ¶
Display disassembly buffer for the thread at current line (gdb-display-disassembly-for-thread).

f ¶
Display the GDB Stack buffer for the thread at current line (gdb-display-stack-for-thread).

l ¶
Display the GDB Locals buffer for the thread at current line (gdb-display-locals-for-thread).

r ¶
Display the GDB Registers buffer for the thread at current line (gdb-display-registers-for-thread).

Their upper-case counterparts, D, F ,L and R, display the corresponding buffer in a new frame.

When you create a buffer showing information about some specific thread, it becomes bound to that thread and keeps showing actual information while you debug your program. The mode indicator for each GDB buffer shows the number of the thread whose information that buffer displays. The thread number is also included in the name of each bound buffer.

Further commands are available in the GDB Threads buffer which depend on the mode of GDB that is used for controlling execution of your program. See Multithreaded Debugging.


***** Stack Buffer

The GDB Stack buffer displays a call stack, with one line for each of the nested subroutine calls (stack frames) in the debugger session. See Backtraces in The GNU debugger.

On graphical displays, the selected stack frame is indicated by an arrow in the fringe. On text terminals, or when fringes are disabled, the selected stack frame is displayed in reverse contrast. To select a stack frame, move point in its line and type RET (gdb-frames-select), or click mouse-2 on it. Doing so also updates the Locals buffer (see Other GDB Buffers).

If you want the frame address to be shown each stack frame, customize the variable gdb-stack-buffer-addresses to a non-nil value.


***** Other GDB Buffers

Other buffers provided by M-x gdb whose display you can optionally request include:

Locals Buffer
This buffer displays the values of local variables of the current stack frame for simple data types (see Information on a frame in The GNU debugger). Press RET or click mouse-2 on the value if you want to edit it.

Arrays and structures display their type only. With GDB 6.4 or later, you can examine the value of the local variable at point by typing RET, or with a mouse-2 click. With earlier versions of GDB, use RET or mouse-2 on the type description (‘[struct/union]’ or ‘[array]’). See Watch Expressions.

To display the Locals buffer, type M-x gdb-display-locals-buffer.

I/O Buffer
If the program you are debugging uses standard input and output streams for interaction with the user, or emits a significant amount of output to its standard output, you may wish to separate its I/O from interaction with GDB. Use the command M-x gdb-display-io-buffer to show a window with a buffer to which Emacs redirects the input and output from the program you are debugging.

Registers Buffer
This buffer displays the values held by the registers (see Registers in The GNU debugger). Request the display of this buffer with the command M-x gdb-display-registers-buffer. Press RET or click mouse-2 on a register if you want to edit its value. With GDB 6.4 or later, recently changed register values display with font-lock-warning-face.

Assembler Buffer
The assembler buffer displays the current frame as machine code. An arrow points to the current instruction, and you can set and remove breakpoints as in a source buffer. Breakpoint icons also appear in the fringe or margin. To request the display of this buffer, use M-x gdb-display-disassembly-buffer.

Memory Buffer
The memory buffer lets you examine sections of program memory (see Examining memory in The GNU debugger). Click mouse-1 on the appropriate part of the header line to change the starting address or number of data items that the buffer displays. Alternatively, use S or N respectively. Click mouse-3 on the header line to select the display format or unit size for these data items. Use M-x gdb-display-memory-buffer to request display of this buffer.

When gdb-many-windows is non-nil, the locals buffer shares its window with the registers buffer, just like breakpoints and threads buffers. To switch from one to the other, click with mouse-1 on the relevant button in the header line.


***** Watch Expressions

If you want to see how a variable changes each time your program stops, move point into the variable name and click on the watch icon in the tool bar (gud-watch) or type C-x C-a C-w. If you specify a prefix argument, you can enter the variable name in the minibuffer.

Each watch expression is displayed in the speedbar (see Speedbar Frames). Complex data types, such as arrays, structures and unions are represented in a tree format. Leaves and simple data types show the name of the expression and its value and, when the speedbar frame is selected, display the type as a tooltip. Higher levels show the name, type and address value for pointers and just the name and type otherwise. Root expressions also display the frame address as a tooltip to help identify the frame in which they were defined.

To expand or contract a complex data type, click mouse-2 or press SPC on the tag to the left of the expression. Emacs asks for confirmation before expanding the expression if its number of immediate children exceeds the value of the variable gdb-max-children.

To delete a complex watch expression, move point to the root expression in the speedbar and type D (gdb-var-delete).

To edit a variable with a simple data type, or a simple element of a complex data type, move point there in the speedbar and type RET (gdb-edit-value). Or you can click mouse-2 on a value to edit it. Either way, this reads the new value using the minibuffer.

If you set the variable gdb-show-changed-values to non-nil (the default value), Emacs uses font-lock-warning-face to highlight values that have recently changed and shadow face to make variables which have gone out of scope less noticeable. When a variable goes out of scope you can’t edit its value.

If the variable gdb-delete-out-of-scope is non-nil (the default value), Emacs automatically deletes watch expressions which go out of scope. Sometimes, when your program re-enters the same function many times, it may be useful to set this value to nil so that you don’t need to recreate the watch expression.

If the variable gdb-use-colon-colon-notation is non-nil, Emacs uses the ‘function::variable’ format. This allows the user to display watch expressions which share the same variable name. The default value is nil.

To automatically raise the speedbar every time the display of watch expressions updates, set gdb-speedbar-auto-raise to non-nil. This can be useful if you are debugging with a full screen Emacs frame.


***** Multithreaded Debugging

In GDB’s all-stop mode, whenever your program stops, all execution threads stop. Likewise, whenever you restart the program, all threads start executing. See All-Stop Mode in The GNU debugger. For some multi-threaded targets, GDB supports a further mode of operation, called non-stop mode, in which you can examine stopped program threads in the debugger while other threads continue to execute freely. See Non-Stop Mode in The GNU debugger. Versions of GDB prior to 7.0 do not support non-stop mode, and it does not work on all targets.

The variable gdb-non-stop-setting determines whether Emacs runs GDB in all-stop mode or non-stop mode. The default is t, which means it tries to use non-stop mode if that is available. If you change the value to nil, or if non-stop mode is unavailable, Emacs runs GDB in all-stop mode. The variable takes effect when Emacs begins a debugging session; if you change its value, you should restart any active debugging session.

When a thread stops in non-stop mode, Emacs usually switches to that thread. If you don’t want Emacs to do this switch if another stopped thread is already selected, change the variable gdb-switch-when-another-stopped to nil.

Emacs can decide whether or not to switch to the stopped thread depending on the reason which caused the stop. Customize the variable gdb-switch-reasons to select the stop reasons which will cause a thread switch.

The variable gdb-stopped-functions allows you to execute your functions whenever some thread stops.

In non-stop mode, you can switch between different modes for GUD execution control commands.

Non-stop/A
When gdb-gud-control-all-threads is t (the default value), interruption and continuation commands apply to all threads, so you can halt or continue all your threads with one command using gud-stop-subjob and gud-cont, respectively. The ‘Go’ button is shown on the tool bar when at least one thread is stopped, whereas ‘Stop’ button is shown when at least one thread is running.

Non-stop/T
When gdb-gud-control-all-threads is nil, only the current thread is stopped/continued. ‘Go’ and ‘Stop’ buttons on the GUD tool bar are shown depending on the state of current thread.

You can change the current value of gdb-gud-control-all-threads from the tool bar or from ‘GUD->GDB-MI’ menu.

Stepping commands always apply to the current thread.

In non-stop mode, you can interrupt/continue your threads without selecting them. Hitting i in threads buffer interrupts thread under point, c continues it, s steps through. More such commands may be added in the future.

Note that when you interrupt a thread, it stops with the ‘signal received’ reason. If that reason is included in your gdb-switch-reasons (it is by default), Emacs will switch to that thread.


*** Executing Lisp Expressions

Emacs has major modes for several variants of Lisp. They use the same editing commands as other programming language modes (see Editing Programs). In addition, they provide special commands for executing Lisp expressions.

Emacs Lisp mode
The mode for editing Emacs Lisp source files. It defines C-M-x to evaluate the current top-level Lisp expression. See Evaluating Emacs Lisp Expressions.

Lisp Interaction mode
The mode for an interactive Emacs Lisp session. It defines C-j to evaluate the expression before point and insert its value in the buffer. See Lisp Interaction Buffers.

Lisp mode
The mode for editing source files of programs that run in Lisps other than Emacs Lisp. It defines C-M-x to evaluate the current top-level expression in an external Lisp. See Running an External Lisp.

Inferior Lisp mode
The mode for an interactive session with an external Lisp which is being run as a subprocess (or inferior process) of Emacs. See Running an External Lisp.

Scheme mode
Like Lisp mode, but for Scheme programs.

Inferior Scheme mode
Like Inferior Lisp mode, but for Scheme.


*** Libraries of Lisp Code for Emacs

Emacs Lisp code is stored in files whose names conventionally end in .el. Such files are automatically visited in Emacs Lisp mode.

Emacs Lisp code can be compiled into byte-code, which loads faster, takes up less space, and executes faster. By convention, compiled Emacs Lisp code goes in a separate file whose name ends in ‘.elc’. For example, the compiled code for foo.el goes in foo.elc. See Byte Compilation in the Emacs Lisp Reference Manual.

Emacs Lisp code can also be compiled into native code: machine code not unlike the one produced by a C or Fortran compiler. Native code runs even faster than byte-code. Natively-compiled Emacs Lisp code is stored in files whose names end in ‘.eln’. See Native Compilation in the Emacs Lisp Reference Manual.

To load an Emacs Lisp file, type M-x load-file. This command reads a file name using the minibuffer, and executes the contents of that file as Emacs Lisp code. It is not necessary to visit the file first; this command reads the file directly from disk, not from an existing Emacs buffer.

If an Emacs Lisp file is installed in the Emacs Lisp load path (defined below), you can load it by typing M-x load-library, instead of using M-x load-file. The M-x load-library command prompts for a library name rather than a file name; it searches through each directory in the Emacs Lisp load path, trying to find a file matching that library name. If the library name is ‘foo’, it tries looking for files named foo.elc, foo.el, and foo. (If Emacs was built with native compilation enabled, load-library looks for a ‘.eln’ file that corresponds to foo.el and loads it instead of foo.elc.) The default behavior is to load the first file found. This command prefers .eln files over .elc files, and prefers .elc files over .el files, because compiled files load and run faster. If it finds that lib.el is newer than lib.elc, it issues a warning, in case someone made changes to the .el file and forgot to recompile it, but loads the .elc file anyway. (Due to this behavior, you can save unfinished edits to Emacs Lisp source files, and not recompile until your changes are ready for use.) If you set the option load-prefer-newer to a non-nil value, however, then rather than the procedure described above, Emacs loads whichever version of the file is newest. If Emacs was built with native compilation, and it cannot find the ‘.eln’ file corresponding to lib.el, it will load a lib.elc and start native compilation of lib.el in the background, then load the ‘.eln’ file when it finishes compilation.

Emacs Lisp programs usually load Emacs Lisp files using the load function. This is similar to load-library, but is lower-level and accepts additional arguments. See How Programs Do Loading in the Emacs Lisp Reference Manual.

The Emacs Lisp load path is specified by the variable load-path. Its value should be a list of directories (strings). These directories are searched, in the specified order, by the M-x load-library command, the lower-level load function, and other Emacs functions that find Emacs Lisp libraries. An entry in load-path can also have the special value nil, which stands for the current default directory, but it is almost always a bad idea to use this, because its meaning will depend on the buffer that is current when load-path is used by Emacs. (If you find yourself wishing that nil were in the list, most likely what you really want is to use M-x load-file.)

The default value of load-path is a list of directories where the Lisp code for Emacs itself is stored. If you have libraries of your own in another directory, you can add that directory to the load path. Unlike most other variables described in this manual, load-path cannot be changed via the Customize interface (see Easy Customization Interface), but you can add a directory to it by putting a line like this in your init file (see The Emacs Initialization File):

(add-to-list 'load-path "/path/to/my/lisp/library")
It is customary to put locally installed libraries in the site-lisp directory that is already in the default value of load-path, or in some subdirectory of site-lisp. This way, you don’t need to modify the default value of load-path.

Similarly to load-path, the list of directories where Emacs looks for *.eln files with natively-compiled Lisp code is specified by the variable native-comp-eln-load-path.

Some commands are autoloaded; when you run them, Emacs automatically loads the associated library first. For instance, the M-x compile command (see Running Compilations under Emacs) is autoloaded; if you call it, Emacs automatically loads the compile library first. In contrast, the command M-x recompile is not autoloaded, so it is unavailable until you load the compile library.

Automatic loading can also occur when you look up the documentation of an autoloaded command (see Help by Command or Variable Name), if the documentation refers to other functions and variables in its library (loading the library lets Emacs properly set up the hyperlinks in the *Help* buffer). To disable this feature, change the variable help-enable-autoload to nil.

Automatic loading also occurs when completing names for describe-variable and describe-function, based on the prefix being completed. To disable this feature, change the variable help-enable-completion-autoload to nil.

Once you put your library in a directory where Emacs can find and load it, you may wish to make it available at startup. This is useful when the library defines features that should be available automatically on demand, and manually loading the library is thus inconvenient. In these cases, make sure the library will be loaded by adding suitable forms to your init file: either load or require (if you always need to load the library at startup), or autoload if you need Emacs to load the library when some command or function is invoked. For example:

 ;; Loads my-shining-package.elc unconditionally.
 (require 'my-shining-package)
 ;; Will load my-shining-package.elc when my-func is invoked.
 (autoload 'my-func "my-shining-package")
Note that installing a package using package-install (see Package Installation) takes care of placing the package’s Lisp files in a directory where Emacs will find it, and also writes the necessary initialization code into your init files, making the above manual customizations unnecessary.


*** Evaluating Emacs Lisp Expressions

Emacs Lisp mode is the major mode for editing Emacs Lisp. Its mode command is M-x emacs-lisp-mode.

Emacs provides several commands for evaluating Emacs Lisp expressions. You can use these commands in Emacs Lisp mode, to test your Emacs Lisp code as it is being written. For example, after re-writing a function, you can evaluate the function definition to make it take effect for subsequent function calls. These commands are also available globally, and can be used outside Emacs Lisp mode.

M-:
Read a single Emacs Lisp expression in the minibuffer, evaluate it, and print the value in the echo area (eval-expression).

C-x C-e
Evaluate the Emacs Lisp expression before point, and print the value in the echo area (eval-last-sexp).

C-M-x (in Emacs Lisp mode)
M-x eval-defun
Evaluate the defun containing or after point, and print the value in the echo area (eval-defun).

M-x eval-region
Evaluate all the Emacs Lisp expressions in the region.

M-x eval-buffer
Evaluate all the Emacs Lisp expressions in the buffer.

M-: (eval-expression) reads an expression using the minibuffer, and evaluates it. (Before evaluating the expression, the current buffer switches back to the buffer that was current when you typed M-:, not the minibuffer into which you typed the expression.)

The command C-x C-e (eval-last-sexp) evaluates the Emacs Lisp expression preceding point in the buffer, and displays the value in the echo area. When the result of an evaluation is an integer, it is displayed together with the value in other formats (octal, hexadecimal, and character if eval-expression-print-maximum-character, described below, allows it).

If M-: or C-x C-e is given a prefix argument, it inserts the value into the current buffer at point, rather than displaying it in the echo area. If the prefix argument is zero, any integer output is inserted together with its value in other formats (octal, hexadecimal, and character). Such a prefix argument also prevents abbreviation of the output according to the variables eval-expression-print-level and eval-expression-print-length (see below). Similarly, a prefix argument of -1 overrides the effect of eval-expression-print-length.

C-x C-e (eval-last-sexp) treats defvar expressions specially. Normally, evaluating a defvar expression does nothing if the variable it defines already has a value. But this command unconditionally resets the variable to the initial value specified by the defvar; this is convenient for debugging Emacs Lisp programs. defcustom and defface expressions are treated similarly. Note the other commands documented in this section, except eval-defun, do not have this special feature.

The eval-defun command is bound to C-M-x in Emacs Lisp mode. It evaluates the top-level Lisp expression containing or following point, and prints the value in the echo area. In this context, a top-level expression is referred to as a “defun”, but it need not be an actual defun (function definition).

This command handles defvar/defcustom/defface forms the same way that eval-last-sexp does.

With a prefix argument, C-M-x instruments the function definition for Edebug, the Emacs Lisp Debugger. See Instrumenting for Edebug in the Emacs Lisp Reference Manual.

The command M-x eval-region parses the text of the region as one or more Lisp expressions, evaluating them one by one. M-x eval-buffer is similar but evaluates the entire buffer.

The options eval-expression-print-level and eval-expression-print-length control the maximum depth and length of lists to print in the result of the evaluation commands before abbreviating them. Supplying a zero prefix argument to eval-expression or eval-last-sexp causes lists to be printed in full. eval-expression-debug-on-error controls whether evaluation errors invoke the debugger when these commands are used; its default is t. eval-expression-print-maximum-character prevents integers which are larger than it from being displayed as characters.


*** Lisp Interaction Buffers

When Emacs starts up, it contains a buffer named *scratch*, which is provided for evaluating Emacs Lisp expressions interactively. Its major mode is Lisp Interaction mode. You can also enable Lisp Interaction mode by typing M-x lisp-interaction-mode.

If you kill the *scratch* buffer, you can recreate it with the M-x scratch-buffer command.

In the *scratch* buffer, and other Lisp Interaction mode buffers, C-j (eval-print-last-sexp) evaluates the Lisp expression before point, and inserts the value at point. Thus, as you type expressions into the buffer followed by C-j after each expression, the buffer records a transcript of the evaluated expressions and their values. All other commands in Lisp Interaction mode are the same as in Emacs Lisp mode.

At startup, the *scratch* buffer contains a short message, in the form of a Lisp comment, that explains what it is for. This message is controlled by the variable initial-scratch-message, which should be either a documentation string, or nil (which means to suppress the message).

An alternative way of evaluating Emacs Lisp expressions interactively is to use Inferior Emacs Lisp mode, which provides an interface rather like Shell mode (see Shell Mode) for evaluating Emacs Lisp expressions. Type M-x ielm to create an *ielm* buffer which uses this mode. For more information, see that command’s documentation.


*** Running an External Lisp

Lisp mode is the major mode for editing programs written in general-purpose Lisp dialects, such as Common Lisp. Its mode command is M-x lisp-mode. Emacs uses Lisp mode automatically for files whose names end in .l, .lsp, or .lisp.

You can run an external Lisp session as a subprocess or inferior process of Emacs, and pass expressions to it to be evaluated. To begin an external Lisp session, type M-x run-lisp. This runs the program named lisp, and sets it up so that both input and output go through an Emacs buffer named *inferior-lisp*. To change the name of the Lisp program run by M-x run-lisp, change the variable inferior-lisp-program.

The major mode for the *lisp* buffer is Inferior Lisp mode, which combines the characteristics of Lisp mode and Shell mode (see Shell Mode). To send input to the Lisp session, go to the end of the *lisp* buffer and type the input, followed by RET. Terminal output from the Lisp session is automatically inserted in the buffer.

When you edit a Lisp program in Lisp mode, you can type C-M-x (lisp-eval-defun) to send an expression from the Lisp mode buffer to a Lisp session that you had started with M-x run-lisp. The expression sent is the top-level Lisp expression at or following point. The resulting value goes as usual into the *inferior-lisp* buffer. Note that the effect of C-M-x in Lisp mode is thus very similar to its effect in Emacs Lisp mode (see Evaluating Emacs Lisp Expressions), except that the expression is sent to a different Lisp environment instead of being evaluated in Emacs.

The facilities for editing Scheme code, and for sending expressions to a Scheme subprocess, are very similar. Scheme source files are edited in Scheme mode, which can be explicitly enabled with M-x scheme-mode. You can initiate a Scheme session by typing M-x run-scheme (the buffer for interacting with Scheme is named *scheme*), and send expressions to it by typing C-M-x.



** Maintaining Large Programs

This chapter describes Emacs features for maintaining medium- to large-size programs and packages. These features include:

Unified interface to Support for Version Control Systems (VCS) that record the history of changes to source files.
Commands for handling programming projects.
A specialized mode for maintaining ChangeLog files that provide a chronological log of program changes.
Xref, a set of commands for displaying definitions of symbols (a.k.a. “identifiers”) and their references.
EDE, the Emacs’s own IDE.
A mode for merging changes to program sources made on separate branches of development.
A minor-mode for highlighting bug references and visiting the referenced bug reports in their issue tracker.
If you are maintaining a large Lisp program, then in addition to the features described here, you may find the Emacs Lisp Regression Testing (ERT) library useful (see ERT in Emacs Lisp Regression Testing).

*** Version Control

A version control system is a program that can record multiple versions of a source file, storing information such as the creation time of each version, who made it, and a description of what was changed.

The Emacs version control interface is called VC. VC commands work with several different version control systems; currently, it supports Bazaar, CVS, Git, Mercurial, Monotone, RCS, SRC, SCCS/CSSC, and Subversion. Of these, the GNU project distributes CVS, RCS, and Bazaar.

VC is enabled automatically whenever you visit a file governed by a version control system. To disable VC entirely, set the customizable variable vc-handled-backends to nil (see Customizing VC).

To update the VC state information for the file visited in the current buffer, use the command vc-refresh-state. This command is useful when you perform version control commands outside Emacs (e.g., from the shell prompt), or if you put the buffer’s file under a different version control system, or remove it from version control entirely.

VC is also enabled automatically in Dired buffers (see Dired, the Directory Editor) showing directories whose files are controlled by a VCS. All VC commands described in this section can be invoked from any Dired buffer showing a directory with VC-controlled files; any files that are marked in a Dired buffer (see Dired Marks vs. Flags) are considered to belong to the current fileset, and VC commands operate on the files in this fileset. This allows you to construct VC filesets including any files you want, regardless of their VC state. (If no files are marked when a VC command is invoked from a Dired buffer, the file shown on the current line in the buffer is considered the only file in the fileset.)


**** Introduction to Version Control

VC allows you to use a version control system from within Emacs, integrating the version control operations smoothly with editing. It provides a uniform interface for common operations in many version control operations.

Some uncommon or intricate version control operations, such as altering repository settings, are not supported in VC. You should perform such tasks outside VC, e.g., via the command line.

This section provides a general overview of version control, and describes the version control systems that VC supports. You can skip this section if you are already familiar with the version control system you want to use.


***** Understanding the Problems it Addresses

Version control systems provide you with three important capabilities:

Reversibility: the ability to back up to a previous state if you discover that some modification you did was a mistake or a bad idea.
Concurrency: the ability to have many people modifying the same collection of files knowing that conflicting modifications can be detected and resolved.
History: the ability to attach historical data to your data, such as explanatory comments about the intention behind each change. Even for a programmer working solo, change histories are an important aid to memory; for a multi-person project, they are a vitally important form of communication among developers.


***** Supported Version Control Systems

VC currently works with many different version control systems, which it refers to as back ends:

Git is a decentralized version control system originally invented by Linus Torvalds to support development of Linux (his kernel). VC supports many common Git operations, but others, such as repository syncing, must be done from the command line.
CVS is the free version control system that was, until circa 2008, used by the majority of free software projects. Since then, it has been superseded by newer systems. CVS allows concurrent multi-user development either locally or over the network. Unlike newer systems, it lacks support for atomic commits and file moving/renaming. VC supports all basic editing operations under CVS.
Subversion (svn) is a free version control system designed to be similar to CVS but without its problems (e.g., it supports atomic commits of filesets, and versioning of directories, symbolic links, meta-data, renames, copies, and deletes).
SCCS was the first version control system ever built, and was long ago superseded by more advanced ones. VC compensates for certain features missing in SCCS (e.g., tag names for releases) by implementing them itself. Other VC features, such as multiple branches, are simply unavailable. Since SCCS is non-free, we recommend avoiding it.
CSSC is a free replacement for SCCS. You should use CSSC only if, for some reason, you cannot use a more recent and better-designed version control system.
RCS is the free version control system around which VC was initially built. It is relatively primitive: it cannot be used over the network, and works at the level of individual files. Almost everything you can do with RCS can be done through VC.
Mercurial (hg) is a decentralized version control system broadly resembling Git. VC supports most Mercurial commands, with the exception of repository sync operations.
Bazaar (bzr) is a decentralized version control system that supports both repository-based and decentralized versioning. VC supports most basic editing operations under Bazaar.
SRC (src) is RCS, reloaded—a specialized version-control system designed for single-file projects worked on by only one person. It allows multiple files with independent version-control histories to exist in one directory, and is thus particularly well suited for maintaining small documents, scripts, and dotfiles. While it uses RCS for revision storage, it presents a modern user interface featuring lockless operation and integer sequential version numbers. VC supports almost all SRC operations.


***** Concepts of Version Control

When a file is under version control, we say that it is registered in the version control system. The system has a repository which stores both the file’s present state and its change history—enough to reconstruct the current version or any earlier version. The repository also contains other information, such as log entries that describe the changes made to each file.

The copy of a version-controlled file that you actually edit is called the work file. You can change each work file as you would an ordinary file. After you are done with a set of changes, you may commit (or check in) the changes; this records the changes in the repository, along with a descriptive log entry.

A directory tree of work files is called a working tree.

Each commit creates a new revision in the repository. The version control system keeps track of all past revisions and the changes that were made in each revision. Each revision is named by a revision ID, whose format depends on the version control system; in the simplest case, it is just an integer.

To go beyond these basic concepts, you will need to understand three aspects in which version control systems differ. As explained in the next three sections, they can be lock-based or merge-based; file-based or changeset-based; and centralized or decentralized. VC handles all these modes of operation, but it cannot hide the differences.


***** Merge-based vs Lock-based Version Control

A version control system typically has some mechanism to coordinate between users who want to change the same file. There are two ways to do this: merging and locking.

In a version control system that uses merging, each user may modify a work file at any time. The system lets you merge your work file, which may contain changes that have not been committed, with the latest changes that others have committed.

Older version control systems use a locking scheme instead. Here, work files are normally read-only. To edit a file, you ask the version control system to make it writable for you by locking it; only one user can lock a given file at any given time. This procedure is analogous to, but different from, the locking that Emacs uses to detect simultaneous editing of ordinary files (see Protection against Simultaneous Editing). When you commit your changes, that unlocks the file, and the work file becomes read-only again. Other users may then lock the file to make their own changes.

Both locking and merging systems can have problems when multiple users try to modify the same file at the same time. Locking systems have lock conflicts; a user may try to check a file out and be unable to because it is locked. In merging systems, merge conflicts happen when you commit a change to a file that conflicts with a change committed by someone else after your checkout. Both kinds of conflict have to be resolved by human judgment and communication. Experience has shown that merging is superior to locking, both in convenience to developers and in minimizing the number and severity of conflicts that actually occur.

SCCS always uses locking. RCS is lock-based by default but can be told to operate in a merging style. CVS and Subversion are merge-based by default but can be told to operate in a locking mode. Decentralized version control systems, such as Git and Mercurial, are exclusively merging-based.

VC mode supports both locking and merging version control. The terms “commit” and “update” are used in newer version control systems; older lock-based systems use the terms “check in” and “check out”. VC hides the differences between them as much as possible.


***** Changeset-based vs File-based Version Control

On SCCS, RCS, CVS, and other early version control systems (and also in SRC), version control operations are file-based: each file has its own comment and revision history separate from that of all other files. Newer systems, beginning with Subversion, are changeset-based: a commit may include changes to several files, and the entire set of changes is handled as a unit. Any comment associated with the change does not belong to a single file, but to the changeset itself.

Changeset-based version control is more flexible and powerful than file-based version control; usually, when a change to multiple files has to be reversed, it’s good to be able to easily identify and remove all of it.


***** Decentralized vs Centralized Repositories

Early version control systems were designed around a centralized model in which each project has only one repository used by all developers. SCCS, RCS, CVS, Subversion, and SRC share this kind of model. One of its drawbacks is that the repository is a choke point for reliability and efficiency.

GNU Arch pioneered the concept of distributed or decentralized version control, later implemented in Git, Mercurial, and Bazaar. A project may have several different repositories, and these systems support a sort of super-merge between repositories that tries to reconcile their change histories. In effect, there is one repository for each developer, and repository merges take the place of commit operations.

VC helps you manage the traffic between your personal workfiles and a repository. Whether the repository is a single master, or one of a network of peer repositories, is not something VC has to care about.


***** Types of Log File

Projects that use a version control system can have two types of log for changes. One is the log maintained by the version control system: each time you commit a change, you fill out a log entry for the change (see Features of the Log Entry Buffer). This is called the version control log.

The other kind of log is the file ChangeLog (see Change Logs). It provides a chronological record of all changes to a large portion of a program—typically one directory and its subdirectories. A small program would use one ChangeLog file; a large program may have a ChangeLog file in each major directory. See Change Logs. Programmers have used change logs since long before version control systems.

Changeset-based version systems typically maintain a changeset-based modification log for the entire system, which makes change log files somewhat redundant. One advantage that they retain is that it is sometimes useful to be able to view the transaction history of a single directory separately from those of other directories. Another advantage is that commit logs can’t be fixed in many version control systems.

A project maintained with version control can use just the version control log, or it can use both kinds of logs. It can handle some files one way and some files the other way. Each project has its policy, which you should follow.

When the policy is to use both, you typically want to write an entry for each change just once, then put it into both logs. You can write the entry in ChangeLog, then copy it to the log buffer with C-c C-a when committing the change (see Features of the Log Entry Buffer). Or you can write the entry in the log buffer while committing the change (with the help of C-c C-w), and later use the C-x v a command to copy it to ChangeLog (see Change Logs and VC).


**** Version Control and the Mode Line

When you visit a file that is under version control, Emacs indicates this on the mode line. For example, ‘Bzr-1223’ says that Bazaar is used for that file, and the current revision ID is 1223.

The character between the back-end name and the revision ID indicates the version control status of the work file. In a merge-based version control system, a ‘-’ character indicates that the work file is unmodified, and ‘:’ indicates that it has been modified. ‘!’ indicates that the file contains conflicts as result of a recent merge operation (see Merging Branches), or that the file was removed from the version control. Finally, ‘?’ means that the file is under version control, but is missing from the working tree.

In a lock-based system, ‘-’ indicates an unlocked file, and ‘:’ a locked file; if the file is locked by another user (for instance, ‘jim’), that is displayed as ‘RCS:jim:1.3’. ‘@’ means that the file was locally added, but not yet committed to the master repository.

On a graphical display, you can move the mouse over this mode line indicator to pop up a tool-tip, which displays a more verbose description of the version control status. Pressing mouse-1 over the indicator pops up a menu of VC commands, identical to ‘Tools / Version Control’ on the menu bar.

When Auto Revert mode (see Reverting a Buffer) reverts a buffer that is under version control, it updates the version control information in the mode line. However, Auto Revert mode may not properly update this information if the version control status changes without changes to the work file, from outside the current Emacs session. If you set auto-revert-check-vc-info to t, Auto Revert mode updates the version control status information every auto-revert-interval seconds, even if the work file itself is unchanged. The resulting CPU usage depends on the version control system, but is usually not excessive.


**** Basic Editing under Version Control

Most VC commands operate on VC filesets. A VC fileset is a collection of one or more files that a VC operation acts upon. When you type VC commands in a buffer visiting a version-controlled file, the VC fileset is simply that one file. When you type them in a VC Directory buffer, and some files in it are marked, the VC fileset consists of the marked files (see VC Directory Mode). Likewise, when you invoke a VC command from a Dired buffer, the VC fileset consists of the marked files (see Dired Marks vs. Flags), defaulting to the file shown on the current line if no files are marked.

With modern changeset-based version control systems (see Changeset-based vs File-based Version Control), such as Git, Mercurial, and Bazaar, VC commands handle multi-file VC filesets as a group. For example, committing a multi-file VC fileset generates a single revision, containing the changes to all those files. On older file-based version control systems like CVS, each file in a multi-file VC fileset is handled individually; thus, committing a fileset generates one revision for each changed file in the fileset.

C-x v v
Perform the next appropriate version control operation on the current VC fileset.

The principal VC command is a multi-purpose command, C-x v v (vc-next-action), which performs the most appropriate action on the current VC fileset: either registering it with a version control system, or committing it, or unlocking it, or merging changes into it. The precise actions for each situation are described in detail in the following subsections. You can use C-x v v either in a file-visiting buffer, in a Dired buffer, or in a VC Directory buffer; in the latter two cases the command operates on the fileset consisting of the marked files. You can also use C-x v v, in a buffer with patches under Diff Mode (see Diff Mode), in which case the command operates on the files whose diffs are shown in the buffer.

Note that VC filesets are distinct from the named filesets used for viewing and visiting files in functional groups (see Filesets). Unlike named filesets, VC filesets are not named and don’t persist across sessions.


***** Basic Version Control with Merging

With a modern merging-based version control system (such as Git and Hg; see Merge-based vs Lock-based Version Control), C-x v v does the following when invoked from a buffer that visits a version-controlled file or a VC Directory or Dired buffer:

If there is more than one file in the VC fileset and the files have inconsistent version control statuses, signal an error. (Note, however, that a fileset is allowed to include both newly-added files and modified files; see Registering a File for Version Control.) Also signal an error if the files in the fileset are missing (removed from the filesystem, but still tracked by version control), or are ignored by version control.
If every file in the VC fileset is registered and unchanged with respect to the last revision, do nothing.
If none of the files in the VC fileset are registered with a version control system, register the newly-added files in the VC fileset, i.e., place them under version control. See Registering a File for Version Control. If Emacs cannot find a system to register under, it prompts for a repository type, creates a new repository, and registers the VC fileset with it. You can also specify the system explicitly, see Advanced Control in C-x v v. Note that registering the files doesn’t commit them; you must invoke C-x v v again to commit, see below.
If every file in the VC fileset has been either newly-added or modified, commit the changed files. To do this, Emacs pops up a *vc-log* buffer; type the desired log entry for the changes, followed by C-c C-c to commit. See Features of the Log Entry Buffer.
With modern decentralized version control systems (Git, Mercurial, etc.), the changes are committed locally and not automatically propagated to the upstream repository (which is usually on a remote host). In these cases, if the repository has been changed since your last update, the commit may fail. In that case, you must update from upstream and then try again. Use C-x v + (see Pulling/Pushing Changes into/from a Branch) or C-x v m (see Merging Branches) for that.

With a centralized version control system, if the commit fails due to upstream changes, type C-x v v again to merge in the upstream repository changes.

Finally, if you are using a centralized version control system, if any file in the VC fileset is outdated with respect to the upstream repository, offer to update the fileset from the repository.
These rules also apply when you use RCS in its non-locking mode, except that changes are not automatically merged from the repository. Nothing informs you if another user has committed changes in the same file since you began editing it; when you commit your revision, that other user’s changes are removed (however, they remain in the repository and are thus not irrevocably lost). Therefore, you must verify that the current revision is unchanged before committing your changes. In addition, locking is possible with RCS even in this mode: C-x v v with an unmodified file locks the file, just as it does with RCS in its normal locking mode (see Basic Version Control with Locking).

If C-x v v is invoked from a buffer under Diff Mode, the command assumes the buffer holds a set of patches for one or more files. It then applies the changes to the respective files and commits the changes after popping up the *vc-log* buffer to allow you to type a suitable commit log message.


***** Basic Version Control with Locking

With a locking-based version control system (such as SCCS, and RCS in its default mode), C-x v v does the following:

If there is more than one file in the VC fileset and the files have inconsistent version control statuses, signal an error. Also signal an error if the files in the fileset are missing (removed from the filesystem, but still tracked by version control).
If each file in the VC fileset is not registered with a version control system, register the newly-added files in the fileset. See Registering a File for Version Control. If Emacs cannot find a system to register under, it prompts for a repository type, creates a new repository, and registers the VC fileset with it. You can also specify the system explicitly, see Advanced Control in C-x v v.
If each file is registered and unlocked, check the files out: lock each one and make it writable, so that you can begin to edit it.
If each file is locked by you and contains changes, commit (a.k.a. “check-in”) the changes. To do this, Emacs pops up a *vc-log* buffer; type the desired log entry for the new revision, followed by C-c C-c to commit (see Features of the Log Entry Buffer).
If each file is locked by you, but you have not changed it, release the lock and make the file read-only again. This undoes previous check-out operation for files that were not changed since the checkout.
If each file is locked by another user, ask whether you want to steal the lock. If you say yes, the file becomes locked by you, and a warning message is sent to the user who had formerly locked the file.
If files in the fileset are unlocked, but have changes with respect to their last revision, offer to claim the lock for each such file or to revert the file to the last checked-in revision. (This situation is exceptional and should not normally happen.)
These rules also apply when you use CVS in locking mode, except that CVS does not support stealing locks.


***** Previous: Basic Version Control with Locking, Up: Basic Editing under Version Control   [Contents][Index]

29.1.3.3 Advanced Control in C-x v v
When you give a prefix argument to vc-next-action (C-u C-x v v), it still performs the next logical version control operation, but accepts additional arguments to specify precisely how to do the operation.

You can specify the name of a version control system. This is useful if the fileset can be managed by more than one version control system, and Emacs fails to detect the correct one.
Otherwise, if using CVS, RCS or SRC, you can specify a revision ID.
If the fileset is modified (or locked), this makes Emacs commit the files with that revision ID. You can create a new branch by supplying an appropriate revision ID (see Version Control Branches).

If the fileset is unmodified (and unlocked), this checks out the specified revision into the working tree. You can also specify a revision on another branch by giving its revision or branch ID (see Switching between Branches). An empty argument (i.e., C-u C-x v v RET) checks out the latest (a.k.a. “head”) revision on the current branch.

Specifying revision ID in this manner is silently ignored by a decentralized version control system. Those systems do not let you specify your own revision IDs, nor do they use the concept of checking out individual files.


**** Features of the Log Entry Buffer

When you tell VC to commit a change, it pops up a buffer named *vc-log*. In this buffer, you should write a log entry describing the changes you have made (see Understanding the Problems it Addresses). After you are done, type C-c C-c (log-edit-done) to exit the buffer and commit the change, together with your log entry.

The major mode for the *vc-log* buffer is Log Edit mode, a variant of Text mode (see Text Mode). On entering Log Edit mode, Emacs runs the hooks text-mode-hook and vc-log-mode-hook (see Hooks).

In the *vc-log* buffer, you can write one or more header lines, specifying additional information to be supplied to the version control system. Each header line must occupy a single line at the top of the buffer; the first line that is not a header line is treated as the start of the log entry. For example, the following header line states that the present change was not written by you, but by another developer:

Author: J. R. Hacker <jrh@example.com>
Apart from the ‘Author’ header, Emacs recognizes the headers ‘Summary’ (a one-line summary of the changeset), ‘Date’ (a manually-specified commit time), and ‘Fixes’ (a reference to a bug fixed by the change). Not all version control systems recognize all headers. If you specify a header for a system that does not support it, the header is treated as part of the log entry.

While in the *vc-log* buffer, the current VC fileset is considered to be the fileset that will be committed if you type C-c C-c. To view a list of the files in the VC fileset, type C-c C-f (log-edit-show-files). To view a diff of changes between the VC fileset and the version from which you started editing (see Examining And Comparing Old Revisions), type C-c C-d (log-edit-show-diff).

To help generate ChangeLog entries, type C-c C-w (log-edit-generate-changelog-from-diff), to generate skeleton ChangeLog entries, listing all changed file and function names based on the diff of the VC fileset. Consecutive entries left empty will be combined by M-q (fill-paragraph). By default the skeleton will just include the file name, without any leading directories. If you wish to prepend the leading directories up to the VC root, customize diff-add-log-use-relative-names.

If the VC fileset includes one or more ChangeLog files (see Change Logs), type C-c C-a (log-edit-insert-changelog) to pull the relevant entries into the *vc-log* buffer. If the topmost item in each ChangeLog was made under your user name on the current date, this command searches that item for entries matching the file(s) to be committed, and inserts them. If you are using CVS or RCS, see Change Logs and VC, for the opposite way of working—generating ChangeLog entries from the Log Edit buffer.

To abort a commit, just don’t type C-c C-c in that buffer. You can switch buffers and do other editing. As long as you don’t try to make another commit, the entry you were editing remains in the *vc-log* buffer, and you can go back to that buffer at any time to complete the commit.

You can also browse the history of previous log entries to duplicate a commit comment. This can be useful when you want to make several commits with similar comments. The commands M-n, M-p, M-s and M-r for doing this work just like the minibuffer history commands (see Minibuffer History), except that they are used outside the minibuffer.


**** Examining And Comparing Old Revisions

C-x v =
Compare the work files in the current VC fileset with the versions you started from (vc-diff). With a prefix argument, prompt for two revisions of the current VC fileset and compare them. You can also call this command from a Dired buffer (see Dired, the Directory Editor).

M-x vc-ediff
Like C-x v =, but using Ediff. See Ediff in The Ediff Manual.

C-x v D
Compare the entire working tree to the revision you started from (vc-root-diff). With a prefix argument, prompt for two revisions and compare their trees.

C-x v ~
Prompt for a revision of the current file, and visit it in a separate buffer (vc-revision-other-window).

C-x v g
Display an annotated version of the current file: for each line, show the latest revision in which it was modified (vc-annotate).

C-x v = (vc-diff) displays a diff which compares each work file in the current VC fileset to the version(s) from which you started editing. The diff is displayed in another window, in a Diff mode buffer (see Diff Mode) named *vc-diff*. The usual Diff mode commands are available in this buffer. In particular, the g (revert-buffer) command performs the file comparison again, generating a new diff.

To compare two arbitrary revisions of the current VC fileset, call vc-diff with a prefix argument: C-u C-x v =. This prompts for two revision IDs (see Concepts of Version Control), and displays a diff between those versions of the fileset. This will not work reliably for multi-file VC filesets, if the version control system is file-based rather than changeset-based (e.g., CVS), since then revision IDs for different files would not be related in any meaningful way.

Instead of the revision ID, some version control systems let you specify revisions in other formats. For instance, under Bazaar you can enter ‘date:yesterday’ for the argument to C-u C-x v = (and related commands) to specify the first revision committed after yesterday. See the documentation of the version control system for details.

If you invoke C-x v = or C-u C-x v = from a Dired buffer (see Dired, the Directory Editor), the file listed on the current line is treated as the current VC fileset. The VC fileset can also include several marked files.

M-x vc-ediff works like C-x v =, except that it uses an Ediff session. See Ediff in The Ediff Manual.

C-x v D (vc-root-diff) is similar to C-x v =, but it displays the changes in the entire current working tree (i.e., the working tree containing the current VC fileset). If you invoke this command from a Dired buffer, it applies to the working tree containing the directory.

To compare two arbitrary revisions of the whole trees, call vc-root-diff with a prefix argument: C-u C-x v D. This prompts for two revision IDs (see Concepts of Version Control), and displays a diff between those versions of the entire version-controlled directory trees (RCS, SCCS, CVS, and SRC do not support this feature).

You can customize the diff options that C-x v = and C-x v D use for generating diffs. The options used are taken from the first non-nil value amongst the variables vc-backend-diff-switches, vc-diff-switches, and diff-switches (see Comparing Files), in that order. Here, backend stands for the relevant version control system, e.g., bzr for Bazaar. Since nil means to check the next variable in the sequence, either of the first two may use the value t to mean no switches at all. Most of the vc-backend-diff-switches variables default to nil, but some default to t; these are for version control systems whose diff implementations do not accept common diff options, such as Subversion.

To directly examine an older version of a file, visit the work file and type C-x v ~ revision RET (vc-revision-other-window). This retrieves the file version corresponding to revision, saves it to filename.~revision~, and visits it in a separate window.

Many version control systems allow you to view files annotated with per-line revision information, by typing C-x v g (vc-annotate). This creates a new “annotate” buffer displaying the file’s text, with each line colored to show how old it is. Red text is new, blue is old, and intermediate colors indicate intermediate ages. By default, the color is scaled over the full range of ages, such that the oldest changes are blue, and the newest changes are red. If the variable vc-annotate-background-mode is non-nil, the colors expressing the age of each line are applied to the background color, leaving the foreground at its default color.

You can customize the annotate options that C-x v g uses by customizing vc-backend-annotate-switches and vc-annotate-switches. They function similarly to vc-backend-diff-switches and vc-diff-switches, described above.

When you give a prefix argument to C-x v g, Emacs reads two arguments using the minibuffer: the revision to display and annotate (instead of the current file contents), and the time span in days the color range should cover.

From the “annotate” buffer, these and other color scaling options are available from the ‘VC-Annotate’ menu. In this buffer, you can also use the following keys to browse the annotations of past revisions, view diffs, or view log entries:

p
Annotate the previous revision, i.e., the revision before the one currently annotated. A numeric prefix argument is a repeat count, so C-u 10 p would take you back 10 revisions.

n
Annotate the next revision, i.e., the revision after the one currently annotated. A numeric prefix argument is a repeat count.

j
Annotate the revision indicated by the current line.

a
Annotate the revision before the one indicated by the current line. This is useful to see the state the file was in before the change on the current line was made.

f
Show in a buffer the file revision indicated by the current line.

d
Display the diff between the current line’s revision and the previous revision. This is useful to see what the current line’s revision actually changed in the file.

D
Display the diff between the current line’s revision and the previous revision for all files in the changeset (for VC systems that support changesets). This is useful to see what the current line’s revision actually changed in the tree.

l
Show the log of the current line’s revision. This is useful to see the author’s description of the changes in the revision on the current line.

w
Annotate the working revision—the one you are editing. If you used p and n to browse to other revisions, use this key to return to your working revision.

v
Toggle the annotation visibility. This is useful for looking just at the file contents without distraction from the annotations.


**** VC Change Log

C-x v l
Display the change history for the current fileset (vc-print-log).

C-x v L
Display the change history for the current repository (vc-print-root-log).

C-x v b l
Display the change history for another branch (vc-print-branch-log).

C-x v I
Display the changes that a “pull” operation will retrieve (vc-log-incoming).

C-x v O
Display the changes that will be sent by the next “push” operation (vc-log-outgoing).

C-x v h
Display the history of changes made in the region of file visited by the current buffer (vc-region-history).

M-x vc-log-search RET
Search the change history for a specified pattern.

C-x v l (vc-print-log) displays a buffer named *vc-change-log*, showing the history of changes made to the current fileset in the long form, including who made the changes, the dates, and the log entry for each change (these are the same log entries you would enter via the *vc-log* buffer; see Features of the Log Entry Buffer). When invoked from a buffer visiting a file, the current fileset consists of that single file, and point in the displayed *vc-change-log* buffer is centered at the revision of that file. When invoked from a VC Directory buffer (see VC Directory Mode) or from a Dired buffer (see Dired, the Directory Editor), the fileset consists of all the marked files, defaulting to the file shown on the current line in the directory buffer if no file is marked.

If the fileset includes one or more directories, the resulting *vc-change-log* buffer shows a short log of changes (one line for each change), if the VC backend supports that; otherwise it shows the log in the long form.

With a prefix argument, the command prompts for the revision to center on in the *vc-change-log* buffer and for the maximum number of revisions to display.

C-x v L (vc-print-root-log) displays a *vc-change-log* buffer showing the history of the entire version-controlled directory tree (RCS, SCCS, CVS, and SRC do not support this feature). With a prefix argument, the command prompts for the maximum number of revisions to display. A numeric prefix argument specifies the maximum number of revisions without prompting. When the numeric prefix argument is 1, as in C-1 C-x v L or C-u 1 C-x v L, the command prompts for the revision ID, and displays the log entry of that revision together with the changes (diffs) it introduced. (Some less capable version control systems, such as RCS and CVS, don’t have commands to show a revision log with its diffs; for them the command displays only the log entry, and you can request to show the diffs by typing d or D, see below.)

The C-x v L history is shown in a compact form, usually showing only the first line of each log entry. However, you can type RET (log-view-toggle-entry-display) in the *vc-change-log* buffer to reveal the entire log entry for the revision at point. A second RET hides it again.

C-x v b l branch-name RET (vc-print-branch-log) displays a *vc-change-log* buffer showing the history of the version-controlled directory tree, like vc-print-root-log does, but it shows the history of a branch other than the current one; it prompts for the branch whose history to display.

On a decentralized version control system, the C-x v I (vc-log-incoming) command displays a log buffer showing the changes that will be applied, the next time you run the version control system’s pull command to get new revisions from another remote location (see Pulling/Pushing Changes into/from a Branch). This other remote location is the default one from which changes are pulled, as defined by the version control system; with a prefix argument, vc-log-incoming prompts for a specific remote location. Similarly, C-x v O (vc-log-outgoing) shows the changes that will be sent to another remote location, the next time you run the push command; with a prefix argument, it prompts for a specific destination that in case of some version control system can be a branch name.

In the *vc-change-log* buffer, you can use the following keys to move between the logs of revisions and of files, and to examine and compare past revisions (see Examining And Comparing Old Revisions):

p
Move to the previous revision entry. (Revision entries in the log buffer are usually in reverse-chronological order, so the previous revision-item usually corresponds to a newer revision.) A numeric prefix argument is a repeat count.

n
Move to the next revision entry. A numeric prefix argument is a repeat count.

a
Annotate the revision on the current line (see Examining And Comparing Old Revisions).

e
Modify the change comment displayed at point. Note that not all VC systems support modifying change comments.

f
Visit the revision indicated at the current line.

d
Display a diff between the revision at point and the next earlier revision, for the specific file.

D
Display the changeset diff between the revision at point and the next earlier revision. This shows the changes to all files made in that revision.

RET
In a compact-style log buffer (e.g., the one created by C-x v L), toggle between showing and hiding the full log entry for the revision at point.

Because fetching many log entries can be slow, the *vc-change-log* buffer displays no more than 2000 revisions by default. The variable vc-log-show-limit specifies this limit; if you set the value to zero, that removes the limit. You can also increase the number of revisions shown in an existing *vc-change-log* buffer by clicking on the ‘Show 2X entries’ or ‘Show unlimited entries’ buttons at the end of the buffer. However, RCS, SCCS, CVS, and SRC do not support this feature.

A useful variant of examining history of changes is provided by the command vc-region-history (by default bound to C-x v h), which shows a *VC-history* buffer with the history of changes made in the region of the current buffer’s file between point and the mark (see The Mark and the Region). The history of changes includes the commit log messages and also the changes themselves in the Diff format.

Invoke this command after marking in the current buffer the region in whose changes you are interested. In the *VC-history* buffer it pops up, you can use all of the commands available in the *vc-change-log* buffer described above, and also the commands defined by Diff mode (see Diff Mode).

This command is currently available only with Git and Mercurial (hg).

The command vc-log-search allows searching for a pattern in the log of changes. It prompts for a pattern (a regular expression), and displays all entries in the change history whose log messages match the pattern. When invoked with a prefix argument, the command will also prompt for a specific VCS shell command to run for this purpose.


**** Undoing Version Control Actions

C-x v u
Revert the work file(s) in the current VC fileset to the last revision (vc-revert).

If you want to discard all the changes you have made to the current VC fileset, type C-x v u (vc-revert). This will ask you for confirmation before discarding the changes. If you agree, the fileset is reverted.

If vc-revert-show-diff is non-nil, this command will show you a diff between the work file(s) and the revision from which you started editing. Afterwards, the diff buffer will either be killed (if this variable is kill), or the buffer will be buried (any other non-nil value). If you don’t want C-x v u to show a diff, set this variable to nil (you can still view the diff directly with C-x v =; see Examining And Comparing Old Revisions).

On locking-based version control systems, C-x v u leaves files unlocked; you must lock again to resume editing. You can also use C-x v u to unlock a file if you lock it and then decide not to change it.


**** Ignore Version Control Files

C-x v G
Ignore a file under current version control system. (vc-ignore).

Many source trees contain some files that do not need to be versioned, such as editor backups, object or bytecode files, and built programs. You can simply not add them, but then they’ll always crop up as unknown files. You can also tell the version control system to ignore these files by adding them to the ignore file at the top of the tree. C-x v G (vc-ignore) can help you do this. When called with a prefix argument, you can remove a file from the ignored file list.


**** VC Directory Mode

The VC Directory buffer is a specialized buffer for viewing the version control statuses of the files in a directory tree, and performing version control operations on those files. In particular, it is used to specify multi-file VC filesets for commands like C-x v v to act on (see VC Directory Commands).

To use the VC Directory buffer, type C-x v d (vc-dir). This reads a directory’s name using the minibuffer, and switches to a VC Directory buffer for that directory. By default, the buffer is named *vc-dir*. Its contents are described in The VC Directory Buffer.

The vc-dir command automatically detects the version control system to be used in the specified directory. In the event that more than one system is being used in the directory, you should invoke the command with a prefix argument, C-u C-x v d; this prompts for the version control system which the VC Directory buffer should use.

In addition to the VC Directory buffer, Emacs has a similar facility called PCL-CVS which is specialized for CVS. See About PCL-CVS in PCL-CVS—The Emacs Front-End to CVS.

You can also invoke VC commands from Dired buffers (see Dired, the Directory Editor). In that case, any VC command you invoke considers the marked files as the current fileset (see Basic Editing under Version Control), defaulting to the file on the current line if no files are marked.

***** The VC Directory Buffer

The VC Directory buffer contains a list of version-controlled files and their version control statuses. It lists files in the current directory (the one specified when you called C-x v d) and its subdirectories, but only those with a noteworthy status. Files that are up-to-date (i.e., the same as in the repository) are omitted. If all the files in a subdirectory are up-to-date, the subdirectory is not listed either. As an exception, if a file has become up-to-date as a direct result of a VC command, it is listed.

Here is an example of a VC Directory buffer listing:

                     ./
    edited           configure.ac
   added            README
    unregistered     temp.txt
                     src/
   edited           src/main.c
Two work files have been modified but not committed: configure.ac in the current directory, and main.c in the src/ subdirectory. The file named README has been added but is not yet committed, while temp.txt is not under version control (see Registering a File for Version Control).

The ‘*’ characters next to the entries for README and src/main.c indicate that the user has marked these files as the current VC fileset (see VC Directory Commands).

The above example is typical for a decentralized version control system like Bazaar, Git, or Mercurial. Other systems can show other statuses. For instance, CVS shows the ‘needs-update’ status if the repository has changes that have not been applied to the work file. RCS and SCCS show the name of the user locking a file as its status.

On CVS, the vc-dir command normally contacts the repository, which may be on a remote machine, to check for updates. If you change the variable vc-cvs-stay-local to nil (see Options specific for CVS), then Emacs avoids contacting a remote repository when generating the VC Directory buffer (it will still contact it when necessary, e.g., when doing a commit). This may be desirable if you are working offline or the network is slow.

The VC Directory buffer omits subdirectories listed in the variable vc-directory-exclusion-list. Its default value contains directories that are used internally by version control systems.


***** VC Directory Commands

Emacs provides several commands for navigating the VC Directory buffer, and for marking files as belonging to the current VC fileset.

n
SPC
Move point to the next entry (vc-dir-next-line).

p
Move point to the previous entry (vc-dir-previous-line).

TAB
Move to the next directory entry (vc-dir-next-directory).

S-TAB
Move to the previous directory entry (vc-dir-previous-directory).

RET
f
Visit the file or directory listed on the current line (vc-dir-find-file).

o
Visit the file or directory on the current line, in a separate window (vc-dir-find-file-other-window).

m
Mark the file or directory on the current line (vc-dir-mark), putting it in the current VC fileset. If the region is active, mark all files in the region.

A file cannot be marked with this command if it is already in a marked directory, or one of its subdirectories. Similarly, a directory cannot be marked with this command if any file in its tree is marked.

M
If point is on a file entry, mark all files with the same status; if point is on a directory entry, mark all files in that directory tree (vc-dir-mark-all-files). With a prefix argument, mark all listed files and directories.

% m
 %
You can use this command to mark files by regexp (vc-dir-mark-by-regexp). If given a prefix, unmark files instead.

 r
You can use this command to mark files that are in one of registered states, including edited, added or removed. (vc-dir-mark-registered-files).

G
Add the file under point to the list of files that the VC should ignore (vc-dir-ignore). For instance, if the VC is Git, it will append this file to the .gitignore file. If given a prefix, do this with all the marked files.

q
Quit the VC Directory buffer, and bury it (quit-window).

u
Unmark the file or directory on the current line. If the region is active, unmark all the files in the region (vc-dir-unmark).

U
If point is on a file entry, unmark all files with the same status; if point is on a directory entry, unmark all files in that directory tree (vc-dir-unmark-all-files). With a prefix argument, unmark all files and directories.

x
Hide files with ‘up-to-date’ or ‘ignored’ status (vc-dir-hide-up-to-date). With a prefix argument, hide items whose state is that of the item at point.

While in the VC Directory buffer, all the files that you mark with m (vc-dir-mark) or M (vc-dir-mark-all-files) are in the current VC fileset. If you mark a directory entry with m, all the listed files in that directory tree are in the current VC fileset. The files and directories that belong to the current VC fileset are indicated with a ‘*’ character in the VC Directory buffer, next to their VC status. In this way, you can set up a multi-file VC fileset to be acted on by VC commands like C-x v v (see Basic Editing under Version Control), C-x v = (see Examining And Comparing Old Revisions), and C-x v u (see Undoing Version Control Actions).

The VC Directory buffer also defines some single-key shortcuts for VC commands with the C-x v prefix: =, +, l, i, D, L, G, I, O, and v.

For example, you can commit a set of edited files by opening a VC Directory buffer, where the files are listed with the ‘edited’ status; marking the files; and typing v or C-x v v (vc-next-action). If the version control system is changeset-based, Emacs will commit the files in a single revision.

While in the VC Directory buffer, you can also perform search and replace on the current VC fileset, with the following commands:

S
Search the fileset (vc-dir-search).

Q
Do a regular expression query replace on the fileset (vc-dir-query-replace-regexp).

M-s a C-s
Do an incremental search on the fileset (vc-dir-isearch).

M-s a C-M-s
Do an incremental regular expression search on the fileset (vc-dir-isearch-regexp).

Apart from acting on multiple files, these commands behave much like their single-buffer counterparts (see Searching and Replacement).

The VC Directory buffer additionally defines some branch-related commands starting with the prefix b:

b c
Create a new branch (vc-create-branch). See Creating New Branches.

b l
Prompt for the name of a branch and display the change history of that branch (vc-print-branch-log).

b s
Switch to a branch (vc-switch-branch). See Switching between Branches.

d
Delete the marked files, or the current file if no marks (vc-dir-clean-delete). The files will not be marked as deleted in the version control system, so this function is mostly useful for unregistered files.

The above commands are also available via the menu bar, and via a context menu invoked by mouse-2. Furthermore, some VC backends use the menu to provide extra backend-specific commands. For example, Git and Bazaar allow you to manipulate stashes and shelves (which are a way to temporarily put aside uncommitted changes, and bring them back at a later time).


**** Version Control Branches

One use of version control is to support multiple independent lines of development, which are called branches. Amongst other things, branches can be used for maintaining separate stable and development versions of a program, and for developing unrelated features in isolation from one another.

VC’s support for branch operations is currently fairly limited. For decentralized version control systems, it provides commands for updating one branch with the contents of another, and for merging the changes made to two different branches (see Merging Branches). For centralized version control systems, it supports checking out different branches and committing into new or different branches.

***** Switching between Branches

The various version control systems differ in how branches are implemented, and these differences cannot be entirely concealed by VC.

On some decentralized version control systems, including Bazaar and Mercurial in its normal mode of operation, each branch has its own working directory tree, so switching between branches just involves switching directories. On Git, branches are normally co-located in the same directory, and switching between branches is done using the git checkout command, which changes the contents of the working tree to match the branch you switch to. Bazaar also supports co-located branches, in which case the bzr switch command will switch branches in the current directory. With Subversion, you switch to another branch using the svn switch command. With Mercurial, command hg update is used to switch to another branch.

The VC command to switch to another branch in the current directory is C-x v b s branch-name RET (vc-switch-branch).

On centralized version control systems, you can also switch between branches by typing C-u C-x v v in an up-to-date work file (see Advanced Control in C-x v v), and entering the revision ID for a revision on another branch. On CVS, for instance, revisions on the trunk (the main line of development) normally have IDs of the form 1.1, 1.2, 1.3, …, while the first branch created from (say) revision 1.2 has revision IDs 1.2.1.1, 1.2.1.2, …, the second branch created from revision 1.2 has revision IDs 1.2.2.1, 1.2.2.2, …, and so forth. You can also specify the branch ID, which is a branch revision ID omitting its final component (e.g., 1.2.1), to switch to the latest revision on that branch.

On a locking-based system, switching to a different branch also unlocks (write-protects) the working tree.

Once you have switched to a branch, VC commands will apply to that branch until you switch away; for instance, any VC filesets that you commit will be committed to that specific branch.


***** Pulling/Pushing Changes into/from a Branch

C-x v P
With a decentralized version control system, update another repository with locally-committed changes from the current branch (a.k.a. push changes). This concept does not exist for centralized version control systems

C-x v +
With a decentralized version control system, update the current branch of the local repository by pulling in changes from another repository.

With a centralized version control system, update the current VC fileset from the repository.

On a decentralized version control system, the command C-x v P (vc-push) updates another location, commonly known as the upstream repository, with locally-committed changes from the current branch. With a prefix argument, it prompts for the exact version control command to run, which lets you specify where to push changes; the default is bzr push with Bazaar, git push with Git, and hg push with Mercurial. The default commands always push to the repository in the default location determined by the version control system from your branch configuration.

Prior to pushing, you can use C-x v O (vc-log-outgoing) to view a log buffer of the changes to be sent upstream. See VC Change Log.

This command is currently supported only by Bazaar, Git, and Mercurial. The concept of “pushing” does not exist for centralized version control systems, where this operation is a part of committing a changeset, so invoking this command on a centralized VCS signals an error. This command also signals an error when attempted in a Bazaar bound branch, where committing a changeset automatically pushes the changes to the remote repository to which the local branch is bound.

With a decentralized version control system, the command C-x v + (vc-pull) updates the current branch of the local repository and it working tree with changes made in the upstream repository. It is typically used to update a copy (a.k.a. clone) of a remote branch. If you supply a prefix argument, the command prompts for the exact version control command to use, which lets you specify where to pull changes from. Otherwise, it pulls from the repository in the default location determined by the version control system from your branch configuration.

Amongst decentralized version control systems, C-x v + is currently supported only by Bazaar, Git, and Mercurial. With Bazaar, it calls bzr pull for ordinary branches (to pull from a master branch into a mirroring branch), and bzr update for a bound branch (to pull from a central repository). With Git, it calls git pull to fetch changes from a remote repository and merge it into the current branch. With Mercurial, it calls hg pull -u to fetch changesets from the default remote repository and update the working directory.

Prior to pulling, you can use C-x v I (vc-log-incoming) to view a log buffer of the changes to be applied. See VC Change Log.

With a centralized version control system like CVS, C-x v + updates the current VC fileset from the repository.


***** Merging Branches

C-x v m
With a decentralized version control system, merge changes from another branch into the current one.

With a centralized version control system, merge changes from another branch into the current VC fileset.

While developing a branch, you may sometimes need to merge in changes that have already been made in another branch. This is not a trivial operation, as overlapping and conflicting changes may have been made to the two branches.

With a decentralized version control system, you merge changes with the command C-x v m (vc-merge). With Bazaar, this prompts for the exact arguments to pass to the bzr merge command, offering a sensible default if possible. With Git, this prompts for the name of a branch to merge from, with completion (based on the branch names known to the current repository). With Mercurial, this prompts for argument to pass to hg merge. The output from running the merge command is shown in a separate buffer.

With a centralized version control system like CVS, C-x v m prompts for a branch ID, or a pair of revision IDs (see Switching between Branches); then it finds the changes from that branch, or the changes between the two revisions you specified, and merges those changes into the current VC fileset. If you just type RET at the prompt, Emacs simply merges any changes that were made on the same branch since you checked the file out.

Immediately after performing a merge, only the working tree is modified, and you can review the changes produced by the merge with C-x v D and related commands (see Examining And Comparing Old Revisions). If the two branches contained overlapping changes, merging produces a conflict; a warning appears in the output of the merge command, and conflict markers are inserted into each affected work file, surrounding the two sets of conflicting changes. You must then resolve the conflict by editing the conflicted files; by default, Emacs will place buffers with VC conflicts in the special Smerge mode, which provides special commands for resolving the merge conflicts. Once you are done with resolving the conflicts and have saved the files with resolved conflicts, those files must be committed in the usual way for the merge to take effect (see Basic Editing under Version Control).


***** Creating New Branches

On centralized version control systems like CVS, Emacs supports creating new branches as part of a commit operation. When committing a modified VC fileset, type C-u C-x v v (vc-next-action with a prefix argument; see Advanced Control in C-x v v). Then Emacs prompts for a revision ID for the new revision. You should specify a suitable branch ID for a branch starting at the current revision. For example, if the current revision is 2.5, the branch ID should be 2.5.1, 2.5.2, and so on, depending on the number of existing branches at that point.

This procedure will not work for distributed version control systems like git or Mercurial. For those systems you should use the command vc-create-branch (C-x v b c branch-name RET) instead.

To create a new branch at an older revision (one that is no longer the head of a branch), first select that revision (see Switching between Branches). Your procedure will then differ depending on whether you are using a locking or merging-based VCS.

On a locking VCS, you will need to lock the old revision branch with C-x v v. You’ll be asked to confirm, when you lock the old revision, that you really mean to create a new branch—if you say no, you’ll be offered a chance to lock the latest revision instead. On a merging-based VCS you will skip this step.

Then make your changes and type C-x v v again to commit a new revision. This creates a new branch starting from the selected revision.

After the branch is created, subsequent commits create new revisions on that branch. To leave the branch, you must explicitly select a different revision with C-u C-x v v.


**** Miscellaneous Commands and Features of VC

This section explains the less-frequently-used features of VC.

***** Change Logs and VC

If you use RCS or CVS for a program with a ChangeLog file (see Change Logs), you can generate change log entries from the version control log entries of previous commits.

Note that this only works with RCS or CVS. This procedure would be particularly incorrect on a modern changeset-based version control system, where changes to the ChangeLog file would normally be committed as part of a changeset. In that case, you should write the change log entries first, then pull them into the ‘*vc-log*’ buffer when you commit (see Features of the Log Entry Buffer).

C-x v a ¶
Visit the current directory’s ChangeLog file and, for registered files in that directory, create new entries for versions committed since the most recent change log entry (vc-update-change-log).

C-u C-x v a
As above, but only find entries for the current buffer’s file.

For example, suppose the first line of ChangeLog is dated 1999-04-10, and that the only check-in since then was by Nathaniel Bowditch to rcs2log on 1999-05-22 with log entry ‘Ignore log messages that start with '#'.’. Then C-x v a inserts this ChangeLog entry:

1999-05-22  Nathaniel Bowditch  <nat@apn.org>

        * rcs2log: Ignore log messages that start with '#'.
If the version control log entry specifies a function name (in parenthesis at the beginning of a line), that is reflected in the ChangeLog entry. For example, if a log entry for vc.el is ‘(vc-do-command): Check call-process status.’, the ChangeLog entry is:

1999-05-06  Nathaniel Bowditch  <nat@apn.org>

        * vc.el (vc-do-command): Check call-process status.
When C-x v a adds several change log entries at once, it groups related log entries together if they all are checked in by the same author at nearly the same time. If the log entries for several such files all have the same text, it coalesces them into a single entry.


***** Deleting and Renaming Version-Controlled Files

M-x vc-delete-file
Prompt for a file name, delete the file from the working tree, and schedule the deletion for committing.

M-x vc-rename-file
Prompt for two file names, old and new, rename them in the working tree, and schedule the renaming for committing. The old file defaults to the current buffer’s file name if it is under VC.

If you wish to delete a version-controlled file, use the command M-x vc-delete-file. This prompts for the file name, and deletes it via the version control system. The file is removed from the working tree, and in the VC Directory buffer (see VC Directory Mode), it is displayed with the ‘removed’ status. When you commit it, the deletion takes effect in the repository.

To rename a version-controlled file, type M-x vc-rename-file. This prompts for two arguments: the name of the file you wish to rename, and the new name; then it performs the renaming via the version control system. The renaming takes effect immediately in the working tree, and takes effect in the repository when you commit the renamed file.

On modern version control systems that have built-in support for renaming, the renamed file retains the full change history of the original file. On CVS and older version control systems, the vc-rename-file command actually works by creating a copy of the old file under the new name, registering it, and deleting the old file. In this case, the change history is not preserved.


***** Revision Tags

Most version control systems allow you to apply a revision tag to a specific version of a version-controlled tree. On modern changeset-based version control systems, a revision tag is simply a symbolic name for a particular revision. On older file-based systems like CVS, each tag is added to the entire set of version-controlled files, allowing them to be handled as a unit. Revision tags are commonly used to identify releases that are distributed to users.

There are two basic commands for tags; one makes a tag with a given name, the other retrieves a named tag.

C-x v s name RET
Define the working revision of every registered file in or under the current directory as a tag named name (vc-create-tag).

C-x v r name RET
For all registered files at or below the current directory level, retrieve the tagged revision name. This command will switch to a branch if name is a branch name and your VCS distinguishes branches from tags. (vc-retrieve-tag).

This command reports an error if any files are locked at or below the current directory, without changing anything; this is to avoid overwriting work in progress.

You can give a tag or branch name as an argument to C-x v = or C-x v ~ (see Examining And Comparing Old Revisions). Thus, you can use it to compare a tagged version against the current files, or two tagged versions against each other.

On SCCS, VC implements tags itself; these tags are visible only through VC. Most later systems (including CVS, Subversion, bzr, git, and hg) have a native tag facility, and VC uses it where available; those tags will be visible even when you bypass VC.

In file-based version control systems, when you rename a registered file you need to rename its master along with it; the command vc-rename-file will do this automatically (see Deleting and Renaming Version-Controlled Files). If you are using SCCS, you must also update the records of the tag, to mention the file by its new name (vc-rename-file does this, too). An old tag that refers to a master file that no longer exists under the recorded name is invalid; VC can no longer retrieve it. It would be beyond the scope of this manual to explain enough about RCS and SCCS to explain how to update the tags by hand. Using vc-rename-file makes the tag remain valid for retrieval, but it does not solve all problems. For example, some of the files in your program probably refer to others by name. At the very least, the makefile probably mentions the file that you renamed. If you retrieve an old tag, the renamed file is retrieved under its new name, which is not the name that the makefile expects. So the program won’t really work as retrieved.


***** Inserting Version Control Headers

On Subversion, CVS, RCS, and SCCS, you can put certain special strings called version headers into a work file. When the file is committed, the version control system automatically puts the revision number, the name of the user who made the commit, and other relevant information into the version header.

VC does not normally use the information in the version headers. As an exception, when using RCS, Emacs uses the version header, if there is one, to determine the file version, since it is often more reliable than the RCS master file. To inhibit using the version header this way, change the variable vc-consult-headers to nil. VC then always uses the file permissions (if it is supposed to trust them), or else checks the master file.

To insert a suitable header string into the current buffer, use the command M-x vc-insert-headers. This command works only on Subversion, CVS, RCS, and SCCS. The variable vc-backend-header contains the list of keywords to insert into the version header; for instance, CVS uses vc-cvs-header, whose default value is '("\$Id\$"). (The extra backslashes prevent the string constant from being interpreted as a header, if the Emacs Lisp file defining it is maintained with version control.) The vc-insert-headers command inserts each keyword in the list on a new line at point, surrounded by tabs, and inside comment delimiters if necessary.

The variable vc-static-header-alist specifies further strings to add based on the name of the buffer. Its value should be a list of elements of the form (regexp . format). Whenever regexp matches the buffer name, format is also inserted as part of the version header. A ‘%s’ in format is replaced with the file’s version control type.


***** Editing VC Commands

You can use the C-x v ! (vc-edit-next-command) prefix command to edit the shell command line that VC is about to run. This is primarily intended to make it possible to add optional command-line arguments to VCS commands without unnecessary complications of the VC command set and its interfaces with the backend.

For example, Git can produce logs of more than one branch, but C-x v b l (vc-print-branch-log) prompts for the name of just one branch. To obtain a log of more than one branch, you can type C-x v ! C-x v b l and then append the names of additional branches to the end of the ‘git log’ command that VC is about to run.


***** Preparing Patches

When collaborating on projects it is common to send patches via email, to share changes. You can do this using VC with the vc-prepare-patch command. This will prompt you for the revisions you wish to share, and which destination email address(es) to use. Separate the revisions using the value of crm-separator, commas by default. The command will then prepare those revisions using your MUA (Mail User Agent) for you to review and send.

When invoked interactively in a Log View buffer with marked revisions, those marked revisions will be used.

Depending on the value of the user option vc-prepare-patches-separately, vc-prepare-patch will generate one or more messages. The default value t means prepare and display a message for each revision, one after another. A value of nil means to generate a single message with all patches attached in the body.

If you expect to contribute patches on a regular basis, you can set the user option vc-default-patch-addressee to the address(es) you wish to use. This will be used as the default value when invoking vc-prepare-patch. Project maintainers may consider setting this as a directory local variable (see Per-Directory Local Variables).


**** Customizing VC

The variable vc-handled-backends determines which version control systems VC should handle. The default value is (RCS CVS SVN SCCS SRC Bzr Git Hg), so it contains all the version systems that are currently supported. If you want VC to ignore one or more of these systems, exclude its name from the list. To disable VC entirely, set this variable to nil.

The order of systems in the list is significant: when you visit a file registered in more than one system, VC uses the system that comes first in vc-handled-backends by default. The order is also significant when you register a file for the first time (see Registering a File for Version Control).

***** General Options

Emacs normally does not save backup files for source files that are maintained with version control. If you want to make backup files even for files that use version control, set the variable vc-make-backup-files to a non-nil value.

Editing a version-controlled file through a symbolic link may cause unexpected results, if you are unaware that the underlying file is version-controlled. The variable vc-follow-symlinks controls what Emacs does if you try to visit a symbolic link pointing to a version-controlled file. If the value is ask (the default), Emacs asks for confirmation. If it is nil, Emacs just displays a warning message. If it is t, Emacs automatically follows the link and visits the real file instead.

If vc-suppress-confirm is non-nil, then C-x v v and C-x v i can save the current buffer without asking, and C-x v u also operates without asking for confirmation.

VC mode does much of its work by running the shell commands for the appropriate version control system. If vc-command-messages is non-nil, VC displays messages to indicate which shell commands it runs, and additional messages when the commands finish.


***** Options for RCS and SCCS

By default, RCS uses locking to coordinate the activities of several users, but there is a mode called non-strict locking in which you can check-in changes without locking the file first. Use ‘rcs -U’ to switch to non-strict locking for a particular file, see the rcs manual page for details.

When deducing the version control state of an RCS file, VC first looks for an RCS version header string in the file (see Inserting Version Control Headers). If there is no header string, VC normally looks at the file permissions of the work file; this is fast. But there might be situations when the file permissions cannot be trusted. In this case the master file has to be consulted, which is rather expensive. Also the master file can only tell you if there’s any lock on the file, but not whether your work file really contains that locked version.

You can tell VC not to use version headers to determine the file status by setting vc-consult-headers to nil. VC then always uses the file permissions (if it is supposed to trust them), or else checks the master file.

VC determines the version control state of files under SCCS much as with RCS. It does not consider SCCS version headers, though. Thus, the variable vc-consult-headers does not affect SCCS use.


***** Options specific for CVS

You can specify additional command line options to pass to all CVS operations in the variable vc-cvs-global-switches. These switches are inserted immediately after the cvs command, before the name of the operation to invoke.

When using a CVS repository on a remote machine, VC can try keeping network interactions to a minimum. This is controlled by the variable vc-cvs-stay-local. If vc-cvs-stay-local is only-file (the default), VC determines the version control status of each file using only the entry in the local CVS subdirectory and the information returned by previous CVS commands. As a consequence, if you have modified a file and somebody else has checked in other changes, you will not be notified of the conflict until you try to commit.

If you change vc-cvs-stay-local to nil, VC queries the remote repository before it decides what to do in vc-next-action (C-x v v), just as it does for local repositories.

You can also set vc-cvs-stay-local to a regular expression that is matched against the repository host name; VC then stays local only for repositories from hosts that match the pattern.

When using a remote repository, Emacs normally makes automatic version backups of the original versions of each edited file. These local backups are made whenever you save the first changes to a file, and they are removed after you commit your changes to the repository. (Note that these are not the same as ordinary Emacs backup files; see Backup Files.) Commands like C-x v = and C-x v u make use of automatic version backups, if possible, to avoid having to access the network.

Setting vc-cvs-stay-local to nil disables the making of automatic version backups.

Automatic version backups have names of the form file.~version.~. This is similar to the name that C-x v ~ saves old versions to (see Examining And Comparing Old Revisions), except for the additional dot (‘.’) after the version. The relevant VC commands can use both kinds of version backups. The main difference is that the manual version backups made by C-x v ~ are not deleted automatically when you commit.

CVS does not use locking by default, but there are ways to enable locking-like behavior using its CVSREAD or watch feature; see the CVS documentation for details. If that case, you can use C-x v v in Emacs to toggle locking, as you would for a locking-based version control system (see Basic Version Control with Locking).


*** Working with Projects

A project is a collection of files used for producing one or more programs. Files that belong to a project are typically stored in a hierarchy of directories; the top-level directory of the hierarchy is known as the project root.

Whether a given directory is a root of some project is determined by the project-specific infrastructure, known as project back-end. Emacs currently supports two such back-ends: VC-aware (see Version Control), whereby a VCS repository is considered a project; and EDE (see Emacs Development Environment). This is expected to be extended in the future to support additional types of projects.

Which files do or don’t belong to a project is also determined by the project back-end. For example, the VC-aware back-end doesn’t consider “ignored” files (see Ignore Version Control Files) to be part of the project. Also, the VC-aware Project back-end considers “untracked” files by default. That behavior is controllable with the variable project-vc-include-untracked.

**** Project Commands That Operate on Files

C-x p f
Visit a file that belongs to the current project (project-find-file).

C-x p g
Find matches for a regexp in all files that belong to the current project (project-find-regexp).

M-x project-search
Interactively search for regexp matches in all files that belong to the current project.

C-x p r
Perform query-replace for a regexp in all files that belong to the current project (project-query-replace-regexp).

C-x p d
Run Dired in the current project’s root directory (project-dired).

C-x p v
Run vc-dir in the current project’s root directory (project-vc-dir).

C-x p s
Start an inferior shell in the current project’s root directory (project-shell).

C-x p e
Start Eshell in the current project’s root directory (project-eshell).

C-x p c
Run compilation in the current project’s root directory (project-compile).

C-x p !
Run shell command in the current project’s root directory (project-shell-command).

C-x p &
Run shell command asynchronously in the current project’s root directory (project-async-shell-command).

Emacs provides commands for handling project files conveniently. This subsection describes these commands.

All of the commands described here share the notion of the current project. The current project is determined by the default-directory (see File Names) of the buffer that is the current buffer when the command is invoked. If that directory doesn’t seem to belong to a recognizable project, these commands prompt you for the project directory.

The command C-x p f (project-find-file) is a convenient way of visiting files (see Visiting Files) that belong to the current project. Unlike C-x C-f, this command doesn’t require to type the full file name of the file to visit, you can type only the file’s base name (i.e., omit the leading directories). In addition, the completion candidates considered by the command include only the files belonging to the current project, and nothing else. If there’s a file name at point, this command offers that file as the first element of the “future history”. If given a prefix, include all files under the project root, except for VCS directories listed in vc-directory-exclusion-list.

The command C-x p g (project-find-regexp) is similar to rgrep (see Searching with Grep under Emacs), but it searches only the files that belong to the current project. The command prompts for the regular expression to search, and pops up an Xref mode buffer with the search results, where you can select a match using the Xref mode commands (see Commands Available in the *xref* Buffer). When invoked with a prefix argument, this command additionally prompts for the base directory from which to start the search; this allows, for example, to limit the search only to project files under a certain subdirectory of the project root. The way this command displays the matches is affected by the value of xref-auto-jump-to-first-xref (see Searching and Replacing with Identifiers).

M-x project-search is a sequential variant of project-find-regexp. It prompts for a regular expression to search in the current project’s files, but instead of finding all the matches and displaying them, it stops when it finds a match and visits the matched file at the locus of the match, allowing you to edit the matched file. To find the rest of the matches, type M-x fileloop-continue RET.

C-x p r (project-query-replace-regexp) is similar to project-search, but it prompts you for whether to replace each match it finds, like query-replace does (see Query Replace), and continues to the next match after you respond. If your response causes Emacs to exit the query-replace loop, you can later continue with M-x fileloop-continue RET.

The command C-x p d (project-find-dir) prompts you to choose a directory inside the current project, with completion. And opens a Dired buffer (see Dired, the Directory Editor) listing the files in it.

The command C-x p D (project-dired) opens a Dired buffer (see Dired, the Directory Editor) listing the files in the current project’s root directory.

The command C-x p v (project-vc-dir) opens a VC Directory buffer (see VC Directory Mode) listing the version control statuses of the files in a directory tree under the current project’s root directory.

The command C-x p s (project-shell) starts a shell session (see Running Shell Commands from Emacs) in a new buffer with the current project’s root as the working directory.

The command C-x p e (project-eshell) starts an Eshell session in a new buffer with the current project’s root as the working directory. See Eshell in Eshell: The Emacs Shell.

The command C-x p c (project-compile) runs compilation (see Running Compilations under Emacs) in the current project’s root directory.

The command C-x p ! (project-shell-command) runs shell-command in the current project’s root directory.

The command C-x p & (project-async-shell-command) runs async-shell-command in the current project’s root directory.


**** Project Commands That Operate on Buffers

C-x p b
Switch to another buffer belonging to the current project (project-switch-to-buffer).

C-x p C-b
List the project buffers (project-list-buffers).

C-x p k
Kill all live buffers that belong to the current project (project-kill-buffers).

Working on a project could potentially involve having many buffers visiting files that belong to the project, and also buffers that belong to the project, but don’t visit any files (like the *compilation* buffer created by project-compile). The command C-x p b (project-switch-to-buffer) helps you switch between buffers that belong to the current project by prompting for a buffer to switch and considering only the current project’s buffers as candidates for completion.

Like the command list-buffers (see Listing Existing Buffers), the command C-x p C-b (project-list-buffers) displays a list of existing buffers, but only belonging to the current project.

When you finish working on the project, you may wish to kill all the buffers that belong to the project, to keep your Emacs session smaller. The command C-x p k (project-kill-buffers) accomplishes that: it kills all the buffers that belong to the current project that satisfy any of project-kill-buffer-conditions. If project-kill-buffers-display-buffer-list is non-nil, the buffers to be killed will be displayed first.


**** Switching Projects

C-x p p
Run an Emacs command for another project (project-switch-project).

Commands that operate on project files (see Project Commands That Operate on Files) will conveniently prompt you for a project directory when no project is current. When you are inside some project, but you want to operate on a different project, use the C-x p p command (project-switch-project). This command prompts you to choose a directory among known project roots, and then displays the menu of available commands to operate on the project you choose. The variable project-switch-commands controls which commands are available in the menu, and which key invokes each command.

The variable project-list-file names the file in which Emacs records the list of known projects. It defaults to the file projects in user-emacs-directory (see How Emacs Finds Your Init File).


**** Managing the Project List File

M-x project-forget-project
Remove a known project from the project-list-file.

Normally Emacs automatically adds and removes projects to and from the project-list-file, but sometimes you may want to manually edit the available projects. M-x project-forget-project prompts you to choose one of the available projects, and then removes it from the file.


*** Change Logs

Many software projects keep a change log. This is a file, normally named ChangeLog, containing a chronological record of when and how the program was changed. Sometimes, these files are automatically generated from the change log entries stored in version control systems, or are used to generate these change log entries. Sometimes, there are several change log files, each recording the changes in one directory or directory tree.

**** Change Log Commands

The Emacs command C-x 4 a adds a new entry to the change log file for the file you are editing (add-change-log-entry-other-window). If that file is actually a backup file, it makes an entry appropriate for the file’s parent—that is useful for making log entries for functions that have been deleted in the current version.

C-x 4 a visits the change log file and creates a new entry unless the most recent entry is for today’s date and your name. It also creates a new item for the current file. For many languages, it can even guess the name of the function or other object that was changed.

To find the change log file, Emacs searches up the directory tree from the file you are editing. By default, it stops if it finds a directory that seems to be the root of a version-control repository. To change this, customize change-log-directory-files.

When the variable add-log-keep-changes-together is non-nil, C-x 4 a adds to any existing item for the file, rather than starting a new item.

You can combine multiple changes of the same nature. If you don’t enter any text after the initial C-x 4 a, any subsequent C-x 4 a adds another symbol to the change log entry.

If add-log-always-start-new-record is non-nil, C-x 4 a always makes a new entry, even if the last entry was made by you and on the same date.

If the value of the variable change-log-version-info-enabled is non-nil, C-x 4 a adds the file’s version number to the change log entry. It finds the version number by searching the first ten percent of the file, using regular expressions from the variable change-log-version-number-regexp-list.

The change log file is visited in Change Log mode. In this major mode, each bunch of grouped items counts as one paragraph, and each entry is considered a page. This facilitates editing the entries. C-j and auto-fill indent each new line like the previous line; this is convenient for entering the contents of an entry.

You can use the command change-log-goto-source (by default bound to C-c C-c) to go to the source location of the change log entry near point, when Change Log mode is on. Then subsequent invocations of the next-error command (by default bound to M-g M-n and C-x `) will move between entries in the change log. You will jump to the actual site in the file that was changed, not just to the next change log entry. You can also use previous-error to move back through the change log entries.

You can use the command M-x change-log-merge to merge other log files into a buffer in Change Log Mode, preserving the date ordering of entries.

Version control systems are another way to keep track of changes in your program and keep a change log. Many projects that use a VCS don’t keep a separate versioned change log file nowadays, so you may wish to avoid having such a file in the repository. If the value of add-log-dont-create-changelog-file is non-nil, commands like C-x 4 a (add-change-log-entry-other-window) will record changes in a suitably named temporary buffer instead of a file, if such a file does not already exist.

Whether you have a change log file or use a temporary buffer for change logs, you can type C-c C-a (log-edit-insert-changelog) in the VC Log buffer to insert the relevant change log entries, if they exist. See Features of the Log Entry Buffer.


**** Format of ChangeLog

A change log entry starts with a header line that contains the current date, your name (taken from the variable add-log-full-name), and your email address (taken from the variable add-log-mailing-address). Aside from these header lines, every line in the change log starts with a space or a tab. The bulk of the entry consists of items, each of which starts with a line starting with whitespace and a star. Here are two entries, both dated in May 1993, with two items and one item respectively.

1993-05-25  Richard Stallman  <rms@gnu.org>

        * man.el: Rename symbols 'man-*' to 'Man-*'.
        (manual-entry): Make prompt string clearer.

        * simple.el (blink-matching-paren-distance):
        Change default to 12,000.

1993-05-24  Richard Stallman  <rms@gnu.org>

        * vc.el (minor-mode-map-alist): Don't use it if it's void.
        (vc-cancel-version): Doc fix.
One entry can describe several changes; each change should have its own item, or its own line in an item. Normally there should be a blank line between items. When items are related (parts of the same change, in different places), group them by leaving no blank line between them.

You should put a copyright notice and permission notice at the end of the change log file. Here is an example:

Copyright 1997, 1998 Free Software Foundation, Inc.
Copying and distribution of this file, with or without modification, are
permitted provided the copyright notice and this notice are preserved.
Of course, you should substitute the proper years and copyright holder.


*** Find Identifier References

An identifier is a name of a syntactical subunit of the program: a function, a subroutine, a method, a class, a data type, a macro, etc. In a programming language, each identifier is a symbol in the language’s syntax. Identifiers are also known as tags.

Program development and maintenance requires capabilities to quickly find where each identifier was defined and referenced, to rename identifiers across the entire project, etc. These capabilities are also useful for finding references in major modes other than those defined to support programming languages. For example, chapters, sections, appendices, etc. of a text or a TeX document can be treated as subunits as well, and their names can be used as identifiers. In this chapter, we use the term “identifiers” to collectively refer to the names of any kind of subunits, in program source and in other kinds of text alike.

Emacs provides a unified interface to these capabilities, called ‘xref’.

To do its job, xref needs to make use of information and to employ methods specific to the major mode. What files to search for identifiers, how to find references to identifiers, how to complete on identifiers—all this and more is mode-specific knowledge. xref delegates the mode-specific parts of its job to a backend provided by the mode; it also includes defaults for some of its commands, for those modes that don’t provide their own.

A backend can implement its capabilities in a variety of ways. Here are a few examples:

Some major modes provide built-in means for looking up the language symbols. For example, Emacs Lisp symbols can be identified by searching the package load history, maintained by the Emacs Lisp interpreter, and by consulting the built-in documentation strings; the Emacs Lisp mode uses these facilities in its backend to allow finding definitions of symbols. (One disadvantage of this kind of backend is that it only knows about subunits that were loaded into the interpreter.)
If Eglot is activated for the current buffer’s project (see Working with Projects) and the current buffer’s major mode, Eglot consults an external language server program and provides the data supplied by the server regarding the definitions of the identifiers in the project. See Eglot Features in Eglot: The Emacs LSP Client.
An external program can extract references by scanning the relevant files, and build a database of these references. A backend can then access this database whenever it needs to list or look up references. The Emacs distribution includes etags, a command for tagging identifier definitions in programs, which supports many programming languages and other major modes, such as HTML, by extracting references into tags tables. See Creating Tags Tables. Major modes for languages supported by etags can use tags tables as basis for their backend. (One disadvantage of this kind of backend is that tags tables need to be kept reasonably up to date, by rebuilding them from time to time.)

**** Find Identifiers

This subsection describes the commands that find references to identifiers and perform various queries about identifiers. Each such reference could define an identifier, e.g., provide the implementation of a program subunit or the text of a document section; or it could use the identifier, e.g., call a function or a method, assign a value to a variable, mention a chapter in a cross-reference, etc.

***** Looking Up Identifiers

The most important thing that xref enables you to do is to find the definition of a specific identifier.

M-.
Find definitions of an identifier (xref-find-definitions).

C-M-. pattern RET
Find all identifiers whose name matches pattern (xref-find-apropos).

C-x 4 . RET
Find definitions of identifier, but display it in another window (xref-find-definitions-other-window).

C-x 5 . RET
Find definition of identifier, and display it in a new frame (xref-find-definitions-other-frame).

M-x xref-find-definitions-at-mouse
Find definition of identifier at mouse click.

M-,
Go back to where you previously invoked M-. and friends (xref-go-back).

C-M-,
Go forward to where you previously invoked M-, (xref-go-forward).

M-x xref-etags-mode
Switch xref to use the etags backend.

M-. (xref-find-definitions) shows the definition of the identifier at point. With a prefix argument, or if there’s no identifier at point, it prompts for the identifier. (If you want it to always prompt, customize xref-prompt-for-identifier to t.)

When entering the identifier argument to M-., you can use the usual minibuffer completion commands (see Completion), with the known identifier names being the completion candidates.

Like most commands that can switch buffers, xref-find-definitions has a variant that displays the new buffer in another window, and one that makes a new frame for it. The former is C-x 4 . (xref-find-definitions-other-window), and the latter is C-x 5 . (xref-find-definitions-other-frame).

The command xref-find-definitions-at-mouse works like xref-find-definitions, but it looks for the identifier name at or around the place of a mouse event. This command is intended to be bound to a mouse event, such as C-M-mouse-1, for example.

The command C-M-. (xref-find-apropos) is like apropos for tags (see Apropos). It displays a list of identifiers in the selected tags table whose names match the specified regexp. This is just like M-., except that it does regexp matching of identifiers instead of matching symbol names as fixed strings. By default, the command pops up the *xref* buffer, like M-., but you can display additional output by customizing the variable tags-apropos-additional-actions; see its documentation for details.

If any of the above commands finds more than one matching definition, it by default pops up the *xref* buffer showing the matching candidates. (C-M-. always pops up the *xref* buffer if it finds at least one match.) The candidates are normally shown in that buffer as the name of a file and the matching identifier(s) in that file. In that buffer, you can select any of the candidates for display, and you have several additional commands, described in Commands Available in the *xref* Buffer. However, if the value of the variable xref-auto-jump-to-first-definition is move, the first of these candidates is automatically selected in the *xref* buffer, and if it’s t or show, the first candidate is automatically shown in its own window; t also selects the window showing the first candidate. The default value is nil, which just shows the candidates in the *xref* buffer, but doesn’t select any of them.

To go back to places from where you’ve displayed the definition, use M-, (xref-go-back). It jumps back to the point of the last invocation of M-.. Thus you can find and examine the definition of something with M-. and then return to where you were with M-,. M-, allows you to retrace the steps you made forward in the history of places, all the way to the first place in history, where you first invoked M-., or to any place in-between.

If you previously went back too far with M-,, or want to re-examine a place from which you went back, you can use C-M-, (xref-go-forward) to go forward again. This is similar to using M-., except that you don’t need on each step to move point to the identifier whose definition you want to look up. C-M-, allows you to retrace all the steps you made back in the history of places, all the way to the last place in history, where you invoked M-,, or to any place in-between.

Some major modes install xref support facilities that might sometimes fail to find certain identifiers. For example, in Emacs Lisp mode (see Evaluating Emacs Lisp Expressions) M-. will by default find only functions and variables from Lisp packages which are loaded into the current Emacs session or are auto-loaded (see Autoload in The Emacs Lisp Reference Manual). If M-. fails to find some identifiers, you can try forcing xref to use the etags backend (see Find Identifier References). To this end, turn on the Xref Etags minor mode with M-x xref-etags-mode, then invoke M-. again. (For this to work, be sure to run etags to create the tags table in the directory tree of the source files, see Creating Tags Tables.)


***** Commands Available in the *xref* Buffer

The following commands are provided in the *xref* buffer by the special XREF mode:

RET
mouse-1
Display the reference on the current line (xref-goto-xref). With prefix argument, also bury the *xref* buffer.

mouse-2 ¶
The same as mouse-1, but make the window displaying the *xref* buffer the selected window (xref-select-and-show-xref).

n ¶
.
Move to the next reference and display it in the other window (xref-next-line).

N ¶
Move to the first reference of the next reference group and display it in the other window (xref-next-group).

p ¶
,
Move to the previous reference and display it in the other window (xref-prev-line).

P ¶
Move to the first reference of the previous reference group and display it in the other window (xref-prev-group).

C-o ¶
Display the reference on the current line in the other window (xref-show-location-at-point).

r pattern RET replacement RET
Perform interactive query-replace on references that match pattern (xref-query-replace-in-results), replacing the match with replacement. This command can only be used in *xref* buffers that show all the matches for an identifier in all the relevant files. See Searching and Replacing with Identifiers.

g ¶
Refresh the contents of the *xref* buffer (xref-revert-buffer).

M-, ¶
Quit the window showing the *xref* buffer, and then jump to the previous Xref stack location (xref-quit-and-pop-marker-stack).

q ¶
Quit the window showing the *xref* buffer (xref-quit).

In addition, the usual navigation commands, such as the arrow keys, C-n, and C-p are available for moving around the buffer without displaying the references.


***** Searching and Replacing with Identifiers

The commands in this section perform various search and replace operations either on identifiers themselves or on files that reference them.

M-?
Find all the references for the identifier at point.

r
M-x xref-query-replace-in-results RET replacement RET
C-u M-x xref-query-replace-in-results RET regexp RET replacement RET
Interactively replace regexp with replacement in the names of all the identifiers shown in the *xref* buffer.

M-x xref-find-references-and-replace RET from RET to RET
Interactively rename all instances of the identifier from to the new name to.

M-x tags-search RET regexp RET
Search for regexp through the files in the selected tags table.

M-x tags-query-replace RET regexp RET replacement RET
Perform a query-replace-regexp on each file in the selected tags table.

M-x fileloop-continue
Restart one of the last 2 commands above, from the current location of point.

M-? finds all the references for the identifier at point, prompting for the identifier as needed, with completion. Depending on the current backend (see Find Identifier References), the command may prompt even if it finds a valid identifier at point. When invoked with a prefix argument, it always prompts for the identifier. (If you want it to prompt always, customize the value of the variable xref-prompt-for-identifier to t; or set it to nil to prompt only if there’s no usable identifier at point.) The command then presents the *xref* buffer with all the references to the identifier, showing the file name and the line where the identifier is referenced. The XREF mode commands are available in this buffer, see Commands Available in the *xref* Buffer.

If the value of the variable xref-auto-jump-to-first-xref is t, xref-find-references automatically jumps to the first result and selects the window where it is displayed. If the value is show, the first result is shown, but the window showing the *xref* buffer is left selected. If the value is move, the first result is selected in the *xref* buffer, but is not shown. The default value is nil, which just shows the results in the *xref* buffer, but doesn’t select any of them.

r (xref-query-replace-in-results) reads a replacement string, just like ordinary M-x query-replace-regexp. It then renames the identifiers shown in the *xref* buffer in all the places in all the files where these identifiers are referenced, such that their new name is replacement. This is useful when you rename your identifiers as part of refactoring. This command should be invoked in the *xref* buffer generated by M-?. By default, the command replaces the entire name of each identifier with replacement, but if invoked with a prefix argument, the command prompts for a regexp to match identifier names, and replaces only the matches of that regexp in the names of the identifiers with replacement.

M-x xref-find-references-and-replace works similarly to xref-query-replace-in-results, but is more convenient when you want to rename a single identifier specified by its name from.

M-x tags-search reads a regexp using the minibuffer, then searches for matches in all the files in the selected tags table, one file at a time. It displays the name of the file being searched so you can follow its progress. As soon as it finds an occurrence, tags-search returns. This command requires tags tables to be available (see Tags Tables).

Having found one match with tags-search, you probably want to find all the rest. M-x fileloop-continue resumes the tags-search, finding one more match. This searches the rest of the current buffer, followed by the remaining files of the tags table.

M-x tags-query-replace performs a single query-replace-regexp through all the files in the tags table. It reads a regexp to search for and a string to replace with, just like ordinary M-x query-replace-regexp. It searches much like M-x tags-search, but repeatedly, processing matches according to your input. See Query Replace, for more information on query replace.

You can control the case-sensitivity of tags search commands by customizing the value of the variable tags-case-fold-search. The default is to use the same setting as the value of case-fold-search (see Lax Matching During Searching).

It is possible to get through all the files in the tags table with a single invocation of M-x tags-query-replace. But often it is useful to exit temporarily, which you can do with any input event that has no special query replace meaning. You can resume the query replace subsequently by typing M-x fileloop-continue; this command resumes the last tags search or replace command that you did. For instance, to skip the rest of the current file, you can type M-> M-x fileloop-continue.

Note that the commands described above carry out much broader searches than the xref-find-definitions family. The xref-find-definitions commands search only for definitions of identifiers that match your string or regexp. The commands xref-find-references, tags-search, and tags-query-replace find every occurrence of the identifier or regexp, as ordinary search commands and replace commands do in the current buffer.

As an alternative to xref-find-references and tags-search, you can run grep as a subprocess and have Emacs show you the matching lines one by one. See Searching with Grep under Emacs.


***** Identifier Inquiries

C-M-i
M-TAB
Perform completion on the text around point, possibly using the selected tags table if one is loaded (completion-at-point).

M-x list-tags RET file RET
Display a list of the identifiers defined in the program file file.

C-M-. regexp RET
Display a list of all identifiers matching regexp (xref-find-apropos). See Looking Up Identifiers.

M-x tags-next-file
Visit files recorded in the selected tags table.

In most programming language modes, you can type C-M-i or M-TAB (completion-at-point) to complete the symbol at point. Some modes provide specialized completion for this command tailored to the mode; for those that don’t, if there is a tags table loaded, this command can use it to generate completion candidates. See Completion for Symbol Names.

M-x list-tags reads the name of one of the files covered by the selected tags table, and displays a list of tags defined in that file. Do not include a directory as part of the file name unless the file name recorded in the tags table includes a directory. This command works only with the etags backend, and requires a tags table for the project to be available. See Tags Tables. If used interactively, the default tag is file name of the current buffer if used interactively.

M-x tags-next-file visits files covered by the selected tags table. The first time it is called, it visits the first file covered by the table. Each subsequent call visits the next covered file, unless a prefix argument is supplied, in which case it returns to the first file. This command requires a tags table to be selected.



**** Tags Tables

A tags table records the tags18 extracted by scanning the source code of a certain program or a certain document. Tags extracted from generated files reference the original files, rather than the generated files that were scanned during tag extraction. Examples of generated files include C files generated from Cweb source files, from a Yacc parser, or from Lex scanner definitions; .i preprocessed C files; and Fortran files produced by preprocessing .fpp source files.

To produce a tags table, you run the etags shell command on a document or the source code file. The ‘etags’ program writes the tags to a tags table file, or tags file in short. The conventional name for a tags file is TAGS. See Creating Tags Tables. (It is also possible to create a tags table by using one of the commands from other packages that can produce such tables in the same format.)

Emacs uses the tags tables via the etags package as one of the supported backends for xref. Because tags tables are produced by the etags command that is part of an Emacs distribution, we describe tags tables in more detail here.

The Ebrowse facility is similar to etags but specifically tailored for C++. See Ebrowse in Ebrowse User’s Manual. The Semantic package provides another way to generate and use tags, separate from the etags facility. See Semantic.

Source File Tag Syntax
Creating Tags Tables
Etags Regexps
Footnotes
(18)
A tag is a synonym for identifier reference. Commands and features based on the etags package traditionally use “tag” with this meaning, and this subsection follows that tradition.


***** Source File Tag Syntax

Here is how tag syntax is defined for the most popular languages:

In C code, any C function or typedef is a tag, and so are definitions of struct, union and enum. #define macro definitions, #undef and enum constants are also tags, unless you specify ‘--no-defines’ when making the tags table. Similarly, global variables are tags, unless you specify ‘--no-globals’, and so are struct members, unless you specify ‘--no-members’. Use of ‘--no-globals’, ‘--no-defines’ and ‘--no-members’ can make the tags table file much smaller.
You can tag function declarations and external variables in addition to function definitions by giving the ‘--declarations’ option to etags.

In C++ code, in addition to all the tag constructs of C code, member functions are also recognized; member variables are also recognized, unless you use the ‘--no-members’ option. operator definitions have tag names like ‘operator+’. If you specify the ‘--class-qualify’ option, tags for variables and functions in classes are named ‘class::variable’ and ‘class::function’. By default, class methods and members are not class-qualified, which allows to identify their names in the sources more accurately.
In Java code, tags include all the constructs recognized in C++, plus the interface, extends and implements constructs. Tags for variables and functions in classes are named ‘class.variable’ and ‘class.function’.
In LaTeX documents, the arguments for \chapter, \section, \subsection, \subsubsection, \eqno, \label, \ref, \cite, \bibitem, \part, \appendix, \entry, \index, \def, \newcommand, \renewcommand, \newenvironment and \renewenvironment are tags.
Other commands can make tags as well, if you specify them in the environment variable TEXTAGS before invoking etags. The value of this environment variable should be a colon-separated list of command names. For example,

TEXTAGS="mycommand:myothercommand"
export TEXTAGS
specifies (using Bourne shell syntax) that the commands ‘\mycommand’ and ‘\myothercommand’ also define tags.

In Lisp code, any function defined with defun, any variable defined with defvar or defconst, and in general the first argument of any expression that starts with ‘(def’ in column zero is a tag. As an exception, expressions of the form (defvar foo) are treated as declarations, and are only tagged if the ‘--declarations’ option is given.
In Scheme code, tags include anything defined with def or with a construct whose name starts with ‘def’. They also include variables set with set! at top level in the file.
Several other languages are also supported:

In Ada code, functions, procedures, packages, tasks and types are tags. Use the ‘--packages-only’ option to create tags for packages only.
In Ada, the same name can be used for different kinds of entity (e.g., for a procedure and for a function). Also, for things like packages, procedures and functions, there is the spec (i.e., the interface) and the body (i.e., the implementation). To make it easier to pick the definition you want, Ada tag names have suffixes indicating the type of entity:

‘/b’
package body.

‘/f’
function.

‘/k’
task.

‘/p’
procedure.

‘/s’
package spec.

‘/t’
type.

Thus, M-x find-tag RET bidule/b RET will go directly to the body of the package bidule, while M-x find-tag RET bidule RET will just search for any tag bidule.

In assembler code, labels appearing at the start of a line, followed by a colon, are tags.
In Bison or Yacc input files, each rule defines as a tag the nonterminal it constructs. The portions of the file that contain C code are parsed as C code.
In Cobol code, tags are paragraph names; that is, any word starting in column 8 and followed by a period.
In Erlang code, the tags are the functions, records and macros defined in the file.
In Fortran code, functions, subroutines and block data are tags.
In Go code, packages, functions, and types are tags.
In HTML input files, the tags are the title and the h1, h2, h3 headers. Also, tags are name= in anchors and all occurrences of id=.
In Lua input files, all functions are tags.
In makefiles, targets are tags; additionally, variables are tags unless you specify ‘--no-globals’.
In Objective C code, tags include Objective C definitions for classes, class categories, methods and protocols. Tags for variables and functions in classes are named ‘class::variable’ and ‘class::function’.
In Pascal code, the tags are the functions and procedures defined in the file.
In Perl code, the tags are the packages, subroutines and variables defined by the package, sub, use constant, my, and local keywords. Use ‘--globals’ if you want to tag global variables. Tags for subroutines are named ‘package::sub’. The name for subroutines defined in the default package is ‘main::sub’.
In PHP code, tags are functions, classes and defines. Vars are tags too, unless you use the ‘--no-members’ option.
In PostScript code, the tags are the functions.
In Prolog code, tags are predicates and rules at the beginning of line.
In Python code, def or class at the beginning of a line generate a tag.
In Ruby code, def or class or module at the beginning of a line generate a tag. Constants also generate tags.
In Rust code, tags anything defined with fn, enum, struct or macro_rules!.
You can also generate tags based on regexp matching (see Etags Regexps) to handle other formats and languages.


***** Creating Tags Tables

The etags program is used to create a tags table file. It knows the syntax of several languages, as described in Source File Tag Syntax. Here is how to run etags:

etags inputfiles…
The etags program reads the specified files, and writes a tags table named TAGS in the current working directory. You can optionally specify a different file name for the tags table by using the ‘--output=file’ option; specifying - as a file name prints the tags table to standard output. You can also append the newly created tags table to an existing file by using the ‘--append’ option.

If the specified files don’t exist, etags looks for compressed versions of them and uncompresses them to read them. Under MS-DOS, etags also looks for file names like mycode.cgz if it is given ‘mycode.c’ on the command line and mycode.c does not exist.

If the tags table becomes outdated due to changes in the files described in it, you can update it by running the etags program again. If the tags table does not record a tag, or records it for the wrong file, then Emacs will not be able to find that definition until you update the tags table. But if the position recorded in the tags table becomes a little bit wrong (due to other editing), Emacs will still be able to find the right position, with a slight delay.

Thus, there is no need to update the tags table after each edit. You should update a tags table when you define new tags that you want to have listed, or when you move tag definitions from one file to another, or when changes become substantial.

You can make a tags table include another tags table, by passing the ‘--include=file’ option to etags. It then covers all the files covered by the included tags file, as well as its own.

If you specify the source files with relative file names when you run etags, the tags file will contain file names relative to the directory where the tags file was initially written. This way, you can move an entire directory tree containing both the tags file and the source files, and the tags file will still refer correctly to the source files. If the tags file is - or is in the /dev directory, however, the file names are made relative to the current working directory. This is useful, for example, when writing the tags to the standard output.

When using a relative file name, it should not be a symbolic link pointing to a tags file in a different directory, because this would generally render the file names invalid.

If you specify absolute file names as arguments to etags, then the tags file will contain absolute file names. This way, the tags file will still refer to the same files even if you move it, as long as the source files remain in the same place. Absolute file names start with ‘/’, or with ‘device:/’ on MS-DOS and MS-Windows.

When you want to make a tags table from a great number of files, you may have problems listing them on the command line, because some systems have a limit on its length. You can circumvent this limit by telling etags to read the file names from its standard input, by typing a dash in place of the file names, like this:

find . -name "*.[chCH]" -print | etags -
etags recognizes the language used in an input file based on its file name and contents. It first tries to match the file’s name and extension to the ones commonly used with certain languages. Some languages have interpreters with known names (e.g., perl for Perl or pl for Prolog), so etags next looks for an interpreter specification of the form ‘#!interp’ on the first line of an input file, and matches that against known interpreters. If none of that works, or if you want to override the automatic detection of the language, you can specify the language explicitly with the ‘--language=name’ option. You can intermix these options with file names; each one applies to the file names that follow it. Specify ‘--language=auto’ to tell etags to resume guessing the language from the file names and file contents. Specify ‘--language=none’ to turn off language-specific processing entirely; then etags recognizes tags by regexp matching alone (see Etags Regexps). This comes in handy when an input file uses a language not yet supported by etags, and you want to avoid having etags fall back on Fortran and C as the default languages.

The option ‘--parse-stdin=file’ is mostly useful when calling etags from programs. It can be used (only once) in place of a file name on the command line. etags will read from standard input and mark the produced tags as belonging to the file file.

For C and C++, if the source files don’t observe the GNU Coding Standards’ convention if having braces (‘{’ and ‘}’) in column zero only for top-level definitions, like functions and struct definitions, we advise that you use the ‘--ignore-indentation’ option, to prevent etags from incorrectly interpreting closing braces in column zero.

‘etags --help’ outputs the list of the languages etags knows, and the file name rules for guessing the language. It also prints a list of all the available etags options, together with a short explanation. If followed by one or more ‘--language=lang’ options, it outputs detailed information about how tags are generated for lang.


***** Etags Regexps

The ‘--regex’ option to etags allows tags to be recognized by regular expression matching. You can intermix this option with file names; each one applies to the source files that follow it. If you specify multiple ‘--regex’ options, all of them are used in parallel. The syntax is:

--regex=[{language}]/tagregexp/[nameregexp/]modifiers
The essential part of the option value is tagregexp, the regexp for matching tags. It is always used anchored, that is, it only matches at the beginning of a line. If you want to allow indented tags, use a regexp that matches initial whitespace; start it with ‘[ \t]*’.

In these regular expressions, ‘\’ quotes the next character, and all the C character escape sequences are supported: ‘\a’ for bell, ‘\b’ for back space, ‘\e’ for escape, ‘\f’ for formfeed, ‘\n’ for newline, ‘\r’ for carriage return, ‘\t’ for tab, and ‘\v’ for vertical tab. In addition, ‘\d’ stands for the DEL character.

Ideally, tagregexp should not match more characters than are needed to recognize what you want to tag. If the syntax requires you to write tagregexp so it matches more characters beyond the tag itself, you should add a nameregexp, to pick out just the tag. This will enable Emacs to find tags more accurately and to do completion on tag names more reliably. In nameregexp, it is frequently convenient to use “back references” (see Backslash in Regular Expressions) to parenthesized groupings ‘\( … \)’ in tagregexp. For example, ‘\1’ refers to the first such parenthesized grouping. You can find some examples of this below.

The modifiers are a sequence of zero or more characters that modify the way etags does the matching. A regexp with no modifiers is applied sequentially to each line of the input file, in a case-sensitive way. The modifiers and their meanings are:

‘i’
Ignore case when matching this regexp.

‘m’
Match this regular expression against the whole file, so that multi-line matches are possible.

‘s’
Match this regular expression against the whole file, and allow ‘.’ in tagregexp to match newlines.

The ‘-R’ option cancels all the regexps defined by preceding ‘--regex’ options. It too applies to the file names following it. Here’s an example:

etags --regex=/reg1/i voo.doo --regex=/reg2/m \
    bar.ber -R --lang=lisp los.er
Here etags chooses the parsing language for voo.doo and bar.ber according to their contents. etags also uses reg1 to recognize additional tags in voo.doo, and both reg1 and reg2 to recognize additional tags in bar.ber. reg1 is checked against each line of voo.doo and bar.ber, in a case-insensitive way, while reg2 is checked against the whole bar.ber file, permitting multi-line matches, in a case-sensitive way. etags uses only the Lisp tags rules, with no user-specified regexp matching, to recognize tags in los.er.

You can restrict a ‘--regex’ option to match only files of a given language by using the optional prefix {language}. (‘etags --help’ prints the list of languages recognized by etags.) This is particularly useful when storing many predefined regular expressions for etags in a file. The following example tags the DEFVAR macros in the Emacs source files, for the C language only:

--regex='{c}/[ \t]*DEFVAR_[A-Z_ \t(]+"\([^"]+\)"/\1/'
When you have complex regular expressions, you can store the list of them in a file. The following option syntax instructs etags to read two files of regular expressions. The regular expressions contained in the second file are matched without regard to case.

--regex=@case-sensitive-file --ignore-case-regex=@ignore-case-file
A regex file for etags contains one regular expression per line. Empty lines, and lines beginning with space or tab are ignored. When the first character in a line is ‘@’, etags assumes that the rest of the line is the name of another file of regular expressions; thus, one such file can include another file. All the other lines are taken to be regular expressions. If the first non-whitespace text on the line is ‘--’, that line is a comment.

For example, we can create a file called ‘emacs.tags’ with the following contents:

        -- This is for GNU Emacs C source files
{c}/[ \t]*DEFVAR_[A-Z_ \t(]+"\([^"]+\)"/\1/
and then use it like this:

etags --regex=@emacs.tags *.[ch] */*.[ch]
Here are some more examples. The regexps are quoted to protect them from shell interpretation.

Tag Octave files:
etags --language=none \
      --regex='/[ \t]*function.*=[ \t]*\([^ \t]*\)[ \t]*(/\1/' \
      --regex='/###key \(.*\)/\1/' \
      --regex='/[ \t]*global[ \t].*/' \
      *.m
Note that tags are not generated for scripts, so that you have to add a line by yourself of the form ‘###key scriptname’ if you want to jump to it.

Tag Tcl files:
etags --language=none --regex='/proc[ \t]+\([^ \t]+\)/\1/' *.tcl
Tag VHDL files:
etags --language=none \
  --regex='/[ \t]*\(ARCHITECTURE\|CONFIGURATION\) +[^ ]* +OF/' \
  --regex='/[ \t]*\(ATTRIBUTE\|ENTITY\|FUNCTION\|PACKAGE\
  \( BODY\)?\|PROCEDURE\|PROCESS\|TYPE\)[ \t]+\([^ \t(]+\)/\3/'

  
**** Selecting a Tags Table

Emacs has at any time at most one selected tags table. All the commands for working with tags tables use the selected one first. To select a tags table, type M-x visit-tags-table, which reads the tags table file name as an argument, with TAGS defaulting to the first directory that contains a file named TAGS encountered when recursively searching upward from the default directory.

Emacs does not actually read in the tags table contents until you try to use them; all visit-tags-table does is store the file name in the variable tags-file-name, and not much more. The variable’s initial value is nil; that value tells all the commands for working with tags tables that they must ask for a tags table file name to use.

In addition to the selected tags table, Emacs maintains the list of several tags tables that you use together. For example, if you are working on a program that uses a library, you may wish to have the tags tables of both the program and the library available, so that Emacs could easily find identifiers from both. If the selected tags table doesn’t have the identifier or doesn’t mention the source file a tags command needs, the command will try using all the other tags tables in the current list of tags tables.

Using visit-tags-table to load a new tags table when another tags table is already loaded gives you a choice: you can add the new tags table to the current list of tags tables, or discard the current list and start a new list. If you start a new list, the new tags table is used instead of others. If you add the new table to the current list, it is used as well as the others.

You can specify a precise list of tags tables by setting the variable tags-table-list to a list of directory names, like this:

(setq tags-table-list
      '("~/.emacs.d" "/usr/local/lib/emacs/src"))
This tells the tags commands to look at the TAGS files in your ~/.emacs.d directory and in the /usr/local/lib/emacs/src directory. The order depends on which file you are in and which tags table mentions that file.

Do not set both tags-file-name and tags-table-list.


*** Emacs Development Environment

EDE (Emacs Development Environment) is a package that simplifies the task of creating, building, and debugging large programs with Emacs. It provides some of the features of an IDE, or Integrated Development Environment, in Emacs.

This section provides a brief description of EDE usage. For full details, see EDE in Emacs Development Environment.

EDE is implemented as a global minor mode (see Minor Modes). To enable it, type M-x global-ede-mode or click on the ‘Project Support (EDE)’ item in the ‘Tools’ menu. You can also enable EDE each time you start Emacs, by adding the following line to your initialization file:

(global-ede-mode t)
Activating EDE adds a menu named ‘Development’ to the menu bar. Many EDE commands, including the ones described below, can be invoked from this menu.

EDE organizes files into projects, which correspond to directory trees. The project root is the topmost directory of a project. To define a new project, visit a file in the desired project root and type M-x ede-new. This command prompts for a project type, which refers to the underlying method that EDE will use to manage the project (see EDE in Emacs Development Environment). The most common project types are ‘Make’, which uses Makefiles, and ‘Automake’, which uses GNU Automake (see Automake in Automake). In both cases, EDE also creates a file named Project.ede, which stores information about the project.

A project may contain one or more targets. A target can be an object file, executable program, or some other type of file, which is built from one or more of the files in the project.

To add a new target to a project, type C-c . t (M-x ede-new-target). This command also asks if you wish to add the current file to that target, which means that the target is to be built from that file. After you have defined a target, you can add more files to it by typing C-c . a (ede-add-file).

To build a target, type C-c . c (ede-compile-target). To build all the targets in the project, type C-c . C (ede-compile-project). EDE uses the file types to guess how the target should be built.


*** Merging Files with Emerge

It’s not unusual for programmers to get their signals crossed and modify the same program in two different directions. To recover from this confusion, you need to merge the two versions. Emerge makes this easier. For other ways to compare files, see Comparing Files, and Ediff in The Ediff Manual.

**** Overview of Emerge

To start Emerge, run one of these four commands:

M-x emerge-files ¶
Merge two specified files.

M-x emerge-files-with-ancestor ¶
Merge two specified files, with reference to a common ancestor.

M-x emerge-buffers ¶
Merge two buffers.

M-x emerge-buffers-with-ancestor ¶
Merge two buffers with reference to a common ancestor in a third buffer.

The Emerge commands compare two files or buffers, and display the comparison in three buffers: one for each input text (the A buffer and the B buffer), and one (the merge buffer) where merging takes place. The merge buffer shows the full merged text, not just the differences. Wherever the two input texts differ, you can choose which one of them to include in the merge buffer.

The Emerge commands that take input from existing buffers use only the accessible portions of those buffers, if they are narrowed. See Narrowing.

If a common ancestor version is available, from which the two texts to be merged were both derived, Emerge can use it to guess which alternative is right. Wherever one current version agrees with the ancestor, Emerge presumes that the other current version is a deliberate change which should be kept in the merged version. Use the ‘with-ancestor’ commands if you want to specify a common ancestor text. These commands read three file or buffer names—variant A, variant B, and the common ancestor.

After the comparison is done and the buffers are prepared, the interactive merging starts. You control the merging by typing special merge commands in the merge buffer (see Merge Commands). For each run of differences between the input texts, you can choose which one of them to keep, or edit them both together.

The merge buffer uses a special major mode, Emerge mode, with commands for making these choices. But you can also edit the buffer with ordinary Emacs commands.

At any given time, the attention of Emerge is focused on one particular difference, called the selected difference. This difference is marked off in the three buffers like this:

vvvvvvvvvvvvvvvvvvvv
text that differs
^^^^^^^^^^^^^^^^^^^^
Emerge numbers all the differences sequentially and the mode line always shows the number of the selected difference.

Normally, the merge buffer starts out with the A version of the text. But when the A version of a difference agrees with the common ancestor, then the B version is initially preferred for that difference.

Emerge leaves the merged text in the merge buffer when you exit. At that point, you can save it in a file with C-x C-w. If you give a numeric argument to emerge-files or emerge-files-with-ancestor, it reads the name of the output file using the minibuffer. (This is the last file name those commands read.) Then exiting from Emerge saves the merged text in the output file.

Normally, Emerge commands save the output buffer in its file when you exit. If you abort Emerge with C-], the Emerge command does not save the output buffer, but you can save it yourself if you wish.


**** Submodes of Emerge

You can choose between two modes for giving merge commands: Fast mode and Edit mode. In Fast mode, basic merge commands are single characters, but ordinary Emacs commands are disabled. This is convenient if you use only merge commands. In Edit mode, all merge commands start with the prefix key C-c C-c, and the normal Emacs commands are also available. This allows editing the merge buffer, but slows down Emerge operations.

Use e to switch to Edit mode, and C-c C-c f to switch to Fast mode. The mode line indicates Edit and Fast modes with ‘E’ and ‘F’.

Emerge has two additional submodes that affect how particular merge commands work: Auto Advance mode and Skip Prefers mode.

If Auto Advance mode is in effect, the a and b commands advance to the next difference. This lets you go through the merge faster as long as you simply choose one of the alternatives from the input. The mode line indicates Auto Advance mode with ‘A’.

If Skip Prefers mode is in effect, the n and p commands skip over differences in states “prefer-A” and “prefer-B” (see State of a Difference). Thus you see only differences for which neither version is presumed correct. The mode line indicates Skip Prefers mode with ‘S’. This mode is only relevant when there is an ancestor.

Use the command s a (emerge-auto-advance) to set or clear Auto Advance mode. Use s s (emerge-skip-prefers) to set or clear Skip Prefers mode. These commands turn on the mode with a positive argument, turn it off with a negative or zero argument, and toggle the mode with no argument.


**** State of a Difference

In the merge buffer, a difference is marked with lines of ‘v’ and ‘^’ characters. Each difference has one of these seven states:

A
The difference is showing the A version. The a command always produces this state; the mode line indicates it with ‘A’.

B
The difference is showing the B version. The b command always produces this state; the mode line indicates it with ‘B’.

default-A
default-B
The difference is showing the A or the B state by default, because you haven’t made a choice. All differences start in the default-A state (and thus the merge buffer is a copy of the A buffer), except those for which one alternative is preferred (see below).

When you select a difference, its state changes from default-A or default-B to plain A or B. Thus, the selected difference never has state default-A or default-B, and these states are never displayed in the mode line.

The command d a chooses default-A as the default state, and d b chooses default-B. This chosen default applies to all differences that you have never selected and for which no alternative is preferred. If you are moving through the merge sequentially, the differences you haven’t selected are those following the selected one. Thus, while moving sequentially, you can effectively make the A version the default for some sections of the merge buffer and the B version the default for others by using d a and d b between sections.

prefer-A
prefer-B
The difference is showing the A or B state because it is preferred. This means that you haven’t made an explicit choice, but one alternative seems likely to be right because the other alternative agrees with the common ancestor. Thus, where the A buffer agrees with the common ancestor, the B version is preferred, because chances are it is the one that was actually changed.

These two states are displayed in the mode line as ‘A*’ and ‘B*’.

combined
The difference is showing a combination of the A and B states, as a result of the x c or x C commands.

Once a difference is in this state, the a and b commands don’t do anything to it unless you give them a numeric argument.

The mode line displays this state as ‘comb’.


**** Merge Commands

Here are the Merge commands for Fast mode; in Edit mode, precede them with C-c C-c:

p
Select the previous difference.

n
Select the next difference.

a
Choose the A version of this difference.

b
Choose the B version of this difference.

C-u n j
Select difference number n.

.
Select the difference containing point.

q
Quit—finish the merge.

C-]
Abort—exit merging and do not save the output.

f
Go into Fast mode. (In Edit mode, this is actually C-c C-c f.)

e
Go into Edit mode.

l
Recenter (like C-l) all three windows. With an argument, reestablish the default three-window display.

-
Specify part of a prefix numeric argument.

digit
Also specify part of a prefix numeric argument.

d a
Choose the A version as the default from here down in the merge buffer.

d b
Choose the B version as the default from here down in the merge buffer.

c a
Copy the A version of this difference into the kill ring.

c b
Copy the B version of this difference into the kill ring.

i a
Insert the A version of this difference at point.

i b
Insert the B version of this difference at point.

m
Put point and mark around the difference.

^
Scroll all three windows down (like M-v).

v
Scroll all three windows up (like C-v).

<
Scroll all three windows left (like C-x <).

>
Scroll all three windows right (like C-x >).

|
Reset horizontal scroll on all three windows.

x 1
Shrink the merge window to one line. (Use C-u l to restore it to full size.)

x c
Combine the two versions of this difference (see Combining the Two Versions).

x f
Show the names of the files/buffers Emerge is operating on, in a Help window. (Use C-u l to restore windows.)

x j
Join this difference with the following one. (C-u x j joins this difference with the previous one.)

x s
Split this difference into two differences. Before you use this command, position point in each of the three buffers at the place where you want to split the difference.

x t
Trim identical lines off the top and bottom of the difference. Such lines occur when the A and B versions are identical but differ from the ancestor version.


**** Exiting Emerge

The q command (emerge-quit) finishes the merge, storing the results into the output file if you specified one. It restores the A and B buffers to their proper contents, or kills them if they were created by Emerge and you haven’t changed them. It also disables the Emerge commands in the merge buffer, since executing them later could damage the contents of the various buffers.

C-] aborts the merge. This means exiting without writing the output file. If you didn’t specify an output file, then there is no real difference between aborting and finishing the merge.

If the Emerge command was called from another Lisp program, then its return value is t for successful completion, or nil if you abort.


**** Combining the Two Versions

Sometimes you want to keep both alternatives for a particular difference. To do this, use x c, which edits the merge buffer like this:

#ifdef NEW
version from B buffer
#else /* not NEW */
version from A buffer
#endif /* not NEW */
While this example shows C preprocessor conditionals delimiting the two alternative versions, you can specify the strings to use by setting the variable emerge-combine-versions-template to a string of your choice. In the string, ‘%a’ says where to put version A, and ‘%b’ says where to put version B. The default setting, which produces the results shown above, looks like this:

"#ifdef NEW\n%b#else /* not NEW */\n%a#endif /* not NEW */\n"


**** Fine Points of Emerge

During the merge, you mustn’t try to edit the A and B buffers yourself. Emerge modifies them temporarily, but ultimately puts them back the way they were.

You can have any number of merges going at once—just don’t use any one buffer as input to more than one merge at once, since the temporary changes made in these buffers would get in each other’s way.

Starting Emerge can take a long time because it needs to compare the files fully. Emacs can’t do anything else until diff finishes. Perhaps in the future someone will change Emerge to do the comparison in the background when the input files are large—then you could keep on doing other things with Emacs until Emerge is ready to accept commands.

After setting up the merge, Emerge runs the hook emerge-startup-hook. See Hooks.


*** Bug Reference

Most projects with a certain amount of users track bug reports in some issue tracking software which assigns each report a unique and short number or identifier. Those are used to reference a given bug, e.g., in a source code comment above the code fixing some bug, in documentation files, or in discussions on some mailing list or IRC channel.

The minor modes bug-reference-mode and bug-reference-prog-mode highlight such bug references and make it possible to follow them to the corresponding bug report on the project’s issue tracker. bug-reference-prog-mode is a variant of bug-reference-mode which highlights bug references only inside source code comments and strings.

For its working, bug reference mode needs to know the syntax of bug references (bug-reference-bug-regexp), and the URL of the tracker where bug reports can be looked up (bug-reference-url-format). Since those are typically different from project to project, it makes sense to specify them in see Per-Directory Local Variables or see Local Variables in Files.

For example, let’s assume in our project, we usually write references to bug reports as bug#1234, or Bug-1234 and that this bug’s page on the issue tracker is https://project.org/issues/1234, then these local variables section would do.

;; Local Variables:
;; bug-reference-bug-regexp: "\\([Bb]ug[#-]\\([0-9]+\\)\\)"
;; bug-reference-url-format: "https://project.org/issues/%s"
;; End:
The string captured by the first regexp group defines the bounds of the overlay bug-reference creates, i.e., the part which is highlighted and made clickable.

The string captured by the second regexp group in bug-reference-bug-regexp is used to replace the %s template in the bug-reference-url-format.

Note that bug-reference-url-format may also be a function in order to cater for more complex scenarios, e.g., when different parts of the bug reference have to be used to distinguish between issues and merge requests resulting in different URLs.

Automatic Setup
If bug-reference-mode is activated, bug-reference-mode-hook has been run and still bug-reference-bug-regexp, and bug-reference-url-format aren’t both set, it’ll try to setup suitable values for these two variables itself by calling the functions in bug-reference-auto-setup-functions one after the other until one is able to set the variables.

Right now, there are three types of setup functions.

Setup for version-controlled files configurable by the variables bug-reference-forge-alist, and bug-reference-setup-from-vc-alist. The defaults are able to setup GNU projects where https://debbugs.gnu.org is used as issue tracker and issues are usually referenced as bug#13 (but many different notations are considered, too), and several kinds of modern software forges such as GitLab, Gitea, SourceHut, or GitHub. If you deploy a self-hosted instance of such a forge, the easiest way to tell bug-reference about it is through bug-reference-forge-alist.
Setup for email guessing from mail folder/mbox names, and mail header values configurable by the variable bug-reference-setup-from-mail-alist. The built-in news- and mailreader Email and Usenet News with Gnus and Reading Mail with Rmail are supported.
Setup for IRC channels configurable by the variable bug-reference-setup-from-irc-alist. The built-in IRC clients Rcirc, See Rcirc in The Rcirc Manual, and ERC, See ERC in The ERC Manual, are supported.
For almost all of those modes, it’s enough to simply enable bug-reference-mode, only Rmail requires a slightly different setup.

;; Use VC-based setup if file is under version control.
(add-hook 'prog-mode-hook #'bug-reference-prog-mode)

;; Gnus (summary & article buffers)
(add-hook 'gnus-mode-hook #'bug-reference-mode)

;; Rmail
(add-hook 'rmail-show-message-hook #'bug-reference-mode-force-auto-setup)

;; Rcirc
(add-hook 'rcirc-mode-hook #'bug-reference-mode)

;; ERC
(add-hook 'erc-mode-hook #'bug-reference-mode)
In the Rmail case, instead of the mode hook, the rmail-show-message-hook has to be used in combination with the function bug-reference-mode-force-auto-setup which activates bug-reference-mode and forces auto-setup. The reason is that with Rmail all messages reside in the same buffer but the setup needs to be performed whenever another messages is displayed.

Adding support for third-party packages
Adding support for bug-reference’ auto-setup is usually quite straight-forward: write a setup function of zero arguments which gathers the required information (e.g., List-Id/To/From/Cc mail header values in the case of a MUA), and then calls one of the following helper functions:

bug-reference-maybe-setup-from-vc which does the setup according to bug-reference-setup-from-vc-alist,
bug-reference-maybe-setup-from-mail which does the setup according to bug-reference-setup-from-mail-alist,
and bug-reference-maybe-setup-from-irc which does the setup according to bug-reference-setup-from-irc-alist.
A setup function should return non-nil if it could setup bug-reference mode which is the case if the last thing the function does is calling one of the helper functions above.

Finally, the setup function has to be added to bug-reference-auto-setup-functions.

Note that these auto-setup functions should check as a first step if they are applicable, e.g., by checking the major-mode value.

Integration with the debbugs package
If your project’s issues are tracked on the server https://debbugs.gnu.org, you can browse and reply to reports directly in Emacs using the debbugs package, which can be downloaded via the Package Menu (see Emacs Lisp Packages). This package adds the minor mode debbugs-browse-mode, which can be activated on top of bug-reference-mode and bug-reference-prog-mode as follows:

(add-hook 'bug-reference-mode-hook 'debbugs-browse-mode)
(add-hook 'bug-reference-prog-mode-hook 'debbugs-browse-mode)



** International Character Set Support

Emacs supports a wide variety of international character sets, including European and Vietnamese variants of the Latin alphabet, as well as Arabic scripts, Brahmic scripts (for languages such as Bengali, Hindi, and Thai), Cyrillic, Ethiopic, Georgian, Greek, Han (for Chinese and Japanese), Hangul (for Korean), Hebrew and IPA. Emacs also supports various encodings of these characters that are used by other internationalized software, such as word processors and mailers.

Emacs allows editing text with international characters by supporting all the related activities:

You can visit files with non-ASCII characters, save non-ASCII text, and pass non-ASCII text between Emacs and programs it invokes (such as compilers, spell-checkers, and mailers). Setting your language environment (see Language Environments) takes care of setting up the coding systems and other options for a specific language or culture. Alternatively, you can specify how Emacs should encode or decode text for each command; see Specifying a Coding System for File Text.
You can display non-ASCII characters encoded by the various scripts. This works by using appropriate fonts on graphics displays (see Defining Fontsets), and by sending special codes to text displays (see Coding Systems for Terminal I/O). If some characters are displayed incorrectly, refer to Undisplayable Characters, which describes possible problems and explains how to solve them.
Characters from scripts whose natural ordering of text is from right to left are reordered for display (see Bidirectional Editing). These scripts include Arabic, Hebrew, Syriac, Thaana, and a few others.
You can insert non-ASCII characters or search for them. To do that, you can specify an Emacs input method (see Selecting an Input Method) suitable for your language, or use the default input method set up when you choose your language environment. If your keyboard can produce non-ASCII characters, you can select an appropriate keyboard coding system (see Coding Systems for Terminal I/O), and Emacs will accept those characters. On graphical displays, modern systems typically provide their native input methods, and Latin-1 characters can also be input by using the C-x 8 prefix, see Unibyte Editing Mode.
With the X Window System, your locale should be set to an appropriate value to make sure Emacs interprets keyboard input correctly; see locales, and Coding Systems for X Keyboard Input.


*** Introduction to International Character Sets

The users of international character sets and scripts have established many more-or-less standard coding systems for storing files. These coding systems are typically multibyte, meaning that sequences of two or more bytes are used to represent individual non-ASCII characters.

Internally, Emacs uses its own multibyte character encoding, which is a superset of the Unicode standard. This internal encoding allows characters from almost every known script to be intermixed in a single buffer or string. Emacs translates between the multibyte character encoding and various other coding systems when reading and writing files, and when exchanging data with subprocesses.

The command C-h h (view-hello-file) displays the file etc/HELLO, which illustrates various scripts by showing how to say “hello” in many languages. If some characters can’t be displayed on your terminal, they appear as ‘?’ or as hollow boxes (see Undisplayable Characters).

Keyboards, even in the countries where these character sets are used, generally don’t have keys for all the characters in them. You can insert characters that your keyboard does not support, using C-x 8 RET (insert-char). See Inserting Text. Shorthands are available for some common characters; for example, you can insert a left single quotation mark ‘ by typing C-x 8 [, or in Electric Quote mode, usually by simply typing `. See Quotation Marks. Emacs also supports various input methods, typically one for each script or language, which make it easier to type characters in the script. See Input Methods.

The prefix key C-x RET is used for commands that pertain to multibyte characters, coding systems, and input methods.

The command C-x = (what-cursor-position) shows information about the character at point. In addition to the character position, which was described in Cursor Position Information, this command displays how the character is encoded. For instance, it displays the following line in the echo area for the character ‘c’:

Char: c (99, #o143, #x63) point=28062 of 36168 (78%) column=53
The four values after ‘Char:’ describe the character that follows point, first by showing it and then by giving its character code in decimal, octal and hex. For a non-ASCII multibyte character, these are followed by ‘file’ and the character’s representation, in hex, in the buffer’s coding system, if that coding system encodes the character safely and with a single byte (see Coding Systems). If the character’s encoding is longer than one byte, Emacs shows ‘file ...’.

On rare occasions, Emacs encounters raw bytes: single bytes whose values are in the range 128 (0200 octal) through 255 (0377 octal), which Emacs cannot interpret as part of a known encoding of some non-ASCII character. Such raw bytes are treated as if they belonged to a special character set eight-bit; Emacs displays them as escaped octal codes (this can be customized; see Customization of Display). In this case, C-x = shows ‘raw-byte’ instead of ‘file’. In addition, C-x = shows the character codes of raw bytes as if they were in the range #x3FFF80..#x3FFFFF, which is where Emacs maps them to distinguish them from Unicode characters in the range #x0080..#x00FF.

With a prefix argument (C-u C-x =), this command additionally calls the command describe-char, which displays a detailed description of the character:

The character set name, and the codes that identify the character within that character set; ASCII characters are identified as belonging to the ascii character set.
The character’s script, syntax and categories.
What keys to type to input the character in the current input method (if it supports the character).
The character’s encodings, both internally in the buffer, and externally if you were to save the buffer to a file.
If you are running Emacs on a graphical display, the font name and glyph code for the character. If you are running Emacs on a text terminal, the code(s) sent to the terminal.
If the character was composed on display with any following characters to form one or more grapheme clusters, the composition information: the font glyphs if the frame is on a graphical display, and the characters that were composed.
The character’s text properties (see Text Properties in the Emacs Lisp Reference Manual), including any non-default faces used to display the character, and any overlays containing it (see Overlays in the same manual).
Here’s an example, with some lines folded to fit into this manual:

position: 1 of 1 (0%), column: 0
character: ê (displayed as ê) (codepoint 234, #o352, #xea)
preferred charset: unicode (Unicode (ISO10646))
code point in charset: 0xEA
script: latin
syntax: w        which means: word
category: .:Base, L:Left-to-right (strong), c:Chinese,
j:Japanese, l:Latin, v:Viet
to input: type "C-x 8 RET ea" or
"C-x 8 RET LATIN SMALL LETTER E WITH CIRCUMFLEX"
buffer code: #xC3 #xAA
file code: #xC3 #xAA (encoded by coding system utf-8-unix)
display: by this font (glyph code)
xft:-PfEd-DejaVu Sans Mono-normal-normal-
normal-*-15-*-*-*-m-0-iso10646-1 (#xAC)

Character code properties: customize what to show
name: LATIN SMALL LETTER E WITH CIRCUMFLEX
old-name: LATIN SMALL LETTER E CIRCUMFLEX
general-category: Ll (Letter, Lowercase)
decomposition: (101 770) ('e' '^')

  
*** Language Environments

All supported character sets are supported in Emacs buffers whenever multibyte characters are enabled; there is no need to select a particular language in order to display its characters. However, it is important to select a language environment in order to set various defaults. Roughly speaking, the language environment represents a choice of preferred script rather than a choice of language.

The language environment controls which coding systems to recognize when reading text (see Recognizing Coding Systems). This applies to files, incoming mail, and any other text you read into Emacs. It may also specify the default coding system to use when you create a file. Each language environment also specifies a default input method.

To select a language environment, customize current-language-environment or use the command M-x set-language-environment. It makes no difference which buffer is current when you use this command, because the effects apply globally to the Emacs session. See the variable language-info-alist for the list of supported language environments, and use the command C-h L lang-env RET (describe-language-environment) for more information about the language environment lang-env. Supported language environments include:

ASCII, Arabic, Belarusian, Bengali, Brazilian Portuguese, Bulgarian, Burmese, Cham, Chinese-BIG5, Chinese-CNS, Chinese-EUC-TW, Chinese-GB, Chinese-GB18030, Chinese-GBK, Croatian, Cyrillic-ALT, Cyrillic-ISO, Cyrillic-KOI8, Czech, Devanagari, Dutch, English, Esperanto, Ethiopic, French, Georgian, German, Greek, Gujarati, Hebrew, IPA, Italian, Japanese, Kannada, Khmer, Korean, Lao, Latin-1, Latin-2, Latin-3, Latin-4, Latin-5, Latin-6, Latin-7, Latin-8, Latin-9, Latvian, Lithuanian, Malayalam, Oriya, Persian, Polish, Punjabi, Romanian, Russian, Sinhala, Slovak, Slovenian, Spanish, Swedish, TaiViet, Tajik, Tamil, Telugu, Thai, Tibetan, Turkish, UTF-8, Ukrainian, Vietnamese, Welsh, and Windows-1255.

To display the script(s) used by your language environment on a graphical display, you need to have suitable fonts. See Fontsets, for more details about setting up your fonts.

Some operating systems let you specify the character-set locale you are using by setting the locale environment variables LC_ALL, LC_CTYPE, or LANG. (If more than one of these is set, the first one that is nonempty specifies your locale for this purpose.) During startup, Emacs looks up your character-set locale’s name in the system locale alias table, matches its canonical name against entries in the value of the variables locale-charset-language-names and locale-language-names (the former overrides the latter), and selects the corresponding language environment if a match is found. It also adjusts the display table and terminal coding system, the locale coding system, the preferred coding system as needed for the locale, and—last but not least—the way Emacs decodes non-ASCII characters sent by your keyboard.

If you modify the LC_ALL, LC_CTYPE, or LANG environment variables while running Emacs (by using M-x setenv), you may want to invoke the set-locale-environment command afterwards to readjust the language environment from the new locale.

The set-locale-environment function normally uses the preferred coding system established by the language environment to decode system messages. But if your locale matches an entry in the variable locale-preferred-coding-systems, Emacs uses the corresponding coding system instead. For example, if the locale ‘ja_JP.PCK’ matches japanese-shift-jis in locale-preferred-coding-systems, Emacs uses that encoding even though it might normally use utf-8.

You can override the language environment chosen at startup with explicit use of the command set-language-environment, or with customization of current-language-environment in your init file.

To display information about the effects of a certain language environment lang-env, use the command C-h L lang-env RET (describe-language-environment). This tells you which languages this language environment is useful for, and lists the character sets, coding systems, and input methods that go with it. It also shows some sample text to illustrate scripts used in this language environment. If you give an empty input for lang-env, this command describes the chosen language environment.

You can customize any language environment with the normal hook set-language-environment-hook. The command set-language-environment runs that hook after setting up the new language environment. The hook functions can test for a specific language environment by checking the variable current-language-environment. This hook is where you should put non-default settings for specific language environments, such as coding systems for keyboard input and terminal output, the default input method, etc.

Before it starts to set up the new language environment, set-language-environment first runs the hook exit-language-environment-hook. This hook is useful for undoing customizations that were made with set-language-environment-hook. For instance, if you set up a special key binding in a specific language environment using set-language-environment-hook, you should set up exit-language-environment-hook to restore the normal binding for that key.


*** Input Methods

An input method is a kind of character conversion designed specifically for interactive input. This section describes input methods that come with Emacs; for native input methods provided by the underlying OS, see Unibyte Editing Mode.

In Emacs, typically each language has its own input method; sometimes several languages that use the same characters can share one input method. A few languages support several input methods.

The simplest kind of input method works by mapping ASCII letters into another alphabet; this allows you to use one other alphabet instead of ASCII. The Greek and Russian input methods work this way.

A more powerful technique is composition: converting sequences of characters into one letter. Many European input methods use composition to produce a single non-ASCII letter from a sequence that consists of a letter followed by accent characters (or vice versa). For example, some methods convert the sequence o ^ into a single accented letter. These input methods have no special commands of their own; all they do is compose sequences of printing characters.

The input methods for syllabic scripts typically use mapping followed by composition. The input methods for Thai and Korean work this way. First, letters are mapped into symbols for particular sounds or tone marks; then, sequences of these that make up a whole syllable are mapped into one syllable sign.

Chinese and Japanese require more complex methods. In Chinese input methods, first you enter the phonetic spelling of a Chinese word (in input method chinese-py, among others), or a sequence of portions of the character (input methods chinese-4corner and chinese-sw, and others). One input sequence typically corresponds to many possible Chinese characters. You select the one you mean using keys such as C-f, C-b, C-n, C-p (or the arrow keys), and digits, which have special meanings in this situation.

The possible characters are conceptually arranged in several rows, with each row holding up to 10 alternatives. Normally, Emacs displays just one row at a time, in the echo area; (i/j) appears at the beginning, to indicate that this is the ith row out of a total of j rows. Type C-n or C-p to display the next row or the previous row.

Type C-f and C-b to move forward and backward among the alternatives in the current row. As you do this, Emacs highlights the current alternative with a special color; type C-SPC to select the current alternative and use it as input. The alternatives in the row are also numbered; the number appears before the alternative. Typing a number selects the associated alternative of the current row and uses it as input.

TAB in these Chinese input methods displays a buffer showing all the possible characters at once; then clicking mouse-2 on one of them selects that alternative. The keys C-f, C-b, C-n, C-p, and digits continue to work as usual, but they do the highlighting in the buffer showing the possible characters, rather than in the echo area.

To enter characters according to the pīnyīn transliteration method instead, use the chinese-sisheng input method. This is a composition based method, where e.g. pi1 results in ‘pī’.

In Japanese input methods, first you input a whole word using phonetic spelling; then, after the word is in the buffer, Emacs converts it into one or more characters using a large dictionary. One phonetic spelling corresponds to a number of different Japanese words; to select one of them, use C-n and C-p to cycle through the alternatives.

Sometimes it is useful to cut off input method processing so that the characters you have just entered will not combine with subsequent characters. For example, in input method latin-1-postfix, the sequence o ^ combines to form an ‘o’ with an accent. What if you want to enter them as separate characters?

One way is to type the accent twice; this is a special feature for entering the separate letter and accent. For example, o ^ ^ gives you the two characters ‘o^’. Another way is to type another letter after the o—something that won’t combine with that—and immediately delete it. For example, you could type o o DEL ^ to get separate ‘o’ and ‘^’. Another method, more general but not quite as easy to type, is to use C-\ C-\ between two characters to stop them from combining. This is the command C-\ (toggle-input-method) used twice. See Selecting an Input Method.

C-\ C-\ is especially useful inside an incremental search, because it stops waiting for more characters to combine, and starts searching for what you have already entered.

To find out how to input the character after point using the current input method, type C-u C-x =. See Cursor Position Information.

The variables input-method-highlight-flag and input-method-verbose-flag control how input methods explain what is happening. If input-method-highlight-flag is non-nil, the partial sequence is highlighted in the buffer (for most input methods—some disable this feature). If input-method-verbose-flag is non-nil, the list of possible characters to type next is displayed in the echo area (but not when you are in the minibuffer).

You can modify how an input method works by making your changes in a function that you add to the hook variable quail-activate-hook. See Hooks. For example, you can redefine some of the input method’s keys by defining key bindings in the keymap returned by the function quail-translation-keymap, using define-key. See Rebinding Keys in Your Init File.

Input methods are inhibited when the text in the buffer is read-only for some reason. This is so single-character key bindings work in modes that make buffer text or parts of it read-only, such as read-only-mode and image-mode, even when an input method is active.

Another facility for typing characters not on your keyboard is by using C-x 8 RET (insert-char) to insert a single character based on its Unicode name or code-point; see Inserting Text.

There are specialized commands for inserting Emoji, and these can be found on the C-x 8 e keymap. C-x 8 e e (emoji-insert) will let you navigate through different Emoji categories and then choose one. C-x 8 e l (emoji-list) will pop up a new buffer and list all the Emoji; clicking (or using RET) on an emoji character will insert it in the current buffer. Finally, C-x 8 e s (emoji-search) will allow you to search for Emoji based on their names.

describe-char displays a lot of information about the character/glyphs under point (including emojis). It’s sometimes useful to get a quick description of the name, and you can use the C-x 8 e d (emoji-describe) command to do that. It’s meant primarily to help distinguish between different Emoji variants (which can look very similar), but it will also tell you the names of non-Emoji characters.


*** Selecting an Input Method

C-\
Enable or disable use of the selected input method (toggle-input-method).

C-x RET C-\ method RET
Select a new input method for the current buffer (set-input-method).

C-x \ method RET
Temporarily enable the selected transient input method ; it will be automatically disabled after inserting a single character (activate-transient-input-method).

C-h I method RET ¶
C-h C-\ method RET
Describe the input method method (describe-input-method). By default, it describes the current input method (if any). This description should give you the full details of how to use any particular input method.

M-x list-input-methods
Display a list of all the supported input methods.

To choose an input method for the current buffer, use C-x RET C-\ (set-input-method). This command reads the input method name from the minibuffer; the name normally starts with the language environment that it is meant to be used with. The variable current-input-method records which input method is selected.

Input methods use various sequences of ASCII characters to stand for non-ASCII characters. Sometimes it is useful to turn off the input method temporarily. To do this, type C-\ (toggle-input-method). To reenable the input method, type C-\ again.

If you type C-\ and you have not yet selected an input method, it prompts you to specify one. This has the same effect as using C-x RET C-\ to specify an input method.

When invoked with a numeric argument, as in C-u C-\, toggle-input-method always prompts you for an input method, suggesting the most recently selected one as the default.

Selecting a language environment specifies a default input method for use in various buffers. When you have a default input method, you can select it in the current buffer by typing C-\. The variable default-input-method specifies the default input method (nil means there is none).

In some language environments, which support several different input methods, you might want to use an input method different from the default chosen by set-language-environment. You can instruct Emacs to select a different default input method for a certain language environment, if you wish, by using set-language-environment-hook (see set-language-environment-hook). For example:

(defun my-chinese-setup ()
"Set up my private Chinese environment."
(if (equal current-language-environment "Chinese-GB")
(setq default-input-method "chinese-tonepy")))
(add-hook 'set-language-environment-hook 'my-chinese-setup)
This sets the default input method to be chinese-tonepy whenever you choose a Chinese-GB language environment.

You can instruct Emacs to activate a certain input method automatically. For example:

(add-hook 'text-mode-hook
(lambda () (set-input-method "german-prefix")))
This automatically activates the input method german-prefix in Text mode.

Some input methods for alphabetic scripts work by (in effect) remapping the keyboard to emulate various keyboard layouts commonly used for those scripts. How to do this remapping properly depends on your actual keyboard layout. To specify which layout your keyboard has, use the command M-x quail-set-keyboard-layout.

You can use the command M-x quail-show-key to show what key (or key sequence) to type in order to input the character following point, using the selected keyboard layout. The command C-u C-x = also shows that information, in addition to other information about the character.

M-x list-input-methods displays a list of all the supported input methods. The list gives information about each input method, including the string that stands for it in the mode line.

Sometimes it can be convenient to enable an input method transiently, for inserting only a single character. Typing C-x \ (activate-transient-input-method) will temporarily enable an input method, let you insert a single character using the input method rules, and then automatically disable the input method. If no transient input method was selected yet, C-x \ will prompt you for an input method; subsequent invocations of this command will enable the selected transient input method. To select a different transient input method, type C-u C-x \. You can select a transient method that is different from the input method which you selected using C-u C-\.


*** Coding Systems

Users of various languages have established many more-or-less standard coding systems for representing them. Emacs does not use these coding systems internally; instead, it converts from various coding systems to its own system when reading data, and converts the internal coding system to other coding systems when writing data. Conversion is possible in reading or writing files, in sending or receiving from the terminal, and in exchanging data with subprocesses.

Emacs assigns a name to each coding system. Most coding systems are used for one language, and the name of the coding system starts with the language name. Some coding systems are used for several languages; their names usually start with ‘iso’. There are also special coding systems, such as no-conversion, raw-text, and emacs-internal.

A special class of coding systems, collectively known as codepages, is designed to support text encoded by MS-Windows and MS-DOS software. The names of these coding systems are cpnnnn, where nnnn is a 3- or 4-digit number of the codepage. You can use these encodings just like any other coding system; for example, to visit a file encoded in codepage 850, type C-x RET c cp850 RET C-x C-f filename RET.

In addition to converting various representations of non-ASCII characters, a coding system can perform end-of-line conversion. Emacs handles three different conventions for how to separate lines in a file: newline (Unix), carriage return followed by linefeed (DOS), and just carriage return (Mac).

C-h C coding RET
Describe coding system coding (describe-coding-system).

C-h C RET
Describe the coding systems currently in use (describe-coding-system).

M-x list-coding-systems
Display a list of all the supported coding systems.

The command C-h C (describe-coding-system) displays information about particular coding systems, including the end-of-line conversion specified by those coding systems. You can specify a coding system name as the argument; alternatively, with an empty argument, it describes the coding systems currently selected for various purposes, both in the current buffer and as the defaults, and the priority list for recognizing coding systems (see Recognizing Coding Systems).

To display a list of all the supported coding systems, type M-x list-coding-systems. The list gives information about each coding system, including the letter that stands for it in the mode line (see The Mode Line).

Each of the coding systems that appear in this list—except for no-conversion, which means no conversion of any kind—specifies how and whether to convert printing characters, but leaves the choice of end-of-line conversion to be decided based on the contents of each file. For example, if the file appears to use the sequence carriage return and linefeed to separate lines, DOS end-of-line conversion will be used.

Each of the listed coding systems has three variants, which specify exactly what to do for end-of-line conversion:

…-unix
Don’t do any end-of-line conversion; assume the file uses newline to separate lines. (This is the convention normally used on Unix and GNU systems, and macOS.)

…-dos
Assume the file uses carriage return followed by linefeed to separate lines, and do the appropriate conversion. (This is the convention normally used on Microsoft systems.9)

…-mac
Assume the file uses carriage return to separate lines, and do the appropriate conversion. (This was the convention used in Classic Mac OS.)

These variant coding systems are omitted from the list-coding-systems display for brevity, since they are entirely predictable. For example, the coding system iso-latin-1 has variants iso-latin-1-unix, iso-latin-1-dos and iso-latin-1-mac.

The coding systems unix, dos, and mac are aliases for undecided-unix, undecided-dos, and undecided-mac, respectively. These coding systems specify only the end-of-line conversion, and leave the character code conversion to be deduced from the text itself.

The coding system raw-text is good for a file which is mainly ASCII text, but may contain byte values above 127 that are not meant to encode non-ASCII characters. With raw-text, Emacs copies those byte values unchanged, and sets enable-multibyte-characters to nil in the current buffer so that they will be interpreted properly. raw-text handles end-of-line conversion in the usual way, based on the data encountered, and has the usual three variants to specify the kind of end-of-line conversion to use.

In contrast, the coding system no-conversion specifies no character code conversion at all—none for non-ASCII byte values and none for end of line. This is useful for reading or writing binary files, tar files, and other files that must be examined verbatim. It, too, sets enable-multibyte-characters to nil.

The easiest way to edit a file with no conversion of any kind is with the M-x find-file-literally command. This uses no-conversion, and also suppresses other Emacs features that might convert the file contents before you see them. See Visiting Files.

The coding system emacs-internal (or utf-8-emacs, which is equivalent) means that the file contains non-ASCII characters stored with the internal Emacs encoding. This coding system handles end-of-line conversion based on the data encountered, and has the usual three variants to specify the kind of end-of-line conversion.

Footnotes
(9)
It is also specified for MIME ‘text/*’ bodies and in other network transport contexts. It is different from the SGML reference syntax record-start/record-end format, which Emacs doesn’t support directly.


*** Recognizing Coding Systems

Whenever Emacs reads a given piece of text, it tries to recognize which coding system to use. This applies to files being read, output from subprocesses, text from X selections, etc. Emacs can select the right coding system automatically most of the time—once you have specified your preferences.

Some coding systems can be recognized or distinguished by which byte sequences appear in the data. However, there are coding systems that cannot be distinguished, not even potentially. For example, there is no way to distinguish between Latin-1 and Latin-2; they use the same byte values with different meanings.

Emacs handles this situation by means of a priority list of coding systems. Whenever Emacs reads a file, if you do not specify the coding system to use, Emacs checks the data against each coding system, starting with the first in priority and working down the list, until it finds a coding system that fits the data. Then it converts the file contents assuming that they are represented in this coding system.

The priority list of coding systems depends on the selected language environment (see Language Environments). For example, if you use French, you probably want Emacs to prefer Latin-1 to Latin-2; if you use Czech, you probably want Latin-2 to be preferred. This is one of the reasons to specify a language environment.

However, you can alter the coding system priority list in detail with the command M-x prefer-coding-system. This command reads the name of a coding system from the minibuffer, and adds it to the front of the priority list, so that it is preferred to all others. If you use this command several times, each use adds one element to the front of the priority list.

If you use a coding system that specifies the end-of-line conversion type, such as iso-8859-1-dos, what this means is that Emacs should attempt to recognize iso-8859-1 with priority, and should use DOS end-of-line conversion when it does recognize iso-8859-1.

Sometimes a file name indicates which coding system to use for the file. The variable file-coding-system-alist specifies this correspondence. There is a special function modify-coding-system-alist for adding elements to this list. For example, to read and write all ‘.txt’ files using the coding system chinese-iso-8bit, you can execute this Lisp expression:

(modify-coding-system-alist 'file "\\.txt\\'" 'chinese-iso-8bit)
The first argument should be file, the second argument should be a regular expression that determines which files this applies to, and the third argument says which coding system to use for these files.

Emacs recognizes which kind of end-of-line conversion to use based on the contents of the file: if it sees only carriage returns, or only carriage return followed by linefeed sequences, then it chooses the end-of-line conversion accordingly. You can inhibit the automatic use of end-of-line conversion by setting the variable inhibit-eol-conversion to non-nil. If you do that, DOS-style files will be displayed with the ‘^M’ characters visible in the buffer; some people prefer this to the more subtle ‘(DOS)’ end-of-line type indication near the left edge of the mode line (see eol-mnemonic).

By default, the automatic detection of the coding system is sensitive to escape sequences. If Emacs sees a sequence of characters that begin with an escape character, and the sequence is valid as an ISO-2022 code, that tells Emacs to use one of the ISO-2022 encodings to decode the file.

However, there may be cases that you want to read escape sequences in a file as is. In such a case, you can set the variable inhibit-iso-escape-detection to non-nil. Then the code detection ignores any escape sequences, and never uses an ISO-2022 encoding. The result is that all escape sequences become visible in the buffer.

The default value of inhibit-iso-escape-detection is nil. We recommend that you not change it permanently, only for one specific operation. That’s because some Emacs Lisp source files in the Emacs distribution contain non-ASCII characters encoded in the coding system iso-2022-7bit, and they won’t be decoded correctly when you visit those files if you suppress the escape sequence detection.

The variables auto-coding-alist and auto-coding-regexp-alist are the strongest way to specify the coding system for certain patterns of file names, or for files containing certain patterns, respectively. These variables even override ‘-*-coding:-*-’ tags in the file itself (see Specifying a File’s Coding System). For example, Emacs uses auto-coding-alist for tar and archive files, to prevent it from being confused by a ‘-*-coding:-*-’ tag in a member of the archive and thinking it applies to the archive file as a whole.

Another way to specify a coding system is with the variable auto-coding-functions. For example, one of the builtin auto-coding-functions detects the encoding for XML files. Unlike the previous two, this variable does not override any ‘-*-coding:-*-’ tag.


*** Specifying a File’s Coding System

If Emacs recognizes the encoding of a file incorrectly, you can reread the file using the correct coding system with C-x RET r (revert-buffer-with-coding-system). This command prompts for the coding system to use. To see what coding system Emacs actually used to decode the file, look at the coding system mnemonic letter near the left edge of the mode line (see The Mode Line), or type C-h C (describe-coding-system).

You can specify the coding system for a particular file in the file itself, using the ‘-*-…-*-’ construct at the beginning, or a local variables list at the end (see Local Variables in Files). You do this by defining a value for the “variable” named coding. Emacs does not really have a variable coding; instead of setting a variable, this uses the specified coding system for the file. For example, ‘-*-mode: C; coding: latin-1; -*-’ specifies use of the Latin-1 coding system, as well as C mode. When you specify the coding explicitly in the file, that overrides file-coding-system-alist.


*** Choosing Coding Systems for Output

Once Emacs has chosen a coding system for a buffer, it stores that coding system in buffer-file-coding-system. That makes it the default for operations that write from this buffer into a file, such as save-buffer and write-region. You can specify a different coding system for further file output from the buffer using set-buffer-file-coding-system (see Specifying a Coding System for File Text).

You can insert any character Emacs supports into any Emacs buffer, but most coding systems can only handle a subset of these characters. Therefore, it’s possible that the characters you insert cannot be encoded with the coding system that will be used to save the buffer. For example, you could visit a text file in Polish, encoded in iso-8859-2, and add some Russian words to it. When you save that buffer, Emacs cannot use the current value of buffer-file-coding-system, because the characters you added cannot be encoded by that coding system.

When that happens, Emacs tries the most-preferred coding system (set by M-x prefer-coding-system or M-x set-language-environment). If that coding system can safely encode all of the characters in the buffer, Emacs uses it, and stores its value in buffer-file-coding-system. Otherwise, Emacs displays a list of coding systems suitable for encoding the buffer’s contents, and asks you to choose one of those coding systems.

If you insert the unsuitable characters in a mail message, Emacs behaves a bit differently. It additionally checks whether the most-preferred coding system is recommended for use in MIME messages; if not, it informs you of this fact and prompts you for another coding system. This is so you won’t inadvertently send a message encoded in a way that your recipient’s mail software will have difficulty decoding. (You can still use an unsuitable coding system if you enter its name at the prompt.)

When you send a mail message (see Sending Mail), Emacs has four different ways to determine the coding system to use for encoding the message text. It first tries the buffer’s own value of buffer-file-coding-system, if that is non-nil. Otherwise, it uses the value of sendmail-coding-system, if that is non-nil. Thirdly, it uses the value of default-sendmail-coding-system. If all of these three values are nil, Emacs encodes outgoing mail using the default coding system for new files (i.e., the default value of buffer-file-coding-system), which is controlled by your choice of language environment.


*** Specifying a Coding System for File Text

In cases where Emacs does not automatically choose the right coding system for a file’s contents, you can use these commands to specify one:

C-x RET f coding RET
Use coding system coding to save or revisit the file in the current buffer (set-buffer-file-coding-system).

C-x RET c coding RET
Specify coding system coding for the immediately following command (universal-coding-system-argument).

C-x RET r coding RET
Revisit the current file using the coding system coding (revert-buffer-with-coding-system).

M-x recode-region RET right RET wrong RET
Convert a region that was decoded using coding system wrong, decoding it using coding system right instead.

The command C-x RET f (set-buffer-file-coding-system) sets the file coding system for the current buffer (i.e., the coding system to use when saving or reverting the file). You specify which coding system using the minibuffer. You can also invoke this command by clicking with mouse-3 on the coding system indicator in the mode line (see The Mode Line).

If you specify a coding system that cannot handle all the characters in the buffer, Emacs will warn you about the troublesome characters, and ask you to choose another coding system, when you try to save the buffer (see Choosing Coding Systems for Output).

You can also use this command to specify the end-of-line conversion (see end-of-line conversion) for encoding the current buffer. For example, C-x RET f dos RET will cause Emacs to save the current buffer’s text with DOS-style carriage return followed by linefeed line endings.

Another way to specify the coding system for a file is when you visit the file. First use the command C-x RET c (universal-coding-system-argument); this command uses the minibuffer to read a coding system name. After you exit the minibuffer, the specified coding system is used for the immediately following command.

So if the immediately following command is C-x C-f, for example, it reads the file using that coding system (and records the coding system for when you later save the file). Or if the immediately following command is C-x C-w, it writes the file using that coding system. When you specify the coding system for saving in this way, instead of with C-x RET f, there is no warning if the buffer contains characters that the coding system cannot handle.

Other file commands affected by a specified coding system include C-x i and C-x C-v, as well as the other-window variants of C-x C-f. C-x RET c also affects commands that start subprocesses, including M-x shell (see Running Shell Commands from Emacs). If the immediately following command does not use the coding system, then C-x RET c ultimately has no effect.

An easy way to visit a file with no conversion is with the M-x find-file-literally command. See Visiting Files.

The default value of the variable buffer-file-coding-system specifies the choice of coding system to use when you create a new file. It applies when you find a new file, and when you create a buffer and then save it in a file. Selecting a language environment typically sets this variable to a good choice of default coding system for that language environment.

If you visit a file with a wrong coding system, you can correct this with C-x RET r (revert-buffer-with-coding-system). This visits the current file again, using a coding system you specify.

If a piece of text has already been inserted into a buffer using the wrong coding system, you can redo the decoding of it using M-x recode-region. This prompts you for the proper coding system, then for the wrong coding system that was actually used, and does the conversion. It first encodes the region using the wrong coding system, then decodes it again using the proper coding system.


*** Coding Systems for Interprocess Communication

This section explains how to specify coding systems for use in communication with other processes.

C-x RET x coding RET
Use coding system coding for transferring selections to and from other graphical applications (set-selection-coding-system).

C-x RET X coding RET
Use coding system coding for transferring one selection—the next one—to or from another graphical application (set-next-selection-coding-system).

C-x RET p input-coding RET output-coding RET
Use coding systems input-coding and output-coding for subprocess input and output in the current buffer (set-buffer-process-coding-system).

The command C-x RET x (set-selection-coding-system) specifies the coding system for sending selected text to other windowing applications, and for receiving the text of selections made in other applications. This command applies to all subsequent selections, until you override it by using the command again. The command C-x RET X (set-next-selection-coding-system) specifies the coding system for the next selection made in Emacs or read by Emacs.

The variable x-select-request-type specifies the data type to request from the X Window System for receiving text selections from other applications. If the value is nil (the default), Emacs tries UTF8_STRING and COMPOUND_TEXT, in this order, and uses various heuristics to choose the more appropriate of the two results; if none of these succeed, Emacs falls back on STRING. If the value of x-select-request-type is one of the symbols COMPOUND_TEXT, UTF8_STRING, STRING, or TEXT, Emacs uses only that request type. If the value is a list of some of these symbols, Emacs tries only the request types in the list, in order, until one of them succeeds, or until the list is exhausted.

The command C-x RET p (set-buffer-process-coding-system) specifies the coding system for input and output to a subprocess. This command applies to the current buffer; normally, each subprocess has its own buffer, and thus you can use this command to specify translation to and from a particular subprocess by giving the command in the corresponding buffer.

You can also use C-x RET c (universal-coding-system-argument) just before the command that runs or starts a subprocess, to specify the coding system for communicating with that subprocess. See Specifying a Coding System for File Text.

The default for translation of process input and output depends on the current language environment.

The variable locale-coding-system specifies a coding system to use when encoding and decoding system strings such as system error messages and format-time-string formats and time stamps. That coding system might also be used for decoding non-ASCII keyboard input on the X Window System and will also be used to encode text sent to the standard output and error streams in batch mode. You should choose a coding system that is compatible with the underlying system’s text representation, which is normally specified by one of the environment variables LC_ALL, LC_CTYPE, and LANG. (The first one, in the order specified above, whose value is nonempty is the one that determines the text representation.)


*** Coding Systems for File Names

C-x RET F coding RET
Use coding system coding for encoding and decoding file names (set-file-name-coding-system).

The command C-x RET F (set-file-name-coding-system) specifies a coding system to use for encoding file names. It has no effect on reading and writing the contents of files.

In fact, all this command does is set the value of the variable file-name-coding-system. If you set the variable to a coding system name (as a Lisp symbol or a string), Emacs encodes file names using that coding system for all file operations. This makes it possible to use non-ASCII characters in file names—or, at least, those non-ASCII characters that the specified coding system can encode.

If file-name-coding-system is nil, Emacs uses a default coding system determined by the selected language environment, and stored in the default-file-name-coding-system variable (normally UTF-8).

When Emacs runs on MS-Windows versions that are descendants of the NT family (Windows 2000, XP, and all the later versions), the value of file-name-coding-system is largely ignored, as Emacs by default uses APIs that allow passing Unicode file names directly. By contrast, on Windows 9X, file names are encoded using file-name-coding-system, which should be set to the codepage (see codepage) pertinent for the current system locale. The value of the variable w32-unicode-filenames controls whether Emacs uses the Unicode APIs when it calls OS functions that accept file names. This variable is set by the startup code to nil on Windows 9X, and to t on newer versions of MS-Windows.

Warning: if you change file-name-coding-system (or the language environment) in the middle of an Emacs session, problems can result if you have already visited files whose names were encoded using the earlier coding system and cannot be encoded (or are encoded differently) under the new coding system. If you try to save one of these buffers under the visited file name, saving may use the wrong file name, or it may encounter an error. If such a problem happens, use C-x C-w to specify a new file name for that buffer.

If a mistake occurs when encoding a file name, use the command M-x recode-file-name to change the file name’s coding system. This prompts for an existing file name, its old coding system, and the coding system to which you wish to convert.


*** Coding Systems for X Keyboard Input

Input methods under the X Window System specify their own coding systems that must be used to decode keyboard input. By default, Emacs determines the coding system used for each input method automatically upon establishing the connection to the input method server, and uses that specific coding system to decode keyboard input. However, that determination can sometimes fail; in that situation, the locale coding system (see Coding Systems for Interprocess Communication) is used instead.

If the input method does not correctly announce the coding system it uses to encode text, then the coding system used by Emacs to decode text from input methods must be manually specified. The value of the variable x-input-coding-system, when set to a symbol, is unconditionally used as the coding system used to decode keyboard input from input methods.


*** Coding Systems for Terminal I/O

C-x RET t coding RET
Use coding system coding for terminal output (set-terminal-coding-system).

C-x RET k coding RET
Use coding system coding for keyboard input (set-keyboard-coding-system).

The command C-x RET t (set-terminal-coding-system) specifies the coding system for terminal output. If you specify a character code for terminal output, all characters output to the terminal are translated into that coding system.

This feature is useful for certain character-only terminals built to support specific languages or character sets—for example, European terminals that support one of the ISO Latin character sets. You need to specify the terminal coding system when using multibyte text, so that Emacs knows which characters the terminal can actually handle.

By default, output to the terminal is not translated at all, unless Emacs can deduce the proper coding system from your terminal type or your locale specification (see Language Environments).

The command C-x RET k (set-keyboard-coding-system), or the variable keyboard-coding-system, specifies the coding system for keyboard input. Character-code translation of keyboard input is useful for terminals with keys that send non-ASCII graphic characters—for example, some terminals designed for ISO Latin-1 or subsets of it.

By default, keyboard input is translated based on your system locale setting. If your terminal does not really support the encoding implied by your locale (for example, if you find it inserts a non-ASCII character if you type M-i), you will need to set keyboard-coding-system to nil to turn off encoding. You can do this by putting

(set-keyboard-coding-system nil)
in your init file.

Setting keyboard-coding-system has no effect on MS-Windows, except on old Windows 9X systems, in which case the encoding must match the current codepage of the MS-Windows console, which can be changed by calling w32-set-console-codepage.

There is a similarity between using a coding system translation for keyboard input, and using an input method: both define sequences of keyboard input that translate into single characters. However, input methods are designed to be convenient for interactive use by humans, and the sequences that are translated are typically sequences of ASCII printing characters. Coding systems typically translate sequences of non-graphic characters.


*** Fontsets

A font typically defines shapes for a single alphabet or script. Therefore, displaying the entire range of scripts that Emacs supports requires a collection of many fonts. In Emacs, such a collection is called a fontset. A fontset is defined by a list of font specifications, each assigned to handle a range of character codes, and may fall back on another fontset for characters that are not covered by the fonts it specifies.

Each fontset has a name, like a font. However, while fonts are stored in the system and the available font names are defined by the system, fontsets are defined within Emacs itself. Once you have defined a fontset, you can use it within Emacs by specifying its name, anywhere that you could use a single font. Of course, Emacs fontsets can use only the fonts that your system supports. If some characters appear on the screen as empty boxes or hex codes, this means that the fontset in use for them has no font for those characters. In this case, or if the characters are shown, but not as well as you would like, you may need to install extra fonts or modify the fontset to use specific fonts already installed on your system (see below). Your operating system may have optional fonts that you can install; or you can install the GNU Intlfonts package, which includes fonts for most supported scripts.10

Emacs creates three fontsets automatically: the standard fontset, the startup fontset and the default fontset. The default fontset is most likely to have fonts for a wide variety of non-ASCII characters, and is the default fallback for the other two fontsets, and if you set a default font rather than fontset. However, it does not specify font family names, so results can be somewhat random if you use it directly. You can specify a particular fontset by starting Emacs with the ‘-fn’ option. For example,

emacs -fn fontset-standard
You can also specify a fontset with the ‘Font’ resource (see X Options and Resources).

If no fontset is specified for use, then Emacs uses an ASCII font, with ‘fontset-default’ as a fallback for characters the font does not cover. The standard fontset is only used if explicitly requested, despite its name.

To show the information about a specific fontset, use the M-x describe-fontset command. It prompts for a fontset name, defaulting to the one used by the current frame, and then displays all the subranges of characters and the fonts assigned to them in that fontset. To see which fonts Emacs is using in a session started without a specific fontset (which is what happens normally), type fontset-default RET at the prompt, or just RET to describe the fontset used by the current frame.

A fontset does not necessarily specify a font for every character code. If a fontset specifies no font for a certain character, or if it specifies a font that does not exist on your system, then it cannot display that character properly. It will display that character as a hex code or thin space or an empty box instead. (See glyphless characters, for details.) Or a fontset might specify a font for some range of characters, but you may not like their visual appearance. If this happens, you may wish to modify your fontset; see Modifying Fontsets, for how to do that.

Footnotes
(10)
If you run Emacs on X, you may need to inform the X server about the location of the newly installed fonts with commands such as:

xset fp+ /usr/local/share/emacs/fonts
xset fp rehash

 
*** Defining Fontsets

When running on X, Emacs creates a standard fontset automatically according to the value of standard-fontset-spec. This fontset’s name is

-*-fixed-medium-r-normal-*-16-*-*-*-*-*-fontset-standard
or just ‘fontset-standard’ for short.

On GNUstep and macOS, the standard fontset is created using the value of ns-standard-fontset-spec, and on MS Windows it is created using the value of w32-standard-fontset-spec.

Bold, italic, and bold-italic variants of the standard fontset are created automatically. Their names have ‘bold’ instead of ‘medium’, or ‘i’ instead of ‘r’, or both.

Emacs generates a fontset automatically, based on any default ASCII font that you specify with the ‘Font’ resource or the ‘-fn’ argument, or the default font that Emacs found when it started. This is the startup fontset and its name is fontset-startup. Emacs generates this fontset by replacing the charset_registry field with ‘fontset’, and replacing the charset_encoding field with ‘startup’, then using the resulting string to specify a fontset.

For instance, if you start Emacs with a font of this form,

emacs -fn "*courier-medium-r-normal--14-140-*-iso8859-1"
Emacs generates the following fontset and uses it for the initial X window frame:

-*-courier-medium-r-normal-*-14-140-*-*-*-*-fontset-startup
The startup fontset will use the font that you specify, or a variant with a different registry and encoding, for all the characters that are supported by that font, and fallback on ‘fontset-default’ for other characters.

With the X resource ‘Emacs.Font’, you can specify a fontset name just like an actual font name. But be careful not to specify a fontset name in a wildcard resource like ‘Emacs*Font’—that wildcard specification matches various other resources, such as for menus, and menus cannot handle fontsets. See X Options and Resources.

You can specify additional fontsets using X resources named ‘Fontset-n’, where n is an integer starting from 0. The resource value should have this form:

fontpattern, [charset:font]…
where fontpattern should have the form of a standard X font name (see the previous fontset-startup example), except for the last two fields. They should have the form ‘fontset-alias’.

Each fontset has two names, one long and one short. The long name is fontpattern. The short name is ‘fontset-alias’, the last 2 fields of the long name (e.g., ‘fontset-startup’ for the fontset automatically created at startup). You can refer to the fontset by either name.

The construct ‘charset:font’ specifies which font to use (in this fontset) for one particular character set. Here, charset is the name of a character set, and font is the font to use for that character set. You can use this construct any number of times in defining one fontset.

For the other character sets, Emacs chooses a font based on fontpattern. It replaces ‘fontset-alias’ with values that describe the character set. For the ASCII character font, ‘fontset-alias’ is replaced with ‘ISO8859-1’.

In addition, when several consecutive fields are wildcards, Emacs collapses them into a single wildcard. This is to prevent use of auto-scaled fonts. Fonts made by scaling larger fonts are not usable for editing, and scaling a smaller font is also not useful, because it is better to use the smaller font in its own size, which is what Emacs does.

Thus if fontpattern is this,

-*-fixed-medium-r-normal-*-24-*-*-*-*-*-fontset-24
the font specification for ASCII characters would be this:

-*-fixed-medium-r-normal-*-24-*-ISO8859-1
and the font specification for Chinese GB2312 characters would be this:

-*-fixed-medium-r-normal-*-24-*-gb2312*-*
You may not have any Chinese font matching the above font specification. Most X distributions include only Chinese fonts that have ‘song ti’ or ‘fangsong ti’ in the family field. In such a case, ‘Fontset-n’ can be specified as:

Emacs.Fontset-0: -*-fixed-medium-r-normal-*-24-*-*-*-*-*-fontset-24,\
chinese-gb2312:-*-*-medium-r-normal-*-24-*-gb2312*-*
Then, the font specifications for all but Chinese GB2312 characters have ‘fixed’ in the family field, and the font specification for Chinese GB2312 characters has a wild card ‘*’ in the family field.

The function that processes the fontset resource value to create the fontset is called create-fontset-from-fontset-spec. You can also call this function explicitly to create a fontset.


*** Modifying Fontsets

Fontsets do not always have to be created from scratch. If only minor changes are required it may be easier to modify an existing fontset, usually ‘fontset-default’. Modifying ‘fontset-default’ will also affect other fontsets that use it as a fallback, so can be an effective way of fixing problems with the fonts that Emacs chooses for a particular script.

Fontsets can be modified using the function set-fontset-font, specifying a character, a charset, a script, or a range of characters to modify the font for, and a font specification for the font to be used. Some examples are:

;; Prefer a big5 font for han characters.
(set-fontset-font "fontset-default"
'han (font-spec :registry "big5")
nil 'prepend)

;; Use MyPrivateFont for the Unicode private use area.
(set-fontset-font "fontset-default"  '(#xe000 . #xf8ff)
"MyPrivateFont")

;; Use Liberation Mono for latin-3 charset.
(set-fontset-font "fontset-default" 'iso-8859-3
"Liberation Mono")

;; Use DejaVu Sans Mono as a fallback in fontset-startup
;; before resorting to fontset-default.
(set-fontset-font "fontset-startup" nil "DejaVu Sans Mono"
nil 'append)
See Fontsets in GNU Emacs Lisp Reference Manual, for more details about using the set-fontset-font function.

If you don’t know the character’s codepoint or the script to which it belongs, you can ask Emacs. With point at the character, type C-u C-x = (what-cursor-position), and this information, together with much more, will be displayed in the *Help* buffer that Emacs pops up. See Cursor Position Information. For example, Japanese characters belong to the ‘kana’ script, but Japanese text also mixes them with Chinese characters so the following uses the ‘han’ script to set up Emacs to use the ‘Kochi Gothic’ font for Japanese text:

(set-fontset-font "fontset-default" 'han "Kochi Gothic")
(For convenience, the ‘han’ script in Emacs is set up to support all of the Chinese, Japanese, and Korean, a.k.a. CJK, characters, not just Chinese characters.)

For the list of known scripts, see the variable script-representative-chars.

Fontset settings like those above only affect characters that the default font doesn’t support, so if the ‘Kochi Gothic’ font covers Latin characters, it will not be used for displaying Latin scripts, since the default font used by Emacs usually covers Basic Latin.

Some fonts installed on your system might be broken, or produce unpleasant results for characters for which they are used, and you may wish to instruct Emacs to completely ignore them while searching for a suitable font required to display a character. You can do that by adding the offending fonts to the value of the variable face-ignored-fonts, which is a list. Here’s an example to put in your ~/.emacs:

(add-to-list 'face-ignored-fonts "Some Bad Font")


*** Undisplayable Characters
There may be some non-ASCII characters that your terminal cannot display. Most text terminals support just a single character set (use the variable default-terminal-coding-system to tell Emacs which one, Coding Systems for Terminal I/O); characters that can’t be encoded in that coding system are displayed as ‘?’ by default.

Graphical displays can display a broader range of characters, but you may not have fonts installed for all of them; characters that have no font appear as a hollow box.

If you use Latin-1 characters but your terminal can’t display Latin-1, you can arrange to display mnemonic ASCII sequences instead, e.g., ‘"o’ for o-umlaut. Load the library iso-ascii to do this.

If your terminal can display Latin-1, you can display characters from other European character sets using a mixture of equivalent Latin-1 characters and ASCII mnemonics. Customize the variable latin1-display to enable this. The mnemonic ASCII sequences mostly correspond to those of the prefix input methods.


*** Unibyte Editing Mode

The ISO 8859 Latin-n character sets define character codes in the range 0240 to 0377 octal (160 to 255 decimal) to handle the accented letters and punctuation needed by various European languages (and some non-European ones). Note that Emacs considers bytes with codes in this range as raw bytes, not as characters, even in a unibyte buffer, i.e., if you disable multibyte characters. However, Emacs can still handle these character codes as if they belonged to one of the single-byte character sets at a time. To specify which of these codes to use, invoke M-x set-language-environment and specify a suitable language environment such as ‘Latin-n’. See Disabling Multibyte Characters in GNU Emacs Lisp Reference Manual.

Emacs can also display bytes in the range 160 to 255 as readable characters, provided the terminal or font in use supports them. This works automatically. On a graphical display, Emacs can also display single-byte characters through fontsets, in effect by displaying the equivalent multibyte characters according to the current language environment. To request this, set the variable unibyte-display-via-language-environment to a non-nil value. Note that setting this only affects how these bytes are displayed, but does not change the fundamental fact that Emacs treats them as raw bytes, not as characters.

If your terminal does not support display of the Latin-1 character set, Emacs can display these characters as ASCII sequences which at least give you a clear idea of what the characters are. To do this, load the library iso-ascii. Similar libraries for other Latin-n character sets could be implemented, but have not been so far.

Normally non-ISO-8859 characters (decimal codes between 128 and 159 inclusive) are displayed as octal escapes. You can change this for non-standard extended versions of ISO-8859 character sets by using the function standard-display-8bit in the disp-table library.

There are two ways to input single-byte non-ASCII characters:

You can use an input method for the selected language environment. See Input Methods. When you use an input method in a unibyte buffer, the non-ASCII character you specify with it is converted to unibyte.
If your keyboard can generate character codes 128 (decimal) and up, representing non-ASCII characters, you can type those character codes directly.
On a graphical display, you should not need to do anything special to use these keys; they should simply work. On a text terminal, you should use the command M-x set-keyboard-coding-system or customize the variable keyboard-coding-system to specify which coding system your keyboard uses (see Coding Systems for Terminal I/O). Enabling this feature will probably require you to use ESC to type Meta characters; however, on a console terminal or a terminal emulator such as xterm, you can arrange for Meta to be converted to ESC and still be able to type 8-bit characters present directly on the keyboard or using Compose or AltGr keys. See Kinds of User Input.

Many modern systems provide native input methods for many languages whose characters don’t have keyboard keys assigned to them. If Emacs was built with support for these native input methods, you can activate such an input method and type the characters they support. How to activate and use these input methods depends on the system and the input method, and will not be described here; see your system documentation. Here we describe some Emacs facilities to control the use of the native input methods.

In Emacs built with the GTK toolkit, the variable x-gtk-use-native-input controls whether Emacs should receive characters produced by GTK input methods. If the value is nil, the default, Emacs uses the X input methods (XIM), otherwise it uses the GTK input methods. The useXIM X resource controls whether to use XIM, and inputStyle X resource controls the display on X of preview text generated by the native input methods; see Table of X Resources for Emacs.

On MS-Windows, Emacs supports native inputs methods provided by IMM, the Input Method Manager, but that can be turned off if needed; see Keyboard Usage on MS-Windows.

You can use the key C-x 8 as a compose-character prefix for entry of non-ASCII Latin-1 and other printing characters. C-x 8 is good for insertion (in the minibuffer as well as other buffers), for searching, and in any other context where a key sequence is allowed.
C-x 8 works by loading the iso-transl library. Once that library is loaded, the Alt modifier key, if the keyboard has one, serves the same purpose as C-x 8: use Alt together with an accent character to modify the following letter. In addition, if the keyboard has keys for the Latin-1 dead accent characters, they too are defined to compose with the following character, once iso-transl is loaded.

Use C-x 8 C-h to list all the available C-x 8 translations.


*** Charsets

In Emacs, charset is short for “character set”. Emacs supports most popular charsets (such as ascii, iso-8859-1, cp1250, big5, and unicode), in addition to some charsets of its own (such as emacs, unicode-bmp, and eight-bit). All supported characters belong to one or more charsets.

Emacs normally does the right thing with respect to charsets, so that you don’t have to worry about them. However, it is sometimes helpful to know some of the underlying details about charsets.

One example is font selection (see Fonts). Each language environment (see Language Environments) defines a priority list for the various charsets. When searching for a font, Emacs initially attempts to find one that can display the highest-priority charsets. For instance, in the Japanese language environment, the charset japanese-jisx0208 has the highest priority, so Emacs tries to use a font whose registry property is ‘JISX0208.1983-0’.

There are two commands that can be used to obtain information about charsets. The command M-x list-charset-chars prompts for a charset name, and displays all the characters in that character set. The command M-x describe-character-set prompts for a charset name, and displays information about that charset, including its internal representation within Emacs.

M-x list-character-sets displays a list of all supported charsets. The list gives the names of charsets and additional information to identity each charset; for more details, see the ISO International Register of Coded Character Sets to be Used with Escape Sequences (ISO-IR) maintained by the Information Processing Society of Japan/Information Technology Standards Commission of Japan (IPSJ/ITSCJ). In this list, charsets are divided into two categories: normal charsets are listed first, followed by supplementary charsets. A supplementary charset is one that is used to define another charset (as a parent or a subset), or to provide backward-compatibility for older Emacs versions.

To find out which charset a character in the buffer belongs to, put point before it and type C-u C-x = (see Introduction to International Character Sets).


*** Bidirectional Editing

Emacs supports editing text written in scripts, such as Arabic, Farsi, and Hebrew, whose natural ordering of horizontal text for display is from right to left. However, digits and Latin text embedded in these scripts are still displayed left to right. It is also not uncommon to have small portions of text in Arabic or Hebrew embedded in an otherwise Latin document; e.g., as comments and strings in a program source file. For these reasons, text that uses these scripts is actually bidirectional: a mixture of runs of left-to-right and right-to-left characters.

This section describes the facilities and options provided by Emacs for editing bidirectional text.

Emacs stores right-to-left and bidirectional text in the so-called logical (or reading) order: the buffer or string position of the first character you read precedes that of the next character. Reordering of bidirectional text into the visual order happens at display time. As a result, character positions no longer increase monotonically with their positions on display. Emacs implements the Unicode Bidirectional Algorithm (UBA) described in the Unicode Standard Annex #9, for reordering of bidirectional text for display. It deviates from the UBA only in how continuation lines are displayed when text direction is opposite to the base paragraph direction, e.g., when a long line of English text appears in a right-to-left paragraph.

The buffer-local variable bidi-display-reordering controls whether text in the buffer is reordered for display. If its value is non-nil, Emacs reorders characters that have right-to-left directionality when they are displayed. The default value is t.

Each paragraph of bidirectional text can have its own base direction, either right-to-left or left-to-right. Text in left-to-right paragraphs begins on the screen at the left margin of the window and is truncated or continued when it reaches the right margin. By contrast, text in right-to-left paragraphs is displayed starting at the right margin and is continued or truncated at the left margin. By default, paragraph boundaries are empty lines, i.e., lines consisting entirely of whitespace characters. To change that, you can customize the two variables bidi-paragraph-start-re and bidi-paragraph-separate-re, whose values should be regular expressions (strings); e.g., to have a single newline start a new paragraph, set both of these variables to "^". These two variables are buffer-local (see Local Variables).

Emacs determines the base direction of each paragraph dynamically, based on the text at the beginning of the paragraph. However, sometimes a buffer may need to force a certain base direction for its paragraphs. The variable bidi-paragraph-direction, if non-nil, disables the dynamic determination of the base direction, and instead forces all paragraphs in the buffer to have the direction specified by its buffer-local value. The value can be either right-to-left or left-to-right. Any other value is interpreted as nil.

Alternatively, you can control the base direction of a paragraph by inserting special formatting characters in front of the paragraph. The special character RIGHT-TO-LEFT MARK, or RLM, forces the right-to-left direction on the following paragraph, while LEFT-TO-RIGHT MARK, or LRM forces the left-to-right direction. (You can use C-x 8 RET to insert these characters.) In a GUI session, the LRM and RLM characters display as very thin blank characters; on text terminals they display as blanks.

Because characters are reordered for display, Emacs commands that operate in the logical order or on stretches of buffer positions may produce unusual effects. For example, the commands C-f and C-b move point in the logical order, so the cursor will sometimes jump when point traverses reordered bidirectional text. Similarly, a highlighted region covering a contiguous range of character positions may look discontinuous if the region spans reordered text. This is normal and similar to the behavior of other programs that support bidirectional text.

Cursor motion commands bound to arrow keys, such as LEFT and C-RIGHT, are sensitive to the base direction of the current paragraph. In a left-to-right paragraph, commands bound to RIGHT with or without modifiers move forward through buffer text, but in a right-to-left paragraph they move backward instead. This reflects the fact that in a right-to-left paragraph buffer positions predominantly increase when moving to the left on display.

When you move out of a paragraph, the meaning of the arrow keys might change if the base direction of the preceding or the following paragraph is different from the paragraph out of which you moved. When that happens, you need to adjust the arrow key you press to the new base direction.

By default, LEFT and RIGHT move in the logical order, but if visual-order-cursor-movement is non-nil, these commands move to the character that is, correspondingly, to the left or right of the current screen position, moving to the next or previous screen line as appropriate. Note that this might potentially move point many buffer positions away, depending on the surrounding bidirectional context.

Bidirectional text sometimes uses special formatting characters to affect the reordering of text for display. The LRM and RLM characters, mentioned above, are two such characters, but there are more of them. They are by default displayed as thin space glyphs on GUI frames, and as simple spaces on text-mode frames. If you want to be aware of these special control characters, so that their effect on display does not come as a surprise, you can turn on the glyphless-display-mode (see How Text Is Displayed). This minor mode will cause these formatting characters to be displayed as acronyms inside a small box, so that they stand out on display, and make their effect easier to understand.




** The Org Manual (check macro replacement)

*** Introduction

**** Summary

Org Mode is an authoring tool and a TODO lists manager for GNU Emacs. It relies on a lightweight plain-text markup language used in files with the ‘.org’ extension.

Authoring Org files is best supported by Emacs, but you can view, understand, and change them with any text editor.

As an authoring tool, Org helps you write structured documents and provides exporting facilities. Org files can also be used for literate programming and reproducible research. As a TODO lists manager, Org helps you organize your tasks in a flexible way, from daily needs to detailed project-planning, allowing logging, multiple views on your tasks, exporting your agendas, etc.

Org mode is implemented on top of Outline mode, which makes it possible to keep the content of large files well structured. Visibility cycling and structure editing help to work with the tree. Tables are easily created with a built-in table editor. Plain text URL-like links connect to websites, emails, Usenet messages, BBDB entries, and any files related to the projects.

Org develops organizational tasks around notes files that contain lists or information about projects as plain text. Project planning and task management make use of metadata which is part of an outline node. Based on this data, specific entries can be extracted in queries and create dynamic agenda views that also integrate the Emacs calendar and diary. Org can be used to implement many different project planning schemes, such as David Allen’s GTD system.

Org files can serve as a single source authoring system with export to many different formats such as HTML, LaTeX, Open Document, and Markdown. New export backends can be derived from existing ones, or defined from scratch.

Org files can include source code blocks, which makes Org uniquely suited for authoring technical documents with code examples. Org source code blocks are fully functional; they can be evaluated in place and their results can be captured in the file. This makes it possible to create a single file reproducible research compendium.

Org keeps simple things simple. When first fired up, it should feel like a straightforward, easy to use outliner. Complexity is not imposed, but a large amount of functionality is available when needed. Org is a toolbox. Many users actually run only a—very personal—fraction of Org’s capabilities, and know that there is more whenever they need it.

All of this is achieved with strictly plain text files, the most portable and future-proof file format. Org runs in Emacs. Emacs is one of the most widely ported programs, so that Org mode is available on every major platform.

There is a website for Org which provides links to the newest version of Org, as well as additional information, frequently asked questions (FAQ), links to tutorials, etc. This page is located at https://orgmode.org.

An earlier version (7.3) of this manual was available as a paperback book from the Network Theory Ltd. publishing company, closed in 2009.


**** Installation

Org is included in distributions of GNU Emacs, you probably do not need to install it. Most users will simply activate Org and begin exploring its features.

If, for one reason or another, you want to install Org on top of this pre-packaged version, you can use the Emacs package system or clone Org’s git repository. We strongly recommend sticking to a single installation method.

When installing Org on top of the pre-packaged version, please note that Org stable versions are meant to be fully compatible with the last three stable versions of Emacs but not with older Emacsen.

Some Org components also depend on third-party packages available through package archives. Org is only guaranteed to be compatible with the latest stable versions of these third-party packages.

Using Emacs packaging system
Recent Emacs distributions include a packaging system which lets you install Elisp libraries. You can install Org from the “package menu”, with M-x list-packages. See Package Menu.

Important: You need to do this in a session where no ‘.org’ file has been visited, i.e., where no Org built-in function have been loaded. Otherwise autoload Org functions will mess up the installation.

To avoid interference with built-in Org mode, you can use command line:

emacs -Q -batch -eval "(progn (require 'package) (package-initialize) (package-refresh-contents) (package-upgrade 'org))"
This approach has the advantage of isolating the upgrade process from a running Emacs session, ensuring that version conflicts can not arise.

Using Org’s git repository
You can clone Org’s repository and install Org like this:

$ cd ~/src/
$ git clone https://git.savannah.gnu.org/git/emacs/org-mode.git
$ cd org-mode/
$ make autoloads
Note that in this case, ‘make autoloads’ is mandatory: it defines Org’s version in ‘org-version.el’ and Org’s autoloads in ‘org-loaddefs.el’.

Make sure you set the load path correctly in your Emacs init file:

(add-to-list 'load-path "~/src/org-mode/lisp")
You can also compile with ‘make’, generate the documentation with ‘make doc’, create a local configuration with ‘make config’ and install Org with ‘make install’. Please run ‘make help’ to get the list of compilation/installation options.

For more detailed explanations on Org’s build system, please check the Org Build System page on Worg.

Installing Org’s contributed packages
Org’s repository used to contain ‘contrib/’ directory for add-ons contributed by others. As of Org 9.5, the directory has been moved to the dedicated org-contrib repository, which you can install separately as a package from NonGNU ELPA.

There are enough valuable packages maintained outside of the Org repository. Worg has a list of org-contrib and external packages, certainly it is not exhaustive.


**** Activation

Org mode buffers need Font Lock to be turned on: this is the default in Emacs1.

There are compatibility issues between Org mode and some other Elisp packages (see Packages that conflict with Org mode). Please take the time to check the list.

For a better experience, the three Org commands org-store-link, org-capture and org-agenda ought to be accessible anywhere in Emacs, not just in Org buffers. To that effect, you need to bind them to globally available keys, like the ones reserved for users (see (elisp)Key Binding Conventions). Here are suggested bindings, please modify the keys to your own liking in your personal init file.

(global-set-key (kbd "C-c l") #'org-store-link)
(global-set-key (kbd "C-c a") #'org-agenda)
(global-set-key (kbd "C-c c") #'org-capture)
Files with the ‘.org’ extension use Org mode by default. To turn on Org mode in a file that does not have the extension ‘.org’, make the first line of a file look like this:

MY PROJECTS    -*- mode: org; -*-
which selects Org mode for this buffer no matter what the file’s name is. See also the variable org-insert-mode-line-in-empty-file.

Many commands in Org work on the region if the region is active. To make use of this, you need to have Transient Mark mode turned on, which is the default. If you do not like it, you can create an active region by using the mouse to select a region, or pressing C-SPC twice before moving point.

Footnotes
(1)
If you do not use Font Lock globally turn it on in Org buffer with ‘(add-hook 'org-mode-hook #'turn-on-font-lock)’.


**** Feedback

If you find problems with Org, or if you have questions, remarks, or ideas about it, please send an email to the Org mailing list mailto:emacs-orgmode@gnu.org. You can subscribe to the list from this web page. If you are not a member of the mailing list, your mail will be passed to the list after a moderator has approved it2. We ask you to read and respect the GNU Kind Communications Guidelines when sending messages on this mailing list. Please allow up to one month for the response and followup if no response is received on the bug report.

For bug reports, please first try to reproduce the bug with the latest version of Org available—if you are running an outdated version, it is quite possible that the bug has been fixed already. If the bug persists, prepare a report and provide as much information as possible, including the version information of Emacs (M-x emacs-version) and Org (M-x org-version), as well as the Org related setup in the Emacs init file. The easiest way to do this is to use the command

M-x org-submit-bug-report <RET>
which puts all this information into an Emacs mail buffer so that you only need to add your description. If you are not sending the Email from within Emacs, please copy and paste the content into your Email program.

Sometimes you might face a problem due to an error in your Emacs or Org mode setup. Before reporting a bug, it is very helpful to start Emacs with minimal customizations and reproduce the problem. Doing so often helps you determine if the problem is with your customization or with Org mode itself. You can start a typical minimal session with a command like the example below.

$ emacs -Q -l /path/to/minimal-org.el
However if you are using Org mode as distributed with Emacs, a minimal setup is not necessary. In that case it is sufficient to start Emacs as ‘emacs -Q’. The ‘minimal-org.el’ setup file can have contents as shown below.

;;; Minimal setup to load latest `org-mode'.

;; Activate debugging.
(setq debug-on-error t
      debug-on-signal nil
      debug-on-quit nil)

;; Add latest Org mode to load path.
(add-to-list 'load-path (expand-file-name "/path/to/org-mode/lisp"))
If you are using Org mode version from Git repository, you can start minimal session using make.

# Bare Emacs
make repro
# or pass extra arguments
make repro REPRO_ARGS="-l /path/to/minimal/config.el /tmp/bug.org"
If an error occurs, a “backtrace” can be very useful—see below on how to create one. Often a small example file helps, along with clear information about:

What exactly did you do?
What did you expect to happen?
What happened instead?
If you experience degraded performance, you can record a “profile” and share it on the Org mailing list. See below for the instructions how to record a useful profile.

Thank you for helping to improve this program.

How to create a useful backtrace
If working with Org produces an error with a message you do not understand, you may have hit a bug. The best way to report this is by providing, in addition to what was mentioned above, a backtrace. This is information from the built-in debugger about where and how the error occurred. Here is how to produce a useful backtrace:

Reload uncompiled versions of all Org mode Lisp files. The backtrace contains much more information if it is produced with uncompiled code. To do this, use
C-u M-x org-reload <RET>
or, from the menu: Org → Refresh/Reload → Reload Org uncompiled.

Then, activate the debugger:
M-x toggle-debug-on-error <RET>
or, from the menu: Options → Enter Debugger on Error.

Do whatever you have to do to hit the error. Do not forget to document the steps you take.
When you hit the error, a ‘*Backtrace*’ buffer appears on the screen. Save this buffer to a file—for example using C-x C-w—and attach it to your bug report.
How to profile Org performance
Sometimes, Org is becoming slow for no apparent reason. Such slowdown is often caused by interaction between third-party packages and Org mode. However, identifying the root cause is not always straightforward.

Emacs is able to record performance statistics, which can then be used to find out which functions are taking most of the time to execute. To record the statistics, one can use so-called profiler. To use the Emacs profiler, we recommend the following steps:

Make sure that no profiler is currently active:
M-x profiler-stop <RET>
Start a new CPU profiler session:
M-x profiler-start <RET> cpu <RET>
Use Emacs as usual, performing the actions that are deemed slow.
Display and examine the recorded performance statistics:
M-x profiler-report <RET>
This command will display a summary of the commands and functions that have been executed between profiler-start and profiler-report invocations, with command taking most of the time displayed on top.

‘<TAB>’ key can be used to fold and unfold lines in the profiler buffer. The child items revealed upon unfolding are the functions and commands called by the unfolded parent.

The root causes are often buried deep inside sub-children items in the profiler. You can press ‘B’ (profiler-report-render-reversed-calltree) to quickly reveal the actual function/command that takes most of the time to run.

Pressing ‘C’ profiler-report-render-calltree will recover the original view.

If you need further help, you can share the statistics data.
Just save the data by issuing

M-x profiler-report-write-profile <RET>
/path/to/profile-file-to-be-saved <RET>
Then, you can attached the saved file to your email to the Org mailing list, alongside with details about what you did to trigger the slowdown.

Note that the saved statistics will only contain the function names and how long their execution takes. No private data will be recorded.

Footnotes
(2)
Please consider subscribing to the mailing list in order to minimize the work the mailing list moderators have to do.


**** Typesetting Conventions Used in this Manual

TODO keywords, tags, properties, etc.
Org uses various syntactical elements: TODO keywords, tags, property names, keywords, blocks, etc. In this manual we use the following conventions:

‘TODO’
‘WAITING’
TODO keywords are written with all capitals, even if they are user-defined.

‘boss’
‘ARCHIVE’
Tags are case-sensitive. User-defined tags are usually written in lowercase; built-in tags with special meaning are written as they should appear in the document, usually with all capitals.

‘Release’
‘PRIORITY’
User-defined properties are capitalized; built-in properties with special meaning are written with all capitals.

‘TITLE’
‘BEGIN’ … ‘END’
Keywords and blocks are written in uppercase to enhance their readability, but you can use lowercase in your Org files.

Key bindings and commands
The manual lists both the keys and the corresponding commands for accessing a functionality. Org mode often uses the same key for different functions, depending on context. The command that is bound to such keys has a generic name, like org-metaright. In the manual we will, wherever possible, give the function that is internally called by the generic command. For example, in the chapter on document structure, M-RIGHT will be listed to call org-do-demote, while in the chapter on tables, it will be listed to call org-table-move-column-right.


*** Document Structure

Org is an outliner. Outlines allow a document to be organized in a hierarchical structure, which, least for me, is the best representation of notes and thoughts. An overview of this structure is achieved by folding, i.e., hiding large parts of the document to show only the general document structure and the parts currently being worked on. Org greatly simplifies the use of outlines by compressing the entire show and hide functionalities into a single command, org-cycle, which is bound to the TAB key.

**** Headlines

Headlines define the structure of an outline tree. Org headlines start on the left margin3 with one or more stars followed by a space. For example:

#+begin_src org

# * Top level headline
# ** Second level
# *** Third level
#     some text
# *** Third level
#     more text
# * Another top level headline

#+end_src

The name defined in org-footnote-section is reserved. Do not use it as a title for your own headings.

Some people find the many stars too noisy and would prefer an outline that has whitespace followed by a single star as headline starters. This can be achieved using an Org Indent minor mode. See A Cleaner Outline View for more information.

Headlines are not numbered. However, you may want to dynamically number some, or all, of them. See Dynamic Headline Numbering.

An empty line after the end of a subtree is considered part of it and is hidden when the subtree is folded. However, if you leave at least two empty lines, one empty line remains visible after folding the subtree, in order to structure the collapsed view. See the variable org-cycle-separator-lines to modify this behavior.

Footnotes
(3)
See the variables org-special-ctrl-a/e, org-special-ctrl-k, and org-ctrl-k-protect-subtree to configure special behavior of C-a, C-e, and C-k in headlines. Note also that clocking only works with headings indented less than 30 stars.


**** Visibility Cycling

***** Global and local cycling

Outlines make it possible to hide parts of the text in the buffer. Org uses just two commands, bound to TAB and S-TAB to change the visibility in the buffer.

TAB (org-cycle)
Subtree cycling: Rotate current subtree among the states

,-> FOLDED -> CHILDREN -> SUBTREE --.
'-----------------------------------'
Point must be on a headline for this to work4.

S-TAB (org-global-cycle)
C-u TAB
Global cycling: Rotate the entire buffer among the states

,-> OVERVIEW -> CONTENTS -> SHOW ALL --.
'--------------------------------------'
When S-TAB is called with a numeric prefix argument N, view contents only up to headlines of level N.

Note that inside tables (see Tables), S-TAB jumps to the previous field instead.

You can run global cycling using TAB only if point is at the very beginning of the buffer, but not on a headline, and org-cycle-global-at-bob is set to a non-nil value.

C-u C-u TAB (org-cycle-set-startup-visibility)
Switch back to the startup visibility of the buffer (see Initial visibility).

C-u C-u C-u TAB (org-show-all)
Show all, including drawers.

C-c C-r (org-reveal)
Reveal context around point, showing the current entry, the following heading and the hierarchy above. It is useful for working near a location that has been exposed by a sparse tree command (see Sparse Trees) or an agenda command (see Commands in the Agenda Buffer). With a prefix argument, show, on each level, all sibling headings. With a double prefix argument, also show the entire subtree of the parent.

C-c C-k (org-show-branches)
Expose all the headings of the subtree, but not their bodies.

C-c TAB (org-show-children)
Expose all direct children of the subtree. With a numeric prefix argument N, expose all children down to level N.

C-c C-x b (org-tree-to-indirect-buffer)
Show the current subtree in an indirect buffer5. With a numeric prefix argument N, go up to level N and then take that tree. If N is negative then go up that many levels. With a C-u prefix, do not remove the previously used indirect buffer.

C-c C-x v (org-copy-visible)
Copy the visible text in the region into the kill ring.

Footnotes
(4)
See, however, the option org-cycle-emulate-tab.

(5)
The indirect buffer contains the entire buffer, but is narrowed to the current tree. Editing the indirect buffer also changes the original buffer, but without affecting visibility in that buffer. For more information about indirect buffers, see GNU Emacs Manual.


***** Initial visibility

When Emacs first visits an Org file, the global state is set to showeverything, i.e., all file content is visible6. This can be configured through the variable org-startup-folded, or on a per-file basis by adding one of the following lines anywhere in the buffer:

#+STARTUP: overview
#+STARTUP: content
#+STARTUP: showall
#+STARTUP: show2levels
#+STARTUP: show3levels
#+STARTUP: show4levels
#+STARTUP: show5levels
#+STARTUP: showeverything
Furthermore, any entries with a ‘VISIBILITY’ property (see Properties and Columns) get their visibility adapted accordingly. Allowed values for this property are ‘folded’, ‘children’, ‘content’, and ‘all’.

C-u C-u TAB (org-cycle-set-startup-visibility)
Switch back to the startup visibility of the buffer, i.e., whatever is requested by startup options and ‘VISIBILITY’ properties in individual entries.

Footnotes
(6)
When org-agenda-inhibit-startup is non-nil, Org does not honor the default visibility state when first opening a file for the agenda (see Speeding Up Your Agendas).


***** Catching invisible edits

Sometimes you may inadvertently edit an invisible part of the buffer and be confused on what has been edited and how to undo the mistake. By default, Org prevents such edits for a limited set of user commands. Users can control which commands are affected by customizing org-fold-catch-invisible-edits-commands.

The strategy used to decide if a given edit is dangerous is controlled by org-fold-catch-invisible-edits. See the docstring of this option on the available strategies. Set the option to nil to disable catching invisible edits completely.

**** Motion

The following commands jump to other headlines in the buffer.

C-c C-n (org-next-visible-heading)
Next heading.

C-c C-p (org-previous-visible-heading)
Previous heading.

C-c C-f (org-forward-heading-same-level)
Next heading same level.

C-c C-b (org-backward-heading-same-level)
Previous heading same level.

C-c C-u (outline-up-heading)
Backward to higher level heading.

C-c C-j (org-goto)
Jump to a different place without changing the current outline visibility. Shows the document structure in a temporary buffer, where you can use the following keys to find your destination:

TAB	Cycle visibility.
DOWN / UP	Next/previous visible headline.
RET	Select this location.
/	Do a Sparse-tree search
The following keys work if you turn off org-goto-auto-isearch

n / p	Next/previous visible headline.
f / b	Next/previous headline same level.
u	One level up.
0 … 9	Digit argument.
q	Quit.
See also the variable org-goto-interface.


**** Structure Editing

M-RET (org-meta-return)
Insert a new heading, item or row.

If the command is used at the beginning of a line, and if there is a heading or a plain list item (see Plain Lists) at point, the new heading/item is created before the current line. When used at the beginning of a regular line of text, turn that line into a heading.

When this command is used in the middle of a line, the line is split and the rest of the line becomes the new item or headline. If you do not want the line to be split, customize org-M-RET-may-split-line.

Calling the command with a C-u prefix unconditionally inserts a new heading at the end of the current subtree, thus preserving its contents. With a double C-u C-u prefix, the new heading is created at the end of the parent subtree instead.

C-RET (org-insert-heading-respect-content)
Insert a new heading at the end of the current subtree.

M-S-RET (org-insert-todo-heading)
Insert new TODO entry with same level as current heading. See also the variable org-treat-insert-todo-heading-as-state-change.

C-S-RET (org-insert-todo-heading-respect-content)
Insert new TODO entry with same level as current heading. Like C-RET, the new headline is inserted after the current subtree.

TAB (org-cycle)
In a new entry with no text yet, the first TAB demotes the entry to become a child of the previous one. The next TAB makes it a parent, and so on, all the way to top level. Yet another TAB, and you are back to the initial level.

M-LEFT (org-do-promote)
M-RIGHT (org-do-demote)
Promote or demote current heading by one level.

When there is an active region—i.e., when Transient Mark mode is active—promotion and demotion work on all headlines in the region. To select a region of headlines, it is best to place both point and mark at the beginning of a line, mark at the beginning of the first headline, and point at the line just after the last headline to change.

M-S-LEFT (org-promote-subtree)
Promote the current subtree by one level.

M-S-RIGHT (org-demote-subtree)
Demote the current subtree by one level.

M-UP (org-move-subtree-up)
Move subtree up, i.e., swap with previous subtree of same level.

M-DOWN (org-move-subtree-down)
Move subtree down, i.e., swap with next subtree of same level.

C-c @ (org-mark-subtree)
Mark the subtree at point. Hitting repeatedly marks subsequent subtrees of the same level as the marked subtree.

C-c C-x C-w (org-cut-subtree)
Kill subtree, i.e., remove it from buffer but save in kill ring. With a numeric prefix argument N, kill N sequential subtrees.

C-c C-x M-w (org-copy-subtree)
Copy subtree to kill ring. With a numeric prefix argument N, copy the N sequential subtrees.

C-c C-x C-y (org-paste-subtree)
Yank subtree from kill ring. This does modify the level of the subtree to make sure the tree fits in nicely at the yank position. The yank level can also be specified with a numeric prefix argument, or by yanking after a headline marker like ‘****’. With C-u prefix, force inserting as a sibling. With C-u C-u prefix argument, force inserting as a child.

C-y (org-yank)
Depending on the variables org-yank-adjusted-subtrees and org-yank-folded-subtrees, Org’s internal yank command pastes subtrees folded and in a clever way, using the same command as C-c C-x C-y. With the default settings, no level adjustment takes place, but the yanked tree is folded unless doing so would swallow text previously visible. Any prefix argument to this command forces a normal yank to be executed, with the prefix passed along. A good way to force a normal yank is C-u C-y. If you use yank-pop after a yank, it yanks previous kill items plainly, without adjustment and folding.

C-c C-x c (org-clone-subtree-with-time-shift)
Clone a subtree by making a number of sibling copies of it. You are prompted for the number of copies to make, and you can also specify if any timestamps in the entry should be shifted. This can be useful, for example, to create a number of tasks related to a series of lectures to prepare. For more details, see the docstring of the command org-clone-subtree-with-time-shift.

C-c C-w (org-refile)
Refile entry or region to a different location. See Refile and Copy.

C-c ^ (org-sort)
Sort same-level entries. When there is an active region, all entries in the region are sorted. Otherwise the children of the current headline are sorted. The command prompts for the sorting method, which can be alphabetically, numerically, by time—first timestamp with active preferred, creation time, scheduled time, deadline time—by priority, by TODO keyword—in the sequence the keywords have been defined in the setup—or by the value of a property. Reverse sorting is possible as well. You can also supply your own function to extract the sorting key. With a C-u prefix, sorting is case-sensitive.

C-x n s (org-narrow-to-subtree)
Narrow buffer to current subtree.

C-x n b (org-narrow-to-block)
Narrow buffer to current block.

C-x n w (widen)
Widen buffer to remove narrowing.

C-c * (org-toggle-heading)
Turn a normal line or plain list item into a headline—so that it becomes a subheading at its location. Also turn a headline into a normal line by removing the stars. If there is an active region, turn all lines in the region into headlines. If the first line in the region was an item, turn only the item lines into headlines. Finally, if the first line is a headline, remove the stars from all headlines in the region.

Note that when point is inside a table (see Tables), the Meta-Cursor keys have different functionality.


**** Sparse Trees

An important feature of Org mode is the ability to construct sparse trees for selected information in an outline tree, so that the entire document is folded as much as possible, but the selected information is made visible along with the headline structure above it7. Just try it out and you will see immediately how it works.

Org mode contains several commands creating such trees, all these commands can be accessed through a dispatcher:

C-c / (org-sparse-tree)
This prompts for an extra key to select a sparse-tree creating command.

C-c / r or C-c / / (org-occur)
Prompts for a regexp (see Regular Expressions) and shows a sparse tree with all matches. If the match is in a headline, the headline is made visible. If the match is in the body of an entry, headline and body are made visible. In order to provide minimal context, also the full hierarchy of headlines above the match is shown, as well as the headline following the match. Each match is also highlighted; the highlights disappear when the buffer is changed by an editing command, or by pressing C-c C-c8. When called with a C-u prefix argument, previous highlights are kept, so several calls to this command can be stacked.

M-g n or M-g M-n (next-error)
Jump to the next sparse tree match in this buffer.

M-g p or M-g M-p (previous-error)
Jump to the previous sparse tree match in this buffer.

For frequently used sparse trees of specific search strings, you can use the variable org-agenda-custom-commands to define fast keyboard access to specific sparse trees. These commands will then be accessible through the agenda dispatcher (see The Agenda Dispatcher). For example:

(setq org-agenda-custom-commands
      '(("f" occur-tree "FIXME")))
defines the key f as a shortcut for creating a sparse tree matching the string ‘FIXME’.

The other sparse tree commands select headings based on TODO keywords, tags, or properties and are discussed later in this manual.

To print a sparse tree, you can use the Emacs command ps-print-buffer-with-faces which does not print invisible parts of the document. Or you can use the command C-c C-e C-v to export only the visible part of the document and print the resulting file.

Footnotes
(7)
See also the variable org-show-context-detail to decide how much context is shown around each match.

(8)
This depends on the option org-remove-highlights-with-change.


**** Plain Lists

Within an entry of the outline tree, hand-formatted lists can provide additional structure. They also provide a way to create lists of checkboxes (see Checkboxes). Org supports editing such lists, and every exporter (see Exporting) can parse and format them.

Org knows ordered lists, unordered lists, and description lists.

Unordered list items start with ‘-’, ‘+’, or ‘*’9 as bullets.
Ordered list items start with a numeral followed by either a period or a right parenthesis10, such as ‘1.’ or ‘1)’11 If you want a list to start with a different value—e.g., 20—start the text of the item with ‘[@20]’12. Those constructs can be used in any item of the list in order to enforce a particular numbering.
Description list items are unordered list items, and contain the separator ‘::’ to distinguish the description term from the description.
Items belonging to the same list must have the same indentation on the first line. In particular, if an ordered list reaches number ‘10.’, then the 2-digit numbers must be written left-aligned with the other numbers in the list. An item ends before the next line that is less or equally indented than its bullet/number.

A list ends whenever every item has ended, which means before any line less or equally indented than items at top level. It also ends before two blank lines. In that case, all items are closed.

Org supports these lists by tuning filling and wrapping commands to deal with them correctly, and by exporting them properly (see Exporting). Since indentation is what governs the structure of these lists, many structural constructs like ‘#+BEGIN_’ blocks can be indented to signal that they belong to a particular item.

If you find that using a different bullet for a sub-list—than that used for the current list-level—improves readability, customize the variable org-list-demote-modify-bullet. To get a greater difference of indentation between items and theirs sub-items, customize org-list-indent-offset.

The following commands act on items when point is in the first line of an item—the line with the bullet or number. Some of them imply the application of automatic rules to keep list structure intact. If some of these actions get in your way, configure org-list-automatic-rules to disable them individually.

TAB (org-cycle)
Items can be folded just like headline levels. Normally this works only if point is on a plain list item. For more details, see the variable org-cycle-include-plain-lists. If this variable is set to integrate, plain list items are treated like low-level headlines. The level of an item is then given by the indentation of the bullet/number. Items are always subordinate to real headlines, however; the hierarchies remain completely separated. In a new item with no text yet, the first TAB demotes the item to become a child of the previous one. Subsequent TABs move the item to meaningful levels in the list and eventually get it back to its initial position.

M-RET (org-insert-heading)
Insert new item at current level. With a prefix argument, force a new heading (see Structure Editing). If this command is used in the middle of an item, that item is split in two, and the second part becomes the new item13. If this command is executed before item’s body, the new item is created before the current one.

M-S-RET
Insert a new item with a checkbox (see Checkboxes).

S-UP
S-DOWN
Jump to the previous/next item in the current list, but only if org-support-shift-select is off14. If not, you can still use paragraph jumping commands like C-UP and C-DOWN to quite similar effect.

M-UP
M-DOWN
Move the item including subitems up/down15, i.e., swap with previous/next item of same indentation. If the list is ordered, renumbering is automatic.

M-LEFT
M-RIGHT
Decrease/increase the indentation of an item, leaving children alone.

M-S-LEFT
M-S-RIGHT
Decrease/increase the indentation of the item, including subitems. Initially, the item tree is selected based on current indentation. When these commands are executed several times in direct succession, the initially selected region is used, even if the new indentation would imply a different hierarchy. To use the new hierarchy, break the command chain by moving point.

As a special case, using this command on the very first item of a list moves the whole list. This behavior can be disabled by configuring org-list-automatic-rules. The global indentation of a list has no influence on the text after the list.

C-c C-c
If there is a checkbox (see Checkboxes) in the item line, toggle the state of the checkbox. In any case, verify bullets and indentation consistency in the whole list.

C-c -
Cycle the entire list level through the different itemize/enumerate bullets (‘-’, ‘+’, ‘*’, ‘1.’, ‘1)’) or a subset of them, depending on org-plain-list-ordered-item-terminator, the type of list, and its indentation. With a numeric prefix argument N, select the Nth bullet from this list. If there is an active region when calling this, all lines are converted to list items. With a prefix argument, the selected text is changed into a single item. If the first line already was a list item, any item marker is removed from the list. Finally, even without an active region, a normal line is converted into a list item.

C-c *
Turn a plain list item into a headline—so that it becomes a subheading at its location. See Structure Editing, for a detailed explanation.

C-c C-*
Turn the whole plain list into a subtree of the current heading. Checkboxes (see Checkboxes) become ‘TODO’, respectively ‘DONE’, keywords when unchecked, respectively checked.

S-LEFT
S-RIGHT
This command also cycles bullet styles when point is in on the bullet or anywhere in an item line, details depending on org-support-shift-select.

C-c ^
Sort the plain list. Prompt for the sorting method: numerically, alphabetically, by time, or by custom function.

Footnotes
(9)
When using ‘*’ as a bullet, lines must be indented so that they are not interpreted as headlines. Also, when you are hiding leading stars to get a clean outline view, plain list items starting with a star may be hard to distinguish from true headlines. In short: even though ‘*’ is supported, it may be better to not use it for plain list items.

(10)
You can filter out any of them by configuring org-plain-list-ordered-item-terminator.

(11)
You can also get ‘a.’, ‘A.’, ‘a)’ and ‘A)’ by configuring org-list-allow-alphabetical. To minimize confusion with normal text, those are limited to one character only. Beyond that limit, bullets automatically become numbers.

(12)
If there’s a checkbox in the item, the cookie must be put before the checkbox. If you have activated alphabetical lists, you can also use counters like ‘[@b]’.

(13)
If you do not want the item to be split, customize the variable org-M-RET-may-split-line.

(14)
If you want to cycle around items that way, you may customize org-list-use-circular-motion.

(15)
See org-list-use-circular-motion for a cyclic behavior.


**** Drawers

Sometimes you want to keep information associated with an entry, but you normally do not want to see it. For this, Org mode has drawers. They can contain anything but a headline and another drawer. Drawers look like this:


Still outside the drawer
:DRAWERNAME:
This is inside the drawer.
:END:
After the drawer.
You can interactively insert a drawer at point by calling org-insert-drawer, which is bound to C-c C-x d. With an active region, this command puts the region inside the drawer. With a prefix argument, this command calls non-interactive function org-insert-property-drawer, which creates a ‘PROPERTIES’ drawer right below the current headline. Org mode uses this special drawer for storing properties (see Properties and Columns). You cannot use it for anything else.

Completion over drawer keywords is also possible using M-TAB16.

Visibility cycling (see Visibility Cycling) on the headline hides and shows the entry, but keep the drawer collapsed to a single line. In order to look inside the drawer, you need to move point to the drawer line and press TAB there.

You can also arrange for state change notes (see Tracking TODO state changes) and clock times (see Clocking Work Time) to be stored in a ‘LOGBOOK’ drawer. If you want to store a quick note there, in a similar way to state changes, use

C-c C-z
Add a time-stamped note to the ‘LOGBOOK’ drawer.

Footnotes
(16)
Many desktops intercept M-TAB to switch windows. Use C-M-i or ESC TAB instead.


**** Blocks

Org mode uses ‘#+BEGIN’ … ‘#+END’ blocks for various purposes from including source code examples (see Literal Examples) to capturing time logging information (see Clocking Work Time). These blocks can be folded and unfolded by pressing TAB in the ‘#+BEGIN’ line. You can also get all blocks folded at startup by configuring the variable org-hide-block-startup or on a per-file basis by using

#+STARTUP: hideblocks
#+STARTUP: nohideblocks


*** Tables

Org comes with a fast and intuitive table editor. Spreadsheet-like calculations are supported using the Emacs Calc package (see GNU Emacs Calculator Manual).

**** Built-in Table Editor

Org makes it easy to format tables in plain ASCII. Any line with ‘|’ as the first non-whitespace character is considered part of a table. ‘|’ is also the column separator17. Moreover, a line starting with ‘|-’ is a horizontal rule. It separates rows explicitly. Rows before the first horizontal rule are header lines. A table might look like this:

| Name  | Phone | Age |
|-------+-------+-----|
| Peter |  1234 |  17 |
| Anna  |  4321 |  25 |

A table is re-aligned automatically each time you press TAB, RET or C-c C-c inside the table. TAB also moves to the next field—RET to the next row—and creates new table rows at the end of the table or before horizontal lines. The indentation of the table is set by the first line. Horizontal rules are automatically expanded on every re-align to span the whole table width. So, to create the above table, you would only type

|Name|Phone|Age|
|-
and then press TAB to align the table and start filling in fields. Even faster would be to type ‘|Name|Phone|Age’ followed by C-c RET.

When typing text into a field, Org treats DEL, Backspace, and all character keys in a special way, so that inserting and deleting avoids shifting other fields. Also, when typing immediately after point was moved into a new field with TAB, S-TAB or RET, the field is automatically made blank. If this behavior is too unpredictable for you, configure the option org-table-auto-blank-field.

Creation and conversion
C-c | (org-table-create-or-convert-from-region)
Convert the active region to table. If every line contains at least one TAB character, the function assumes that the material is tab separated. If every line contains a comma, comma-separated values (CSV) are assumed. If not, lines are split at whitespace into fields. You can use a prefix argument to force a specific separator: C-u forces CSV, C-u C-u forces TAB, C-u C-u C-u prompts for a regular expression to match the separator, and a numeric argument N indicates that at least N consecutive spaces, or alternatively a TAB will be the separator.

If there is no active region, this command creates an empty Org table. But it is easier just to start typing, like | N a m e | P h o n e | A g e RET | - TAB.

Re-aligning and field motion
C-c C-c (org-table-align)
Re-align the table without moving point.

TAB (org-table-next-field)
Re-align the table, move to the next field. Creates a new row if necessary.

M-x org-table-blank-field
Blank the current table field or active region.

S-TAB (org-table-previous-field)
Re-align, move to previous field.

RET (org-table-next-row)
Re-align the table and move down to next row. Creates a new row if necessary. At the beginning or end of a line, RET still inserts a new line, so it can be used to split a table.

M-a (org-table-beginning-of-field)
Move to beginning of the current table field, or on to the previous field.

M-e (org-table-end-of-field)
Move to end of the current table field, or on to the next field.

Column and row editing
M-LEFT (org-table-move-column-left)
Move the current column left.

M-RIGHT (org-table-move-column-right)
Move the current column right.

M-S-LEFT (org-table-delete-column)
Kill the current column.

M-S-RIGHT (org-table-insert-column)
Insert a new column at point position. Move the recent column and all cells to the right of this column to the right.

M-UP (org-table-move-row-up)
Move the current row up.

M-DOWN (org-table-move-row-down)
Move the current row down.

M-S-UP (org-table-kill-row)
Kill the current row or horizontal line.

S-UP (org-table-move-cell-up)
Move cell up by swapping with adjacent cell.

S-DOWN (org-table-move-cell-down)
Move cell down by swapping with adjacent cell.

S-LEFT (org-table-move-cell-left)
Move cell left by swapping with adjacent cell.

S-RIGHT (org-table-move-cell-right)
Move cell right by swapping with adjacent cell.

M-S-DOWN (org-table-insert-row)
Insert a new row above the current row. With a prefix argument, the line is created below the current one.

C-c - (org-table-insert-hline)
Insert a horizontal line below current row. With a prefix argument, the line is created above the current line.

C-c RET (org-table-hline-and-move)
Insert a horizontal line below current row, and move point into the row below that line.

C-c ^ (org-table-sort-lines)
Sort the table lines in the region. The position of point indicates the column to be used for sorting, and the range of lines is the range between the nearest horizontal separator lines, or the entire table. If point is before the first column, you are prompted for the sorting column. If there is an active region, the mark specifies the first line and the sorting column, while point should be in the last line to be included into the sorting. The command prompts for the sorting type, alphabetically, numerically, or by time. You can sort in normal or reverse order. You can also supply your own key extraction and comparison functions. When called with a prefix argument, alphabetic sorting is case-sensitive.

Regions
C-c C-x M-w (org-table-copy-region)
Copy a rectangular region from a table to a special clipboard. Point and mark determine edge fields of the rectangle. If there is no active region, copy just the current field. The process ignores horizontal separator lines.

C-c C-x C-w (org-table-cut-region)
Copy a rectangular region from a table to a special clipboard, and blank all fields in the rectangle. So this is the “cut” operation.

C-c C-x C-y (org-table-paste-rectangle)
Paste a rectangular region into a table. The upper left corner ends up in the current field. All involved fields are overwritten. If the rectangle does not fit into the present table, the table is enlarged as needed. The process ignores horizontal separator lines.

M-RET (org-table-wrap-region)
Split the current field at point position and move the rest to the line below. If there is an active region, and both point and mark are in the same column, the text in the column is wrapped to minimum width for the given number of lines. A numeric prefix argument may be used to change the number of desired lines. If there is no region, but you specify a prefix argument, the current field is made blank, and the content is appended to the field above.

Calculations
C-c + (org-table-sum)
Sum the numbers in the current column, or in the rectangle defined by the active region. The result is shown in the echo area and can be inserted with C-y.

S-RET (org-table-copy-down)
When current field is empty, copy from first non-empty field above. When not empty, copy current field down to next row and move point along with it.

Depending on the variable org-table-copy-increment, integer and time stamp field values, and fields prefixed or suffixed with a whole number, can be incremented during copy. Also, a 0 prefix argument temporarily disables the increment.

This key is also used by shift-selection and related modes (see Packages that conflict with Org mode).

Miscellaneous
C-c ` (org-table-edit-field)
Edit the current field in a separate window. This is useful for fields that are not fully visible (see Column Width and Alignment). When called with a C-u prefix, just make the full field visible, so that it can be edited in place. When called with two C-u prefixes, make the editor window follow point through the table and always show the current field. The follow mode exits automatically when point leaves the table, or when you repeat this command with C-u C-u C-c `.

M-x org-table-import
Import a file as a table. The table should be TAB or whitespace separated. Use, for example, to import a spreadsheet table or data from a database, because these programs generally can write TAB-separated text files. This command works by inserting the file into the buffer and then converting the region to a table. Any prefix argument is passed on to the converter, which uses it to determine the separator.

C-c | (org-table-create-or-convert-from-region)
Tables can also be imported by pasting tabular text into the Org buffer, selecting the pasted text with C-x C-x and then using the C-c | command (see Creation and conversion).

M-x org-table-export
Export the table, by default as a TAB-separated file. Use for data exchange with, for example, spreadsheet or database programs. The format used to export the file can be configured in the variable org-table-export-default-format. You may also use properties ‘TABLE_EXPORT_FILE’ and ‘TABLE_EXPORT_FORMAT’ to specify the file name and the format for table export in a subtree. Org supports quite general formats for exported tables. The exporter format is the same as the format used by Orgtbl radio tables, see Translator functions, for a detailed description.

M-x org-table-header-line-mode
Turn on the display of the first data row of the table at point in the window header line when this first row is not visible anymore in the buffer. You can activate this minor mode by default by setting the option org-table-header-line-p to t.

M-x org-table-transpose-table-at-point
Transpose the table at point and eliminate hlines.

Footnotes
(17)
To insert a vertical bar into a table field, use ‘\vert’ or, inside a word ‘abc\vert{}def’.


**** Column Width and Alignment

The width of columns is automatically determined by the table editor. The alignment of a column is determined automatically from the fraction of number-like versus non-number fields in the column.

Editing a field may modify alignment of the table. Moving a contiguous row or column—i.e., using TAB or RET—automatically re-aligns it. If you want to disable this behavior, set org-table-automatic-realign to nil. In any case, you can always align manually a table:

C-c C-c (org-table-align)
Align the current table.

Setting the option org-startup-align-all-tables re-aligns all tables in a file upon visiting it. You can also set this option on a per-file basis with:

#+STARTUP: align
#+STARTUP: noalign
Sometimes a single field or a few fields need to carry more text, leading to inconveniently wide columns. Maybe you want to hide away several columns or display them with a fixed width, regardless of content, as shown in the following example.

|---+---------------------+--------|           |---+-------…+…|
|   | <6>                 |        |           |   | <6>   …|…|
| 1 | one                 | some   |   ----\   | 1 | one   …|…|
| 2 | two                 | boring |   ----/   | 2 | two   …|…|
| 3 | This is a long text | column |           | 3 | This i…|…|
|---+---------------------+--------|           |---+-------…+…|
To set the width of a column, one field anywhere in the column may contain just the string ‘<N>’ where N specifies the width as a number of characters. You control displayed width of columns with the following tools:

C-c TAB (org-table-toggle-column-width)
Shrink or expand current column.

If a width cookie specifies a width W for the column, shrinking it displays the first W visible characters only. Otherwise, the column is shrunk to a single character.

When called before the first column or after the last one, ask for a list of column ranges to operate on.

C-u C-c TAB (org-table-shrink)
Shrink all columns with a column width. Expand the others.

C-u C-u C-c TAB (org-table-expand)
Expand all columns.

To see the full text of a shrunk field, hold the mouse over it: a tool-tip window then shows the full contents of the field. Alternatively, C-h . (display-local-help) reveals them, too. For convenience, any change near the shrunk part of a column expands it.

Setting the option org-startup-shrink-all-tables shrinks all columns containing a width cookie in a file the moment it is visited. You can also set this option on a per-file basis with:

#+STARTUP: shrink
If you would like to overrule the automatic alignment of number-rich columns to the right and of string-rich columns to the left, you can use ‘<r>’, ‘<c>’ or ‘<l>’ in a similar fashion. You may also combine alignment and field width like this: ‘<r10>’.

Lines which only contain these formatting cookies are removed automatically upon exporting the document.


**** Column Groups

When Org exports tables, it does so by default without vertical lines because that is visually more satisfying in general. Occasionally however, vertical lines can be useful to structure a table into groups of columns, much like horizontal lines can do for groups of rows. In order to specify column groups, you can use a special row where the first field contains only ‘/’. The further fields can either contain ‘<’ to indicate that this column should start a group, ‘>’ to indicate the end of a column, or ‘<>’ (no space between ‘<’ and ‘>’) to make a column a group of its own. Upon export, boundaries between column groups are marked with vertical lines. Here is an example:

| N | N^2 | N^3 | N^4 | sqrt(n) | sqrt[4](N) |
|---+-----+-----+-----+---------+------------|
| / |  <  |     |  >  |       < |          > |
| 1 |  1  |  1  |  1  |       1 |          1 |
| 2 |  4  |  8  | 16  |  1.4142 |     1.1892 |
| 3 |  9  | 27  | 81  |  1.7321 |     1.3161 |
|---+-----+-----+-----+---------+------------|
#+TBLFM: $2=$1^2::$3=$1^3::$4=$1^4::$5=sqrt($1)::$6=sqrt(sqrt(($1)))
It is also sufficient to just insert the column group starters after every vertical line you would like to have:

| N | N^2 | N^3 | N^4 | sqrt(n) | sqrt[4](N) |
|---+-----+-----+-----+---------+------------|
| / | <   |     |     | <       |            |


**** The Orgtbl Minor Mode

If you like the intuitive way the Org table editor works, you might also want to use it in other modes like Text mode or Mail mode. The minor mode Orgtbl mode makes this possible. You can always toggle the mode with M-x orgtbl-mode. To turn it on by default, for example in Message mode, use

(add-hook 'message-mode-hook #'turn-on-orgtbl)
Furthermore, with some special setup, it is possible to maintain tables in arbitrary syntax with Orgtbl mode. For example, it is possible to construct LaTeX tables with the underlying ease and power of Orgtbl mode, including spreadsheet capabilities. For details, see Tables in Arbitrary Syntax.


**** The Spreadsheet

The table editor makes use of the Emacs Calc package to implement spreadsheet-like capabilities. It can also evaluate Emacs Lisp forms to derive fields from other fields. While fully featured, Org’s implementation is not identical to other spreadsheets. For example, Org knows the concept of a column formula that will be applied to all non-header fields in a column without having to copy the formula to each relevant field. There is also a formula debugger, and a formula editor with features for highlighting fields in the table corresponding to the references at point in the formula, moving these references by arrow keys.

***** References

To compute fields in the table from other fields, formulas must reference other fields or ranges. In Org, fields can be referenced by name, by absolute coordinates, and by relative coordinates. To find out what the coordinates of a field are, press C-c ? in that field, or press C-c } to toggle the display of a grid.

Field references
Formulas can reference the value of another field in two ways. Like in any other spreadsheet, you may reference fields with a letter/number combination like ‘B3’, meaning the second field in the third row. However, Org prefers to use another, more general representation that looks like this:18

@ROW$COLUMN
Column specifications can be absolute like ‘$1’, ‘$2’, …, ‘$N’, or relative to the current column, i.e., the column of the field which is being computed, like ‘$+1’ or ‘$-2’. ‘$<’ and ‘$>’ are immutable references to the first and last column, respectively, and you can use ‘$>>>’ to indicate the third column from the right.

The row specification only counts data lines and ignores horizontal separator lines, or “hlines”. Like with columns, you can use absolute row numbers ‘@1’, ‘@2’, …, ‘@N’, and row numbers relative to the current row like ‘@+3’ or ‘@-1’. ‘@<’ and ‘@>’ are immutable references the first and last row in the table, respectively. You may also specify the row relative to one of the hlines: ‘@I’ refers to the first hline, ‘@II’ to the second, etc. ‘@-I’ refers to the first such line above the current line, ‘@+I’ to the first such line below the current line. You can also write ‘@III+2’ which is the second data line after the third hline in the table.

‘@0’ and ‘$0’ refer to the current row and column, respectively, i.e., to the row/column for the field being computed. Also, if you omit either the column or the row part of the reference, the current row/column is implied.

Org’s references with unsigned numbers are fixed references in the sense that if you use the same reference in the formula for two different fields, the same field is referenced each time. Org’s references with signed numbers are floating references because the same reference operator can reference different fields depending on the field being calculated by the formula.

Here are a few examples:

‘@2$3’	2nd row, 3rd column (same as ‘C2’)
‘$5’	column 5 in the current row (same as ‘E&’)
‘@2’	current column, row 2
‘@-1$-3’	field one row up, three columns to the left
‘@-I$2’	field just under hline above current row, column 2
‘@>$5’	field in the last row, in column 5
Range references
You may reference a rectangular range of fields by specifying two field references connected by two dots ‘..’. The ends are included in the range. If both fields are in the current row, you may simply use ‘$2..$7’, but if at least one field is in a different row, you need to use the general ‘@ROW$COLUMN’ format at least for the first field, i.e., the reference must start with ‘@’ in order to be interpreted correctly. Examples:

‘$1..$3’	first three fields in the current row
‘$P..$Q’	range, using column names (see Advanced features)
‘$<<<..$>>’	start in third column, continue to the last but one
‘@2$1..@4$3’	nine fields between these two fields (same as ‘A2..C4’)
‘@-1$-2..@-1’	3 fields in the row above, starting from 2 columns on the left
‘@I..II’	between first and second hline, short for ‘@I..@II’
Range references return a vector of values that can be fed into Calc vector functions. Empty fields in ranges are normally suppressed, so that the vector contains only the non-empty fields. For other options with the mode switches ‘E’, ‘N’ and examples, see Formula syntax for Calc.

Field coordinates in formulas
One of the very first actions during evaluation of Calc formulas and Lisp formulas is to substitute ‘@#’ and ‘$#’ in the formula with the row or column number of the field where the current result will go to. The traditional Lisp formula equivalents are org-table-current-dline and org-table-current-column. Examples:

‘if(@# % 2, $#, string(""))’
Insert column number on odd rows, set field to empty on even rows.

‘$2 = '(identity remote(FOO, @@#$1))’
Copy text or values of each row of column 1 of the table named FOO into column 2 of the current table.

‘@3 = 2 * remote(FOO, @1$$#)’
Insert the doubled value of each column of row 1 of the table named FOO into row 3 of the current table.

For the second and third examples, table FOO must have at least as many rows or columns as the current table. Note that this is inefficient19 for large number of rows.

Named references
‘$name’ is interpreted as the name of a column, parameter or constant. Constants are defined globally through the variable org-table-formula-constants, and locally—for the file—through a line like this example:

#+CONSTANTS: c=299792458. pi=3.14 eps=2.4e-6
Also, properties (see Properties and Columns) can be used as constants in table formulas: for a property ‘Xyz’ use the name ‘$PROP_Xyz’, and the property will be searched in the current outline entry and in the hierarchy above it. If you have the ‘constants.el’ package, it will also be used to resolve constants, including natural constants like ‘$h’ for Planck’s constant, and units like ‘$km’ for kilometers20. Column names and parameters can be specified in special table lines. These are described below, see Advanced features. All names must start with a letter, and further consist of letters and numbers.

Remote references
You may also reference constants, fields and ranges from a different table, either in the current file or even in a different file. The syntax is

remote(NAME,REF)
where NAME can be the name of a table in the current file as set by a ‘#+NAME:’ line before the table. It can also be the ID of an entry, even in a different file, and the reference then refers to the first table in that entry. REF is an absolute field or range reference as described above for example ‘@3$3’ or ‘$somename’, valid in the referenced table.

When NAME has the format ‘@ROW$COLUMN’, it is substituted with the name or ID found in this field of the current table. For example ‘remote($1, @@>$2)’ ⇒ ‘remote(year_2013, @@>$1)’. The format ‘B3’ is not supported because it can not be distinguished from a plain table name or ID.

Footnotes
(18)
Org understands references typed by the user as ‘B4’, but it does not use this syntax when offering a formula for editing. You can customize this behavior using the variable org-table-use-standard-references.

(19)
The computation time scales as O(N^2) because table FOO is parsed for each field to be copied.

(20)
The file ‘constants.el’ can supply the values of constants in two different unit systems, ‘SI’ and ‘cgs’. Which one is used depends on the value of the variable constants-unit-system. You can use the ‘STARTUP’ options ‘constSI’ and ‘constcgs’ to set this value for the current buffer.


***** Formula syntax for Calc

A formula can be any algebraic expression understood by the Emacs Calc package. Note that Calc has the non-standard convention that ‘/’ has lower precedence than ‘*’, so that ‘a/b*c’ is interpreted as ‘(a/(b*c))’. Before evaluation by calc-eval (see Calling Calc from Your Lisp Programs), variable substitution takes place according to the rules described above.

The range vectors can be directly fed into the Calc vector functions like vmean and vsum.

A formula can contain an optional mode string after a semicolon. This string consists of flags to influence Calc and other modes during execution. By default, Org uses the standard Calc modes (precision 12, angular units degrees, fraction and symbolic modes off). The display format, however, has been changed to ‘(float 8)’ to keep tables compact. The default settings can be configured using the variable org-calc-default-modes.

‘p20’
Set the internal Calc calculation precision to 20 digits.

‘n3’, ‘s3’, ‘e2’, ‘f4’
Normal, scientific, engineering or fixed format of the result of Calc passed back to Org. Calc formatting is unlimited in precision as long as the Calc calculation precision is greater.

‘D’, ‘R’
Degree and radian angle modes of Calc.

‘F’, ‘S’
Fraction and symbolic modes of Calc.

‘u’
Units simplification mode of Calc. Calc is also a symbolic calculator and is capable of working with values having a unit, represented with numerals followed by a unit string in Org table cells. This mode instructs Calc to simplify the units in the computed expression before returning the result.

‘T’, ‘t’, ‘U’
Duration computations in Calc or Lisp, Durations and time values.

‘E’
If and how to consider empty fields. Without ‘E’ empty fields in range references are suppressed so that the Calc vector or Lisp list contains only the non-empty fields. With ‘E’ the empty fields are kept. For empty fields in ranges or empty field references the value ‘nan’ (not a number) is used in Calc formulas and the empty string is used for Lisp formulas. Add ‘N’ to use 0 instead for both formula types. For the value of a field the mode ‘N’ has higher precedence than ‘E’.

‘N’
Interpret all fields as numbers, use 0 for non-numbers. See the next section to see how this is essential for computations with Lisp formulas. In Calc formulas it is used only occasionally because there number strings are already interpreted as numbers without ‘N’.

‘L’
Literal, for Lisp formulas only. See the next section.

Unless you use large integer numbers or high-precision calculation and display for floating point numbers you may alternatively provide a printf format specifier to reformat the Calc result after it has been passed back to Org instead of letting Calc already do the formatting21. A few examples:

‘$1+$2’	Sum of first and second field
‘$1+$2;%.2f’	Same, format result to two decimals
‘exp($2)+exp($1)’	Math functions can be used
‘$0;%.1f’	Reformat current cell to 1 decimal
‘($3-32)*5/9’	Degrees F → C conversion
‘$c/$1/$cm’	Hz → cm conversion, using ‘constants.el’
‘tan($1);Dp3s1’	Compute in degrees, precision 3, display SCI 1
‘sin($1);Dp3%.1e’	Same, but use printf specifier for display
‘vmean($2..$7)’	Compute column range mean, using vector function
‘vmean($2..$7);EN’	Same, but treat empty fields as 0
‘taylor($3,x=7,2)’	Taylor series of $3, at x=7, second degree
Calc also contains a complete set of logical operations (see Logical Operations). For example

‘if($1 < 20, teen, string(""))’
‘"teen"’ if age ‘$1’ is less than 20, else the Org table result field is set to empty with the empty string.

‘if("$1" =​= "nan" || "$2" =​= "nan", string(""), $1 + $2); E f-1’
Sum of the first two columns. When at least one of the input fields is empty the Org table result field is set to empty. ‘E’ is required to not convert empty fields to 0. ‘f-1’ is an optional Calc format string similar to ‘%.1f’ but leaves empty results empty.

‘if(typeof(vmean($1..$7)) =​= 12, string(""), vmean($1..$7)); E’
Mean value of a range unless there is any empty field. Every field in the range that is empty is replaced by ‘nan’ which lets ‘vmean’ result in ‘nan’. Then ‘typeof =’ 12= detects the ‘nan’ from vmean and the Org table result field is set to empty. Use this when the sample set is expected to never have missing values.

‘if("$1..$7" =​= "[]", string(""), vmean($1..$7))’
Mean value of a range with empty fields skipped. Every field in the range that is empty is skipped. When all fields in the range are empty the mean value is not defined and the Org table result field is set to empty. Use this when the sample set can have a variable size.

‘vmean($1..$7); EN’
To complete the example before: Mean value of a range with empty fields counting as samples with value 0. Use this only when incomplete sample sets should be padded with 0 to the full size.

You can add your own Calc functions defined in Emacs Lisp with defmath and use them in formula syntax for Calc.

Footnotes
(21)
The printf reformatting is limited in precision because the value passed to it is converted into an “integer” or “double”. The “integer” is limited in size by truncating the signed value to 32 bits. The “double” is limited in precision to 64 bits overall which leaves approximately 16 significant decimal digits.


***** Emacs Lisp forms as formulas

It is also possible to write a formula in Emacs Lisp. This can be useful for string manipulation and control structures, if Calc’s functionality is not enough.

A formula is evaluated as a Lisp form when it starts with a single-quote followed by an opening parenthesis. Cell table references are interpolated into the Lisp form before execution. The evaluation should return either a string or a number. Evaluation modes and a printf format used to render the returned values can be specified after a semicolon.

By default, references are interpolated as literal Lisp strings: the field content is replaced in the Lisp form stripped of leading and trailing white space and surrounded in double-quotes. For example:

'(concat $1 $2)
concatenates the content of columns 1 and column 2.

When the ‘N’ flag is used, all referenced elements are parsed as numbers and interpolated as Lisp numbers, without quotes. Fields that cannot be parsed as numbers are interpolated as zeros. For example:

'(+ $1 $2);N
adds columns 1 and 2, equivalent to Calc’s ‘$1+$2’. Ranges are inserted as space-separated fields, so they can be embedded in list or vector syntax. For example:

'(apply '+ '($1..$4));N
computes the sum of columns 1 to 4, like Calc’s ‘vsum($1..$4)’.

When the ‘L’ flag is used, all fields are interpolated literally: the cell content is replaced in the Lisp form stripped of leading and trailing white space and without quotes. If a reference is intended to be interpreted as a string by the Lisp form, the reference operator itself should be enclosed in double-quotes, like ‘"$3"’. The ‘L’ flag is useful when strings and numbers are used in the same Lisp form. For example:

'(substring "$1" $2 $3);L
extracts the part of the string in column 1 between the character positions specified in the integers in column 2 and 3 and it is easier to read than the equivalent:

'(substring $1 (string-to-number $2) (string-to-number $3))
When the formula itself contains ‘;’ symbol, Org mode may incorrectly interpret everything past ‘;’ as format specifier:

'(concat $1 ";")
You can put an extra tailing ‘;’ to indicate that all the earlier instances of ‘;’ belong to the formula itself:

'(concat $1 ";");

***** Durations and time values

If you want to compute time values use the ‘T’, ‘t’, or ‘U’ flag, either in Calc formulas or Elisp formulas:

|  Task 1 |   Task 2 |    Total |
|---------+----------+----------|
|    2:12 |     1:47 | 03:59:00 |
|    2:12 |     1:47 |    03:59 |
| 3:02:20 | -2:07:00 |     0.92 |
#+TBLFM: @2$3=$1+$2;T::@3$3=$1+$2;U::@4$3=$1+$2;t
Input duration values must be of the form ‘HH:MM[:SS]’, where seconds are optional. With the ‘T’ flag, computed durations are displayed as ‘HH:MM:SS’ (see the first formula above). With the ‘U’ flag, seconds are omitted so that the result is only ‘HH:MM’ (see second formula above). Zero-padding of the hours field depends upon the value of the variable org-table-duration-hour-zero-padding.

With the ‘t’ flag, computed durations are displayed according to the value of the option org-table-duration-custom-format, which defaults to hours and displays the result as a fraction of hours (see the third formula in the example above).

Negative duration values can be manipulated as well, and integers are considered as seconds in addition and subtraction.


***** Field and range formulas

To assign a formula to a particular field, type it directly into the field, preceded by ‘:=’, for example ‘vsum(@II..III)’. When you press TAB or RET or C-c C-c with point still in the field, the formula is stored as the formula for this field, evaluated, and the current field is replaced with the result.

Formulas are stored in a special ‘TBLFM’ keyword located directly below the table. If you type the equation in the fourth field of the third data line in the table, the formula looks like ‘@3$4=$1+$2’. When inserting/deleting/swapping column and rows with the appropriate commands, absolute references (but not relative ones) in stored formulas are modified in order to still reference the same field. To avoid this from happening, in particular in range references, anchor ranges at the table borders (using ‘@<’, ‘@>’, ‘$<’, ‘$>’), or at hlines using the ‘@I’ notation. Automatic adaptation of field references does not happen if you edit the table structure with normal editing commands—you must fix the formulas yourself.

Instead of typing an equation into the field, you may also use the following command

C-u C-c = (org-table-eval-formula)
Install a new formula for the current field. The command prompts for a formula with default taken from the ‘TBLFM’ keyword, applies it to the current field, and stores it.

The left-hand side of a formula can also be a special expression in order to assign the formula to a number of different fields. There is no keyboard shortcut to enter such range formulas. To add them, use the formula editor (see Editing and debugging formulas) or edit the ‘TBLFM’ keyword directly.

‘$2=’
Column formula, valid for the entire column. This is so common that Org treats these formulas in a special way, see Column formulas.

‘@3=’
Row formula, applies to all fields in the specified row. ‘@>=’ means the last row.

‘@1$2..@4$3=’
Range formula, applies to all fields in the given rectangular range. This can also be used to assign a formula to some but not all fields in a row.

‘$NAME=’
Named field, see Advanced features.


***** Column formulas

When you assign a formula to a simple column reference like ‘$3=’, the same formula is used in all fields of that column, with the following very convenient exceptions: (i) If the table contains horizontal separator hlines with rows above and below, everything before the first such hline is considered part of the table header and is not modified by column formulas. Therefore a header is mandatory when you use column formulas and want to add hlines to group rows, like for example to separate a total row at the bottom from the summand rows above. (ii) Fields that already get a value from a field/range formula are left alone by column formulas. These conditions make column formulas very easy to use.

To assign a formula to a column, type it directly into any field in the column, preceded by an equal sign, like ‘=$1+$2’. When you press TAB or RET or C-c C-c with point still in the field, the formula is stored as the formula for the current column, evaluated and the current field replaced with the result. If the field contains only ‘=’, the previously stored formula for this column is used. For each column, Org only remembers the most recently used formula. In the ‘TBLFM’ keyword, column formulas look like ‘$4=$1+$2’. The left-hand side of a column formula can not be the name of column, it must be the numeric column reference or ‘$>’.

Instead of typing an equation into the field, you may also use the following command:

C-c = (org-table-eval-formula)
Install a new formula for the current column and replace current field with the result of the formula. The command prompts for a formula, with default taken from the ‘TBLFM’ keyword, applies it to the current field and stores it. With a numeric prefix argument, e.g., C-5 C-c =, the command applies it to that many consecutive fields in the current column.


***** Lookup functions

Org has three predefined Emacs Lisp functions for lookups in tables.

‘(org-lookup-first VAL S-LIST R-LIST &optional PREDICATE)’
Searches for the first element S in list S-LIST for which

(PREDICATE VAL S)
is non-nil; returns the value from the corresponding position in list R-LIST. The default PREDICATE is equal. Note that the parameters VAL and S are passed to PREDICATE in the same order as the corresponding parameters are in the call to org-lookup-first, where VAL precedes S-LIST. If R-LIST is nil, the matching element S of S-LIST is returned.

‘(org-lookup-last VAL S-LIST R-LIST &optional PREDICATE)’
Similar to org-lookup-first above, but searches for the last element for which PREDICATE is non-nil.

‘(org-lookup-all VAL S-LIST R-LIST &optional PREDICATE)’
Similar to org-lookup-first, but searches for all elements for which PREDICATE is non-nil, and returns all corresponding values. This function can not be used by itself in a formula, because it returns a list of values. However, powerful lookups can be built when this function is combined with other Emacs Lisp functions.

If the ranges used in these functions contain empty fields, the ‘E’ mode for the formula should usually be specified: otherwise empty fields are not included in S-LIST and/or R-LIST which can, for example, result in an incorrect mapping from an element of S-LIST to the corresponding element of R-LIST.

These three functions can be used to implement associative arrays, count matching cells, rank results, group data, etc. For practical examples see this tutorial on Worg.


***** Editing and debugging formulas

You can edit individual formulas in the minibuffer or directly in the field. Org can also prepare a special buffer with all active formulas of a table. When offering a formula for editing, Org converts references to the standard format (like ‘B3’ or ‘D&’) if possible. If you prefer to only work with the internal format (like ‘@3$2’ or ‘$4’), configure the variable org-table-use-standard-references.

C-c = or C-u C-c = (org-table-eval-formula)
Edit the formula associated with the current column/field in the minibuffer. See Column formulas, and Field and range formulas.

C-u C-u C-c = (org-table-eval-formula)
Re-insert the active formula (either a field formula, or a column formula) into the current field, so that you can edit it directly in the field. The advantage over editing in the minibuffer is that you can use the command C-c ?.

C-c ? (org-table-field-info)
While editing a formula in a table field, highlight the field(s) referenced by the reference at point position in the formula.

C-c } (org-table-toggle-coordinate-overlays)
Toggle the display of row and column numbers for a table, using overlays. These are updated each time the table is aligned; you can force it with C-c C-c.

C-c { (org-table-toggle-formula-debugger)
Toggle the formula debugger on and off. See below.

C-c ' (org-table-edit-formulas)
Edit all formulas for the current table in a special buffer, where the formulas are displayed one per line. If the current field has an active formula, point in the formula editor marks it. While inside the special buffer, Org automatically highlights any field or range reference at point position. You may edit, remove and add formulas, and use the following commands:

C-c C-c or C-x C-s (org-table-fedit-finish)
Exit the formula editor and store the modified formulas. With C-u prefix, also apply the new formulas to the entire table.

C-c C-q (org-table-fedit-abort)
Exit the formula editor without installing changes.

C-c C-r (org-table-fedit-toggle-ref-type)
Toggle all references in the formula editor between standard (like ‘B3’) and internal (like ‘@3$2’).

TAB (org-table-fedit-lisp-indent)
Pretty-print or indent Lisp formula at point. When in a line containing a Lisp formula, format the formula according to Emacs Lisp rules. Another TAB collapses the formula back again. In the open formula, TAB re-indents just like in Emacs Lisp mode.

M-TAB (lisp-complete-symbol)
Complete Lisp symbols, just like in Emacs Lisp mode.

S-UP, S-DOWN, S-LEFT, S-RIGHT
Shift the reference at point. For example, if the reference is ‘B3’ and you press S-RIGHT, it becomes ‘C3’. This also works for relative references and for hline references.

M-S-UP (org-table-fedit-line-up)
Move the test line for column formulas up in the Org buffer.

M-S-DOWN (org-table-fedit-line-down)
Move the test line for column formulas down in the Org buffer.

M-UP (org-table-fedit-scroll-up)
Scroll up the window displaying the table.

M-DOWN (org-table-fedit-scroll-down)
Scroll down the window displaying the table.

C-c }
Turn the coordinate grid in the table on and off.

Making a table field blank does not remove the formula associated with the field, because that is stored in a different line—the ‘TBLFM’ keyword line. During the next recalculation, the field will be filled again. To remove a formula from a field, you have to give an empty reply when prompted for the formula, or to edit the ‘TBLFM’ keyword.

You may edit the ‘TBLFM’ keyword directly and re-apply the changed equations with C-c C-c in that line or with the normal recalculation commands in the table.

Using multiple ‘TBLFM’ lines
You may apply the formula temporarily. This is useful when you want to switch the formula applied to the table. Place multiple ‘TBLFM’ keywords right after the table, and then press C-c C-c on the formula to apply. Here is an example:

| x | y |
|---+---|
| 1 |   |
| 2 |   |
#+TBLFM: $2=$1*1
#+TBLFM: $2=$1*2
Pressing C-c C-c in the line of ‘#+TBLFM: $2=$1*2’ yields:

| x | y |
|---+---|
| 1 | 2 |
| 2 | 4 |
#+TBLFM: $2=$1*1
#+TBLFM: $2=$1*2
If you recalculate this table, with C-u C-c *, for example, you get the following result from applying only the first ‘TBLFM’ keyword.

| x | y |
|---+---|
| 1 | 1 |
| 2 | 2 |
#+TBLFM: $2=$1*1
#+TBLFM: $2=$1*2
Debugging formulas
When the evaluation of a formula leads to an error, the field content becomes the string ‘#ERROR’. If you want to see what is going on during variable substitution and calculation in order to find a bug, turn on formula debugging in the Tbl menu and repeat the calculation, for example by pressing C-u C-u C-c = RET in a field. Detailed information are displayed.


***** Updating the table

Recalculation of a table is normally not automatic, but needs to be triggered by a command. To make recalculation at least semi-automatic, see Advanced features.

In order to recalculate a line of a table or the entire table, use the following commands:

C-c * (org-table-recalculate)
Recalculate the current row by first applying the stored column formulas from left to right, and all field/range formulas in the current row.

C-u C-c * or C-u C-c C-c
Recompute the entire table, line by line. Any lines before the first hline are left alone, assuming that these are part of the table header.

C-u C-u C-c * or C-u C-u C-c C-c (org-table-iterate)
Iterate the table by recomputing it until no further changes occur. This may be necessary if some computed fields use the value of other fields that are computed later in the calculation sequence.

M-x org-table-recalculate-buffer-tables
Recompute all tables in the current buffer.

M-x org-table-iterate-buffer-tables
Iterate all tables in the current buffer, in order to converge table-to-table dependencies.


***** Advanced features

If you want the recalculation of fields to happen automatically, or if you want to be able to assign names22 to fields and columns, you need to reserve the first column of the table for special marking characters.

C-# (org-table-rotate-recalc-marks)
Rotate the calculation mark in first column through the states ‘#’, ‘*’, ‘!’, ‘$’. When there is an active region, change all marks in the region.

Here is an example of a table that collects exam results of students and makes use of these features:

|---+---------+--------+--------+--------+-------+------|
|   | Student | Prob 1 | Prob 2 | Prob 3 | Total | Note |
|---+---------+--------+--------+--------+-------+------|
| ! |         |     P1 |     P2 |     P3 |   Tot |      |
| # | Maximum |     10 |     15 |     25 |    50 | 10.0 |
| ^ |         |     m1 |     m2 |     m3 |    mt |      |
|---+---------+--------+--------+--------+-------+------|
| # | Peter   |     10 |      8 |     23 |    41 |  8.2 |
| # | Sam     |      2 |      4 |      3 |     9 |  1.8 |
|---+---------+--------+--------+--------+-------+------|
|   | Average |        |        |        |  25.0 |      |
| ^ |         |        |        |        |    at |      |
| $ | max=50  |        |        |        |       |      |
|---+---------+--------+--------+--------+-------+------|
#+TBLFM: $6=vsum($P1..$P3)::$7=10*$Tot/$max;%.1f::$at=vmean(@-II..@-I);%.1f
Important: Please note that for these special tables, recalculating the table with C-u C-c * only affects rows that are marked ‘#’ or ‘*’, and fields that have a formula assigned to the field itself. The column formulas are not applied in rows with empty first field.

The marking characters have the following meaning:

‘!’
The fields in this line define names for the columns, so that you may refer to a column as ‘$Tot’ instead of ‘$6’.

‘^’
This row defines names for the fields above the row. With such a definition, any formula in the table may use ‘$m1’ to refer to the value ‘10’. Also, if you assign a formula to a names field, it is stored as ‘$name = ...’.

‘_’
Similar to ‘^’, but defines names for the fields in the row below.

‘$’
Fields in this row can define parameters for formulas. For example, if a field in a ‘$’ row contains ‘max=50’, then formulas in this table can refer to the value 50 using ‘$max’. Parameters work exactly like constants, only that they can be defined on a per-table basis.

‘#’
Fields in this row are automatically recalculated when pressing TAB or RET or S-TAB in this row. Also, this row is selected for a global recalculation with C-u C-c *. Unmarked lines are left alone by this command.

‘*’
Selects this line for global recalculation with C-u C-c *, but not for automatic recalculation. Use this when automatic recalculation slows down editing too much.

‘/’
Do not export this line. Useful for lines that contain the narrowing ‘<N>’ markers or column group markers.

Finally, just to whet your appetite for what can be done with the fantastic Calc package, here is a table that computes the Taylor series of degree n at location x for a couple of functions.

|---+-------------+---+-----+--------------------------------------|
|   | Func        | n | x   | Result                               |
|---+-------------+---+-----+--------------------------------------|
| # | exp(x)      | 1 | x   | 1 + x                                |
| # | exp(x)      | 2 | x   | 1 + x + x^2 / 2                      |
| # | exp(x)      | 3 | x   | 1 + x + x^2 / 2 + x^3 / 6            |
| # | x^2+sqrt(x) | 2 | x=0 | x*(0.5 / 0) + x^2 (2 - 0.25 / 0) / 2 |
| # | x^2+sqrt(x) | 2 | x=1 | 2 + 2.5 x - 2.5 + 0.875 (x - 1)^2    |
| * | tan(x)      | 3 | x   | 0.0175 x + 1.77e-6 x^3               |
|---+-------------+---+-----+--------------------------------------|
#+TBLFM: $5=taylor($2,$4,$3);n3
Footnotes
(22)
Such names must start with an alphabetic character and use only alphanumeric/underscore characters.


**** Org Plot

Org Plot can produce graphs of information stored in Org tables, either graphically or in ASCII art.

Graphical plots using Gnuplot
Org Plot can produce 2D and 3D graphs of information stored in Org tables using Gnuplot and Gnuplot mode. To see this in action, ensure that you have both Gnuplot and Gnuplot mode installed on your system, then call C-c " g or M-x org-plot/gnuplot on the following table.

#+PLOT: title:"Citas" ind:1 deps:(3) type:2d with:histograms set:"yrange [0:]"
| Sede      | Max cites | H-index |
|-----------+-----------+---------|
| Chile     |    257.72 |   21.39 |
| Leeds     |    165.77 |   19.68 |
| Sao Paolo |     71.00 |   11.50 |
| Stockholm |    134.19 |   14.33 |
| Morelia   |    257.56 |   17.67 |
Org Plot supports a range of plot types, and provides the ability to add more. For example, a radar plot can be generated like so:

#+PLOT: title:"An evaluation of plaintext document formats" transpose:yes type:radar min:0 max:4
| Format            | Fine-grained-control | Initial Effort | Syntax simplicity | Editor Support | Integrations | Ease-of-referencing | Versatility |
|-------------------+----------------------+----------------+-------------------+----------------+--------------+---------------------+-------------|
| Word              |                    2 |              4 |                 4 |              2 |            3 |                   2 |           2 |
| LaTeX             |                    4 |              1 |                 1 |              3 |            2 |                   4 |           3 |
| Org Mode          |                    4 |              2 |               3.5 |              1 |            4 |                   4 |           4 |
| Markdown          |                    1 |              3 |                 3 |              4 |            3 |                   3 |           1 |
| Markdown + Pandoc |                  2.5 |            2.5 |               2.5 |              3 |            3 |                   3 |           2 |
Notice that Org Plot is smart enough to apply the table’s headers as labels. Further control over the labels, type, content, and appearance of plots can be exercised through the ‘PLOT’ keyword preceding a table. See below for a complete list of Org Plot options. For more information and examples see the Org Plot tutorial.

Plot options
‘set’
Specify any Gnuplot option to be set when graphing.

‘title’
Specify the title of the plot.

‘ind’
Specify which column of the table to use as the ‘x’ axis.

‘timeind’
Specify which column of the table to use as the ‘x’ axis as a time value.

‘deps’
Specify the columns to graph as a Lisp style list, surrounded by parentheses and separated by spaces for example ‘dep:(3 4)’ to graph the third and fourth columns. Defaults to graphing all other columns aside from the ‘ind’ column.

‘transpose’
When ‘y’, ‘yes’, or ‘t’ attempt to transpose the table data before plotting. Also recognizes the shorthand option ‘trans’.

‘type’
Specify the type of the plot, by default one of ‘2d’, ‘3d’, ‘radar’, or ‘grid’. Available types can be customized with org-plot/preset-plot-types.

‘with’
Specify a ‘with’ option to be inserted for every column being plotted, e.g., ‘lines’, ‘points’, ‘boxes’, ‘impulses’. Defaults to ‘lines’.

‘file’
If you want to plot to a file, specify ‘"path/to/desired/output-file"’.

‘labels’
List of labels to be used for the ‘deps’. Defaults to the column headers if they exist.

‘line’
Specify an entire line to be inserted in the Gnuplot script.

‘map’
When plotting ‘3d’ or ‘grid’ types, set this to ‘t’ to graph a flat mapping rather than a ‘3d’ slope.

‘min’
Provides a minimum axis value that may be used by a plot type. Implicitly assumes the ‘y’ axis is being referred to. Can explicitly provide a value for a either the ‘x’ or ‘y’ axis with ‘xmin’ and ‘ymin’.

‘max’
Provides a maximum axis value that may be used by a plot type. Implicitly assumes the ‘y’ axis is being referred to. Can explicitly provide a value for a either the ‘x’ or ‘y’ axis with ‘xmax’ and ‘ymax’.

‘ticks’
Provides a desired number of axis ticks to display, that may be used by a plot type. If none is given a plot type that requires ticks will use org--plot/sensible-tick-num to try to determine a good value.

‘timefmt’
Specify format of Org mode timestamps as they will be parsed by Gnuplot. Defaults to ‘%Y-%m-%d-%H:%M:%S’.

‘script’
If you want total control, you can specify a script file—place the file name between double-quotes—which will be used to plot. Before plotting, every instance of ‘$datafile’ in the specified script will be replaced with the path to the generated data file. Note: even if you set this option, you may still want to specify the plot type, as that can impact the content of the data file.

ASCII bar plots
While point is on a column, typing C-c " a or M-x orgtbl-ascii-plot create a new column containing an ASCII-art bars plot. The plot is implemented through a regular column formula. When the source column changes, the bar plot may be updated by refreshing the table, for example typing C-u C-c *.

| Sede          | Max cites |              |
|---------------+-----------+--------------|
| Chile         |    257.72 | WWWWWWWWWWWW |
| Leeds         |    165.77 | WWWWWWWh     |
| Sao Paolo     |     71.00 | WWW;         |
| Stockholm     |    134.19 | WWWWWW:      |
| Morelia       |    257.56 | WWWWWWWWWWWH |
| Rochefourchat |      0.00 |              |
#+TBLFM: $3='(orgtbl-ascii-draw $2 0.0 257.72 12)
The formula is an Elisp call.

Function: orgtbl-ascii-draw value min max &optional width
Draw an ASCII bar in a table.

VALUE is the value to plot.

MIN is the value displayed as an empty bar. MAX is the value filling all the WIDTH. Sources values outside this range are displayed as ‘too small’ or ‘too large’.

WIDTH is the number of characters of the bar plot. It defaults to ‘12’.


*** Hyperlinks

Like HTML, Org provides support for links inside a file, external links to other files, Usenet articles, emails, and much more.

**** Link Format

Org recognizes plain URIs, possibly wrapped within angle brackets23, and activate them as clickable links.

The general link format, however, looks like this:

[[LINK][DESCRIPTION]]
or alternatively

[[LINK]]
Some ‘\’, ‘[’ and ‘]’ characters in the LINK part need to be “escaped”, i.e., preceded by another ‘\’ character. More specifically, the following characters, and only them, must be escaped:

all ‘[’ and ‘]’ characters,
every ‘\’ character preceding either ‘]’ or ‘[’,
every ‘\’ character at the end of the link.
Functions inserting links (see Handling Links) properly escape ambiguous characters. You only need to bother about the rules above when inserting directly, or yanking, a URI within square brackets. When in doubt, you may use the function org-link-escape, which turns a link string into its escaped form.

Once a link in the buffer is complete, with all brackets present, Org changes the display so that ‘DESCRIPTION’ is displayed instead of ‘[[LINK][DESCRIPTION]]’ and ‘LINK’ is displayed instead of ‘[[LINK]]’. Links are highlighted in the org-link face, which, by default, is an underlined face.

You can directly edit the visible part of a link. This can be either the LINK part, if there is no description, or the DESCRIPTION part otherwise. To also edit the invisible LINK part, use C-c C-l with point on the link (see Handling Links).

If you place point at the beginning or just behind the end of the displayed text and press BS, you remove the—invisible—bracket at that location24. This makes the link incomplete and the internals are again displayed as plain text. Inserting the missing bracket hides the link internals again. To show the internal structure of all links, use the menu: Org → Hyperlinks → Literal links, customize org-link-descriptive, or use ‘literallinks’ startup option.

Footnotes
(23)
Plain URIs are recognized only for a well-defined set of schemes. See External Links. Unlike URI syntax, they cannot contain parenthesis or white spaces, either. URIs within angle brackets have no such limitation.

(24)
More accurately, the precise behavior depends on how point arrived there—see Invisible Text.


**** Internal Links

A link that does not look like a URL—i.e., does not start with a known scheme or a file name—refers to the current document. You can follow it with C-c C-o when point is on the link, or with a mouse click (see Handling Links).

Org provides several refinements to internal navigation within a document. Most notably, a construct like ‘[[#my-custom-id]]’ specifically targets the entry with the ‘CUSTOM_ID’ property set to ‘my-custom-id’. Also, an internal link looking like ‘[[*Some section]]’ points to a headline with the name ‘Some section’25.

When the link does not belong to any of the cases above, Org looks for a dedicated target: the same string in double angular brackets, like ‘<<My Target>>’.

If no dedicated target exists, the link tries to match the exact name of an element within the buffer. Naming is done, unsurprisingly, with the ‘NAME’ keyword, which has to be put in the line before the element it refers to, as in the following example

#+NAME: My Target
| a  | table      |
|----+------------|
| of | four cells |
Ultimately, if none of the above succeeds, Org searches for a headline that is exactly the link text but may also include a TODO keyword and tags, or initiates a plain text search, according to the value of org-link-search-must-match-exact-headline.

Note that you must make sure custom IDs, dedicated targets, and names are unique throughout the document. Org provides a linter to assist you in the process, if needed. See Org Syntax.

During export, internal links are used to mark objects and assign them a number. Marked objects are then referenced by links pointing to them. In particular, links without a description appear as the number assigned to the marked object26. In the following excerpt from an Org buffer

1. one item
2. <<target>>another item
Here we refer to item [[target]].
The last sentence will appear as ‘Here we refer to item 2’ when exported.

In non-Org files, the search looks for the words in the link text. In the above example the search would be for ‘target’.

Following a link pushes a mark onto Org’s own mark ring. You can return to the previous position with C-c &. Using this command several times in direct succession goes back to positions recorded earlier.

Footnotes
(25)
To insert a link targeting a headline, in-buffer completion can be used. Just type a star followed by a few optional letters into the buffer and press M-TAB. All headlines in the current buffer are offered as completions.

(26)
When targeting a ‘NAME’ keyword, the ‘CAPTION’ keyword is mandatory in order to get proper numbering (see Captions).


**** Radio Targets

Org can automatically turn any occurrences of certain target names in normal text into a link. So without explicitly creating a link, the text connects to the target radioing its position. Radio targets are enclosed by triple angular brackets. For example, a target ‘<<<My Target>>>’ causes each occurrence of ‘my target’ in normal text to become activated as a link. The Org file is scanned automatically for radio targets only when the file is first loaded into Emacs. To update the target list during editing, press C-c C-c with point on or at a target.


**** External Links

Org supports links to files, websites, Usenet and email messages, BBDB database entries and links to both IRC conversations and their logs. External links are URL-like locators. They start with a short identifying string followed by a colon. There can be no space after the colon.

Here is the full set of built-in link types:

‘file’
File links. File name may be remote, absolute, or relative.

As a special case, “file” prefix may be omitted if the file name is complete, e.g., it starts with ‘./’, or ‘/’.

‘attachment’
Same as file links but for files and folders attached to the current node (see Attachments). Attachment links are intended to behave exactly as file links but for files relative to the attachment directory.

‘bbdb’
Link to a BBDB record, with possible regexp completion.

‘docview’
Link to a document opened with DocView mode. You may specify a page number.

‘doi’
Link to an electronic resource, through its handle.

‘elisp’
Execute an Elisp command upon activation.

‘gnus’, ‘rmail’, ‘mhe’
Link to messages or folders from a given Emacs MUA.

‘help’
Display documentation of a symbol in ‘*Help*’ buffer.

‘http’, ‘https’
Web links.

‘id’
Link to a specific headline by its ID property, in an Org file.

‘info’
Link to an Info manual, or to a specific node.

‘irc’
Link to an IRC channel.

‘mailto’
Link to message composition.

‘news’
Usenet links.

‘shell’
Execute a shell command upon activation.

For ‘file:’ and ‘id:’ links, you can additionally specify a line number, or a text search string, separated by ‘::’. In Org files, you may link to a headline name, a custom ID, or a code reference instead.

The following table illustrates the link types above, along with their options:

Link Type	Example
http	‘http://staff.science.uva.nl/c.dominik/’
https	‘https://orgmode.org/’
doi	‘doi:10.1000/182’
file	‘file:/home/dominik/images/jupiter.jpg’
‘/home/dominik/images/jupiter.jpg’ (same as above)
‘file:papers/last.pdf’
‘./papers/last.pdf’ (same as above)
‘file:/ssh:me@some.where:papers/last.pdf’ (remote)
‘/ssh:me@some.where:papers/last.pdf’ (same as above)
‘file:sometextfile::NNN’ (jump to line number)
‘file:projects.org’
‘file:projects.org::some words’ (text search)27
‘file:projects.org::*task title’ (headline search)
‘file:projects.org::#custom-id’ (headline search)
attachment	‘attachment:projects.org’
‘attachment:projects.org::some words’ (text search)
docview	‘docview:papers/last.pdf::NNN’
id	‘id:B7423F4D-2E8A-471B-8810-C40F074717E9’
‘id:B7423F4D-2E8A-471B-8810-C40F074717E9::*task’ (headline search)
news	‘news:comp.emacs’
mailto	‘mailto:adent@galaxy.net’
mhe	‘mhe:folder’ (folder link)
‘mhe:folder#id’ (message link)
rmail	‘rmail:folder’ (folder link)
‘rmail:folder#id’ (message link)
gnus	‘gnus:group’ (group link)
‘gnus:group#id’ (article link)
bbdb	‘bbdb:R.*Stallman’ (record with regexp)
irc	‘irc:/irc.com/#emacs/bob’
help	‘help:org-store-link’
info	‘info:org#External links’
shell	‘shell:ls *.org’
elisp	‘elisp:(find-file "Elisp.org")’ (Elisp form to evaluate)
‘elisp:org-agenda’ (interactive Elisp command)
On top of these built-in link types, additional ones are available through the ‘org-contrib’ repository (see Installation). For example, these links to VM or Wanderlust messages are available when you load the corresponding libraries from the ‘org-contrib’ repository:

‘vm:folder’	VM folder link
‘vm:folder#id’	VM message link
‘vm://myself@some.where.org/folder#id’	VM on remote machine
‘vm-imap:account:folder’	VM IMAP folder link
‘vm-imap:account:folder#id’	VM IMAP message link
‘wl:folder’	Wanderlust folder link
‘wl:folder#id’	Wanderlust message link
For information on customizing Org to add new link types, see Adding Hyperlink Types.

A link should be enclosed in double brackets and may contain descriptive text to be displayed instead of the URL (see Link Format), for example:

[[https://www.gnu.org/software/emacs/][GNU Emacs]]
If the description is a file name or URL that points to an image, HTML export (see HTML Export) inlines the image as a clickable button. If there is no description at all and the link points to an image, that image is inlined into the exported HTML file.

Org also recognizes external links amid normal text and activates them as links. If spaces must be part of the link (for example in ‘bbdb:R.*Stallman’), or if you need to remove ambiguities about the end of the link, enclose the link in square or angular brackets.

Footnotes
(27)
The actual behavior of the search depends on the value of the variable org-link-search-must-match-exact-headline. If its value is nil, then a fuzzy text search is done. If it is t, then only the exact headline is matched, ignoring spaces and statistic cookies. If the value is query-to-create, then an exact headline is searched; if it is not found, then the user is queried to create it.


**** Handling Links

Org provides methods to create a link in the correct syntax, to insert it into an Org file, and to follow the link.

The main function is org-store-link, called with M-x org-store-link. Because of its importance, we suggest to bind it to a widely available key (see Activation). It stores a link to the current location. The link is stored for later insertion into an Org buffer—see below. The kind of link that is created depends on the current buffer:

Org mode buffers
For Org files, if there is a ‘<<target>>’ at point, the link points to the target. If there is a named block (using ‘#+name:’) at point, the link points to that name. Otherwise it points to the current headline, which is also the description.

If the headline has a ‘CUSTOM_ID’ property, store a link to this custom ID. In addition or alternatively, depending on the value of org-id-link-to-org-use-id, create and/or use a globally unique ‘ID’ property for the link28. So using this command in Org buffers potentially creates two links: a human-readable link from the custom ID, and one that is globally unique and works even if the entry is moved from file to file. The ‘ID’ property can be either a UUID (default) or a timestamp, depending on org-id-method. Later, when inserting the link, you need to decide which one to use.

When org-id-link-consider-parent-id is t29, parent ‘ID’ properties are considered. This allows linking to specific targets, named blocks, or headlines (which may not have a globally unique ‘ID’ themselves) within the context of a parent headline or file which does.

For example, given this org file:
#+begin_src org

# * Parent
# :PROPERTIES:
# :ID: abc
# :END:
# ** Child 1
# ** Child 2

#+end_src 

Storing a link with point at “Child 1” will produce a link ‘<id:abc::*Child 1>’, which precisely links to the “Child 1” headline even though it does not have its own ID.

Email/News clients: VM, Rmail, Wanderlust, MH-E, Gnus
Pretty much all Emacs mail clients are supported. The link points to the current article, or, in some Gnus buffers, to the group. The description is constructed according to the variable org-link-email-description-format. By default, it refers to the addressee and the subject.

Web browsers: W3M and EWW
Here the link is the current URL, with the page title as the description.

Contacts: BBDB
Links created in a BBDB buffer point to the current entry.

Chat: IRC
For IRC links, if the variable org-irc-link-to-logs is non-nil, create a ‘file’ style link to the relevant point in the logs for the current conversation. Otherwise store an ‘irc’ style link to the user/channel/server under the point.

Other files
For any other file, the link points to the file, with a search string (see Search Options in File Links) pointing to the contents of the current line. If there is an active region, the selected words form the basis of the search string. You can write custom Lisp functions to select the search string and perform the search for particular file types (see Custom Searches).

You can also define dedicated links to other files. See Adding Hyperlink Types.

Agenda view
When point is in an agenda view, the created link points to the entry referenced by the current line.

From an Org buffer, the following commands create, navigate or, more generally, act on links.

C-c C-l (org-insert-link)
Insert a link30. This prompts for a link to be inserted into the buffer. You can just type a link, using text for an internal link, or one of the link type prefixes mentioned in the examples above. The link is inserted into the buffer, along with a descriptive text31. If some text was selected at this time, it becomes the default description.

Inserting stored links
All links stored during the current session are part of the history for this prompt, so you can access them with UP and DOWN (or M-p, M-n).

Completion support
Completion with TAB helps you to insert valid link prefixes like ‘http’ or ‘ftp’, including the prefixes defined through link abbreviations (see Link Abbreviations). If you press RET after inserting only the prefix, Org offers specific completion support for some link types32. For example, if you type f i l e RET—alternative access: C-u C-c C-l, see below—Org offers file name completion, and after b b d b RET you can complete contact names.

C-u C-c C-l
When C-c C-l is called with a C-u prefix argument, insert a link to a file. You may use file name completion to select the name of the file. The path to the file is inserted relative to the directory of the current Org file, if the linked file is in the current directory or in a sub-directory of it, or if the path is written relative to the current directory using ‘../’. Otherwise an absolute path is used, if possible with ‘~/’ for your home directory. You can force an absolute path with two C-u prefixes.

C-c C-l (with point on existing link)
When point is on an existing link, C-c C-l allows you to edit the link and description parts of the link.

C-c C-o (org-open-at-point)
Open link at point. This launches a web browser for URL (using browse-url-at-point), run VM/MH-E/Wanderlust/Rmail/Gnus/BBDB for the corresponding links, and execute the command in a shell link. When point is on an internal link, this command runs the corresponding search. When point is on the tags part of a headline, it creates the corresponding tags view (see Matching tags and properties). If point is on a timestamp, it compiles the agenda for that date. Furthermore, it visits text and remote files in ‘file’ links with Emacs and select a suitable application for local non-text files. Classification of files is based on file extension only. See option org-file-apps. If you want to override the default application and visit the file with Emacs, use a C-u prefix. If you want to avoid opening in Emacs, use a C-u C-u prefix.

If point is on a headline, but not on a link, offer all links in the headline and entry text. If you want to setup the frame configuration for following links, customize org-link-frame-setup.

RET
When org-return-follows-link is set, RET also follows the link at point.

mouse-2 or mouse-1
On links, mouse-1 and mouse-2 opens the link just as C-c C-o does.

mouse-3
Like mouse-2, but force file links to be opened with Emacs, and internal links to be displayed in another window33.

C-c % (org-mark-ring-push)
Push the current position onto the Org mark ring, to be able to return easily. Commands following an internal link do this automatically.

C-c & (org-mark-ring-goto)
Jump back to a recorded position. A position is recorded by the commands following internal links, and by C-c %. Using this command several times in direct succession moves through a ring of previously recorded positions.

C-c C-x C-n (org-next-link)
C-c C-x C-p (org-previous-link)
Move forward/backward to the next link in the buffer. At the limit of the buffer, the search fails once, and then wraps around. The key bindings for this are really too long; you might want to bind this also to M-n and M-p.

(with-eval-after-load 'org
  (define-key org-mode-map (kbd "M-n") #'org-next-link)
  (define-key org-mode-map (kbd "M-p") #'org-previous-link))
Footnotes
(28)
The Org Id library must first be loaded, either through org-customize, by enabling id in org-modules, or by adding ‘(require 'org-id)’ in your Emacs init file.

(29)
Also, org-link-context-for-files and org-id-link-use-context should be both enabled (which they are, by default).

(30)
Note that you do not have to use this command to insert a link. Links in Org are plain text, and you can type or paste them straight into the buffer. By using this command, the links are automatically enclosed in double brackets, and you will be asked for the optional descriptive text.

(31)
After insertion of a stored link, the link will be removed from the list of stored links. To keep it in the list for later use, use a triple C-u prefix argument to C-c C-l, or configure the option org-link-keep-stored-after-insertion.

(32)
This works if a function has been defined in the :complete property of a link in org-link-parameters.

(33)
See the variable org-link-use-indirect-buffer-for-internals.


**** Using Links Outside Org

You can insert and follow links that have Org syntax not only in Org, but in any Emacs buffer. For this, Org provides two functions: org-insert-link-global and org-open-at-point-global.

You might want to bind them to globally available keys. See Activation for some advice.


**** Link Abbreviations

Long URL can be cumbersome to type, and often many similar links are needed in a document. For this you can use link abbreviations. An abbreviated link looks like this

[[linkword:tag][description]]
where the tag is optional. The linkword must be a word, starting with a letter, followed by letters, numbers, ‘-’, and ‘_’. Abbreviations are resolved according to the information in the variable org-link-abbrev-alist that relates the linkwords to replacement text. Here is an example:

(setq org-link-abbrev-alist
      '(("bugzilla"        . "https://10.1.2.9/bugzilla/show_bug.cgi?id=")
        ("Nu Html Checker" . "https://validator.w3.org/nu/?doc=%h")
        ("duckduckgo"      . "https://duckduckgo.com/?q=%s")
        ("omap"            . "https://nominatim.openstreetmap.org/search?q=%s&polygon=1")
        ("ads"             . "https://ui.adsabs.harvard.edu/search/q=%20author%3A\"%s\"")))
If the replacement text contains the string ‘%s’, it is replaced with the tag. Using ‘%h’ instead of ‘%s’ percent-encodes the tag (see the example above, where we need to encode the URL parameter). Using ‘%(my-function)’ passes the tag to a custom Lisp function, and replace it by the resulting string.

If the replacement text do not contain any specifier, it is simply appended to the string in order to create the link.

Instead of a string, you may also specify a Lisp function to create the link. Such a function will be called with the tag as the only argument.

With the above setting, you could link to a specific bug with ‘[[bugzilla:129]]’, search the web for ‘OrgMode’ with ‘[[duckduckgo:OrgMode]]’, show the map location of the Free Software Foundation ‘[[omap:31 Milk Street, Boston]]’ or of Carsten’s office ‘[[omap:Science Park 904, Amsterdam, The Netherlands]]’ and find out what the Org author is doing besides Emacs hacking with ‘[[ads:Dominik,C]]’.

If you need special abbreviations just for a single Org buffer, you can define them in the file with

#+LINK: bugzilla  https://10.1.2.9/bugzilla/show_bug.cgi?id=
#+LINK: duckduckgo https://duckduckgo.com/?q=%s
#+LINK: "Nu Html Checker" https://validator.w3.org/nu/?doc=%h
The abbreviations containing spaces must be quoted.

In-buffer completion (see Completion) can be used after ‘[’ to complete link abbreviations. You may also define a Lisp function that implements special (e.g., completion) support for inserting such a link with C-c C-l. Such a function should not accept any arguments, and should return the full link with a prefix. You can set the link completion function like this:

(org-link-set-parameter "type" :complete #'some-completion-function)

**** Search Options in File Links

File links can contain additional information to make Emacs jump to a particular location in the file when following a link. This can be a line number or a search option after a double colon34. For example, when the command org-store-link creates a link (see Handling Links) to a file, it encodes the words in the current line as a search string that can be used to find this line back later when following the link with C-c C-o.

Note that all search options apply for Attachment and ID links in the same way that they apply for File links.

Here is the syntax of the different ways to attach a search to a file link, together with explanations for each:

[[file:~/code/main.c::255]]
[[file:~/xx.org::My Target]]
[[file:~/xx.org::*My Target]]
[[file:~/xx.org::#my-custom-id]]
[[file:~/xx.org::/regexp/]]
[[attachment:main.c::255]]
‘255’
Jump to line 255.

‘My Target’
Search for a link target ‘<<My Target>>’, or do a text search for ‘my target’, similar to the search in internal links, see Internal Links. In HTML export (see HTML Export), such a file link becomes a HTML reference to the corresponding named anchor in the linked file.

‘*My Target’
In an Org file, restrict search to headlines.

‘#my-custom-id’
Link to a heading with a ‘CUSTOM_ID’ property

‘/REGEXP/’
Do a regular expression search for REGEXP (see Regular Expressions). This uses the Emacs command occur to list all matches in a separate window. If the target file is in Org mode, org-occur is used to create a sparse tree with the matches.

As a degenerate case, a file link with an empty file name can be used to search the current file. For example, ‘[[file:::find me]]’ does a search for ‘find me’ in the current file, just as ‘[[find me]]’ would.

Footnotes
(34)
For backward compatibility, line numbers can also follow a single colon.


**** Custom Searches

The default mechanism for creating search strings and for doing the actual search related to a file link may not work correctly in all cases. For example, BibTeX database files have many entries like year="1993" which would not result in good search strings, because the only unique identification for a BibTeX entry is the citation key.

If you come across such a problem, you can write custom functions to set the right search string for a particular file type, and to do the search for the string in the file. Using add-hook, these functions need to be added to the hook variables org-create-file-search-functions and org-execute-file-search-functions. See the docstring for these variables for more information. Org actually uses this mechanism for BibTeX database files, and you can use the corresponding code as an implementation example. See the file ‘ol-bibtex.el’.


*** TODO Items

Org mode does not maintain TODO lists as separate documents35. Instead, TODO items are an integral part of the notes file, because TODO items usually come up while taking notes! With Org mode, simply mark any entry in a tree as being a TODO item. In this way, information is not duplicated, and the entire context from which the TODO item emerged is always present.

Of course, this technique for managing TODO items scatters them throughout your notes file. Org mode compensates for this by providing methods to give you an overview of all the things that you have to do.

**** Basic TODO Functionality

Any headline becomes a TODO item when it starts with the word ‘TODO’, for example:
#+begin_src org
 * TODO Write letter to Sam Fortune
#+end_src 
The most important commands to work with TODO entries are:

C-c C-t (org-todo)
Rotate the TODO state of the current item among

,-> (unmarked) -> TODO -> DONE --.
'--------------------------------'
If TODO keywords have fast access keys (see Fast access to TODO states), prompt for a TODO keyword through the fast selection interface; this is the default behavior when org-use-fast-todo-selection is non-nil.

The same state changing can also be done “remotely” from the agenda buffer with the t command key (see Commands in the Agenda Buffer).

S-RIGHT S-LEFT
Select the following/preceding TODO state, similar to cycling. Useful mostly if more than two TODO states are possible (see Extended Use of TODO Keywords). See also Packages that conflict with Org mode, for a discussion of the interaction with shift-selection. See also the variable org-treat-S-cursor-todo-selection-as-state-change.

C-c / t (org-show-todo-tree)
View TODO items in a sparse tree (see Sparse Trees). Folds the entire buffer, but shows all TODO items—with not-DONE state—and the headings hierarchy above them. With a prefix argument, or by using C-c / T, search for a specific TODO. You are prompted for the keyword, and you can also give a list of keywords like ‘KWD1|KWD2|...’ to list entries that match any one of these keywords. With a numeric prefix argument N, show the tree for the Nth keyword in the variable org-todo-keywords. With two prefix arguments, find all TODO states, both un-done and done.

M-x org-agenda t (org-todo-list)
Show the global TODO list. Collects the TODO items (with not-DONE states) from all agenda files (see Agenda Views) into a single buffer. The new buffer is in Org Agenda mode, which provides commands to examine and manipulate the TODO entries from the new buffer (see Commands in the Agenda Buffer). See The global TODO list, for more information.

S-M-RET (org-insert-todo-heading)
Insert a new TODO entry below the current one.

Changing a TODO state can also trigger tag changes. See the docstring of the option org-todo-state-tags-triggers for details.


**** Extended Use of TODO Keywords

By default, marked TODO entries have one of only two states: TODO and DONE. Org mode allows you to classify TODO items in more complex ways with TODO keywords (stored in org-todo-keywords). With special setup, the TODO keyword system can work differently in different files.

Note that tags are another way to classify headlines in general and TODO items in particular (see Tags).

***** todo keywords as workflow states

You can use TODO keywords to indicate different, possibly sequential states in the process of working on an item, for example36:

(setq org-todo-keywords
      '((sequence "TODO" "FEEDBACK" "VERIFY" "|" "DONE" "DELEGATED")))
The vertical bar separates the TODO keywords (states that need action) from the DONE states (which need no further action). If you do not provide the separator bar, the last state is used as the DONE state.

With this setup, the command C-c C-t cycles an entry from ‘TODO’ to ‘FEEDBACK’, then to ‘VERIFY’, and finally to ‘DONE’ and ‘DELEGATED’. You may also use a numeric prefix argument to quickly select a specific state. For example C-3 C-c C-t changes the state immediately to ‘VERIFY’. Or you can use S-RIGHT and S-LEFT to go forward and backward through the states. If you define many keywords, you can use in-buffer completion (see Completion) or a special one-key selection scheme (see Fast access to TODO states) to insert these words into the buffer. Changing a TODO state can be logged with a timestamp, see Tracking TODO state changes, for more information.

Footnotes
(36)
Changing the variable org-todo-keywords only becomes effective after restarting Org mode in a buffer.


***** todo keywords as types

The second possibility is to use TODO keywords to indicate different types of action items. For example, you might want to indicate that items are for “work” or “home”. Or, when you work with several people on a single project, you might want to assign action items directly to persons, by using their names as TODO keywords. This type of functionality is actually much better served by using tags (see Tags), so the TODO implementation is kept just for backward compatibility.

Using TODO types, it would be set up like this:

(setq org-todo-keywords '((type "Fred" "Sara" "Lucy" "|" "DONE")))
In this case, different keywords do not indicate states, but rather different types. So the normal work flow would be to assign a task to a person, and later to mark it DONE. Org mode supports this style by adapting the workings of the command C-c C-t37. When used several times in succession, it still cycles through all names, in order to first select the right type for a task. But when you return to the item after some time and execute C-c C-t again, it will switch from any name directly to ‘DONE’. Use prefix arguments or completion to quickly select a specific name. You can also review the items of a specific TODO type in a sparse tree by using a numeric prefix to C-c / t. For example, to see all things Lucy has to do, you would use C-3 C-c / t. To collect Lucy’s items from all agenda files into a single buffer, you would use the numeric prefix argument as well when creating the global TODO list: C-3 M-x org-agenda t.

Footnotes
(37)
This is also true for the t command in the agenda buffer.

***** Multiple keyword sets in one file

Sometimes you may want to use different sets of TODO keywords in parallel. For example, you may want to have the basic TODO/DONE, but also a workflow for bug fixing, and a separate state indicating that an item has been canceled—so it is not DONE, but also does not require action. Your setup would then look like this:

(setq org-todo-keywords
      '((sequence "TODO" "|" "DONE")
        (sequence "REPORT" "BUG" "KNOWNCAUSE" "|" "FIXED")
        (sequence "|" "CANCELED")))
The keywords should all be different, this helps Org mode keep track of which subsequence should be used for a given entry. In this setup, C-c C-t only operates within a sub-sequence, so it switches from ‘DONE’ to (nothing) to ‘TODO’, and from ‘FIXED’ to (nothing) to ‘REPORT’. Therefore you need a mechanism to initially select the correct sequence. In addition to typing a keyword or using completion (see Completion), you may also apply the following commands:

C-u C-u C-c C-t
C-S-RIGHT
C-S-LEFT
These keys jump from one TODO sub-sequence to the next. In the above example, C-u C-u C-c C-t or C-S-RIGHT would jump from ‘TODO’ or ‘DONE’ to ‘REPORT’, and any of the words in the second row to ‘CANCELED’. Note that the C-S- key binding conflict with shift-selection (see Packages that conflict with Org mode).

S-RIGHT
S-LEFT
S-LEFT and S-RIGHT walk through all keywords from all sub-sequences, so for example S-RIGHT would switch from ‘DONE’ to ‘REPORT’ in the example above. For a discussion of the interaction with shift-selection, see Packages that conflict with Org mode.


***** Fast access to TODO states

If you would like to quickly change an entry to an arbitrary TODO state instead of cycling through the states, you can set up keys for single-letter access to the states. This is done by adding the selection character after each keyword, in parentheses38. For example:

(setq org-todo-keywords
      '((sequence "TODO(t)" "|" "DONE(d)")
        (sequence "REPORT(r)" "BUG(b)" "KNOWNCAUSE(k)" "|" "FIXED(f)")
        (sequence "|" "CANCELED(c)")))
If you then press C-c C-t followed by the selection key, the entry is switched to this state. SPC can be used to remove any TODO keyword from an entry.

Footnotes
(38)
All characters are allowed except ‘@’, ‘^’ and ‘!’, which have a special meaning here.


***** Setting up keywords for individual files

It can be very useful to use different aspects of the TODO mechanism in different files. For file-local settings, you need to add special lines to the file which set the keywords and interpretation for that file only. For example, to set one of the two examples discussed above, you need one of the following lines, starting in column zero anywhere in the file:

#+TODO: TODO FEEDBACK VERIFY | DONE CANCELED
You may also write ‘#+SEQ_TODO’ to be explicit about the interpretation, but it means the same as ‘#+TODO’, or

#+TYP_TODO: Fred Sara Lucy Mike | DONE
A setup for using several sets in parallel would be:

#+TODO: TODO(t) | DONE(d)
#+TODO: REPORT(r) BUG(b) KNOWNCAUSE(k) | FIXED(f)
#+TODO: | CANCELED(c)
To make sure you are using the correct keyword, type ‘#+’ into the buffer and then use M-TAB to complete it (see Completion).

Remember that the keywords after the vertical bar—or the last keyword if no bar is there—must always mean that the item is DONE, although you may use a different word. After changing one of these lines, use C-c C-c with point still in the line to make the changes known to Org mode39.

Footnotes
(39)
Org mode parses these lines only when Org mode is activated after visiting a file. C-c C-c with point in a line starting with ‘#+’ is simply restarting Org mode for the current buffer.


***** Faces for TODO keywords

Org mode highlights TODO keywords with special faces: org-todo for keywords indicating that an item still has to be acted upon, and org-done for keywords indicating that an item is finished. If you are using more than two different states, you might want to use special faces for some of them. This can be done using the variable org-todo-keyword-faces. For example:

(setq org-todo-keyword-faces
      '(("TODO" . org-warning) ("STARTED" . "yellow")
        ("CANCELED" . (:foreground "blue" :weight bold))))
While using a list with face properties as shown for ‘CANCELED’ should work, this does not always seem to be the case. If necessary, define a special face and use that. A string is interpreted as a color. The variable org-faces-easy-properties determines if that color is interpreted as a foreground or a background color.


***** todo dependencies

The structure of Org files—hierarchy and lists—makes it easy to define TODO dependencies. Usually, a parent TODO task should not be marked as done until all TODO subtasks, or children tasks, are marked as done. Sometimes there is a logical sequence to (sub)tasks, so that one subtask cannot be acted upon before all siblings above it have been marked as done. If you customize the variable org-enforce-todo-dependencies, Org blocks entries from changing state to DONE while they have TODO children that are not DONE. Furthermore, if an entry has a property ‘ORDERED’, each of its TODO children is blocked until all earlier siblings are marked as done. Here is an example:

#+begin_src org


# * TODO Blocked until (two) is done
# ** DONE one
# ** TODO two

# * Parent
# :PROPERTIES:
# :ORDERED:  t
# :END:
# ** TODO a
# ** TODO b, needs to wait for (a)
# ** TODO c, needs to wait for (a) and (b)
# You can ensure an entry is never blocked by using the ‘NOBLOCKING’ property (see Properties and Columns):

# * This entry is never blocked
# :PROPERTIES:
# :NOBLOCKING: t
# :END:


  
#+end_src

C-c C-x o (org-toggle-ordered-property)
Toggle the ‘ORDERED’ property of the current entry. A property is used for this behavior because this should be local to the current entry, not inherited from entries above like a tag (see Tags). However, if you would like to track the value of this property with a tag for better visibility, customize the variable org-track-ordered-property-with-tag.

C-u C-u C-u C-c C-t
Change TODO state, regardless of any state blocking.

If you set the variable org-agenda-dim-blocked-tasks, TODO entries that cannot be marked as done because of unmarked children are shown in a dimmed font or even made invisible in agenda views (see Agenda Views).

You can also block changes of TODO states by using checkboxes (see Checkboxes). If you set the variable org-enforce-todo-checkbox-dependencies, an entry that has unchecked checkboxes is blocked from switching to DONE.

If you need more complex dependency structures, for example dependencies between entries in different trees or files, check out the module ‘org-depend.el’ in the ‘org-contrib’ repository.


**** Progress Logging

To record a timestamp and a note when changing a TODO state, call the command org-todo with a prefix argument.

C-u C-c C-t (org-todo)
Prompt for a note and record a the time of the TODO state change. The note is inserted as a list item below the headline, but can also be placed into a drawer, see Tracking TODO state changes.

If you want to be more systematic, Org mode can automatically record a timestamp and optionally a note when you mark a TODO item as DONE, or even each time you change the state of a TODO item. This system is highly configurable, settings can be on a per-keyword basis and can be localized to a file or even a subtree. For information on how to clock working time for a task, see Clocking Work Time.

***** Closing items

The most basic automatic logging is to keep track of when a certain TODO item was marked as done. This can be achieved with40

(setq org-log-done 'time)
Then each time you turn an entry from a TODO (not-done) state into any of the DONE states, a line ‘CLOSED: [timestamp]’ is inserted just after the headline. If you turn the entry back into a TODO item through further state cycling, that line is removed again. If you turn the entry back to a non-TODO state (by pressing C-c C-t SPC for example), that line is also removed, unless you set org-closed-keep-when-no-todo to non-nil. If you want to record a note along with the timestamp, use41

(setq org-log-done 'note)
You are then prompted for a note, and that note is stored below the entry with a ‘Closing Note’ heading.

Footnotes
(40)
The corresponding in-buffer setting is: ‘#+STARTUP: logdone’.

(41)
The corresponding in-buffer setting is: ‘#+STARTUP: lognotedone’.


***** Tracking TODO state changes

You might want to automatically keep track of when a state change occurred and maybe take a note about this change. You can either record just a timestamp, or a time-stamped note. These records are inserted after the headline as an itemized list, newest first42. When taking a lot of notes, you might want to get the notes out of the way into a drawer (see Drawers). Customize the variable org-log-into-drawer to get this behavior—the recommended drawer for this is called ‘LOGBOOK’43. You can also overrule the setting of this variable for a subtree by setting a ‘LOG_INTO_DRAWER’ property.

Since it is normally too much to record a note for every state, Org mode expects configuration on a per-keyword basis for this. This is achieved by adding special markers ‘!’ (for a timestamp) or ‘@’ (for a note with timestamp) in parentheses after each keyword. For example, with the setting

(setq org-todo-keywords
      '((sequence "TODO(t)" "WAIT(w@/!)" "|" "DONE(d!)" "CANCELED(c@)")))
You not only define global TODO keywords and fast access keys, but also request that a time is recorded when the entry is set to ‘DONE’, and that a note is recorded when switching to ‘WAIT’ or ‘CANCELED’44. The setting for ‘WAIT’ is even more special: the ‘!’ after the slash means that in addition to the note taken when entering the state, a timestamp should be recorded when leaving the ‘WAIT’ state, if and only if the target state does not configure logging for entering it. So it has no effect when switching from ‘WAIT’ to ‘DONE’, because ‘DONE’ is configured to record a timestamp only. But when switching from ‘WAIT’ back to ‘TODO’, the ‘/!’ in the ‘WAIT’ setting now triggers a timestamp even though ‘TODO’ has no logging configured.

You can use the exact same syntax for setting logging preferences local to a buffer:

#+TODO: TODO(t) WAIT(w@/!) | DONE(d!) CANCELED(c@)
To record a timestamp without a note for TODO keywords configured with ‘@’, just type C-c C-c to enter a blank note when prompted.

In order to define logging settings that are local to a subtree or a single item, define a ‘LOGGING’ property in this entry. Any non-empty ‘LOGGING’ property resets all logging settings to nil. You may then turn on logging for this specific tree using ‘STARTUP’ keywords like ‘lognotedone’ or ‘logrepeat’, as well as adding state specific settings like ‘TODO(!)’. For example:
#+begin_src org

# * TODO Log each state with only a time
#   :PROPERTIES:
#   :LOGGING: TODO(!) WAIT(!) DONE(!) CANCELED(!)
#   :END:
# * TODO Only log when switching to WAIT, and when repeating
#   :PROPERTIES:
#   :LOGGING: WAIT(@) logrepeat
#   :END:
# * TODO No logging at all
#   :PROPERTIES:
#   :LOGGING: nil
#   :END:

  
#+end_src 

  
Footnotes
(42)
See the variable org-log-states-order-reversed.

(43)
Note that the ‘LOGBOOK’ drawer is unfolded when pressing SPC in the agenda to show an entry—use C-u SPC to keep it folded here.

(44)
It is possible that Org mode records two timestamps when you are using both org-log-done and state change logging. However, it never prompts for two notes: if you have configured both, the state change recording note takes precedence and cancel the closing note.


***** Tracking your habits

Org has the ability to track the consistency of a special category of TODO, called “habits.” To use habits, you have to enable the habit module by customizing the variable org-modules.

A habit has the following properties:

The habit is a TODO item, with a TODO keyword representing an open state.
The property ‘STYLE’ is set to the value ‘habit’ (see Properties and Columns).
The TODO has a scheduled date, usually with a ‘.+’ style repeat interval. A ‘++’ style may be appropriate for habits with time constraints, e.g., must be done on specific days of week (‘++1w’), or a ‘+’ style for an unusual habit that can have a backlog, e.g., weekly reports. See Repeated tasks for more details about repeat intervals.
The TODO may also have minimum and maximum ranges specified by using the syntax ‘.+2d/3d’, which says that you want to do the task at least every three days, but at most every two days.
State logging for the DONE state is enabled (see Tracking TODO state changes), in order for historical data to be represented in the consistency graph. If it is not enabled it is not an error, but the consistency graphs are largely meaningless.
To give you an idea of what the above rules look like in action, here’s an actual habit with some history:

#+begin_src org


# ** TODO Shave
#    SCHEDULED: <2009-10-17 Sat .+2d/4d>
#    :PROPERTIES:
#    :STYLE:    habit
#    :LAST_REPEAT: [2009-10-19 Mon 00:36]
#    :END:

   
#+end_src

   - State "DONE"       from "TODO"       [2009-10-15 Thu]
   - State "DONE"       from "TODO"       [2009-10-12 Mon]
   - State "DONE"       from "TODO"       [2009-10-10 Sat]
   - State "DONE"       from "TODO"       [2009-10-04 Sun]
   - State "DONE"       from "TODO"       [2009-10-02 Fri]
   - State "DONE"       from "TODO"       [2009-09-29 Tue]
   - State "DONE"       from "TODO"       [2009-09-25 Fri]
   - State "DONE"       from "TODO"       [2009-09-19 Sat]
   - State "DONE"       from "TODO"       [2009-09-16 Wed]
   - State "DONE"       from "TODO"       [2009-09-12 Sat]
What this habit says is: I want to shave at most every 2 days—given by the ‘SCHEDULED’ date and repeat interval—and at least every 4 days. If today is the 15th, then the habit first appears in the agenda (see Agenda Views) on Oct 17, after the minimum of 2 days has elapsed, and will appear overdue on Oct 19, after four days have elapsed.

What’s really useful about habits is that they are displayed along with a consistency graph, to show how consistent you’ve been at getting that task done in the past. This graph shows every day that the task was done over the past three weeks, with colors for each day. The colors used are:

Blue
If the task was not to be done yet on that day.

Green
If the task could have been done on that day.

Yellow
If the task was going to be overdue the next day.

Red
If the task was overdue on that day.

In addition to coloring each day, the day is also marked with an asterisk if the task was actually done that day, and an exclamation mark to show where the current day falls in the graph.

There are several configuration variables that can be used to change the way habits are displayed in the agenda.

org-habit-graph-column
The buffer column at which the consistency graph should be drawn. This overwrites any text in that column, so it is a good idea to keep your habits’ titles brief and to the point.

org-habit-preceding-days
The amount of history, in days before today, to appear in consistency graphs.

org-habit-following-days
The number of days after today that appear in consistency graphs.

org-habit-show-habits-only-for-today
If non-nil, only show habits in today’s agenda view. The default value is t. Pressing C-u K in the agenda toggles this variable.

Lastly, pressing K in the agenda buffer causes habits to temporarily be disabled and do not appear at all. Press K again to bring them back. They are also subject to tag filtering, if you have habits which should only be done in certain contexts, for example.


**** Priorities

If you use Org mode extensively, you may end up with enough TODO items that it starts to make sense to prioritize them. Prioritizing can be done by placing a priority cookie into the headline of a TODO item right after the TODO keyword, like this:

#+begin_src org


# *** TODO [#A] Write letter to Sam Fortune
# By default, Org mode supports three priorities: ‘A’, ‘B’, and ‘C’. ‘A’ is the highest priority. An entry without a cookie is treated as equivalent if it had priority ‘B’. Priorities make a difference only for sorting in the agenda (see Weekly/daily agenda). Outside the agenda, they have no inherent meaning to Org mode. The cookies are displayed with the face defined by the variable org-priority-faces, which can be customized.

# You can also use numeric values for priorities, such as

# *** TODO [#1] Write letter to Sam Fortune
# When using numeric priorities, you need to set org-priority-highest, org-priority-lowest and org-priority-default to integers, which must all be strictly inferior to 65


  
#+end_src

Priorities can be attached to any outline node; they do not need to be TODO items.

C-c , (org-priority)
Set the priority of the current headline. The command prompts for a priority character ‘A’, ‘B’ or ‘C’. When you press SPC instead, the priority cookie, if one is set, is removed from the headline. The priorities can also be changed “remotely” from the agenda buffer with the , command (see Commands in the Agenda Buffer).

S-UP (org-priority-up)
S-DOWN (org-priority-down)
Increase/decrease the priority of the current headline45. Note that these keys are also used to modify timestamps (see Creating Timestamps). See also Packages that conflict with Org mode, for a discussion of the interaction with shift-selection.

You can change the range of allowed priorities by setting the variables org-priority-highest, org-priority-lowest, and org-priority-default. For an individual buffer, you may set these values (highest, lowest, default) like this (please make sure that the highest priority is earlier in the alphabet than the lowest priority):

#+PRIORITIES: A C B
Or, using numeric values:

#+PRIORITIES: 1 10 5
Footnotes
(45)
See also the option org-priority-start-cycle-with-default.


**** Breaking Down Tasks into Subtasks

It is often advisable to break down large tasks into smaller, manageable subtasks. You can do this by creating an outline tree below a TODO item, with detailed subtasks on the tree46. To keep an overview of the fraction of subtasks that have already been marked as done, insert either ‘[/]’ or ‘[%]’ anywhere in the headline. These cookies are updated each time the TODO status of a child changes, or when pressing C-c C-c on the cookie. For example:

#+begin_src org



# * Organize Party [33%]
# ** TODO Call people [1/2]
# *** TODO Peter
# *** DONE Sarah
# ** TODO Buy food
# ** DONE Talk to neighbor
# If a heading has both checkboxes and TODO children below it, the meaning of the statistics cookie become ambiguous. Set the property ‘COOKIE_DATA’ to either ‘checkbox’ or ‘todo’ to resolve this issue.

# If you would like to have the statistics cookie count any TODO entries in the subtree (not just direct children), configure the variable org-hierarchical-todo-statistics. To do this for a single subtree, include the word ‘recursive’ into the value of the ‘COOKIE_DATA’ property.

# * Parent capturing statistics [2/20]
#   :PROPERTIES:
#   :COOKIE_DATA: todo recursive
#   :END:

  
#+end_src
  
If you would like a TODO entry to automatically change to DONE when all children are done, you can use the following setup:

(defun org-summary-todo (n-done n-not-done)
  "Switch entry to DONE when all subentries are done, to TODO otherwise."
  (let (org-log-done org-todo-log-states)   ; turn off logging
    (org-todo (if (= n-not-done 0) "DONE" "TODO"))))

(add-hook 'org-after-todo-statistics-hook #'org-summary-todo)
Another possibility is the use of checkboxes to identify (a hierarchy of) a large number of subtasks (see Checkboxes).

Footnotes
(46)
To keep subtasks out of the global TODO list, see the option org-agenda-todo-list-sublevels.


**** Checkboxes

Every item in a plain list47 (see Plain Lists) can be made into a checkbox by starting it with the string ‘[ ]’. This feature is similar to TODO items (see TODO Items), but is more lightweight. Checkboxes are not included into the global TODO list, so they are often great to split a task into a number of simple steps. Or you can use them in a shopping list.

Here is an example of a checkbox list.

; * TODO Organize party [2/4]
  - [-] call people [1/3]
    - [ ] Peter
    - [X] Sarah
    - [ ] Sam
  - [X] order food
  - [ ] think about what music to play
  - [X] talk to the neighbors
The ‘[2/4]’ and ‘[1/3]’ in the first and second line are cookies indicating how many checkboxes present in this entry have been checked off, and the total number of checkboxes present. This can give you an idea on how many checkboxes remain, even without opening a folded entry. The cookies can be placed into a headline or into (the first line of) a plain list item. Each cookie covers checkboxes of direct children structurally below the headline/item on which the cookie appears48. You have to insert the cookie yourself by typing either ‘[/]’ or ‘[%]’. With ‘[/]’ you get an ‘n out of m’ result, as in the examples above. With ‘[%]’ you get information about the percentage of checkboxes checked (in the above example, this would be ‘[50%]’ and ‘[33%]’, respectively). In a headline, a cookie can count either checkboxes below the heading or TODO states of children, and it displays whatever was changed last. Set the property ‘COOKIE_DATA’ to either ‘checkbox’ or ‘todo’ to resolve this issue.

If the current outline node has an ‘ORDERED’ property, checkboxes must be checked off in sequence, and an error is thrown if you try to check off a box while there are unchecked boxes above it.

A checkbox can be in one of the three states:

not checked ‘[ ]’
partially checked ‘[-]’
checked ‘[X]’
Checkboxes work hierarchically, so if a checkbox item has children that are checkboxes, toggling one of the children checkboxes makes the parent checkbox reflect if none, some, or all of the children are checked.

If all child checkboxes are not checked, the parent checkbox is also not checked.

- [ ] call people
  - [ ] Peter
  - [ ] Sarah
If some but not all child checkboxes are checked, the parent checkbox is partially checked.

- [-] call people
  - [X] Peter
  - [ ] Sarah
If all child checkboxes are checked, the parent checkbox is also checked.

- [X] call people
  - [X] Peter
  - [X] Sarah
The following commands work with checkboxes:

C-c C-c (org-toggle-checkbox)
Toggle checkbox status or—with prefix argument—checkbox presence at point. With a single prefix argument, add an empty checkbox or remove the current one49. With a double prefix argument, set it to ‘[-]’, which is considered to be an intermediate state.

C-c C-x C-b (org-toggle-checkbox)
Toggle checkbox status or—with prefix argument—checkbox presence at point. With double prefix argument, set it to ‘[-]’, which is considered to be an intermediate state.

If there is an active region, toggle the first checkbox in the region and set all remaining boxes to the same status as the first. With a prefix argument, add or remove the checkbox for all items in the region.
If point is in a headline, toggle checkboxes in the region between this headline and the next—so not the entire subtree.
If there is no active region, just toggle the checkbox at point.
C-c C-x C-r (org-toggle-radio-button)
Toggle checkbox status by using the checkbox of the item at point as a radio button: when the checkbox is turned on, all other checkboxes on the same level will be turned off. With a universal prefix argument, toggle the presence of the checkbox. With a double prefix argument, set it to ‘[-]’.

C-c C-c can be told to consider checkboxes as radio buttons by setting ‘#+ATTR_ORG: :radio t’ right before the list or by calling M-x org-list-checkbox-radio-mode to activate this minor mode.

M-S-RET (org-insert-todo-heading)
Insert a new item with a checkbox. This works only if point is already in a plain list item (see Plain Lists).

C-c C-x o (org-toggle-ordered-property)
Toggle the ‘ORDERED’ property of the entry, to toggle if checkboxes must be checked off in sequence. A property is used for this behavior because this should be local to the current entry, not inherited like a tag. However, if you would like to track the value of this property with a tag for better visibility, customize org-track-ordered-property-with-tag.

C-c # (org-update-statistics-cookies)
Update the statistics cookie in the current outline entry. When called with a C-u prefix, update the entire file. Checkbox statistic cookies are updated automatically if you toggle checkboxes with C-c C-c and make new ones with M-S-RET. TODO statistics cookies update when changing TODO states. If you delete boxes/entries or add/change them by hand, use this command to get things back into sync.

Footnotes
(47)
With the exception of description lists. But you can allow it by modifying org-list-automatic-rules accordingly.

(48)
Set the variable org-checkbox-hierarchical-statistics if you want such cookies to count all checkboxes below the cookie, not just those belonging to direct children.

(49)
C-u C-c C-c on the first item of a list with no checkbox adds checkboxes to the rest of the list.


*** Tags

An excellent way to implement labels and contexts for cross-correlating information is to assign tags to headlines. Org mode has extensive support for tags.

Every headline can contain a list of tags; they occur at the end of the headline. Tags are normal words containing letters, numbers, ‘_’, and ‘@’. Tags must be preceded and followed by a single colon, e.g., ‘:work:’. Several tags can be specified, as in ‘:work:urgent:’. Tags by default are in bold face with the same color as the headline. You may specify special faces for specific tags using the variable org-tag-faces, in much the same way as you can for TODO keywords (see Faces for TODO keywords).

**** Tag Inheritance

Tags make use of the hierarchical structure of outline trees. If a heading has a certain tag, all subheadings inherit the tag as well. For example, in the list

#+begin_src org


# * Meeting with the French group      :work:
# ** Summary by Frank                  :boss:notes:
# *** TODO Prepare slides for him      :action:

  
#+end_src

the final heading has the tags ‘work’, ‘boss’, ‘notes’, and ‘action’ even though the final heading is not explicitly marked with those tags. You can also set tags that all entries in a file should inherit just as if these tags were defined in a hypothetical level zero that surrounds the entire file. Use a line like this50

#+filetags:   :emacs:
To limit tag inheritance to specific tags, or to turn it off entirely, use the variables org-use-tag-inheritance and org-tags-exclude-from-inheritance.

Tag inheritance is relevant when the agenda search tries to match a tag, either in the tags or tags-todo agenda types. In other agenda types, org-use-tag-inheritance has no effect. Still, you may want to have your tags correctly set in the agenda, so that tag filtering works fine, with inherited tags. Set org-agenda-use-tag-inheritance to control this: the default value includes all agenda types, but setting this to nil can really speed up agenda generation.

Footnotes
(50)
As with all these in-buffer settings, pressing C-c C-c activates any changes in the line.


**** Setting Tags

Tags can simply be typed into the buffer at the end of a headline. After a colon, M-TAB offers completion on tags. There is also a special command for inserting tags:

C-c C-q (org-set-tags-command)
Enter new tags for the current headline. Org mode either offers completion or a special single-key interface for setting tags, see below. After pressing RET, the tags are inserted and aligned to org-tags-column. When called with a C-u prefix, all tags in the current buffer are aligned to that column, just to make things look nice. Tags are automatically realigned after promotion, demotion, and TODO state changes (see Basic TODO Functionality).

C-c C-c (org-set-tags-command)
When point is in a headline, this does the same as C-c C-q.

Org supports tag insertion based on a list of tags. By default this list is constructed dynamically, containing all tags currently used in the buffer51. You may also globally specify a hard list of tags with the variable org-tag-alist. Finally you can set the default tags for a given file using the ‘TAGS’ keyword, like

#+TAGS: @work @home @tennisclub
#+TAGS: laptop car pc sailboat
If you have globally defined your preferred set of tags using the variable org-tag-alist, but would like to use a dynamic tag list in a specific file, add an empty ‘TAGS’ keyword to that file:

#+TAGS:
If you have a preferred set of tags that you would like to use in every file, in addition to those defined on a per-file basis by ‘TAGS’ keyword, then you may specify a list of tags with the variable org-tag-persistent-alist. You may turn this off on a per-file basis by adding a ‘STARTUP’ keyword to that file:

#+STARTUP: noptag
By default Org mode uses the standard minibuffer completion facilities for entering tags. However, it also implements another, quicker, tag selection method called fast tag selection. This allows you to select and deselect tags with just a single key press. For this to work well you should assign unique letters to most of your commonly used tags. You can do this globally by configuring the variable org-tag-alist in your Emacs init file. For example, you may find the need to tag many items in different files with ‘@home’. In this case you can set something like:

(setq org-tag-alist '(("@work" . ?w) ("@home" . ?h) ("laptop" . ?l)))
If the tag is only relevant to the file you are working on, then you can instead set the ‘TAGS’ keyword as:

#+TAGS: @work(w)  @home(h)  @tennisclub(t)  laptop(l)  pc(p)
The tags interface shows the available tags in a splash window. If you want to start a new line after a specific tag, insert ‘\n’ into the tag list

#+TAGS: @work(w) @home(h) @tennisclub(t) \n laptop(l) pc(p)
or write them in two lines:

#+TAGS: @work(w)  @home(h)  @tennisclub(t)
#+TAGS: laptop(l)  pc(p)
You can also group together tags that are mutually exclusive by using braces, as in:

#+TAGS: { @work(w)  @home(h)  @tennisclub(t) }  laptop(l)  pc(p)
you indicate that at most one of ‘@work’, ‘@home’, and ‘@tennisclub’ should be selected. Multiple such groups are allowed.

Do not forget to press C-c C-c with point in one of these lines to activate any changes.

To set these mutually exclusive groups in the variable org-tags-alist, you must use the dummy tags :startgroup and :endgroup instead of the braces. Similarly, you can use :newline to indicate a line break. The previous example would be set globally by the following configuration:

(setq org-tag-alist '((:startgroup . nil)
                      ("@work" . ?w) ("@home" . ?h)
                      ("@tennisclub" . ?t)
                      (:endgroup . nil)
                      ("laptop" . ?l) ("pc" . ?p)))
If at least one tag has a selection key then pressing C-c C-c automatically presents you with a special interface, listing inherited tags, the tags of the current headline, and a list of all valid tags with corresponding keys52.

Pressing keys assigned to tags adds or removes them from the list of tags in the current line. Selecting a tag in a group of mutually exclusive tags turns off any other tag from that group.

In this interface, you can also use the following special keys:

TAB
Enter a tag in the minibuffer, even if the tag is not in the predefined list. You can complete on all tags present in the buffer and globally pre-defined tags from org-tag-alist and org-tag-persistent-alist. You can also add several tags: just separate them with a comma.

SPC
Clear all tags for this line.

RET
Accept the modified set.

C-g
Abort without installing changes.

q
If q is not assigned to a tag, it aborts like C-g.

!
Turn off groups of mutually exclusive tags. Use this to (as an exception) assign several tags from such a group.

C-c
Toggle auto-exit after the next change (see below). If you are using expert mode, the first C-c displays the selection window.

This method lets you assign tags to a headline with very few keys. With the above setup, you could clear the current tags and set ‘@home’, ‘laptop’ and ‘pc’ tags with just the following keys: C-c C-c SPC h l p RET. Switching from ‘@home’ to ‘@work’ would be done with C-c C-c w RET or alternatively with C-c C-c C-c w. Adding the non-predefined tag ‘sarah’ could be done with C-c C-c TAB s a r a h RET.

If you find that most of the time you need only a single key press to modify your list of tags, set the variable org-fast-tag-selection-single-key. Then you no longer have to press RET to exit fast tag selection—it exits after the first change. If you then occasionally need more keys, press C-c to turn off auto-exit for the current tag selection process (in effect: start selection with C-c C-c C-c instead of C-c C-c). If you set the variable to the value expert, the special window is not even shown for single-key tag selection, it comes up only when you press an extra C-c.

The number of tags displayed in the fast tag selection interface is limited by org-fast-tag-selection-maximum-tags to avoid running out of keyboard keys. You can customize this variable.

Footnotes
(51)
To extend this default list to all tags used in all agenda files (see Agenda Views), customize the variable org-complete-tags-always-offer-all-agenda-tags.

(52)
Keys are automatically assigned to tags that have no configured keys.


**** Tag Hierarchy

Tags can be defined in hierarchies. A tag can be defined as a group tag for a set of other tags. The group tag can be seen as the “broader term” for its set of tags. Defining multiple group tags and nesting them creates a tag hierarchy.

One use-case is to create a taxonomy of terms (tags) that can be used to classify nodes in a document or set of documents.

When you search for a group tag, it return matches for all members in the group and its subgroups. In an agenda view, filtering by a group tag displays or hide headlines tagged with at least one of the members of the group or any of its subgroups. This makes tag searches and filters even more flexible.

You can set group tags by using brackets and inserting a colon between the group tag and its related tags—beware that all whitespaces are mandatory so that Org can parse this line correctly:

#+TAGS: [ GTD : Control Persp ]
In this example, ‘GTD’ is the group tag and it is related to two other tags: ‘Control’, ‘Persp’. Defining ‘Control’ and ‘Persp’ as group tags creates a hierarchy of tags:

#+TAGS: [ Control : Context Task ]
#+TAGS: [ Persp : Vision Goal AOF Project ]
That can conceptually be seen as a hierarchy of tags:

‘GTD’
‘Persp’
‘Vision’
‘Goal’
‘AOF’
‘Project’
‘Control’
‘Context’
‘Task’
You can use the :startgrouptag, :grouptags and :endgrouptag keyword directly when setting org-tag-alist directly:

(setq org-tag-alist '((:startgrouptag)
                      ("GTD")
                      (:grouptags)
                      ("Control")
                      ("Persp")
                      (:endgrouptag)
                      (:startgrouptag)
                      ("Control")
                      (:grouptags)
                      ("Context")
                      ("Task")
                      (:endgrouptag)))
The tags in a group can be mutually exclusive if using the same group syntax as is used for grouping mutually exclusive tags together; using curly brackets.

#+TAGS: { Context : @Home @Work @Call }
When setting org-tag-alist you can use :startgroup and :endgroup instead of :startgrouptag and :endgrouptag to make the tags mutually exclusive.

Furthermore, the members of a group tag can also be regular expressions, creating the possibility of a more dynamic and rule-based tag structure (see Regular Expressions). The regular expressions in the group must be specified within curly brackets. Here is an expanded example:

#+TAGS: [ Vision : {V@.+} ]
#+TAGS: [ Goal : {G@.+} ]
#+TAGS: [ AOF : {AOF@.+} ]
#+TAGS: [ Project : {P@.+} ]
Searching for the tag ‘Project’ now lists all tags also including regular expression matches for ‘P@.+’, and similarly for tag searches on ‘Vision’, ‘Goal’ and ‘AOF’. For example, this would work well for a project tagged with a common project-identifier, e.g., ‘P@2014_OrgTags’.

If you want to ignore group tags temporarily, toggle group tags support with org-toggle-tags-groups, bound to C-c C-x q. If you want to disable tag groups completely, set org-group-tags to nil.


**** Tag Searches

Once a system of tags has been set up, it can be used to collect related information into special lists.

C-c / m or C-c \ (org-match-sparse-tree)
Create a sparse tree with all headlines matching a tags search. With a C-u prefix argument, ignore headlines that are not a TODO line.

M-x org-agenda m (org-tags-view)
Create a global list of tag matches from all agenda files. See Matching tags and properties.

M-x org-agenda M (org-tags-view)
Create a global list of tag matches from all agenda files, but check only TODO items.

These commands all prompt for a match string which allows basic Boolean logic like ‘+boss+urgent-project1’, to find entries with tags ‘boss’ and ‘urgent’, but not ‘project1’, or ‘Kathy|Sally’ to find entries which are tagged, like ‘Kathy’ or ‘Sally’. The full syntax of the search string is rich and allows also matching against TODO keywords, entry levels and properties. For a complete description with many examples, see Matching tags and properties.


*** Properties and Columns

A property is a key-value pair associated with an entry. Properties can be set so they are associated with a single entry, with every entry in a tree, or with the whole buffer.

There are two main applications for properties in Org mode. First, properties are like tags, but with a value. Imagine maintaining a file where you document bugs and plan releases for a piece of software. Instead of using tags like ‘release_1’, ‘release_2’, you can use a property, say ‘Release’, that in different subtrees has different values, such as ‘1.0’ or ‘2.0’. Second, you can use properties to implement (very basic) database capabilities in an Org buffer. Imagine keeping track of your music CDs, where properties could be things such as the album, artist, date of release, number of tracks, and so on.

Properties can be conveniently edited and viewed in column view (see Column View).

**** Property Syntax

Properties are key–value pairs. When they are associated with a single entry or with a tree they need to be inserted into a special drawer (see Drawers) with the name ‘PROPERTIES’, which has to be located right below a headline, and its planning line (see Deadlines and Scheduling) when applicable. Each property is specified on a single line, with the key—surrounded by colons—first, and the value after it. Keys are case-insensitive. Here is an example:

#+begin_src


# * CD collection
# ** Classic
# *** Goldberg Variations
#     :PROPERTIES:
#     :Title:     Goldberg Variations
#     :Composer:  J.S. Bach
#     :Artist:    Glenn Gould
#     :Publisher: Deutsche Grammophon
#     :NDisks:    1
#     :END:
  
  #+end_src

Depending on the value of org-use-property-inheritance, a property set this way is associated either with a single entry, or with the subtree defined by the entry, see Property Inheritance.

You may define the allowed values for a particular property ‘Xyz’ by setting a property ‘Xyz_ALL’. This special property is inherited, so if you set it in a level 1 entry, it applies to the entire tree. When allowed values are defined, setting the corresponding property becomes easier and is less prone to typing errors. For the example with the CD collection, we can pre-define publishers and the number of disks in a box like this:

#+begin_src org


# * CD collection
#   :PROPERTIES:
#   :NDisks_ALL:  1 2 3 4
#   :Publisher_ALL: "Deutsche Grammophon" Philips EMI
#   :END:
  
  #+end_src 

  Properties can be inserted at the buffer level. That means they apply before the first headline and can be inherited by all entries in a file. Property blocks defined before the first headline must be at the top of the buffer with only comments above them.

  Properties can also be defined using lines like:

  ,#+PROPERTY: NDisks_ALL 1 2 3 4
  If you want to add to the value of an existing property, append a ‘+’ to the property name. The following results in the property ‘var’ having the value ‘foo=1 bar=2’.

  ,#+PROPERTY: var  foo=1
  ,#+PROPERTY: var+ bar=2
  It is also possible to add to the values of inherited properties. The following results in the ‘Genres’ property having the value ‘Classic Baroque’ under the ‘Goldberg Variations’ subtree.

  ,#+begin_src org

    
  # * CD collection
  # ** Classic
  #     :PROPERTIES:
  #     :Genres: Classic
  #     :END:
  # *** Goldberg Variations
  #     :PROPERTIES:
  #     :Title:     Goldberg Variations
  #     :Composer:  J.S. Bach
  #     :Artist:    Glenn Gould
  #     :Publisher: Deutsche Grammophon
  #     :NDisks:    1
  #     :Genres+:   Baroque
  #     :END:

#+end_src

Note that a property can only have one entry per drawer.

Property values set with the global variable org-global-properties can be inherited by all entries in all Org files.

The following commands help to work with properties:

M-TAB (pcomplete)
After an initial colon in a line, complete property keys. All keys used in the current file are offered as possible completions.

C-c C-x p (org-set-property)
Set a property. This prompts for a property name and a value. If necessary, the property drawer is created as well.

C-u M-x org-insert-drawer
Insert a property drawer into the current entry. The drawer is inserted early in the entry, but after the lines with planning information like deadlines. If before first headline the drawer is inserted at the top of the drawer after any potential comments.

C-c C-c (org-property-action)
With point in a property drawer, this executes property commands.

C-c C-c s (org-set-property)
Set a property in the current entry. Both the property and the value can be inserted using completion.

S-RIGHT (org-property-next-allowed-value)
S-LEFT (org-property-previous-allowed-value)
Switch property at point to the next/previous allowed value.

C-c C-c d (org-delete-property)
Remove a property from the current entry.

C-c C-c D (org-delete-property-globally)
Globally remove a property, from all entries in the current file.

C-c C-c c (org-compute-property-at-point)
Compute the property at point, using the operator and scope from the nearest column format definition.


**** Special Properties

Special properties provide an alternative access method to Org mode features, like the TODO state or the priority of an entry, discussed in the previous chapters. This interface exists so that you can include these states in a column view (see Column View), or to use them in queries. The following property names are special and should not be used as keys in the properties drawer:

‘ALLTAGS’	All tags, including inherited ones.
‘BLOCKED’	t if task is currently blocked by children or siblings.
‘CATEGORY’	The category of an entry.
‘CLOCKSUM’	The sum of CLOCK intervals in the subtree. org-clock-sum
must be run first to compute the values in the current buffer.
‘CLOCKSUM_T’	The sum of CLOCK intervals in the subtree for today.
org-clock-sum-today must be run first to compute the
values in the current buffer.
‘CLOSED’	When was this entry closed?
‘DEADLINE’	The deadline timestamp.
‘FILE’	The filename the entry is located in.
‘ITEM’	The headline of the entry.
‘PRIORITY’	The priority of the entry, a string with a single letter.
‘SCHEDULED’	The scheduling timestamp.
‘TAGS’	The tags defined directly in the headline.
‘TIMESTAMP’	The first active keyword-less timestamp in the entry.53
‘TIMESTAMP_IA’	The first inactive keyword-less timestamp in the entry.
‘TODO’	The TODO keyword of the entry.
Footnotes
(53)
For both ‘TIMESTAMP’ and ‘TIMESTAMP_IA’: the word “first” refers to the first occurrence in the entry, not the earliest in time; the prefix ‘CLOCK:’ at the beginning of a clock entry is considered a keyword in this context; and timestamps inside property drawers are ignored.


**** Property Searches

To create sparse trees and special lists with selection based on properties, the same commands are used as for tag searches (see Tag Searches).

C-c / m or C-c \ (org-match-sparse-tree)
Create a sparse tree with all matching entries. With a C-u prefix argument, ignore headlines that are not a TODO line.

M-x org-agenda m (org-tags-view)
Create a global list of tag/property matches from all agenda files.

M-x org-agenda M (org-tags-view)
Create a global list of tag matches from all agenda files, but check only TODO items.

The syntax for the search string is described in Matching tags and properties.

There is also a special command for creating sparse trees based on a single property:

C-c / p
Create a sparse tree based on the value of a property. This first prompts for the name of a property, and then for a value. A sparse tree is created with all entries that define this property with the given value. If you enclose the value in curly braces, it is interpreted as a regular expression and matched against the property values (see Regular Expressions).


**** Property Inheritance

The outline structure of Org documents lends itself to an inheritance model of properties: if the parent in a tree has a certain property, the children can inherit this property. Org mode does not turn this on by default, because it can slow down property searches significantly and is often not needed. However, if you find inheritance useful, you can turn it on by setting the variable org-use-property-inheritance. It may be set to t to make all properties inherited from the parent, to a list of properties that should be inherited, or to a regular expression that matches inherited properties. If a property has the value nil, this is interpreted as an explicit un-define of the property, so that inheritance search stops at this value and returns nil.

Org mode has a few properties for which inheritance is hard-coded, at least for the special applications for which they are used:

COLUMNS
The ‘COLUMNS’ property defines the format of column view (see Column View). It is inherited in the sense that the level where a ‘COLUMNS’ property is defined is used as the starting point for a column view table, independently of the location in the subtree from where columns view is turned on.

CATEGORY
For agenda view, a category set through a ‘CATEGORY’ property applies to the entire subtree.

ARCHIVE
For archiving, the ‘ARCHIVE’ property may define the archive location for the entire subtree (see Moving a tree to an archive file).

LOGGING
The ‘LOGGING’ property may define logging settings for an entry or a subtree (see Tracking TODO state changes).


**** Column View

A great way to view and edit properties in an outline tree is column view. In column view, each outline node is turned into a table row. Columns in this table provide access to properties of the entries. Org mode implements columns by overlaying a tabular structure over the headline of each item. While the headlines have been turned into a table row, you can still change the visibility of the outline tree. For example, you get a compact table by switching to “contents” view—S-TAB S-TAB, or simply c while column view is active—but you can still open, read, and edit the entry below each headline. Or, you can switch to column view after executing a sparse tree command and in this way get a table only for the selected items. Column view also works in agenda buffers (see Agenda Views) where queries have collected selected items, possibly from a number of files.

***** Defining columns

Setting up a column view first requires defining the columns. This is done by defining a column format line.

****** Scope of column definitions

To specify a format that only applies to a specific tree, add a ‘COLUMNS’ property to the top node of that tree, for example:

#+begin_src org


# ** Top node for columns view
#    :PROPERTIES:
#    :COLUMNS: %25ITEM %TAGS %PRIORITY %TODO
#    :END:
   
  
#+end_src

A ‘COLUMNS’ property within a property drawer before first headline will apply to the entire file. As an addition to property drawers, keywords can also be defined for an entire file using a line like:

#+COLUMNS: %25ITEM %TAGS %PRIORITY %TODO
If a ‘COLUMNS’ property is present in an entry, it defines columns for the entry itself, and for the entire subtree below it. Since the column definition is part of the hierarchical structure of the document, you can define columns on level 1 that are general enough for all sublevels, and more specific columns further down, when you edit a deeper part of the tree.


****** Column attributes

A column definition sets the attributes of a column. The general definition looks like this:

%[WIDTH]PROPERTY[(TITLE)][{SUMMARY-TYPE}]
Except for the percent sign and the property name, all items are optional. The individual parts have the following meaning:

WIDTH
An integer specifying the width of the column in characters. If omitted, the width is determined automatically.

PROPERTY
The property that should be edited in this column. Special properties representing meta data are allowed here as well (see Special Properties).

TITLE
The header text for the column. If omitted, the property name is used.

SUMMARY-TYPE
The summary type. If specified, the column values for parent nodes are computed from the children54.

Supported summary types are:

‘+’	Sum numbers in this column.
‘+;%.1f’	Like ‘+’, but format result with ‘%.1f’.
‘$’	Currency, short for ‘+;%.2f’.
‘min’	Smallest number in column.
‘max’	Largest number.
‘mean’	Arithmetic mean of numbers.
‘X’	Checkbox status, ‘[X]’ if all children are ‘[X]’.
‘X/’	Checkbox status, ‘[n/m]’.
‘X%’	Checkbox status, ‘[n%]’.
‘:’	Sum times, HH:MM, plain numbers are minutes.
‘:min’	Smallest time value in column.
‘:max’	Largest time value.
‘:mean’	Arithmetic mean of time values.
‘@min’	Minimum age55 (in days/hours/mins/seconds).
‘@max’	Maximum age (in days/hours/mins/seconds).
‘@mean’	Arithmetic mean of ages (in days/hours/mins/seconds).
‘est+’	Add low-high estimates.
You can also define custom summary types by setting org-columns-summary-types.

The ‘est+’ summary type requires further explanation. It is used for combining estimates, expressed as low-high ranges. For example, instead of estimating a particular task will take 5 days, you might estimate it as 5–6 days if you’re fairly confident you know how much work is required, or 1–10 days if you do not really know what needs to be done. Both ranges average at 5.5 days, but the first represents a more predictable delivery.

When combining a set of such estimates, simply adding the lows and highs produces an unrealistically wide result. Instead, ‘est+’ adds the statistical mean and variance of the subtasks, generating a final estimate from the sum. For example, suppose you had ten tasks, each of which was estimated at 0.5 to 2 days of work. Straight addition produces an estimate of 5 to 20 days, representing what to expect if everything goes either extremely well or extremely poorly. In contrast, ‘est+’ estimates the full job more realistically, at 10–15 days.

Here is an example for a complete columns definition, along with allowed values56.

:COLUMNS:  %25ITEM %9Approved(Approved?){X} %Owner %11Status \
                   %10Time_Estimate{:} %CLOCKSUM %CLOCKSUM_T
:Owner_ALL:    Tammy Mark Karl Lisa Don
:Status_ALL:   "In progress" "Not started yet" "Finished" ""
:Approved_ALL: "[ ]" "[X]"
The first column, ‘%25ITEM’, means the first 25 characters of the item itself, i.e., of the headline. You probably always should start the column definition with the ‘ITEM’ specifier. The other specifiers create columns ‘Owner’ with a list of names as allowed values, for ‘Status’ with four different possible values, and for a checkbox field ‘Approved’. When no width is given after the ‘%’ character, the column is exactly as wide as it needs to be in order to fully display all values. The ‘Approved’ column does have a modified title (‘Approved?’, with a question mark). Summaries are created for the ‘Time_Estimate’ column by adding time duration expressions like HH:MM, and for the ‘Approved’ column, by providing an ‘[X]’ status if all children have been checked. The ‘CLOCKSUM’ and ‘CLOCKSUM_T’ columns are special, they lists the sums of CLOCK intervals in the subtree, either for all clocks or just for today.

Footnotes
(54)
If more than one summary type applies to the same property, the parent values are computed according to the first of them.

(55)
An age can be defined as a duration, using units defined in org-duration-units, e.g., ‘3d 1h’. If any value in the column is as such, the summary is also expressed as a duration.

(56)
Please note that the ‘COLUMNS’ definition must be on a single line; it is wrapped here only because of formatting constraints.


***** Using column view

Turning column view on or off
C-c C-x C-c (org-columns)
Turn on column view. If point is before the first headline in the file, column view is turned on for the entire file, using the ‘#+COLUMNS’ definition. If point is somewhere inside the outline, this command searches the hierarchy, up from point, for a ‘COLUMNS’ property that defines a format. When one is found, the column view table is established for the tree starting at the entry that contains the ‘COLUMNS’ property. If no such property is found, the format is taken from the ‘#+COLUMNS’ line or from the variable org-columns-default-format, and column view is established for the current entry and its subtree.

r or g on a columns view line (org-columns-redo)
Recreate the column view, to include recent changes made in the buffer.

C-c C-c or q on a columns view line (org-columns-quit)
Exit column view.

Editing values
LEFT, RIGHT, UP, DOWN
Move through the column view from field to field.

1..9,0
Directly select the Nth allowed value, 0 selects the 10th value.

n or S-RIGHT (org-columns-next-allowed-value)
p or S-LEFT (org-columns-previous-allowed-value)
Switch to the next/previous allowed value of the field. For this, you have to have specified allowed values for a property.

e (org-columns-edit-value)
Edit the property at point. For the special properties, this invokes the same interface that you normally use to change that property. For example, the tag completion or fast selection interface pops up when editing a ‘TAGS’ property.

C-c C-c (org-columns-toggle-or-columns-quit)
When there is a checkbox at point, toggle it. Else exit column view.

v (org-columns-show-value)
View the full value of this property. This is useful if the width of the column is smaller than that of the value.

a (org-columns-edit-allowed)
Edit the list of allowed values for this property. If the list is found in the hierarchy, the modified values is stored there. If no list is found, the new value is stored in the first entry that is part of the current column view.

Modifying column view on-the-fly
< (org-columns-narrow)
> (org-columns-widen)
Make the column narrower/wider by one character.

S-M-RIGHT (org-columns-new)
Insert a new column, to the left of the current column.

S-M-LEFT (org-columns-delete)
Delete the current column.

M-LEFT (org-columns-move-left)
Move the current column left.

M-RIGHT (org-columns-move-right)
Move the current column right.

M-UP (org-columns-move-row-up)
Move the current row up.

M-DOWN (org-columns-move-row-down)
Move the current row down.


***** Capturing column view

Since column view is just an overlay over a buffer, it cannot be exported or printed directly. If you want to capture a column view, use a ‘columnview’ dynamic block (see Dynamic Blocks). The frame of this block looks like this:

 The column view
#+BEGIN: columnview :hlines 1 :id "label"

#+END:
This dynamic block has the following parameters:

‘:id’
This is the most important parameter. Column view is a feature that is often localized to a certain (sub)tree, and the capture block might be at a different location in the file. To identify the tree whose view to capture, you can use four values:

‘local’
Use the tree in which the capture block is located.

‘global’
Make a global view, including all headings in the file.

‘file:FILENAME’
Run column view at the top of the FILENAME file.

‘LABEL’
Call column view in the tree that has an ‘ID’ property with the value LABEL. You can use M-x org-id-copy to create a globally unique ID for the current entry and copy it to the kill-ring.

‘:match’
When set to a string, use this as a tags/property match filter to select only a subset of the headlines in the scope set by the :id parameter.

‘:hlines’
When t, insert an hline after every line. When a number N, insert an hline before each headline with level <= N.

‘:vlines’
When non-nil, force column groups to get vertical lines.

‘:maxlevel’
When set to a number, do not capture entries below this level.

‘:skip-empty-rows’
When non-nil, skip rows where the only non-empty specifier of the column view is ‘ITEM’.

‘:exclude-tags’
List of tags to exclude from column view table: entries with these tags will be excluded from the column view.

‘:indent’
When non-nil, indent each ‘ITEM’ field according to its level.

‘:link’
When non-nil, link the ‘ITEM’ headlines in the table to their origins.

‘:format’
Specify a column attribute (see Column attributes) for the dynamic block.

‘:formatter’
A function to format column view data and insert it into the buffer. See the option org-columns-dblock-formatter.

The following commands insert or update the dynamic block:

org-columns-insert-dblock
Insert a dynamic block capturing a column view. Prompt for the scope or ID of the view.

This command can be invoked by calling org-dynamic-block-insert-dblock (C-c C-x x) and selecting “columnview” (see Dynamic Blocks).

C-c C-c C-c C-x C-u (org-dblock-update)
Update dynamic block at point. Point needs to be on the ‘#+BEGIN’ line of the dynamic block.

C-u C-c C-x C-u (org-update-all-dblocks)
Update all dynamic blocks (see Dynamic Blocks). This is useful if you have several clock table blocks, column-capturing blocks or other dynamic blocks in a buffer.

You can add formulas to the column view table and you may add plotting instructions in front of the table—these survive an update of the block. If there is a ‘TBLFM’ keyword after the table, the table is recalculated automatically after an update.

An alternative way to capture and process property values into a table is provided by Eric Schulte’s ‘org-collector.el’, which is a package in ‘org-contrib’57. It provides a general API to collect properties from entries in a certain scope, and arbitrary Lisp expressions to process these values before inserting them into a table or a dynamic block.

Footnotes
(57)
Contributed packages are not part of Emacs, but are distributed with the main distribution of Org—visit https://orgmode.org.


*** Dates and Times

To assist project planning, TODO items can be labeled with a date and/or a time. The specially formatted string carrying the date and time information is called a timestamp in Org mode. This may be a little confusing because timestamp is often used as indicating when something was created or last changed. However, in Org mode this term is used in a much wider sense.

Timestamps can be used to plan appointments, schedule tasks, set deadlines, track time, and more. The following sections describe the timestamp format and tooling that Org mode provides for common use cases dealing with time and time intervals.

**** Timestamps

A timestamp is a specification of a date—possibly with a time or time range—in a special format, either ‘<2003-09-16 Tue>’ or ‘<2003-09-16 Tue 09:39>’ or ‘<2003-09-16 Tue 12:00-12:30>’58. A timestamp can appear anywhere in the headline or body of an Org tree entry. Its presence causes entries to be shown on specific dates in the agenda (see Weekly/daily agenda). We distinguish:

Plain timestamp; Event; Appointment
A simple timestamp just assigns a date/time to an item. This is just like writing down an appointment or event in a paper agenda. In the agenda display, the headline of an entry associated with a plain timestamp is shown exactly on that date. There can be multiple timestamps in an item.


#+begin_src org


# * Meet Peter at the movies
#   <2006-11-01 Wed 19:15>
# * Discussion on climate change
#   <2006-11-02 Thu 10:00-12:00>
# * My days off
#   <2006-11-03 Fri>
#   <2006-11-06 Mon>
# Timestamp with repeater interval
# A timestamp may contain a repeater interval, indicating that it applies not only on the given date, but again and again after a certain interval of N hours (h), days (d), weeks (w), months (m), or years (y). The following shows up in the agenda every Wednesday:

# * Pick up Sam at school
#   <2007-05-16 Wed 12:30 +1w>
# Diary-style expression entries
# For more complex date specifications, Org mode supports using the special expression diary entries implemented in the Emacs Calendar package59. For example, with optional time:

# * 22:00-23:00 The nerd meeting on every 2nd Thursday of the month
#   <%%(diary-float t 4 2) 22:00-23:00>
# Time range
# Time range is a timestamp having two time units connected by ‘-’

# * Discussion on climate change
#    <2006-11-02 Thu 10:00-12:00>
# Time/Date range
# Two timestamps connected by ‘--’ denote a range. In the agenda, the headline is shown on the first and last day of the range, and on any dates that are displayed and fall in the range. The first example specifies just the dates of the range while the second example specifies a time range for each date.

# ** Meeting in Amsterdam
#    <2004-08-23 Mon>--<2004-08-26 Thu>
# ** This weeks committee meetings
#    <2004-08-23 Mon 10:00-11:00>--<2004-08-26 Thu 10:00-11:00>
# Inactive timestamp
# Just like a plain timestamp, but with square brackets instead of angular ones. These timestamps are inactive in the sense that they do not trigger an entry to show up in the agenda.

# * Gillian comes late for the fifth time
#   [2006-11-01 Wed]
  
#+end_src


Footnotes
(58)
The Org date format is inspired by the standard ISO 8601 date/time format. To use an alternative format, see Custom time format. The day name is optional when you type the date yourself. However, any date inserted or modified by Org adds that day name, for reading convenience.

(59)
When working with the standard diary expression functions, you need to be very careful with the order of the arguments. That order depends evilly on the variable calendar-date-style. For example, to specify a date December 1, 2005, the call might look like ‘(diary-date 12 1 2005)’ or ‘(diary-date 1 12 2005)’ or ‘(diary-date 2005 12 1)’, depending on the settings. This has been the source of much confusion. Org mode users can resort to special versions of these functions, namely org-date, org-anniversary, org-cyclic, and org-block. These work just like the corresponding diary- functions, but with stable ISO order of arguments (year, month, day) wherever applicable, independent of the value of calendar-date-style.


**** Creating Timestamps

For Org mode to recognize timestamps, they need to be in the specific format. All commands listed below produce timestamps in the correct format.

C-c . (org-timestamp)
Prompt for a date and insert a corresponding timestamp. When point is at an existing timestamp in the buffer, the command is used to modify this timestamp instead of inserting a new one. When this command is used twice in succession, a time range is inserted.

When called with a prefix argument, use the alternative format which contains date and time. The default time can be rounded to multiples of 5 minutes. See the option org-timestamp-rounding-minutes.

With two prefix arguments, insert an active timestamp with the current time without prompting.

C-c ! (org-timestamp-inactive)
Like C-c ., but insert an inactive timestamp that does not cause an agenda entry.

C-c C-c
Normalize timestamp, insert or fix day name if missing or wrong.

C-c < (org-date-from-calendar)
Insert a timestamp corresponding to point date in the calendar.

C-c > (org-goto-calendar)
Access the Emacs calendar for the current date. If there is a timestamp in the current line, go to the corresponding date instead.

C-c C-o (org-open-at-point)
Access the agenda for the date given by the timestamp or -range at point (see Weekly/daily agenda).

S-LEFT (org-timestamp-down-day)
S-RIGHT (org-timestamp-up-day)
Change date at point by one day. These key bindings conflict with shift-selection and related modes (see Packages that conflict with Org mode).

S-UP (org-timestamp-up)
S-DOWN (org-timestamp-down)
On the beginning or enclosing bracket of a timestamp, change its type. Within a timestamp, change the item under point. Point can be on a year, month, day, hour or minute. When the timestamp contains a time range like ‘15:30-16:30’, modifying the first time also shifts the second, shifting the time block with constant length. To change the length, modify the second time. Note that if point is in a headline and not at a timestamp, these same keys modify the priority of an item (see Priorities). The key bindings also conflict with shift-selection and related modes (see Packages that conflict with Org mode).

C-c C-y (org-evaluate-time-range)
Evaluate a time range by computing the difference between start and end. With a prefix argument, insert result after the time range (in a table: into the following column).

***** The date/time prompt

When Org mode prompts for a date/time, the default is shown in default date/time format, and the prompt therefore seems to ask for a specific format. But it in fact accepts date/time information in a variety of formats. Generally, the information should start at the beginning of the string. Org mode finds whatever information is in there and derives anything you have not specified from the default date and time. The default is usually the current date and time, but when modifying an existing timestamp, or when entering the second stamp of a range, it is taken from the stamp in the buffer. When filling in information, Org mode assumes that most of the time you want to enter a date in the future: if you omit the month/year and the given day/month is before today, it assumes that you mean a future date60. If the date has been automatically shifted into the future, the time prompt shows this with ‘(=>F)’.

For example, let’s assume that today is June 13, 2006. Here is how various inputs are interpreted, the items filled in by Org mode are in bold.

‘3-2-5’	⇒ 2003-02-05
‘2/5/3’	⇒ 2003-02-05
‘14’	⇒ 2006-06-14
‘12’	⇒ 2006-07-12
‘2/5’	⇒ 2007-02-05
‘Fri’	⇒ nearest Friday (default date or later)
‘sep 15’	⇒ 2006-09-15
‘feb 15’	⇒ 2007-02-15
‘sep 12 9’	⇒ 2009-09-12
‘12:45’	⇒ 2006-06-13 12:45
‘22 sept 0:34’	⇒ 2006-09-22 0:34
‘w4’	⇒ ISO week for of the current year 2006
‘2012 w4 fri’	⇒ Friday of ISO week 4 in 2012
‘2012-w04-5’	⇒ Same as above
Furthermore you can specify a relative date by giving, as the first thing in the input: a plus/minus sign, a number and a letter—‘h’, ‘d’, ‘w’, ‘m’ or ‘y’—to indicate a change in hours, days, weeks, months, or years. With ‘h’ the date is relative to the current time, with the other letters and a single plus or minus, the date is relative to today at 00:00. With a double plus or minus, it is relative to the default date. If instead of a single letter, you use the abbreviation of day name, the date is the Nth such day, e.g.:

‘+0’	⇒ today
‘.’	⇒ today
‘+2h’	⇒ two hours from now
‘+4d’	⇒ four days from today
‘+4’	⇒ same as +4d
‘+2w’	⇒ two weeks from today
‘++5’	⇒ five days from default date
‘+2tue’	⇒ second Tuesday from now
The function understands English month and weekday abbreviations. If you want to use un-abbreviated names and/or other languages, configure the variables parse-time-months and parse-time-weekdays.

Not all dates can be represented in a given Emacs implementation. By default Org mode forces dates into the compatibility range 1970–2037 which works on all Emacs implementations. If you want to use dates outside of this range, read the docstring of the variable org-read-date-force-compatible-dates.

You can specify a time range by giving start and end times or by giving a start time and a duration (in HH:MM format). Use one or two dash(es) as the separator in the former case and use ‘+’ as the separator in the latter case, e.g.:

‘11am-1:15pm’	⇒ 11:00-13:15
‘11h-13h15’	⇒ same as above
‘11am--1:15pm’	⇒ same as above
‘11am+2:15’	⇒ same as above
Parallel to the minibuffer prompt, a calendar is popped up61. When you exit the date prompt, either by clicking on a date in the calendar, or by pressing RET, the date selected in the calendar is combined with the information entered at the prompt. You can control the calendar fully from the minibuffer:

RET	Choose date at point in calendar.
mouse-1	Select date by clicking on it.
S-RIGHT	One day forward.
S-LEFT	One day backward.
S-DOWN	One week forward.
S-UP	One week backward.
M-S-RIGHT	One month forward.
M-S-LEFT	One month backward.
>	Scroll calendar forward by one month.
<	Scroll calendar backward by one month.
M-v	Scroll calendar forward by 3 months.
C-v	Scroll calendar backward by 3 months.
C-.	Select today’s date62
The actions of the date/time prompt may seem complex, but I assure you they will grow on you, and you will start getting annoyed by pretty much any other way of entering a date/time out there. To help you understand what is going on, the current interpretation of your input is displayed live in the minibuffer63.

Footnotes
(60)
See the variable org-read-date-prefer-future. You may set that variable to the symbol time to even make a time before now shift the date to tomorrow.

(61)
If you do not need/want the calendar, configure the variable org-popup-calendar-for-date-prompt.

(62)
You can also use the calendar command . to jump to today’s date, but if you are inserting an hour specification for your timestamp, . will then insert a dot after the hour. By contrast, C-. will always jump to today’s date.

(63)
If you find this distracting, turn off the display with org-read-date-display-live.


***** Custom time format

Org mode uses the standard ISO notation for dates and times as it is defined in ISO 8601. If you cannot get used to this and require another representation of date and time to keep you happy, you can get it by customizing the variables org-display-custom-times and org-timestamp-custom-formats.

C-c C-x C-t (org-toggle-timestamp-overlays)
Toggle the display of custom formats for dates and times.

Org mode needs the default format for scanning, so the custom date/time format does not replace the default format. Instead, it is put over the default format using text properties. This has the following consequences:

You cannot place point onto a timestamp anymore, only before or after.
The S-UP and S-DOWN keys can no longer be used to adjust each component of a timestamp. If point is at the beginning of the stamp, S-UP and S-DOWN change the stamp by one day, just like S-LEFT S-RIGHT. At the end of the stamp, change the time by one minute.
If the timestamp contains a range of clock times or a repeater, these are not overlaid, but remain in the buffer as they were.
When you delete a timestamp character-by-character, it only disappears from the buffer after all (invisible) characters belonging to the ISO timestamp have been removed.
If the custom timestamp format is longer than the default and you are using dates in tables, table alignment will be messed up. If the custom format is shorter, things do work as expected.


**** Deadlines and Scheduling

A timestamp may be preceded by special keywords to facilitate planning. Both the timestamp and the keyword have to be positioned immediately after the task they refer to.

‘DEADLINE’
Meaning: the task—most likely a TODO item, though not necessarily—is supposed to be finished on that date.

On the deadline date, the task is listed in the agenda. In addition, the agenda for today carries a warning about the approaching or missed deadline, starting org-deadline-warning-days before the due date, and continuing until the entry is marked as done. An example:

#+begin_src org


# *** TODO write article about the Earth for the Guide
#     DEADLINE: <2004-02-29 Sun>

  
#+end_src
    
    The editor in charge is [[bbdb:Ford Prefect]]
You can specify a different lead time for warnings for a specific deadlines using the following syntax. Here is an example with a warning period of 5 days ‘DEADLINE: <2004-02-29 Sun -5d>’. This warning is deactivated if the task gets scheduled and you set org-agenda-skip-deadline-prewarning-if-scheduled to t.

‘SCHEDULED’
Meaning: you are planning to start working on that task on the given date.

The headline is listed under the given date64. In addition, a reminder that the scheduled date has passed is present in the compilation for today, until the entry is marked as done, i.e., the task is automatically forwarded until completed.

#+begin_src org 
  

  # *** TODO Call Trillian for a date on New Years Eve.
  #     SCHEDULED: <2004-12-25 Sat>

    
#+end_src 

If you want to delay the display of this task in the agenda, use ‘SCHEDULED: <2004-12-25 Sat -2d>’: the task is still scheduled on the 25th but will appear two days later. In case the task contains a repeater, the delay is considered to affect all occurrences; if you want the delay to only affect the first scheduled occurrence of the task, use ‘--2d’ instead. See org-scheduled-delay-days and org-agenda-skip-scheduled-delay-if-deadline for details on how to control this globally or per agenda.

Important: Scheduling an item in Org mode should not be understood in the same way that we understand scheduling a meeting. Setting a date for a meeting is just a simple appointment, you should mark this entry with a simple plain timestamp, to get this item shown on the date where it applies. This is a frequent misunderstanding by Org users. In Org mode, scheduling means setting a date when you want to start working on an action item.

You may use timestamps with repeaters in scheduling and deadline entries. Org mode issues early and late warnings based on the assumption that the timestamp represents the nearest instance of the repeater. However, the use of diary expression entries like

<%%(diary-float t 42)>
in scheduling and deadline timestamps is limited. Org mode does not know enough about the internals of each function to issue early and late warnings. However, it shows the item on each day where the expression entry matches.

Inserting deadlines or schedules
Repeated tasks
Footnotes
(64)
It will still be listed on that date after it has been marked as done. If you do not like this, set the variable org-agenda-skip-scheduled-if-done.


***** Inserting deadlines or schedules

The following commands allow you to quickly insert a deadline or to schedule an item:65

C-c C-d (org-deadline)
Insert ‘DEADLINE’ keyword along with a stamp. The insertion happens in the line directly following the headline. Remove any ‘CLOSED’ timestamp . When called with a prefix argument, also remove any existing deadline from the entry. Depending on the variable org-log-redeadline, take a note when changing an existing deadline66.

C-c C-s (org-schedule)
Insert ‘SCHEDULED’ keyword along with a stamp. The insertion happens in the line directly following the headline. Remove any ‘CLOSED’ timestamp. When called with a prefix argument, also remove the scheduling date from the entry. Depending on the variable org-log-reschedule, take a note when changing an existing scheduling time67.

C-c / d (org-check-deadlines)
Create a sparse tree with all deadlines that are either past-due, or which will become due within org-deadline-warning-days. With C-u prefix, show all deadlines in the file. With a numeric prefix, check that many days. For example, C-1 C-c / d shows all deadlines due tomorrow.

C-c / b (org-check-before-date)
Sparse tree for deadlines and scheduled items before a given date.

C-c / a (org-check-after-date)
Sparse tree for deadlines and scheduled items after a given date.

Note that org-schedule and org-deadline supports setting the date by indicating a relative time e.g., ‘+1d’ sets the date to the next day after today, and ‘--1w’ sets the date to the previous week before any current timestamp.

Footnotes
(65)
The ‘SCHEDULED’ and ‘DEADLINE’ dates are inserted on the line right below the headline. Do not put any text between this line and the headline.

(66)
Note the corresponding ‘STARTUP’ options ‘logredeadline’, ‘lognoteredeadline’, and ‘nologredeadline’.

(67)
Note the corresponding ‘STARTUP’ options ‘logreschedule’, ‘lognotereschedule’, and ‘nologreschedule’.


***** Repeated tasks

Some tasks need to be repeated again and again. Org mode helps to organize such tasks using a so-called repeater in a ‘DEADLINE’, ‘SCHEDULED’, or plain timestamps68. In the following example:

#+begin_src org


# ** TODO Pay the rent
#    DEADLINE: <2005-10-01 Sat +1m>

  
#+end_src
   
the ‘+1m’ is a repeater; the intended interpretation is that the task has a deadline on ‘<2005-10-01>’ and repeats itself every (one) month starting from that time. You can use yearly, monthly, weekly, daily and hourly repeat cookies by using the ‘y’, ‘m’, ‘w’, ‘d’ and ‘h’ letters. If you need both a repeater and a special warning period in a deadline entry, the repeater should come first and the warning period last

DEADLINE: <2005-10-01 Sat +1m -3d>
Deadlines and scheduled items produce entries in the agenda when they are over-due, so it is important to be able to mark such an entry as done once you have done so. When you mark a ‘DEADLINE’ or a ‘SCHEDULED’ with the TODO keyword ‘DONE’, it no longer produces entries in the agenda. The problem with this is, however, is that then also the next instance of the repeated entry will not be active. Org mode deals with this in the following way: when you try to mark such an entry as done, using C-c C-t, it shifts the base date of the repeating timestamp by the repeater interval, and immediately sets the entry state back to TODO69. In the example above, setting the state to ‘DONE’ would actually switch the date like this:


#+begin_src org
  
# ** TODO Pay the rent
#    DEADLINE: <2005-11-01 Tue +1m>

#+end_src
   
When task contains multiple timestamps with repeater interval, all these timestamps are shifted.

To mark a task with a repeater as DONE, use C-- 1 C-c C-t, i.e., org-todo with a numeric prefix argument of ‘-1’.

A timestamp70 is added under the deadline, to keep a record that you actually acted on the previous instance of this deadline.

As a consequence of shifting the base date, this entry is no longer visible in the agenda when checking past dates, but all future instances will be visible.

With the ‘+1m’ cookie, the date shift is always exactly one month. So if you have not paid the rent for three months, marking this entry DONE still keeps it as an overdue deadline. Depending on the task, this may not be the best way to handle it. For example, if you forgot to call your father for 3 weeks, it does not make sense to call him 3 times in a single day to make up for it. Finally, there are tasks, like changing batteries, which should always repeat a certain time after the last time you did it. For these tasks, Org mode has special repeaters ‘++’ and ‘.+’. For example:

#+begin_src org

  
# ** TODO Call Father
#    DEADLINE: <2008-02-10 Sun ++1w>


  #+end_src
     
     Marking this DONE shifts the date by at least one week, but also
     by as many weeks as it takes to get this date into the future.
     However, it stays on a Sunday, even if you called and marked it
     done on Saturday.

 #+begin_src org

  # ** TODO Empty kitchen trash
  #    DEADLINE: <2008-02-08 Fri 20:00 ++1d>

   #+end_src
        
        Marking this DONE shifts the date by at least one day, and also
        by as many days as it takes to get the timestamp into the future.
        Since there is a time in the timestamp, the next deadline in the
        future will be on today's date if you complete the task before
        20:00.

 #+begin_src org

          
     # ** TODO Check the batteries in the smoke detectors
     #    DEADLINE: <2005-11-01 Tue .+1m>


#+end_src
        
        Marking this DONE shifts the date to one month after today.

#+begin_src org


     # ** TODO Wash my hands
     #    DEADLINE: <2019-04-05 08:00 Fri .+1h>

          
#+end_src 
   
   Marking this DONE shifts the date to exactly one hour from now.
You may have both scheduling and deadline information for a specific task. If the repeater is set for the scheduling information only, you probably want the repeater to be ignored after the deadline. If so, set the variable org-agenda-skip-scheduled-repeats-after-deadline to t. However, any scheduling information without a repeater is no longer relevant once the task is done, and thus, removed upon repeating the task. If you want both scheduling and deadline information to repeat after the same interval, set the same repeater for both timestamps.

An alternative to using a repeater is to create a number of copies of a task subtree, with dates shifted in each copy. The command C-c C-x c was created for this purpose; it is described in Structure Editing.

Footnotes
(68)
Org does not repeat inactive timestamps, however. See Timestamps.

(69)
In fact, the target state is taken from, in this sequence, the ‘REPEAT_TO_STATE’ property, the variable org-todo-repeat-to-state if it is a string, the previous TODO state if org-todo-repeat-to-state is t, or the first state of the TODO state sequence.

(70)
You can change this using the option org-log-repeat, or the ‘STARTUP’ options ‘logrepeat’, ‘lognoterepeat’, and ‘nologrepeat’. With ‘lognoterepeat’, you will also be prompted for a note.


**** Clocking Work Time

Org mode allows you to clock the time you spend on specific tasks in a project. When you start working on an item, you can start the clock. When you stop working on that task, or when you mark the task done, the clock is stopped and the corresponding time interval is recorded. It also computes the total time spent on each subtree71 of a project. And it remembers a history or tasks recently clocked, so that you can jump quickly between a number of tasks absorbing your time.

To save the clock history across Emacs sessions, use:

(setq org-clock-persist 'history)
(org-clock-persistence-insinuate)
When you clock into a new task after resuming Emacs, the incomplete clock72 is retrieved (see Resolving idle time (1)) and you are prompted about what to do with it.

Clocking commands
The clock table
Resolving idle time and continuous clocking
Footnotes
(71)
Clocking only works if all headings are indented with less than 30 stars. This is a hard-coded limitation of lmax in org-clock-sum.

(72)
To resume the clock under the assumption that you have worked on this task while outside Emacs, use ‘(setq org-clock-persist t)’.

***** Clocking commands

C-c C-x C-i (org-clock-in)
Start the clock on the current item (clock-in). This inserts the ‘CLOCK’ keyword together with a timestamp. If this is not the first clocking of this item, the multiple ‘CLOCK’ lines are wrapped into a ‘LOGBOOK’ drawer (see also the variable org-clock-into-drawer). You can also overrule the setting of this variable for a subtree by setting a ‘CLOCK_INTO_DRAWER’ or ‘LOG_INTO_DRAWER’ property. When called with a C-u prefix argument, select the task from a list of recently clocked tasks. With two C-u C-u prefixes, clock into the task at point and mark it as the default task; the default task is always be available with letter d when selecting a clocking task. With three C-u C-u C-u prefixes, force continuous clocking by starting the clock when the last clock stopped.

While the clock is running, Org shows the current clocking time in the mode line, along with the title of the task. The clock time shown is all time ever clocked for this task and its children. If the task has an effort estimate (see Effort Estimates), the mode line displays the current clocking time against it73. If the task is a repeating one (see Repeated tasks), show only the time since the last reset of the task74. You can exercise more control over show time with the ‘CLOCK_MODELINE_TOTAL’ property. It may have the values ‘current’ to show only the current clocking instance, ‘today’ to show all time clocked on this tasks today—see also the variable org-extend-today-until, all to include all time, or auto which is the default75. Clicking with mouse-1 onto the mode line entry pops up a menu with clocking options.

C-c C-x C-o (org-clock-out)
Stop the clock (clock-out). This inserts another timestamp at the same location where the clock was last started. It also directly computes the resulting time in inserts it after the time range as ‘=>HH:MM’. See the variable org-log-note-clock-out for the possibility to record an additional note together with the clock-out timestamp76.

C-c C-x C-x (org-clock-in-last)
Re-clock the last clocked task. With one C-u prefix argument, select the task from the clock history. With two C-u prefixes, force continuous clocking by starting the clock when the last clock stopped.

C-c C-x C-e (org-clock-modify-effort-estimate)
Update the effort estimate for the current clock task.

C-c C-c or C-c C-y (org-evaluate-time-range)
Recompute the time interval after changing one of the timestamps. This is only necessary if you edit the timestamps directly. If you change them with S-<cursor> keys, the update is automatic.

C-S-UP (org-clock-timestamps-up)
C-S-DOWN (org-clock-timestamps-down)
On CLOCK log lines, increase/decrease both timestamps so that the clock duration keeps the same value.

S-M-UP (org-timestamp-up)
S-M-DOWN (org-timestamp-down)
On ‘CLOCK’ log lines, increase/decrease the timestamp at point and the one of the previous, or the next, clock timestamp by the same duration. For example, if you hit S-M-UP to increase a clocked-out timestamp by five minutes, then the clocked-in timestamp of the next clock is increased by five minutes.

Only ‘CLOCK’ logs created during current Emacs session are considered when adjusting next/previous timestamp.

C-c C-t (org-todo)
Changing the TODO state of an item to DONE automatically stops the clock if it is running in this same item.

C-c C-x C-q (org-clock-cancel)
Cancel the current clock. This is useful if a clock was started by mistake, or if you ended up working on something else.

C-c C-x C-j (org-clock-goto)
Jump to the headline of the currently clocked in task. With a C-u prefix argument, select the target task from a list of recently clocked tasks.

C-c C-x C-d (org-clock-display)
Display time summaries for each subtree in the current buffer. This puts overlays at the end of each headline, showing the total time recorded under that heading, including the time of any subheadings. You can use visibility cycling to study the tree, but the overlays disappear when you change the buffer (see variable org-remove-highlights-with-change) or press C-c C-c.

The l key may be used in the agenda (see Weekly/daily agenda) to show which tasks have been worked on or closed during a day.

Important: note that both org-clock-out and org-clock-in-last can have a global keybinding and do not modify the window disposition.

Footnotes
(73)
To add an effort estimate “on the fly”, hook a function doing this to org-clock-in-prepare-hook.

(74)
The last reset of the task is recorded by the ‘LAST_REPEAT’ property.

(75)
See also the variable org-clock-mode-line-total.

(76)
The corresponding in-buffer setting is: ‘#+STARTUP: lognoteclock-out’.


***** The clock table

Org mode can produce quite complex reports based on the time clocking information. Such a report is called a clock table, because it is formatted as one or several Org tables.

org-clock-report
Insert or update a clock table. When called with a prefix argument, jump to the first clock table in the current document and update it. The clock table includes archived trees.

This command can be invoked by calling org-dynamic-block-insert-dblock (C-c C-x x) and selecting “clocktable” (see Dynamic Blocks).

C-c C-c or C-c C-x C-u (org-dblock-update)
Update dynamic block at point. Point needs to be in the ‘BEGIN’ line of the dynamic block.

C-u C-c C-x C-u
Update all dynamic blocks (see Dynamic Blocks). This is useful if you have several clock table blocks in a buffer.

S-LEFT
S-RIGHT (org-clocktable-try-shift)
Shift the current ‘:block’ interval and update the table. Point needs to be in the ‘#+BEGIN: clocktable’ line for this command. If ‘:block’ is ‘today’, it is shifted to ‘today-1’, etc.

Here is an example of the frame for a clock table as it is inserted into the buffer by org-clock-report:

#+BEGIN: clocktable :maxlevel 2 :emphasize nil :scope file
#+END:
The ‘#+BEGIN’ line contains options to define the scope, structure, and formatting of the report. Defaults for all these options can be configured in the variable org-clocktable-defaults.

First there are options that determine which clock entries are to be selected:

‘:maxlevel’
Maximum level depth to which times are listed in the table. Clocks at deeper levels are summed into the upper level.

‘:scope’
The scope to consider. This can be any of the following:

‘nil’	the current buffer or narrowed region
‘file’	the full current buffer
‘subtree’	the subtree where the clocktable is located
‘treeN’	the surrounding level N tree, for example ‘tree3’
‘tree’	the surrounding level 1 tree
‘agenda’	all agenda files
‘("file" ...)’	scan these files
‘FUNCTION’	scan files returned by calling FUNCTION with no argument
‘file-with-archives’	current file and its archives
‘agenda-with-archives’	all agenda files, including archives
‘:block’
The time block to consider. This block is specified either absolutely, or relative to the current time and may be any of these formats:

‘2007-12-31’	New year eve 2007
‘2007-12’	December 2007
‘2007-W50’	ISO-week 50 in 2007
‘2007-Q2’	2nd quarter in 2007
‘2007’	the year 2007
‘today’, ‘yesterday’, ‘today-N’	a relative day
‘thisweek’, ‘lastweek’, ‘thisweek-N’	a relative week
‘thismonth’, ‘lastmonth’, ‘thismonth-N’	a relative month
‘thisyear’, ‘lastyear’, ‘thisyear-N’	a relative year
‘untilnow’77	all clocked time ever
When this option is not set, Org falls back to the value in org-clock-display-default-range, which defaults to the current year.

Use S-LEFT or S-RIGHT to shift the time interval.

‘:tstart’
A time string specifying when to start considering times. Relative times like ‘"<-2w>"’ can also be used. See Matching tags and properties for relative time syntax.

‘:tend’
A time string specifying when to stop considering times. Relative times like ‘"<now>"’ can also be used. See Matching tags and properties for relative time syntax.

‘:wstart’
The starting day of the week. The default is 1 for Monday.

‘:mstart’
The starting day of the month. The default is 1 for the first.

‘:step’
Set to ‘day’, ‘week’, ‘semimonth’, ‘month’, ‘quarter’, or ‘year’ to split the table into chunks. To use this, either ‘:block’, or ‘:tstart’ and ‘:tend’ are required.

‘:stepskip0’
When non-nil, do not show steps that have zero time.

‘:fileskip0’
When non-nil, do not show table sections from files which did not contribute.

‘:match’
A tags match to select entries that should contribute. See Matching tags and properties for the match syntax.

Then there are options that determine the formatting of the table. There options are interpreted by the function org-clocktable-write-default, but you can specify your own function using the ‘:formatter’ parameter.

‘:emphasize’
When non-nil, emphasize level one and level two items.

‘:lang’
Language78 to use for descriptive cells like “Task”.

‘:link’
Link the item headlines in the table to their origins.

‘:narrow’
An integer to limit the width of the headline column in the Org table. If you write it like ‘50!’, then the headline is also shortened in export.

‘:indent’
Indent each headline field according to its level.

‘:filetitle’
Show title in the file column if the file has a ‘#+title’.

‘:hidefiles’
Hide the file column when multiple files are used to produce the table.

‘:tcolumns’
Number of columns to be used for times. If this is smaller than ‘:maxlevel’, lower levels are lumped into one column.

‘:level’
Should a level number column be included?

‘:sort’
A cons cell containing the column to sort and a sorting type. E.g., ‘:sort (1 . ?a)’ sorts the first column alphabetically.

‘:compact’
Abbreviation for ‘:level nil :indent t :narrow 40! :tcolumns 1’. All are overwritten except if there is an explicit ‘:narrow’.

‘:timestamp’
A timestamp for the entry, when available. Look for ‘SCHEDULED’, ‘DEADLINE’, ‘TIMESTAMP’ and ‘TIMESTAMP_IA’ special properties (see Special Properties), in this order.

‘:tags’
When this flag is non-nil, show the headline’s tags.

‘:properties’
List of properties shown in the table. Each property gets its own column.

‘:inherit-props’
When this flag is non-nil, the values for ‘:properties’ are inherited.

‘:formula’
Content of a ‘TBLFM’ keyword to be added and evaluated. As a special case, ‘:formula %’ adds a column with % time. If you do not specify a formula here, any existing formula below the clock table survives updates and is evaluated.

‘:formatter’
A function to format clock data and insert it into the buffer.

To get a clock summary of the current level 1 tree, for the current day, you could write:

#+BEGIN: clocktable :maxlevel 2 :block today :scope tree1 :link t
#+END:
To use a specific time range you could write79

#+BEGIN: clocktable :tstart "<2006-08-10 Thu 10:00>"
                    :tend "<2006-08-10 Thu 12:00>"
#+END:
A range starting a week ago and ending right now could be written as

#+BEGIN: clocktable :tstart "<-1w>" :tend "<now>"
#+END:
A summary of the current subtree with % times would be

#+BEGIN: clocktable :scope subtree :link t :formula %
#+END:
A horizontally compact representation of everything clocked during last week would be

#+BEGIN: clocktable :scope agenda :block lastweek :compact t
#+END:
Footnotes
(77)
When using :step, untilnow starts from the beginning of 2003, not the beginning of time.

(78)
Language terms can be set through the variable org-clock-clocktable-language-setup.

(79)
Note that all parameters must be specified in a single line—the line is broken here only to fit it into the manual.


***** Resolving idle time and continuous clocking

Resolving idle time
If you clock in on a work item, and then walk away from your computer—perhaps to take a phone call—you often need to “resolve” the time you were away by either subtracting it from the current clock, or applying it to another one.

By customizing the variable org-clock-idle-time to some integer, such as 10 or 15, Emacs can alert you when you get back to your computer after being idle for that many minutes80, and ask what you want to do with the idle time. There will be a question waiting for you when you get back, indicating how much idle time has passed constantly updated with the current amount, as well as a set of choices to correct the discrepancy:

k
To keep some or all of the minutes and stay clocked in, press k. Org asks how many of the minutes to keep. Press RET to keep them all, effectively changing nothing, or enter a number to keep that many minutes.

K
If you use the shift key and press K, it keeps however many minutes you request and then immediately clock out of that task. If you keep all of the minutes, this is the same as just clocking out of the current task.

s
To keep none of the minutes, use s to subtract all the away time from the clock, and then check back in from the moment you returned.

S
To keep none of the minutes and just clock out at the start of the away time, use the shift key and press S. Remember that using shift always leave you clocked out, no matter which option you choose.

C
To cancel the clock altogether, use C. Note that if instead of canceling you subtract the away time, and the resulting clock amount is less than a minute, the clock is still canceled rather than cluttering up the log with an empty entry.

What if you subtracted those away minutes from the current clock, and now want to apply them to a new clock? Simply clock in to any task immediately after the subtraction. Org will notice that you have subtracted time “on the books”, so to speak, and will ask if you want to apply those minutes to the next task you clock in on.

There is one other instance when this clock resolution magic occurs. Say you were clocked in and hacking away, and suddenly your cat chased a mouse who scared a hamster that crashed into your UPS’s power button! You suddenly lose all your buffers, but thanks to auto-save you still have your recent Org mode changes, including your last clock in.

If you restart Emacs and clock into any task, Org will notice that you have a dangling clock which was never clocked out from your last session. Using that clock’s starting time as the beginning of the unaccounted-for period, Org will ask how you want to resolve that time. The logic and behavior is identical to dealing with away time due to idleness; it is just happening due to a recovery event rather than a set amount of idle time.

You can also check all the files visited by your Org agenda for dangling clocks at any time using M-x org-resolve-clocks RET (or C-c C-x C-z).

Continuous clocking
You may want to start clocking from the time when you clocked out the previous task. To enable this systematically, set org-clock-continuously to non-nil. Each time you clock in, Org retrieves the clock-out time of the last clocked entry for this session, and start the new clock from there.

If you only want this from time to time, use three universal prefix arguments with org-clock-in and two C-u C-u with org-clock-in-last.

Clocking out automatically after some idle time
When you often forget to clock out before being idle and you don’t want to manually set the clocking time to take into account, you can set org-clock-auto-clockout-timer to a number of seconds and add ‘(org-clock-auto-clockout-insinuate)’ to your ‘.emacs’ file.

When the clock is running and Emacs is idle for more than this number of seconds, the clock will be clocked out automatically.

Use ‘M-x org-clock-toggle-auto-clockout RET’ to temporarily turn this on or off.

Footnotes
(80)
On computers using macOS, idleness is based on actual user idleness, not just Emacs’s idle time. For X11, you can install a utility program ‘x11idle.c’, available in the ‘org-contrib/’ repository, or install the xprintidle package and set it to the variable org-clock-x11idle-program-name if you are running Debian, to get the same general treatment of idleness. On other systems, idle time refers to Emacs idle time only.


**** Effort Estimates

If you want to plan your work in a very detailed way, or if you need to produce offers with quotations of the estimated work effort, you may want to assign effort estimates to entries. If you are also clocking your work, you may later want to compare the planned effort with the actual working time, a great way to improve planning estimates.

Effort estimates are stored in a special property ‘EFFORT’. Multiple formats are supported, such as ‘3:12’, ‘1:23:45’, or ‘1d3h5min’; see the file ‘org-duration.el’ for more detailed information about the format.

You can set the effort for an entry with the following commands:

C-c C-x e (org-set-effort)
Set the effort estimate for the current entry. With a prefix argument, set it to the next allowed value—see below. This command is also accessible from the agenda with the e key.

C-c C-x C-e (org-clock-modify-effort-estimate)
Modify the effort estimate of the item currently being clocked.

Clearly the best way to work with effort estimates is through column view (see Column View). You should start by setting up discrete values for effort estimates, and a ‘COLUMNS’ format that displays these values together with clock sums—if you want to clock your time. For a specific buffer you can use:

#+PROPERTY: Effort_ALL 0 0:10 0:30 1:00 2:00 3:00 4:00 5:00 6:00 7:00
#+COLUMNS: %40ITEM(Task) %17Effort(Estimated Effort){:} %CLOCKSUM
or, even better, you can set up these values globally by customizing the variables org-global-properties and org-columns-default-format. In particular if you want to use this setup also in the agenda, a global setup may be advised.

The way to assign estimates to individual items is then to switch to column mode, and to use S-RIGHT and S-LEFT to change the value. The values you enter are immediately summed up in the hierarchy. In the column next to it, any clocked time is displayed.

If you switch to column view in the daily/weekly agenda, the effort column summarizes the estimated work effort for each day81, and you can use this to find space in your schedule. To get an overview of the entire part of the day that is committed, you can set the option org-agenda-columns-add-appointments-to-effort-sum. The appointments on a day that take place over a specified time interval are then also added to the load estimate of the day.

Effort estimates can be used in secondary agenda filtering that is triggered with the / key in the agenda (see Commands in the Agenda Buffer). If you have these estimates defined consistently, two or three key presses narrow down the list to stuff that fits into an available time slot.

Footnotes
(81)
Please note the pitfalls of summing hierarchical data in a flat list (see Using Column View in the Agenda).


**** Taking Notes with a Relative Timer

Org provides two types of timers. There is a relative timer that counts up, which can be useful when taking notes during, for example, a meeting or a video viewing. There is also a countdown timer.

The relative and countdown are started with separate commands.

C-c C-x 0 (org-timer-start)
Start or reset the relative timer. By default, the timer is set to 0. When called with a C-u prefix, prompt the user for a starting offset. The prompt will default to a timer string at point (if any), providing a convenient way to restart taking notes after a break in the process. When called with a double prefix argument C-u C-u, change all timer strings in the active region by a certain amount. This can be used to fix timer strings if the timer was not started at exactly the right moment.

C-c C-x ; (org-timer-set-timer)
Start a countdown timer. The user is prompted for a duration. org-timer-default-timer sets the default countdown value. Giving a numeric prefix argument overrides this default value. This command is available as ; in agenda buffers.

Once started, relative and countdown timers are controlled with the same commands.

C-c C-x . (org-timer)
Insert a relative time into the buffer. The first time you use this, the timer starts. Using a prefix argument restarts it.

C-c C-x - (org-timer-item)
Insert a description list item with the current relative time. With a prefix argument, first reset the timer to 0.

M-RET (org-insert-heading)
Once the timer list is started, you can also use M-RET to insert new timer items.

C-c C-x , (org-timer-pause-or-continue)
Pause the timer, or continue it if it is already paused.

C-c C-x _ (org-timer-stop)
Stop the timer. After this, you can only start a new timer, not continue the old one. This command also removes the timer from the mode line.


*** Refiling and Archiving

Once information is in the system, it may need to be moved around. Org provides Refile, Copy and Archive commands for this. Refile and Copy helps with moving and copying outlines. Archiving helps to keep the system compact and fast.

**** Refile and Copy

When reviewing the captured data, you may want to refile or to copy some of the entries into a different list, for example into a project. Cutting, finding the right location, and then pasting the note is cumbersome. To simplify this process, you can use the following special command:

C-c C-w (org-refile)
Refile the entry or region at point. This command offers possible locations for refiling the entry and lets you select one with completion. The item (or all items in the region) is filed below the target heading as a subitem. Depending on org-reverse-note-order, it is either the first or last subitem.

By default, all level 1 headlines in the current buffer are considered to be targets, but you can have more complex definitions across a number of files. See the variable org-refile-targets for details. If you would like to select a location via a file-path-like completion along the outline path, see the variables org-refile-use-outline-path and org-outline-path-complete-in-steps. If you would like to be able to create new nodes as new parents for refiling on the fly, check the variable org-refile-allow-creating-parent-nodes. When the variable org-log-refile82 is set, a timestamp or a note is recorded whenever an entry is refiled.

C-u C-c C-w
Use the refile interface to jump to a heading.

C-u C-u C-c C-w (org-refile-goto-last-stored)
Jump to the location where org-refile last moved a tree to.

C-2 C-c C-w
Refile as the child of the item currently being clocked.

C-3 C-c C-w
Refile and keep the entry in place. Also see org-refile-keep to make this the default behavior, and beware that this may result in duplicated ‘ID’ properties.

C-0 C-c C-w or C-u C-u C-u C-c C-w (org-refile-cache-clear)
Clear the target cache. Caching of refile targets can be turned on by setting org-refile-use-cache. To make the command see new possible targets, you have to clear the cache with this command.

C-c M-w (org-refile-copy)
Copying works like refiling, except that the original note is not deleted.

C-c C-M-w (org-refile-reverse)
Works like refiling, except that it temporarily toggles how the value of org-reverse-note-order applies to the current buffer. So if org-refile would append the entry as the last entry under the target header, org-refile-reverse will prepend it as the first entry, and vice-versa.

Footnotes
(82)
Note the corresponding ‘STARTUP’ options ‘logrefile’, ‘lognoterefile’, and ‘nologrefile’.


**** Archiving

When a project represented by a (sub)tree is finished, you may want to move the tree out of the way and to stop it from contributing to the agenda. Archiving is important to keep your working files compact and global searches like the construction of agenda views fast.

C-c C-x C-a (org-archive-subtree-default)
Archive the current entry using the command specified in the variable org-archive-default-command.

***** Moving a tree to an archive file

The most common archiving action is to move a project tree to another file, the archive file.

C-c C-x C-s or short C-c $ (org-archive-subtree)
Archive the subtree starting at point position to the location given by org-archive-location.

C-u C-c C-x C-s
Check if any direct children of the current headline could be moved to the archive. To do this, check each subtree for open TODO entries. If none is found, the command offers to move it to the archive location. If point is not on a headline when this command is invoked, check level 1 trees.

C-u C-u C-c C-x C-s
As above, but check subtree for timestamps instead of TODO entries. The command offers to archive the subtree if it does contain a timestamp, and that timestamp is in the past.

The default archive location is a file in the same directory as the current file, with the name derived by appending ‘_archive’ to the current file name. You can also choose what heading to file archived items under, with the possibility to add them to a datetree in a file. For information and examples on how to specify the file and the heading, see the documentation string of the variable org-archive-location.

There is also an in-buffer option for setting this variable, for example:

#+ARCHIVE: %s_done::
If you would like to have a special archive location for a single entry or a (sub)tree, give the entry an ‘ARCHIVE’ property with the location as the value (see Properties and Columns).

When a subtree is moved, it receives a number of special properties that record context information like the file from where the entry came, its outline path the archiving time etc. Configure the variable org-archive-save-context-info to adjust the amount of information added.

When org-archive-subtree-save-file-p is non-nil, save the target archive buffer.


***** Internal archiving

If you want to just switch off—for agenda views—certain subtrees without moving them to a different file, you can use the ‘ARCHIVE’ tag.

A headline that is marked with the ‘ARCHIVE’ tag (see Tags) stays at its location in the outline tree, but behaves in the following way:

It does not open when you attempt to do so with a visibility cycling command (see Visibility Cycling). You can force cycling archived subtrees with C-c C-TAB, or by setting the option org-cycle-open-archived-trees. Also normal outline commands, like org-show-all, open archived subtrees.
During sparse tree construction (see Sparse Trees), matches in archived subtrees are not exposed, unless you configure the option org-sparse-tree-open-archived-trees.
During agenda view construction (see Agenda Views), the content of archived trees is ignored unless you configure the option org-agenda-skip-archived-trees, in which case these trees are always included. In the agenda you can press v a to get archives temporarily included.
Archived trees are not exported (see Exporting), only the headline is. Configure the details using the variable org-export-with-archived-trees.
Archived trees are excluded from column view unless the variable org-columns-skip-archived-trees is configured to nil.
The following commands help manage the ‘ARCHIVE’ tag:

C-c C-x a (org-toggle-archive-tag)
Toggle the archive tag for the current headline. When the tag is set, the headline changes to a shadowed face, and the subtree below it is hidden.

C-u C-c C-x a
Check if any direct children of the current headline should be archived. To do this, check each subtree for open TODO entries. If none is found, the command offers to set the ‘ARCHIVE’ tag for the child. If point is not on a headline when this command is invoked, check the level 1 trees.

C-c C-TAB (org-cycle-force-archived)
Cycle a tree even if it is tagged with ‘ARCHIVE’.

C-c C-x A (org-archive-to-archive-sibling)
Move the current entry to the Archive Sibling. This is a sibling of the entry with the heading ‘Archive’ and the archive tag. The entry becomes a child of that sibling and in this way retains a lot of its original context, including inherited tags and approximate position in the outline.


*** Capture and Attachments

An important part of any organization system is the ability to quickly capture new ideas and tasks, and to associate reference material with them. Org does this using a process called capture. It also can store files related to a task (attachments) in a special directory. Finally, it can parse RSS feeds for information. To learn how to let external programs (for example a web browser) trigger Org to capture material, see Protocols for External Access.

**** Capture

Capture lets you quickly store notes with little interruption of your work flow. Org’s method for capturing new items is heavily inspired by John Wiegley’s excellent Remember package.

***** Setting up capture

The following customization sets a default target file for notes.

(setq org-default-notes-file (concat org-directory "/notes.org"))

You may also define a global key for capturing new material (see Activation).


***** Using capture

M-x org-capture (org-capture)
Display the capture templates menu. If you have templates defined (see Capture templates), it offers these templates for selection or use a new Org outline node as the default template. It inserts the template into the target file and switch to an indirect buffer narrowed to this new node. You may then insert the information you want.

C-c C-c (org-capture-finalize)
Once you have finished entering information into the capture buffer, C-c C-c returns you to the window configuration before the capture process, so that you can resume your work without further distraction. When called with a prefix argument, finalize and then jump to the captured item.

C-c C-w (org-capture-refile)
Finalize the capture process by refiling the note to a different place (see Refile and Copy). Please realize that this is a normal refiling command that will be executed—so point position at the moment you run this command is important. If you have inserted a tree with a parent and children, first move point back to the parent. Any prefix argument given to this command is passed on to the org-refile command.

C-c C-k (org-capture-kill)
Abort the capture process and return to the previous state.

You can also call org-capture in a special way from the agenda, using the k c key combination. With this access, any timestamps inserted by the selected capture template defaults to the date at point in the agenda, rather than to the current date.

To find the locations of the last stored capture, use org-capture with prefix commands:

C-u M-x org-capture
Visit the target location of a capture template. You get to select the template in the usual way.

C-u C-u M-x org-capture
Visit the last stored capture item in its buffer.

You can also jump to the bookmark org-capture-last-stored, which is automatically created unless you customize org-bookmark-names-plist.

To insert the capture at point in an Org buffer, call org-capture with a C-0 prefix argument.


***** Capture templates

You can use templates for different types of capture items, and for different target locations. The easiest way to create such templates is through the customize interface.

C
Customize the variable org-capture-templates.

Before we give the formal description of template definitions, let’s look at an example. Say you would like to use one template to create general TODO entries, and you want to put these entries under the heading ‘Tasks’ in your file ‘~/org/gtd.org’. Also, a date tree in the file ‘journal.org’ should capture journal entries. A possible configuration would look like:

(setq org-capture-templates
      '(("t" "Todo" entry (file+headline "~/org/gtd.org" "Tasks")
         "* TODO %?\n  %i\n  %a")
        ("j" "Journal" entry (file+datetree "~/org/journal.org")
         "* %?\nEntered on %U\n  %i\n  %a")))
If you then press t from the capture menu, Org will prepare the template for you like this:

#+begin_src
 
# * TODO
#   [[file:LINK TO WHERE YOU INITIATED CAPTURE]]
  
#+end_src 
  
During expansion of the template, ‘%a’ has been replaced by a link to the location from where you called the capture command. This can be extremely useful for deriving tasks from emails, for example. You fill in the task definition, press C-c C-c and Org returns you to the same place where you started the capture process.

To define special keys to capture to a particular template without going through the interactive template selection, you can create your key binding like this:

(define-key global-map (kbd "C-c x")
  (lambda () (interactive) (org-capture nil "x")))

****** Template elements

Now lets look at the elements of a template definition. Each entry in org-capture-templates is a list with the following items:

keys
The keys that selects the template, as a string, characters only, for example ‘"a"’, for a template to be selected with a single key, or ‘"bt"’ for selection with two keys. When using several keys, keys using the same prefix key must be sequential in the list and preceded by a 2-element entry explaining the prefix key, for example:

("b" "Templates for marking stuff to buy")
If you do not define a template for the C key, this key opens the Customize buffer for this complex variable.

description
A short string describing the template, shown during selection.

type
The type of entry, a symbol. Valid values are:

entry
An Org mode node, with a headline. Will be filed as the child of the target entry or as a top-level entry. The target file should be an Org file.

item
A plain list item, placed in the first plain list at the target location. Again the target file should be an Org file.

checkitem
A checkbox item. This only differs from the plain list item by the default template.

table-line
A new line in the first table at the target location. Where exactly the line will be inserted depends on the properties :prepend and :table-line-pos (see below).

plain
Text to be inserted as it is.

target
Specification of where the captured item should be placed. In Org files, targets usually define a node. Entries will become children of this node. Other types will be added to the table or list in the body of this node. Most target specifications contain a file name. If that file name is the empty string, it defaults to org-default-notes-file. A file can also be given as a variable or as a function called with no argument. When an absolute path is not specified for a target, it is taken as relative to org-directory.

Valid values are:

‘(file "path/to/file")’
Text will be placed at the beginning or end of that file.

‘(id "id of existing org entry")’
Filing as child of this entry, or in the body of the entry.

‘(file+headline "filename" "node headline")’
Fast configuration if the target heading is unique in the file.

‘(file+olp "filename" "Level 1 heading" "Level 2" ...)’
For non-unique headings, the full path is safer.

‘(file+regexp "filename" "regexp to find location")’
Use a regular expression to position point.

‘(file+olp+datetree "filename" [ "Level 1 heading" ...])’
This target83 creates a heading in a date tree84 for today’s date. If the optional outline path is given, the tree will be built under the node it is pointing to, instead of at top level. Check out the :time-prompt and :tree-type properties below for additional options.

‘(file+function "filename" function-finding-location)’
A function to find the right location in the file.

‘(clock)’
File to the entry that is currently being clocked.

‘(here)’
The position of ‘point’.

‘(function function-finding-location)’
Most general way: write your own function which both visits the file and moves point to the right location.

template
The template for creating the capture item. If you leave this empty, an appropriate default template will be used. Otherwise this is a string with escape codes, which will be replaced depending on time and context of the capture call. You may also get this template string from a file85, or dynamically, from a function using either syntax:

(file "/path/to/template-file")
(function FUNCTION-RETURNING-THE-TEMPLATE)
properties
The rest of the entry is a property list of additional options. Recognized properties are:

:prepend
Normally new captured information will be appended at the target location (last child, last table line, last list item, …). Setting this property changes that.

:immediate-finish
When set, do not offer to edit the information, just file it away immediately. This makes sense if the template only needs information that can be added automatically.

:jump-to-captured
When set, jump to the captured entry when finished.

:empty-lines
Set this to the number of lines to insert before and after the new item. Default 0, and the only other common value is 1.

:empty-lines-after
Set this to the number of lines that should be inserted after the new item. Overrides :empty-lines for the number of lines inserted after.

:empty-lines-before
Set this to the number of lines that should be inserted before the new item. Overrides :empty-lines for the number lines inserted before.

:clock-in
Start the clock in this item.

:clock-keep
Keep the clock running when filing the captured entry.

:clock-resume
If starting the capture interrupted a clock, restart that clock when finished with the capture. Note that :clock-keep has precedence over :clock-resume. When setting both to non-nil, the current clock will run and the previous one will not be resumed.

:time-prompt
Prompt for a date/time to be used for date/week trees and when filling the template. Without this property, capture uses the current date and time. Even if this property has not been set, you can force the same behavior by calling org-capture with a C-1 prefix argument.

:tree-type
Use week to make a week tree instead of the month-day tree, i.e., place the headings for each day under a heading with the current ISO week. Use month to group entries by month only. Default is to group entries by day.

:unnarrowed
Do not narrow the target buffer, simply show the full buffer. Default is to narrow it so that you only see the new material.

:table-line-pos
Specification of the location in the table where the new line should be inserted. It should be a string like ‘II-3’ meaning that the new line should become the third line before the second horizontal separator line.

:kill-buffer
If the target file was not yet visited when capture was invoked, kill the buffer again after capture is completed.

:no-save
Do not save the target file after finishing the capture.

:refile-targets
Temporarily set org-refile-targets to the value of this property.

:hook
A nullary function or list of nullary functions run before org-capture-mode-hook when the template is selected.

:prepare-finalize
A nullary function or list of nullary functions run before org-capture-prepare-finalize-hook when the template is selected.

:before-finalize
A nullary function or list of nullary functions run before org-capture-before-finalize-hook when the template is selected.

:after-finalize
A nullary function or list of nullary functions run before org-capture-after-finalize-hook when the template is selected.

Footnotes
(83)
Org used to offer four different targets for date/week tree capture. Now, Org automatically translates these to use file+olp+datetree, applying the :time-prompt and :tree-type properties. Please rewrite your date/week-tree targets using file+olp+datetree since the older targets are now deprecated.

(84)
A date tree is an outline structure with years on the highest level, months or ISO weeks as sublevels and then dates on the lowest level.

#+begin_src 
  
# * 2022
# ** 2022-10 October
# *** 2022-10-07 Friday
# *** 2022-10-08 Saturday

#+end_src

TODO state, priority, tags, statistics cookies, and COMMENT keywords are allowed in the tree structure.

(85)
When the file name is not absolute, Org assumes it is relative to org-directory.


****** Template expansion

In the template itself, special “%-escapes”86 allow dynamic insertion of content. The templates are expanded in the order given here:

‘%[FILE]’
Insert the contents of the file given by FILE.

‘%(EXP)’
Evaluate Elisp expression EXP and replace it with the result. The EXP form must return a string. Only placeholders pre-existing within the template, or introduced with ‘%[file]’, are expanded this way. Since this happens after expanding non-interactive “%-escapes”, those can be used to fill the expression.

‘%<FORMAT>’
The result of format-time-string on the FORMAT specification.

‘%t’
Timestamp, date only.

‘%T’
Timestamp, with date and time.

‘%u’, ‘%U’
Like ‘%t’, ‘%T’ above, but inactive timestamps.

‘%i’
Initial content, the region when capture is called while the region is active. If there is text before ‘%i’ on the same line, such as indentation, and ‘%i’ is not inside a ‘%(exp)’ form, that prefix is added before every line in the inserted text.

‘%a’
Annotation, normally the link created with org-store-link.

‘%A’
Like ‘%a’, but prompt for the description part.

‘%l’
Like ‘%a’, but only insert the literal link.

‘%L’
Like ‘%l’, but without brackets (the link content itself).

‘%c’
Current kill ring head.

‘%x’
Content of the X clipboard.

‘%k’
Title of the currently clocked task.

‘%K’
Link to the currently clocked task.

‘%n’
User name (taken from user-full-name).

‘%f’
File visited by current buffer when org-capture was called.

‘%F’
Full path of the file or directory visited by current buffer.

‘%:keyword’
Specific information for certain link types, see below.

‘%^g’
Prompt for tags, with completion on tags in target file.

‘%^G’
Prompt for tags, with completion all tags in all agenda files.

‘%^t’
Like ‘%t’, but prompt for date. Similarly ‘%^T’, ‘%^u’, ‘%^U’. You may define a prompt like ‘%^{Birthday}t’.

‘%^C’
Interactive selection of which kill or clip to use.

‘%^L’
Like ‘%^C’, but insert as link.

‘%^{PROP}p’
Prompt the user for a value for property PROP. You may specify a default value with ‘%^{PROP|default}’.

‘%^{PROMPT}X’, X is one of g,G,t,T,u,U,C,L
Prompt the user as in ‘%^X’, but use the custom prompt string. You may specify a default value and completions with ‘%^{PROMPT|default|completion1|completion2|completion3...}X’.

‘%^{PROMPT}’
Prompt the user for a string and replace this sequence with it. You may specify a default value and a completion table with ‘%^{prompt|default|completion2|completion3...}’. The arrow keys access a prompt-specific history.

‘%\N’
Insert the text entered at the Nth ‘%^{PROMPT}’, where N is a number, starting from 1.

‘%?’
After completing the template, position point here.

For specific link types, the following keywords are defined87:

Link type	Available keywords
bbdb	‘%:name’, ‘%:company’
irc	‘%:server’, ‘%:port’, ‘%:nick’
mh, rmail	‘%:type’, ‘%:subject’, ‘%:message-id’
‘%:from’, ‘%:fromname’, ‘%:fromaddress’
‘%:to’, ‘%:toname’, ‘%:toaddress’
‘%:date’ (message date header field)
‘%:date-timestamp’ (date as active timestamp)
‘%:date-timestamp-inactive’ (date as inactive timestamp)
‘%:fromto’ (either “to NAME” or “from NAME”)88
gnus	‘%:group’, for messages also all email fields
w3, w3m	‘%:url’
info	‘%:file’, ‘%:node’
calendar	‘%:date’
org-protocol	‘%:link’, ‘%:description’, ‘%:annotation’
Footnotes
(86)
If you need one of these sequences literally, escape the ‘%’ with a backslash.

(87)
If you define your own link types (see Adding Hyperlink Types), any property you store with org-store-link-props can be accessed in capture templates in a similar way.

(88)
This is always the other, not the user. See the variable org-link-from-user-regexp.


****** Templates in contexts

To control whether a capture template should be accessible from a specific context, you can customize org-capture-templates-contexts. Let’s say, for example, that you have a capture template “p” for storing Gnus emails containing patches. Then you would configure this option like this:

(setq org-capture-templates-contexts
      '(("p" ((in-mode . "message-mode")))))
You can also tell that the command key p should refer to another template. In that case, add this command key like this:

(setq org-capture-templates-contexts
      '(("p" "q" ((in-mode . "message-mode")))))
See the docstring of the variable for more information.


**** Attachments

It is often useful to associate reference material with an outline node. Small chunks of plain text can simply be stored in the subtree of a project. Hyperlinks (see Hyperlinks) can establish associations with files that live elsewhere on a local, or even remote, computer, like emails or source code files belonging to a project.

Another method is attachments, which are files located in a directory belonging to an outline node. Org uses directories either named by a unique ID of each entry, or by a ‘DIR’ property.

***** Attachment defaults and dispatcher

By default, Org attach uses ID properties when adding attachments to outline nodes. This makes working with attachments fully automated. There is no decision needed for folder-name or location. ID-based directories are by default located in the ‘data/’ directory, which lives in the same directory where your Org file lives89.

When attachments are made using org-attach a default tag ‘ATTACH’ is added to the node that gets the attachments.

For more control over the setup, see Attachment options.

The following commands deal with attachments:

C-c C-a (org-attach)
The dispatcher for commands related to the attachment system. After these keys, a list of commands is displayed and you must press an additional key to select a command:

a (org-attach-attach)
Select a file and move it into the task’s attachment directory. The file is copied, moved, or linked, depending on org-attach-method. Note that hard links are not supported on all systems.

c/m/l
Attach a file using the copy/move/link method. Note that hard links are not supported on all systems.

b (org-attach-buffer)
Select a buffer and save it as a file in the task’s attachment directory.

n (org-attach-new)
Create a new attachment as an Emacs buffer.

z (org-attach-sync)
Synchronize the current task with its attachment directory, in case you added attachments yourself.

o (org-attach-open)
Open current task’s attachment. If there is more than one, prompt for a file name first. Opening follows the rules set by org-file-apps. For more details, see the information on following hyperlinks (see Handling Links).

O (org-attach-open-in-emacs)
Also open the attachment, but force opening the file in Emacs.

f (org-attach-reveal)
Open the current task’s attachment directory.

F (org-attach-reveal-in-emacs)
Also open the directory, but force using Dired in Emacs.

d (org-attach-delete-one)
Select and delete a single attachment.

D (org-attach-delete-all)
Delete all of a task’s attachments. A safer way is to open the directory in Dired and delete from there.

s (org-attach-set-directory)
Set a specific directory as the entry’s attachment directory. This works by putting the directory path into the ‘DIR’ property.

S (org-attach-unset-directory)
Remove the attachment directory. This command removes the ‘DIR’ property and asks the user to either move content inside that folder, if an ‘ID’ property is set, delete the content, or to leave the attachment directory as is but no longer attached to the outline node.

Footnotes
(89)
If you move entries or Org files from one directory to another, you may want to configure org-attach-id-dir to contain an absolute path.


***** Attachment options

There are a couple of options for attachments that are worth mentioning.

org-attach-id-dir
The directory where attachments are stored when ‘ID’ is used as method.

org-attach-dir-relative
When setting the ‘DIR’ property on a node using C-c C-a s (org-attach-set-directory), absolute links are entered by default. This option changes that to relative links.

org-attach-use-inheritance
By default folders attached to an outline node are inherited from parents according to org-use-property-inheritance. If one instead want to set inheritance specifically for Org attach that can be done using org-attach-use-inheritance. Inheriting documents through the node hierarchy makes a lot of sense in most cases. Especially when using attachment links (see Attachment links). The following example shows one use case for attachment inheritance:

#+begin_src
  
# * Chapter A ...
#   :PROPERTIES:
#   :DIR: Chapter A/
#   :END:
# ** Introduction
# Some text

# #+NAME: Image 1
# [[attachment:image 1.jpg]]
  
#+end_src 

Without inheritance one would not be able to resolve the link to ‘image 1.jpg’, since the link is inside a sub-heading to ‘Chapter A’.

Inheritance works the same way for both ‘ID’ and ‘DIR’ property. If both properties are defined on the same headline then ‘DIR’ takes precedence. This is also true if inheritance is enabled. If ‘DIR’ is inherited from a parent node in the outline, that property still takes precedence over an ‘ID’ property defined on the node itself.

org-attach-method
When attaching files using the dispatcher C-c C-a it defaults to copying files. The behavior can be changed by customizing org-attach-method. Options are Copy, Move/Rename, Hard link or Symbolic link.

org-attach-preferred-new-method
This customization lets you choose the default way to attach to nodes without existing ‘ID’ and ‘DIR’ property. It defaults to id but can also be set to dir, ask or nil.

org-attach-archive-delete
Configure this to determine if attachments should be deleted or not when a subtree that has attachments is archived.

org-attach-auto-tag
When attaching files to a heading it will be assigned a tag according to what is set here.

org-attach-id-to-path-function-list
When ‘ID’ is used for attachments, the ID is parsed into a part of a directory-path. See org-attach-id-uuid-folder-format for the default function. Define a new one and add it as first element in org-attach-id-to-path-function-list if you want the folder structure in any other way. All functions in this list will be tried when resolving existing ID’s into paths, to maintain backward compatibility with existing folders in your system.

org-attach-store-link-p
Stores a link to the file that is being attached. The link is stored in org-stored-links for later insertion with C-c C-l (see Handling Links). Depending on what option is set in org-attach-store-link-p, the link is stored to either the original location as a file link, the attachment location as an attachment link or to the attachment location as a file link.

org-attach-commands
List of all commands used in the attach dispatcher.

org-attach-expert
Do not show the splash buffer with the attach dispatcher when org-attach-expert is set to non-nil.

See customization group ‘Org Attach’ if you want to change the default settings.


***** Attachment links

Attached files and folders can be referenced using attachment links. This makes it easy to refer to the material added to an outline node. Especially if it was attached using the unique ID of the entry!

#+begin_src
  
# * TODO Some task
#   :PROPERTIES:
#   :ID:       95d50008-c12e-479f-a4f2-cc0238205319
#   :END:
  
#+end_src

See attached document for more information: [[attachment:info.org]]
See External Links for more information about these links.


***** Automatic version-control with Git

If the directory attached to an outline node is a Git repository, Org can be configured to automatically commit changes to that repository when it sees them.

To make Org mode take care of versioning of attachments for you, add the following to your Emacs config:

(require 'org-attach-git)


***** Attach from Dired

It is possible to attach files to a subtree from a Dired buffer. To use this feature, have one window in Dired mode containing the file(s) to be attached and another window with point in the subtree that shall get the attachments. In the Dired window, with point on a file, M-x org-attach-dired-to-subtree attaches the file to the subtree using the attachment method set by variable org-attach-method. When files are marked in the Dired window then all marked files get attached.

Add the following lines to the Emacs init file to have C-c C-x a attach files in Dired buffers.

(add-hook 'dired-mode-hook
          (lambda ()
            (define-key dired-mode-map
              (kbd "C-c C-x a")
              #'org-attach-dired-to-subtree)))
The following code shows how to bind the previous command with a specific attachment method.

(add-hook 'dired-mode-hook
          (lambda ()
            (define-key dired-mode-map (kbd "C-c C-x c")
              (lambda ()
                (interactive)
                (let ((org-attach-method 'cp))
                  (call-interactively #'org-attach-dired-to-subtree))))))

**** RSS Feeds

Org can add and change entries based on information found in RSS feeds and Atom feeds. You could use this to make a task out of each new podcast in a podcast feed. Or you could use a phone-based note-creating service on the web to import tasks into Org. To access feeds, configure the variable org-feed-alist. The docstring of this variable has detailed information. With the following

(setq org-feed-alist
      '(("Slashdot"
         "https://rss.slashdot.org/Slashdot/slashdot"
         "~/txt/org/feeds.org" "Slashdot Entries")))
new items from the feed provided by ‘rss.slashdot.org’ result in new entries in the file ‘~/org/feeds.org’ under the heading ‘Slashdot Entries’, whenever the following command is used:

C-c C-x g (org-feed-update-all)
Collect items from the feeds configured in org-feed-alist and act upon them.

C-c C-x G (org-feed-goto-inbox)
Prompt for a feed name and go to the inbox configured for this feed.

Under the same headline, Org creates a drawer ‘FEEDSTATUS’ in which it stores information about the status of items in the feed, to avoid adding the same item several times.

For more information, including how to read atom feeds, see ‘org-feed.el’ and the docstring of org-feed-alist.


*** Agenda Views

Due to the way Org works, TODO items, time-stamped items, and tagged headlines can be scattered throughout a file or even a number of files. To get an overview of open action items, or of events that are important for a particular date, this information must be collected, sorted and displayed in an organized way.

Org can select items based on various criteria and display them in a separate buffer. Six different view types are provided:

an agenda that is like a calendar and shows information for specific dates,
a TODO list that covers all unfinished action items,
a match view, showings headlines based on the tags, properties, and TODO state associated with them,
a text search view that shows all entries from multiple files that contain specified keywords,
a stuck projects view showing projects that currently do not move along, and
custom views that are special searches and combinations of different views.
The extracted information is displayed in a special agenda buffer. This buffer is read-only, but provides commands to visit the corresponding locations in the original Org files, and even to edit these files remotely.

By default, the report ignores commented (see Comment Lines) and archived (see Internal archiving) entries. You can override this by setting org-agenda-skip-comment-trees and org-agenda-skip-archived-trees to nil.

Two variables control how the agenda buffer is displayed and whether the window configuration is restored when the agenda exits: org-agenda-window-setup and org-agenda-restore-windows-after-quit.

**** Agenda Files

The information to be shown is normally collected from all agenda files, the files listed in the variable org-agenda-files90. If a directory is part of this list, all files with the extension ‘.org’ in this directory are part of the list.

Thus, even if you only work with a single Org file, that file should be put into the list91. You can customize org-agenda-files, but the easiest way to maintain it is through the following commands

C-c [ (org-agenda-file-to-front)
Add current file to the list of agenda files. The file is added to the front of the list. If it was already in the list, it is moved to the front. With a prefix argument, file is added/moved to the end.

C-c ] (org-remove-file)
Remove current file from the list of agenda files.

C-'
C-, (org-cycle-agenda-files)
Cycle through agenda file list, visiting one file after the other.

M-x org-switchb
Command to use an Iswitchb-like interface to switch to and between Org buffers.

The Org menu contains the current list of files and can be used to visit any of them.

If you would like to focus the agenda temporarily on a file not in this list, or on just one file in the list, or even on only a subtree in a file, then this can be done in different ways. For a single agenda command, you may press < once or several times in the dispatcher (see The Agenda Dispatcher). To restrict the agenda scope for an extended period, use the following commands:

C-c C-x < (org-agenda-set-restriction-lock)
Restrict the agenda to the current subtree. If there already is a restriction at point, remove it. When called with a universal prefix argument or with point before the first headline in a file, set the agenda scope to the entire file. This restriction remains in effect until removed with C-c C-x >, or by typing either < or > in the agenda dispatcher. If there is a window displaying an agenda view, the new restriction takes effect immediately.

C-c C-x > (org-agenda-remove-restriction-lock)
Remove the restriction created by C-c C-x <.

When working with Speedbar, you can use the following commands in the Speedbar frame:

< (org-speedbar-set-agenda-restriction)
Restrict the agenda to the item—either an Org file or a subtree in such a file—at point in the Speedbar frame. If agenda is already restricted there, remove the restriction. If there is a window displaying an agenda view, the new restriction takes effect immediately.

> (org-agenda-remove-restriction-lock)
Remove the restriction.

Footnotes
(90)
If the value of that variable is not a list, but a single file name, then the list of agenda files in maintained in that external file.

(91)
When using the dispatcher, pressing < before selecting a command actually limits the command to the current file, and ignores org-agenda-files until the next dispatcher command.


**** The Agenda Dispatcher

The views are created through a dispatcher, accessible with M-x org-agenda, or, better, bound to a global key (see Activation). It displays a menu from which an additional letter is required to execute a command. The dispatcher offers the following default commands:

a
Create the calendar-like agenda (see Weekly/daily agenda).

t
T
Create a list of all TODO items (see The global TODO list).

m
M
Create a list of headlines matching a given expression (see Matching tags and properties).

s
Create a list of entries selected by a boolean expression of keywords and/or regular expressions that must or must not occur in the entry.

/
Search for a regular expression in all agenda files and additionally in the files listed in org-agenda-text-search-extra-files. This uses the Emacs command multi-occur. A prefix argument can be used to specify the number of context lines for each match, the default is 1.

#
Create a list of stuck projects (see Stuck projects).

!
Configure the list of stuck projects (see Stuck projects).

<
Restrict an agenda command to the current buffer92. If narrowing is in effect restrict to the narrowed part of the buffer. After pressing <, you still need to press the character selecting the command.

< <
If there is an active region, restrict the following agenda command to the region. Otherwise, restrict it to the current subtree. After pressing < <, you still need to press the character selecting the command.

*
Toggle sticky agenda views. By default, Org maintains only a single agenda buffer and rebuilds it each time you change the view, to make sure everything is always up to date. If you switch between views often and the build time bothers you, you can turn on sticky agenda buffers (make this the default by customizing the variable org-agenda-sticky). With sticky agendas, the dispatcher only switches to the selected view, you need to update it by hand with r or g. You can toggle sticky agenda view any time with org-toggle-sticky-agenda.

You can also define custom commands that are accessible through the dispatcher, just like the default commands. This includes the possibility to create extended agenda buffers that contain several blocks together, for example the weekly agenda, the global TODO list and a number of special tags matches. See Custom Agenda Views.

Footnotes
(92)
For backward compatibility, you can also press 1 to restrict to the current buffer.


**** The Built-in Agenda Views

In this section we describe the built-in views.

***** Weekly/daily agenda

The purpose of the weekly/daily agenda is to act like a page of a paper agenda, showing all the tasks for the current week or day.

M-x org-agenda a (org-agenda-list)
Compile an agenda for the current week from a list of Org files. The agenda shows the entries for each day. With a numeric prefix argument93—like C-u 2 1 M-x org-agenda a—you may set the number of days to be displayed.

The default number of days displayed in the agenda is set by the variable org-agenda-span. This variable can be set to any number of days you want to see by default in the agenda, or to a span name, such a day, week, month or year. For weekly agendas, the default is to start on the previous Monday (see org-agenda-start-on-weekday). You can also set the start date using a date shift: ‘(setq org-agenda-start-day "+10d")’ starts the agenda ten days from today in the future. org-agenda-start-on-weekday takes precedence over org-agenda-start-day in weekly and bi-weekly agendas.

Remote editing from the agenda buffer means, for example, that you can change the dates of deadlines and appointments from the agenda buffer. The commands available in the Agenda buffer are listed in Commands in the Agenda Buffer.

Calendar/Diary integration
Emacs contains the calendar and diary by Edward M. Reingold. The calendar displays a three-month calendar with holidays from different countries and cultures. The diary allows you to keep track of anniversaries, lunar phases, sunrise/set, recurrent appointments (weekly, monthly) and more. In this way, it is quite complementary to Org. It can be very useful to combine output from Org with the diary.

In order to include entries from the Emacs diary into Org mode’s agenda, you only need to customize the variable

(setq org-agenda-include-diary t)
After that, everything happens automatically. All diary entries including holidays, anniversaries, etc., are included in the agenda buffer created by Org mode. SPC, TAB, and RET can be used from the agenda buffer to jump to the diary file in order to edit existing diary entries. The i command to insert new entries for the current date works in the agenda buffer, as well as the commands S, M, and C to display Sunrise/Sunset times, show lunar phases and to convert to other calendars, respectively. c can be used to switch back and forth between calendar and agenda.

If you are using the diary only for expression entries and holidays, it is faster to not use the above setting, but instead to copy or even move the entries into an Org file. Org mode evaluates diary-style expression entries, and does it faster because there is no overhead for first creating the diary display. Note that the expression entries must start at the left margin, no whitespace is allowed before them, as seen in the following segment of an Org file:94

#+begin_src

# * Holidays
#   :PROPERTIES:
#   :CATEGORY: Holiday
#   :END:
# %%(org-calendar-holiday)   ; special function for holiday names

# * Birthdays
#   :PROPERTIES:
#   :CATEGORY: Ann
#   :END:
# %%(org-anniversary 1956  5 14) Arthur Dent is %d years old
# %%(org-anniversary 1869 10  2) Mahatma Gandhi would be %d years old

  #+end_src 

Anniversaries from BBDB
If you are using the Insidious Big Brother Database to store your contacts, you very likely prefer to store anniversaries in BBDB rather than in a separate Org or diary file. Org supports this and can show BBDB anniversaries as part of the agenda. All you need to do is to add the following to one of your agenda files:

#+begin_src

# * Anniversaries
#   :PROPERTIES:
#   :CATEGORY: Anniv
#   :END:
# %%(org-bbdb-anniversaries)
  
  #+end_src

You can then go ahead and define anniversaries for a BBDB record. Basically, you need a field named ‘anniversary’ for the BBDB record which contains the date in the format ‘YYYY-MM-DD’ or ‘MM-DD’, followed by a space and the class of the anniversary (‘birthday’, ‘wedding’, or a format string). If you omit the class, it defaults to ‘birthday’. Here are a few examples, the header for the file ‘ol-bbdb.el’ contains more detailed information.

1973-06-22
06-22
1955-08-02 wedding
2008-04-14 %s released version 6.01 of Org mode, %d years ago
After a change to BBDB, or for the first agenda display during an Emacs session, the agenda display suffers a short delay as Org updates its hash with anniversaries. However, from then on things will be very fast, much faster in fact than a long list of ‘%%(diary-anniversary)’ entries in an Org or Diary file.

If you would like to see upcoming anniversaries with a bit of forewarning, you can use the following instead:

#+begin_src

# * Anniversaries
#   :PROPERTIES:
#   :CATEGORY: Anniv
#   :END:
# %%(org-bbdb-anniversaries-future 3)  
#+end_src


That will give you three days’ warning: on the anniversary date itself and the two days prior. The argument is optional: if omitted, it defaults to 7.

Appointment reminders
Org can interact with Emacs appointments notification facility. To add the appointments of your agenda files, use the command org-agenda-to-appt. This command lets you filter through the list of your appointments and add only those belonging to a specific category or matching a regular expression. It also reads a ‘APPT_WARNTIME’ property which overrides the value of appt-message-warning-time for this appointment. See the docstring for details.

Footnotes
(93)
For backward compatibility, the universal prefix argument C-u causes all TODO entries to be listed before the agenda. This feature is deprecated, use the dedicated TODO list, or a block agenda instead (see Block agenda).

(94)
The variable org-anniversary used in the example is just like diary-anniversary, but the argument order is always according to ISO and therefore independent of the value of calendar-date-style.


***** The global TODO list

The global TODO list contains all unfinished TODO items formatted and collected into a single place.

M-x org-agenda t (org-todo-list)
Show the global TODO list. This collects the TODO items from all agenda files (see Agenda Views) into a single buffer. By default, this lists items with a state that is not a DONE state. The buffer is in Agenda mode, so there are commands to examine and manipulate the TODO entries directly from that buffer (see Commands in the Agenda Buffer).

M-x org-agenda T (org-todo-list)
Like the above, but allows selection of a specific TODO keyword. You can also do this by specifying a prefix argument to t. You are prompted for a keyword, and you may also specify several keywords by separating them with ‘|’ as the boolean OR operator. With a numeric prefix, the Nth keyword in org-todo-keywords is selected.

The r key in the agenda buffer regenerates it, and you can give a prefix argument to this command to change the selected TODO keyword, for example 3 r. If you often need a search for a specific keyword, define a custom command for it (see The Agenda Dispatcher).

Matching specific TODO keywords can also be done as part of a tags search (see Tag Searches).

Remote editing of TODO items means that you can change the state of a TODO entry with a single key press. The commands available in the TODO list are described in Commands in the Agenda Buffer.

Normally the global TODO list simply shows all headlines with TODO keywords. This list can become very long. There are two ways to keep it more compact:

Some people view a TODO item that has been scheduled for execution or have a deadline (see Timestamps) as no longer open. Configure the variables org-agenda-todo-ignore-scheduled to exclude some or all scheduled items from the global TODO list, org-agenda-todo-ignore-deadlines to exclude some or all items with a deadline set, org-agenda-todo-ignore-timestamp to exclude some or all items with an active timestamp other than a DEADLINE or a SCHEDULED timestamp and/or org-agenda-todo-ignore-with-date to exclude items with at least one active timestamp.
TODO items may have sublevels to break up the task into subtasks. In such cases it may be enough to list only the highest level TODO headline and omit the sublevels from the global list. Configure the variable org-agenda-todo-list-sublevels to get this behavior.

***** Matching tags and properties

If headlines in the agenda files are marked with tags (see Tags), or have properties (see Properties and Columns), you can select headlines based on this metadata and collect them into an agenda buffer. The match syntax described here also applies when creating sparse trees with C-c / m.

M-x org-agenda m (org-tags-view)
Produce a list of all headlines that match a given set of tags. The command prompts for a selection criterion, which is a boolean logic expression with tags, like ‘+work+urgent-withboss’ or ‘work|home’ (see Tags). If you often need a specific search, define a custom command for it (see The Agenda Dispatcher).

M-x org-agenda M (org-tags-view)
Like m, but only select headlines that are also TODO items. To exclude scheduled/deadline items, see the variable org-agenda-tags-todo-honor-ignore-options. Matching specific TODO keywords together with a tags match is also possible, see Tag Searches.

The commands available in the tags list are described in Commands in the Agenda Buffer.

A search string can use Boolean operators ‘&’ for AND and ‘|’ for OR. ‘&’ binds more strongly than ‘|’. Parentheses are currently not implemented. Each element in the search is either a tag, a regular expression matching tags, or an expression like ‘PROPERTY OPERATOR VALUE’ with a comparison operator, accessing a property value. Each element may be preceded by ‘-’ to select against it, and ‘+’ is syntactic sugar for positive selection. The AND operator ‘&’ is optional when ‘+’ or ‘-’ is present. Here are some examples, using only tags.

‘+work-boss’
Select headlines tagged ‘work’, but discard those also tagged ‘boss’.

‘work|laptop’
Selects lines tagged ‘work’ or ‘laptop’.

‘work|laptop+night’
Like before, but require the ‘laptop’ lines to be tagged also ‘night’.

Instead of a tag, you may also specify a regular expression enclosed in curly braces (see Regular Expressions). For example, ‘work+{^boss.*}’ matches headlines that contain the tag ‘:work:’ and any tag starting with ‘boss’.

Group tags (see Tag Hierarchy) are expanded as regular expressions. E.g., if ‘work’ is a group tag for the group ‘:work:lab:conf:’, then searching for ‘work’ also searches for ‘{\(?:work\|lab\|conf\)}’ and searching for ‘-work’ searches for all headlines but those with one of the tags in the group (i.e., ‘-{\(?:work\|lab\|conf\)}’).

You may also test for properties (see Properties and Columns) at the same time as matching tags. The properties may be real properties, or special properties that represent other metadata (see Special Properties). For example, the property ‘TODO’ represents the TODO keyword of the entry. Or, the property ‘LEVEL’ represents the level of an entry. So searching ‘+LEVEL=3+boss-TODO​="DONE"’ lists all level three headlines that have the tag ‘boss’ and are not marked with the TODO keyword ‘DONE’. In buffers with org-odd-levels-only set, ‘LEVEL’ does not count the number of stars, but ‘LEVEL=2’ corresponds to 3 stars etc.

Here are more examples:

‘work+TODO​="WAITING"’
Select ‘work’-tagged TODO lines with the specific TODO keyword ‘WAITING’.

‘work+TODO​="WAITING"|home+TODO​="WAITING"’
Waiting tasks both at work and at home.

When matching properties, a number of different operators can be used to test the value of a property. Here is a complex example:

+work-boss+PRIORITY="A"+Coffee="unlimited"+Effort<*2
         +With={Sarah\|Denny}+SCHEDULED>="<2008-10-11>"
The type of comparison depends on how the comparison value is written:

If the comparison value is a plain number, a numerical comparison is done, and the allowed operators are ‘<’, ‘=’, ‘>’, ‘<=’, ‘>=’, and ‘<>’. As a synonym for the equality operator ‘=’, there is also ‘==’; ‘!=’ and ‘/=’ are synonyms of the inequality operator ‘<>’.
If the comparison value is enclosed in double-quotes, a string comparison is done, and the same operators are allowed.
If the comparison value is enclosed in double-quotes and angular brackets (like ‘DEADLINE<​="<2008-12-24 18:30>"’), both values are assumed to be date/time specifications in the standard Org way, and the comparison is done accordingly. Valid values also include ‘"<now>"’ for now (including time), ‘"<today>"’, and ‘"<tomorrow>"’ for these days at 0:00 hours, i.e., without a time specification. You can also use strings like ‘"<+5d>"’ or ‘"<-2m>"’ with units ‘d’, ‘w’, ‘m’, and ‘y’ for day, week, month, and year, respectively.
If the comparison value is enclosed in curly braces, a regexp match is performed, with ‘=’ meaning that the regexp matches the property value, and ‘<>’ meaning that it does not match.
All operators may be optionally followed by an asterisk ‘*’, like in ‘<*’, ‘!=*’, etc. Such starred operators work like their regular, unstarred counterparts except that they match only headlines where the tested property is actually present. This is most useful for search terms that logically exclude results, like the inequality operator.
So the search string in the example finds entries tagged ‘work’ but not ‘boss’, which also have a priority value ‘A’, a ‘Coffee’ property with the value ‘unlimited’, an ‘EFFORT’ property that is numerically smaller than 2, a ‘With’ property that is matched by the regular expression ‘Sarah\|Denny’, and that are scheduled on or after October 11, 2008.

Note that the test on the ‘EFFORT’ property uses operator ‘<*’, so that the search result will include only entries that actually have an ‘EFFORT’ property defined and with numerical value smaller than 2. With the regular ‘<’ operator, the search would handle entries without an ‘EFFORT’ property as having a zero effort and would include them in the result as well.

You can use all characters valid in property names when matching properties. However, you have to quote some characters in property names with backslashes when using them in search strings, namely all characters different from alphanumerics and underscores95. For example, to search for all entries having a property ‘boss-prio’, ‘boss:prio’, or ‘boss\prio’, respectively, with value ‘C’, use search strings

boss\-prio="C"
boss\:prio="C"
boss\\prio="C"
You can configure Org mode to use property inheritance during a search, but beware that this can slow down searches considerably. See Property Inheritance, for details.

For backward compatibility, and also for typing speed, there is also a different way to test TODO states in a search. For this, terminate the tags/property part of the search string (which may include several terms connected with ‘|’) with a ‘/’ and then specify a Boolean expression just for TODO keywords. The syntax is then similar to that for tags, but should be applied with care: for example, a positive selection on several TODO keywords cannot meaningfully be combined with boolean AND. However, negative selection combined with AND can be meaningful. To make sure that only lines are checked that actually have any TODO keyword (resulting in a speed-up), use M-x org-agenda M, or equivalently start the TODO part after the slash with ‘!’. Using M-x org-agenda M or ‘/!’ does not match TODO keywords in a DONE state. Examples:

‘work/WAITING’
Same as ‘work+TODO​="WAITING"’.

‘work/!-WAITING-NEXT’
Select ‘work’-tagged TODO lines that are neither ‘WAITING’ nor ‘NEXT’.

‘work/!+WAITING|+NEXT’
Select ‘work’-tagged TODO lines that are either ‘WAITING’ or ‘NEXT’.

Footnotes
(95)
If you quote alphanumeric characters or underscores with a backslash, that backslash is ignored.


***** Search view

This agenda view is a general text search facility for Org mode entries. It is particularly useful to find notes.

M-x org-agenda s (org-search-view)
This is a special search that lets you select entries by matching a substring or specific words using a boolean logic.

For example, the search string ‘computer equipment’ matches entries that contain ‘computer equipment’ as a substring, even if the two words are separated by more space or a line break.

Search view can also search for specific keywords in the entry, using Boolean logic. The search string ‘+computer +wifi -ethernet -{8\.11[bg]}’ matches note entries that contain the keywords ‘computer’ and ‘wifi’, but not the keyword ‘ethernet’, and which are also not matched by the regular expression ‘8\.11[bg]’, meaning to exclude both ‘8.11b’ and ‘8.11g’. The first ‘+’ is necessary to turn on boolean search, other ‘+’ characters are optional. For more details, see the docstring of the command org-search-view.

You can incrementally and conveniently adjust a boolean search from the agenda search view with the following keys

[	Add a positive search word
]	Add a negative search word
{	Add a positive regular expression
}	Add a negative regular expression
Note that in addition to the agenda files, this command also searches the files listed in org-agenda-text-search-extra-files.


***** Stuck projects

If you are following a system like David Allen’s GTD to organize your work, one of the “duties” you have is a regular review to make sure that all projects move along. A stuck project is a project that has no defined next actions, so it never shows up in the TODO lists Org mode produces. During the review, you need to identify such projects and define next actions for them.

M-x org-agenda # (org-agenda-list-stuck-projects)
List projects that are stuck.

M-x org-agenda !
Customize the variable org-stuck-projects to define what a stuck project is and how to find it.

You almost certainly need to configure this view before it works for you. The built-in default assumes that all your projects are level-2 headlines, and that a project is not stuck if it has at least one entry marked with a TODO keyword ‘TODO’ or ‘NEXT’ or ‘NEXTACTION’.

Let’s assume that you, in your own way of using Org mode, identify projects with a tag ‘:PROJECT:’, and that you use a TODO keyword ‘MAYBE’ to indicate a project that should not be considered yet. Let’s further assume that the TODO keyword ‘DONE’ marks finished projects, and that ‘NEXT’ and ‘TODO’ indicate next actions. The tag ‘:@shop:’ indicates shopping and is a next action even without the NEXT tag. Finally, if the project contains the special word ‘IGNORE’ anywhere, it should not be listed either. In this case you would start by identifying eligible projects with a tags/TODO match (see Tag Searches) ‘+PROJECT/-MAYBE-DONE’, and then check for ‘TODO’, ‘NEXT’, ‘@shop’, and ‘IGNORE’ in the subtree to identify projects that are not stuck. The correct customization for this is:

(setq org-stuck-projects
      '("+PROJECT/-MAYBE-DONE" ("NEXT" "TODO") ("@shop")
        "\\<IGNORE\\>"))
Note that if a project is identified as non-stuck, the subtree of this entry is searched for stuck projects.


**** Presentation and Sorting

Before displaying items in an agenda view, Org mode visually prepares the items and sorts them. Each item occupies a single line. The line starts with a prefix that contains the category (see Categories) of the item and other important information. You can customize in which column tags are displayed through org-agenda-tags-column. You can also customize the prefix using the option org-agenda-prefix-format. This prefix is followed by a cleaned-up version of the outline headline associated with the item.

***** Categories

The category is a broad label assigned to each agenda item. By default, the category is simply derived from the file name, but you can also specify it with a special line in the buffer, like this:

#+CATEGORY: Thesis
If you would like to have a special category for a single entry or a (sub)tree, give the entry a ‘CATEGORY’ property with the special category you want to apply as the value.

The display in the agenda buffer looks best if the category is not longer than 10 characters. You can set up icons for category by customizing the org-agenda-category-icon-alist variable.


***** Time-of-day specifications

Org mode checks each agenda item for a time-of-day specification. The time can be part of the timestamp that triggered inclusion into the agenda, for example

<2005-05-10 Tue 19:00>
Time ranges can be specified with two timestamps:

<2005-05-10 Tue 20:30>--<2005-05-10 Tue 22:15>
In the headline of the entry itself, a time(range)—like ‘12:45’ or a ‘8:30-1pm’—may also appear as plain text96.

If the agenda integrates the Emacs diary (see Weekly/daily agenda), time specifications in diary entries are recognized as well.

For agenda display, Org mode extracts the time and displays it in a standard 24 hour format as part of the prefix. The example times in the previous paragraphs would end up in the agenda like this:

 8:30-13:00 Arthur Dent lies in front of the bulldozer
12:45...... Ford Prefect arrives and takes Arthur to the pub
19:00...... The Vogon reads his poem
20:30-22:15 Marvin escorts the Hitchhikers to the bridge
If the agenda is in single-day mode, or for the display of today, the timed entries are embedded in a time grid, like

 8:00...... ------------------
 8:30-13:00 Arthur Dent lies in front of the bulldozer
10:00...... ------------------
12:00...... ------------------
12:45...... Ford Prefect arrives and takes Arthur to the pub
14:00...... ------------------
16:00...... ------------------
18:00...... ------------------
19:00...... The Vogon reads his poem
20:00...... ------------------
20:30-22:15 Marvin escorts the Hitchhikers to the bridge
The time grid can be turned on and off with the variable org-agenda-use-time-grid, and can be configured with org-agenda-time-grid.

Footnotes
(96)
You can, however, disable this by setting org-agenda-search-headline-for-time variable to a nil value.


***** Sorting of agenda items

Before being inserted into a view, the items are sorted. How this is done depends on the type of view.

For the daily/weekly agenda, the items for each day are sorted. The default order is to first collect all items containing an explicit time-of-day specification. These entries are shown at the beginning of the list, as a schedule for the day. After that, items remain grouped in categories, in the sequence given by org-agenda-files. Within each category, items are sorted by urgency, which is composed of the base priority (see Priorities; 2000 for priority ‘A’, 1000 for ‘B’, and 0 for ‘C’), plus additional increments for overdue scheduled or deadline items.
For the TODO list, items remain in the order of categories, but within each category, sorting takes place according to urgency. The urgency used for sorting derives from the priority cookie, with additions depending on how close an item is to its due or scheduled date.
For tags matches, items are not sorted at all, but just appear in the sequence in which they are found in the agenda files.
Sorting can be customized using the variable org-agenda-sorting-strategy, and may also include criteria based on the estimated effort of an entry (see Effort Estimates).


***** Filtering/limiting agenda items

Agenda built-in or custom commands are statically defined. Agenda filters and limits allow flexibly narrowing down the list of agenda entries.

Filters only change the visibility of items, are very fast and are mostly used interactively97. You can switch quickly between different filters without having to recreate the agenda. Limits on the other hand take effect before the agenda buffer is populated, so they are mostly useful when defined as local variables within custom agenda commands.

Filtering in the agenda
The general filtering command is org-agenda-filter, bound to /. Before we introduce it, we describe commands for individual filter types. All filtering commands handle prefix arguments in the same way: A single C-u prefix negates the filter, so it removes lines selected by the filter. A double prefix adds the new filter condition to the one(s) already in place, so filter elements are accumulated.

\ (org-agenda-filter-by-tag)
Filter the agenda view with respect to a tag. You are prompted for a tag selection letter; SPC means any tag at all. Pressing TAB at that prompt offers completion to select a tag, including any tags that do not have a selection character. The command then hides all entries that do not contain or inherit this tag. Pressing + or - at the prompt switches between filtering for and against the next tag. To clear the filter, press \ twice (once to call the command again, and once at the prompt).

< (org-agenda-filter-by-category)
Filter by category of the line at point, and show only entries with this category. When called with a prefix argument, hide all entries with the category at point. To clear the filter, call this command again by pressing <.

= (org-agenda-filter-by-regexp)
Filter the agenda view by a regular expression: only show agenda entries matching the regular expression the user entered. To clear the filter, call the command again by pressing =.

_ (org-agenda-filter-by-effort)
Filter the agenda view with respect to effort estimates, so select tasks that take the right amount of time. You first need to set up a list of efforts globally, for example

(setq org-global-properties
      '(("Effort_ALL". "0 0:10 0:30 1:00 2:00 3:00 4:00")))
You can then filter for an effort by first typing an operator, one of <, > and =, and then the one-digit index of an effort estimate in your array of allowed values, where 0 means the 10th value. The filter then restricts to entries with effort smaller-or-equal, equal, or larger-or-equal than the selected value. For application of the operator, entries without a defined effort are treated according to the value of org-sort-agenda-noeffort-is-high. To clear the filter, press _ twice (once to call the command again, and once at the first prompt).

^ (org-agenda-filter-by-top-headline)
Filter the current agenda view and only display items that fall under the same top-level headline as the current entry. To clear the filter, call this command again by pressing ^.

/ (org-agenda-filter)
This is the unified interface to four of the five filter methods described above. At the prompt, specify different filter elements in a single string, with full completion support. For example,

+work-John+<0:10-/plot/
selects entries with category ‘work’ and effort estimates below 10 minutes, and deselects entries with tag ‘John’ or matching the regexp ‘plot’ (see Regular Expressions). You can leave ‘+’ out if that does not lead to ambiguities. The sequence of elements is arbitrary. The filter syntax assumes that there is no overlap between categories and tags. Otherwise, tags take priority. If you reply to the prompt with the empty string, all filtering is removed. If a filter is specified, it replaces all current filters. But if you call the command with a double prefix argument, or if you add an additional ‘+’ (e.g., ‘++work’) to the front of the string, the new filter elements are added to the active ones. A single prefix argument applies the entire filter in a negative sense.

| (org-agenda-filter-remove-all)
Remove all filters in the current agenda view.

Computed tag filtering
If the variable org-agenda-auto-exclude-function is set to a user-defined function, that function can select tags that should be used as a tag filter when requested. The function will be called with lower-case versions of all tags represented in the current view. The function should return ‘"-tag"’ if the filter should remove entries with that tag, ‘"+tag"’ if only entries with this tag should be kept, or ‘nil’ if that tag is irrelevant. For example, let’s say you use a ‘Net’ tag to identify tasks which need network access, an ‘Errand’ tag for errands in town, and a ‘Call’ tag for making phone calls. You could auto-exclude these tags based on the availability of the Internet, and outside of business hours, with something like this:

(defun my-auto-exclude-fn (tag)
  (when (cond ((string= tag "net")
               (/= 0 (call-process "/sbin/ping" nil nil nil
                                   "-c1" "-q" "-t1" "mail.gnu.org")))
              ((member tag '("errand" "call"))
               (let ((hr (nth 2 (decode-time))))
                 (or (< hr 8) (> hr 21)))))
    (concat "-" tag)))

(setq org-agenda-auto-exclude-function #'my-auto-exclude-fn)
You can apply this self-adapting filter by using a triple prefix argument to org-agenda-filter, i.e. press C-u C-u C-u /, or by pressing RET in org-agenda-filter-by-tag.

Setting limits for the agenda
Here is a list of options that you can set, either globally, or locally in your custom agenda views (see Custom Agenda Views).

org-agenda-max-entries
Limit the number of entries.

org-agenda-max-effort
Limit the duration of accumulated efforts (as minutes).

org-agenda-max-todos
Limit the number of entries with TODO keywords.

org-agenda-max-tags
Limit the number of tagged entries.

When set to a positive integer, each option excludes entries from other categories: for example, ‘(setq org-agenda-max-effort 100)’ limits the agenda to 100 minutes of effort and exclude any entry that has no effort property. If you want to include entries with no effort property, use a negative value for org-agenda-max-effort. One useful setup is to use org-agenda-max-entries locally in a custom command. For example, this custom command displays the next five entries with a ‘NEXT’ TODO keyword.

(setq org-agenda-custom-commands
      '(("n" todo "NEXT"
         ((org-agenda-max-entries 5)))))
Once you mark one of these five entry as DONE, rebuilding the agenda will again the next five entries again, including the first entry that was excluded so far.

You can also dynamically set temporary limits, which are lost when rebuilding the agenda:

~ (org-agenda-limit-interactively)
This prompts for the type of limit to apply and its value.

Footnotes
(97)
Custom agenda commands can preset a filter by binding one of the variables org-agenda-tag-filter-preset, org-agenda-category-filter-preset, org-agenda-effort-filter-preset or org-agenda-regexp-filter-preset as an option. This filter is then applied to the view and persists as a basic filter through refreshes and more secondary filtering. The filter is a global property of the entire agenda view—in a block agenda, you should only set this in the global options section, not in the section of an individual block.


**** Commands in the Agenda Buffer

Entries in the agenda buffer are linked back to the Org file or diary file where they originate. You are not allowed to edit the agenda buffer itself, but commands are provided to show and jump to the original entry location, and to edit the Org files “remotely” from the agenda buffer. In this way, all information is stored only once, removing the risk that your agenda and note files may diverge.

Some commands can be executed with mouse clicks on agenda lines. For the other commands, point needs to be in the desired line.

Motion
n (org-agenda-next-line)
Next line (same as DOWN and C-n).

p (org-agenda-previous-line)
Previous line (same as UP and C-p).

View/Go to Org file
SPC or mouse-3 (org-agenda-show-and-scroll-up)
Display the original location of the item in another window. With a prefix argument, make sure that drawers stay folded.

L (org-agenda-recenter)
Display original location and recenter that window.

TAB or mouse-2 (org-agenda-goto)
Go to the original location of the item in another window.

RET (org-agenda-switch-to)
Go to the original location of the item and delete other windows.

F (org-agenda-follow-mode)
Toggle Follow mode. In Follow mode, as you move point through the agenda buffer, the other window always shows the corresponding location in the Org file. The initial setting for this mode in new agenda buffers can be set with the variable org-agenda-start-with-follow-mode.

C-c C-x b (org-agenda-tree-to-indirect-buffer)
Display the entire subtree of the current item in an indirect buffer. With a numeric prefix argument N, go up to level N and then take that tree. If N is negative, go up that many levels. With a C-u prefix, do not remove the previously used indirect buffer.

C-c C-o (org-agenda-open-link)
Follow a link in the entry. This offers a selection of any links in the text belonging to the referenced Org node. If there is only one link, follow it without a selection prompt.

Change display
A
Interactively select another agenda view and append it to the current view.

o
Delete other windows.

v d or short d (org-agenda-day-view)
Switch to day view. When switching to day view, this setting becomes the default for subsequent agenda refreshes. A numeric prefix argument may be used to jump directly to a specific day of the year. For example, 32 d jumps to February 1st. When setting day view, a year may be encoded in the prefix argument as well. For example, 200712 d jumps to January 12, 2007. If such a year specification has only one or two digits, it is expanded into one of the 30 next years or the last 69 years.

v w or short w (org-agenda-week-view)
Switch to week view. When switching week view, this setting becomes the default for subsequent agenda refreshes. A numeric prefix argument may be used to jump directly to a specific day of the ISO week. For example 9 w to ISO week number 9. When setting week view, a year may be encoded in the prefix argument as well. For example, 200712 w jumps to week 12 in 2007. If such a year specification has only one or two digits, it is expanded into one of the 30 next years or the last 69 years.

v m (org-agenda-month-view)
Switch to month view. Because month views are slow to create, they do not become the default for subsequent agenda refreshes. A numeric prefix argument may be used to jump directly to a specific day of the month. When setting month view, a year may be encoded in the prefix argument as well. For example, 200712 m jumps to December, 2007. If such a year specification has only one or two digits, it is expanded into one of the 30 next years or the last 69 years.

v y (org-agenda-year-view)
Switch to year view. Because year views are slow to create, they do not become the default for subsequent agenda refreshes. A numeric prefix argument may be used to jump directly to a specific day of the year.

v SPC (org-agenda-reset-view)
Reset the current view to org-agenda-span.

f (org-agenda-later)
Go forward in time to display the span following the current one. For example, if the display covers a week, switch to the following week. With a prefix argument, repeat that many times.

b (org-agenda-earlier)
Go backward in time to display earlier dates.

. (org-agenda-goto-today)
Go to today.

j (org-agenda-goto-date)
Prompt for a date and go there.

J (org-agenda-clock-goto)
Go to the currently clocked-in task in the agenda buffer.

D (org-agenda-toggle-diary)
Toggle the inclusion of diary entries. See Weekly/daily agenda.

v l or v L or short l (org-agenda-log-mode)
Toggle Logbook mode. In Logbook mode, entries that were marked as done while logging was on (see the variable org-log-done) are shown in the agenda, as are entries that have been clocked on that day. You can configure the entry types that should be included in log mode using the variable org-agenda-log-mode-items. When called with a C-u prefix argument, show all possible logbook entries, including state changes. When called with two prefix arguments C-u C-u, show only logging information, nothing else. v L is equivalent to C-u v l.

v [ or short [ (org-agenda-manipulate-query-add)
Include inactive timestamps into the current view. Only for weekly/daily agenda.

v a (org-agenda-archives-mode)
Toggle Archives mode. In Archives mode, trees that are archived (see Internal archiving) are also scanned when producing the agenda. To exit archives mode, press v a again. The initial setting for this mode in new agenda buffers can set with the variable org-agenda-start-with-archives-mode, which can be set with the same values as org-agenda-archives-mode.

v A
Toggle Archives mode. Include all archive files as well.

v R or short R (org-agenda-clockreport-mode)
Toggle Clockreport mode. In Clockreport mode, the daily/weekly agenda always shows a table with the clocked times for the time span and file scope covered by the current agenda view. The initial setting for this mode in new agenda buffers can be set with the variable org-agenda-start-with-clockreport-mode. By using a prefix argument when toggling this mode (i.e., C-u R), the clock table does not show contributions from entries that are hidden by agenda filtering98. See also the variables org-clock-report-include-clocking-task and org-agenda-clock-report-header.

v c
Show overlapping clock entries, clocking gaps, and other clocking problems in the current agenda range. You can then visit clocking lines and fix them manually. See the variable org-agenda-clock-consistency-checks for information on how to customize the definition of what constituted a clocking problem. To return to normal agenda display, press l to exit Logbook mode.

v E or short E (org-agenda-entry-text-mode)
Toggle entry text mode. In entry text mode, a number of lines from the Org outline node referenced by an agenda line are displayed below the line. The maximum number of lines is given by the variable org-agenda-entry-text-maxlines. Calling this command with a numeric prefix argument temporarily modifies that number to the prefix value.

G (org-agenda-toggle-time-grid)
Toggle the time grid on and off. See also the variables org-agenda-use-time-grid and org-agenda-time-grid.

r (org-agenda-redo)
g
Recreate the agenda buffer, for example to reflect the changes after modification of the timestamps of items with S-LEFT and S-RIGHT. When the buffer is the global TODO list, a prefix argument is interpreted to create a selective list for a specific TODO keyword.

C-x C-s or short s (org-save-all-org-buffers)
Save all Org buffers in the current Emacs session, and also the locations of IDs.

C-c C-x C-c (org-agenda-columns)
Invoke column view (see Column View) in the agenda buffer. The column view format is taken from the entry at point, or, if there is no entry at point, from the first entry in the agenda view. So whatever the format for that entry would be in the original buffer (taken from a property, from a ‘COLUMNS’ keyword, or from the default variable org-columns-default-format) is used in the agenda.

C-c C-x > (org-agenda-remove-restriction-lock)
Remove the restriction lock on the agenda, if it is currently restricted to a file or subtree (see Agenda Files).

M-UP (org-agenda-drag-line-backward)
Drag the line at point backward one line. With a numeric prefix argument, drag backward by that many lines.

Moving agenda lines does not persist after an agenda refresh and does not modify the contributing Org files.

M-DOWN (org-agenda-drag-line-forward)
Drag the line at point forward one line. With a numeric prefix argument, drag forward by that many lines.

Remote editing
0--9
Digit argument.

C-_ (org-agenda-undo)
Undo a change due to a remote editing command. The change is undone both in the agenda buffer and in the remote buffer.

t (org-agenda-todo)
Change the TODO state of the item, both in the agenda and in the original Org file. A prefix arg is passed through to the org-todo command, so for example a C-u prefix are will trigger taking a note to document the state change.

C-S-RIGHT (org-agenda-todo-nextset)
Switch to the next set of TODO keywords.

C-S-LEFT, org-agenda-todo-previousset
Switch to the previous set of TODO keywords.

C-k (org-agenda-kill)
Delete the current agenda item along with the entire subtree belonging to it in the original Org file. If the text to be deleted remotely is longer than one line, the kill needs to be confirmed by the user. See variable org-agenda-confirm-kill.

C-c C-w (org-agenda-refile)
Refile the entry at point.

C-c C-x C-a or short a (org-agenda-archive-default-with-confirmation)
Archive the subtree corresponding to the entry at point using the default archiving command set in org-archive-default-command. When using the a key, confirmation is required.

C-c C-x a (org-agenda-toggle-archive-tag)
Toggle the archive tag (see Internal archiving) for the current headline.

C-c C-x A (org-agenda-archive-to-archive-sibling)
Move the subtree corresponding to the current entry to its archive sibling.

C-c C-x C-s or short $ (org-agenda-archive)
Archive the subtree corresponding to the current headline. This means the entry is moved to the configured archive location, most likely a different file.

T (org-agenda-show-tags)
Show all tags associated with the current item. This is useful if you have turned off org-agenda-show-inherited-tags, but still want to see all tags of a headline occasionally.

: (org-agenda-set-tags)
Set tags for the current headline. If there is an active region in the agenda, change a tag for all headings in the region.

, (org-agenda-priority)
Set the priority for the current item. Org mode prompts for the priority character. If you reply with SPC, the priority cookie is removed from the entry.

+ or S-UP (org-agenda-priority-up)
Increase the priority of the current item. The priority is changed in the original buffer, but the agenda is not resorted. Use the r key for this.

- or S-DOWN (org-agenda-priority-down)
Decrease the priority of the current item.

C-c C-x e or short e (org-agenda-set-effort)
Set the effort property for the current item.

C-c C-z or short z (org-agenda-add-note)
Add a note to the entry. This note is recorded, and then filed to the same location where state change notes are put. Depending on org-log-into-drawer, this may be inside a drawer.

C-c C-a (org-attach)
Dispatcher for all command related to attachments.

C-c C-s (org-agenda-schedule)
Schedule this item. With a prefix argument, remove the scheduling timestamp

C-c C-d (org-agenda-deadline)
Set a deadline for this item. With a prefix argument, remove the deadline.

S-RIGHT (org-agenda-do-date-later)
Change the timestamp associated with the current line by one day into the future. If the date is in the past, the first call to this command moves it to today. With a numeric prefix argument, change it by that many days. For example, 3 6 5 S-RIGHT changes it by a year. With a C-u prefix, change the time by one hour. If you immediately repeat the command, it will continue to change hours even without the prefix argument. With a double C-u C-u prefix, do the same for changing minutes. The stamp is changed in the original Org file, but the change is not directly reflected in the agenda buffer. Use r or g to update the buffer.

S-LEFT (org-agenda-do-date-earlier)
Change the timestamp associated with the current line by one day into the past.

> (org-agenda-date-prompt)
Change the timestamp associated with the current line. The key > has been chosen, because it is the same as S-. on my keyboard.

I (org-agenda-clock-in)
Start the clock on the current item. If a clock is running already, it is stopped first.

O (org-agenda-clock-out)
Stop the previously started clock.

X (org-agenda-clock-cancel)
Cancel the currently running clock.

J (org-agenda-clock-goto)
Jump to the running clock in another window.

k (org-agenda-capture)
Like org-capture, but use the date at point as the default date for the capture template. See org-capture-use-agenda-date to make this the default behavior of org-capture.

Bulk remote editing selected entries
m (org-agenda-bulk-mark)
Mark the entry at point for bulk action. If there is an active region in the agenda, mark the entries in the region. With numeric prefix argument, mark that many successive entries.

 (org-agenda-bulk-mark-all)
Mark all visible agenda entries for bulk action.

u (org-agenda-bulk-unmark)
Unmark entry for bulk action.

U (org-agenda-bulk-unmark-all)
Unmark all marked entries for bulk action.

M-m (org-agenda-bulk-toggle)
Toggle mark of the entry at point for bulk action.

M-* (org-agenda-bulk-toggle-all)
Toggle mark of every entry for bulk action.

% (org-agenda-bulk-mark-regexp)
Mark entries matching a regular expression for bulk action.

B (org-agenda-bulk-action)
Bulk action: act on all marked entries in the agenda. This prompts for another key to select the action to be applied. The prefix argument to B is passed through to the s and d commands, to bulk-remove these special timestamps. By default, marks are removed after the bulk. If you want them to persist, set org-agenda-bulk-persistent-marks to t or hit p at the prompt.

p
Toggle persistent marks.

$
Archive all selected entries.

A
Archive entries by moving them to their respective archive siblings.

t
Change TODO state. This prompts for a single TODO keyword and changes the state of all selected entries, bypassing blocking and suppressing logging notes—but not timestamps.

+
Add a tag to all selected entries.

-
Remove a tag from all selected entries.

s
Schedule all items to a new date. To shift existing schedule dates by a fixed number of days, use something starting with double plus at the prompt, for example ‘++8d’ or ‘++2w’.

d
Set deadline to a specific date.

r
Prompt for a single refile target and move all entries. The entries are no longer in the agenda; refresh (g) to bring them back.

S
Reschedule randomly into the coming N days. N is prompted for. With a prefix argument (C-u B S), scatter only across weekdays.

f
Apply a function99 to marked entries. For example, the function below sets the ‘CATEGORY’ property of the entries to ‘web’.

(defun set-category ()
  (interactive "P")
  (let ((marker (or (org-get-at-bol 'org-hd-marker)
                    (org-agenda-error))))
    (org-with-point-at marker
      (org-back-to-heading t)
      (org-set-property "CATEGORY" "web"))))
Calendar commands
c (org-agenda-goto-calendar)
Open the Emacs calendar and go to the date at point in the agenda.

c (org-calendar-goto-agenda)
When in the calendar, compute and show the Org agenda for the date at point.

i (org-agenda-diary-entry)
Insert a new entry into the diary, using the date at point and (for block entries) the date at the mark. This adds to the Emacs diary file100, in a way similar to the i command in the calendar. The diary file pops up in another window, where you can add the entry.

If you configure org-agenda-diary-file to point to an Org file, Org creates entries in that file instead. Most entries are stored in a date-based outline tree that will later make it easy to archive appointments from previous months/years. The tree is built under an entry with a ‘DATE_TREE’ property, or else with years as top-level entries. Emacs prompts you for the entry text—if you specify it, the entry is created in org-agenda-diary-file without further interaction. If you directly press RET at the prompt without typing text, the target file is shown in another window for you to finish the entry there. See also the k r command.

M (org-agenda-phases-of-moon)
Show the phases of the moon for the three months around current date.

S (org-agenda-sunrise-sunset)
Show sunrise and sunset times. The geographical location must be set with calendar variables, see the documentation for the Emacs calendar.

C (org-agenda-convert-date)
Convert the date at point into many other cultural and historic calendars.

H (org-agenda-holidays)
Show holidays for three months around point date.

Quit and exit
q (org-agenda-quit)
Quit agenda, remove the agenda buffer.

x (org-agenda-exit)
Exit agenda, remove the agenda buffer and all buffers loaded by Emacs for the compilation of the agenda. Buffers created by the user to visit Org files are not removed.

Footnotes
(98)
Only tags filtering is respected here, effort filtering is ignored.

(99)
You can also create persistent custom functions through org-agenda-bulk-custom-functions.

(100)
This file is parsed for the agenda when org-agenda-include-diary is set.


**** Custom Agenda Views

Custom agenda commands serve two purposes: to store and quickly access frequently used TODO and tags searches, and to create special composite agenda buffers. Custom agenda commands are accessible through the dispatcher (see The Agenda Dispatcher), just like the default commands.

***** Storing searches

The first application of custom searches is the definition of keyboard shortcuts for frequently used searches, either creating an agenda buffer, or a sparse tree (the latter covering of course only the current buffer).

Custom commands are configured in the variable org-agenda-custom-commands. You can customize this variable, for example by pressing C from the agenda dispatcher (see The Agenda Dispatcher). You can also directly set it with Emacs Lisp in the Emacs init file. The following example contains all valid agenda views:

(setq org-agenda-custom-commands
      '(("x" agenda)
        ("y" agenda*)
        ("w" todo "WAITING")
        ("W" todo-tree "WAITING")
        ("u" tags "+boss-urgent")
        ("v" tags-todo "+boss-urgent")
        ("U" tags-tree "+boss-urgent")
        ("f" occur-tree "\\<FIXME\\>")
        ("h" . "HOME+Name tags searches") ;description for "h" prefix
        ("hl" tags "+home+Lisa")
        ("hp" tags "+home+Peter")
        ("hk" tags "+home+Kim")))
The initial string in each entry defines the keys you have to press after the dispatcher command in order to access the command. Usually this is just a single character, but if you have many similar commands, you can also define two-letter combinations where the first character is the same in several combinations and serves as a prefix key101. The second parameter is the search type, followed by the string or regular expression to be used for the matching. The example above will therefore define:

x
as a global search for agenda entries planned102 this week/day.

y
as the same search, but only for entries with an hour specification like ‘[h]h:mm’—think of them as appointments.

w
as a global search for TODO entries with ‘WAITING’ as the TODO keyword.

W
as the same search, but only in the current buffer and displaying the results as a sparse tree.

u
as a global tags search for headlines tagged ‘boss’ but not ‘urgent’.

v
The same search, but limiting it to headlines that are also TODO items.

U
as the same search, but only in the current buffer and displaying the result as a sparse tree.

f
to create a sparse tree (again, current buffer only) with all entries containing the word ‘FIXME’.

h
as a prefix command for a ‘HOME’ tags search where you have to press an additional key (l, p or k) to select a name (Lisa, Peter, or Kim) as additional tag to match.

Note that *-tree agenda views need to be called from an Org buffer as they operate on the current buffer only.

Footnotes
(101)
You can provide a description for a prefix key by inserting a cons cell with the prefix and the description.

(102)
Planned means here that these entries have some planning information attached to them, like a timestamp, a scheduled or a deadline string. See org-agenda-entry-types on how to set what planning information is taken into account.


***** Block agenda

Another possibility is the construction of agenda views that comprise the results of several commands, each of which creates a block in the agenda buffer. The available commands include agenda for the daily or weekly agenda (as created with a) , alltodo for the global TODO list (as constructed with t), stuck for the list of stuck projects (as obtained with #) and the matching commands discussed above: todo, tags, and tags-todo.

Here are two examples:

(setq org-agenda-custom-commands
      '(("h" "Agenda and Home-related tasks"
         ((agenda "")
          (tags-todo "home")
          (tags "garden")))
        ("o" "Agenda and Office-related tasks"
         ((agenda "")
          (tags-todo "work")
          (tags "office")))))
This defines h to create a multi-block view for stuff you need to attend to at home. The resulting agenda buffer contains your agenda for the current week, all TODO items that carry the tag ‘home’, and also all lines tagged with ‘garden’. Finally the command o provides a similar view for office tasks.


***** Setting options for custom commands

Org mode contains a number of variables regulating agenda construction and display. The global variables define the behavior for all agenda commands, including the custom commands. However, if you want to change some settings just for a single custom view, you can do so. Setting options requires inserting a list of variable names and values at the right spot in org-agenda-custom-commands. For example:

(setq org-agenda-custom-commands
      '(("w" todo "WAITING"
         ((org-agenda-sorting-strategy '(priority-down))
          (org-agenda-prefix-format "  Mixed: ")))
        ("U" tags-tree "+boss-urgent"
         ((org-show-context-detail 'minimal)))
        ("N" search ""
         ((org-agenda-files '("~org/notes.org"))
          (org-agenda-text-search-extra-files nil)))))
Now the w command sorts the collected entries only by priority, and the prefix format is modified to just say ‘Mixed:’ instead of giving the category of the entry. The sparse tags tree of U now turns out ultra-compact, because neither the headline hierarchy above the match, nor the headline following the match are shown. The command N does a text search limited to only a single file.

For command sets creating a block agenda, org-agenda-custom-commands has two separate spots for setting options. You can add options that should be valid for just a single command in the set, and options that should be valid for all commands in the set. The former are just added to the command entry; the latter must come after the list of command entries. Going back to the block agenda example (see Block agenda), let’s change the sorting strategy for the h commands to priority-down, but let’s sort the results for ‘garden’ tags query in the opposite order, priority-up. This would look like this:

(setq org-agenda-custom-commands
      '(("h" "Agenda and Home-related tasks"
         ((agenda)
          (tags-todo "home")
          (tags "garden"
                ((org-agenda-sorting-strategy '(priority-up)))))
         ((org-agenda-sorting-strategy '(priority-down))))
        ("o" "Agenda and Office-related tasks"
         ((agenda)
          (tags-todo "work")
          (tags "office")))))
As you see, the values and parentheses setting is a little complex. When in doubt, use the customize interface to set this variable—it fully supports its structure. Just one caveat: when setting options in this interface, the values are just Lisp expressions. So if the value is a string, you need to add the double-quotes around the value yourself.

To control whether an agenda command should be accessible from a specific context, you can customize org-agenda-custom-commands-contexts. Let’s say for example that you have an agenda command o displaying a view that you only need when reading emails. Then you would configure this option like this:

(setq org-agenda-custom-commands-contexts
      '(("o" (in-mode . "message-mode"))))
You can also tell that the command key o should refer to another command key r. In that case, add this command key like this:

(setq org-agenda-custom-commands-contexts
      '(("o" "r" (in-mode . "message-mode"))))
See the docstring of the variable for more information.

**** Exporting Agenda Views

If you are away from your computer, it can be very useful to have a printed version of some agenda views to carry around. Org mode can export custom agenda views as plain text, HTML103, Postscript, PDF104, and iCalendar files. If you want to do this only occasionally, use the following command:

C-x C-w (org-agenda-write)
Write the agenda view to a file.

If you need to export certain agenda views frequently, you can associate any custom agenda command with a list of output file names105. Here is an example that first defines custom commands for the agenda and the global TODO list, together with a number of files to which to export them. Then we define two block agenda commands and specify file names for them as well. File names can be relative to the current working directory, or absolute.

(setq org-agenda-custom-commands
      '(("X" agenda "" nil ("agenda.html" "agenda.ps"))
        ("Y" alltodo "" nil ("todo.html" "todo.txt" "todo.ps"))
        ("h" "Agenda and Home-related tasks"
         ((agenda "")
          (tags-todo "home")
          (tags "garden"))
         nil
         ("~/views/home.html"))
        ("o" "Agenda and Office-related tasks"
         ((agenda)
          (tags-todo "work")
          (tags "office"))
         nil
         ("~/views/office.ps" "~/calendars/office.ics"))))
The extension of the file name determines the type of export. If it is ‘.html’, Org mode uses the htmlize package to convert the buffer to HTML and save it to this file name. If the extension is ‘.ps’, ps-print-buffer-with-faces is used to produce Postscript output. If the extension is ‘.ics’, iCalendar export is run export over all files that were used to construct the agenda, and limit the export to entries listed in the agenda. Any other extension produces a plain ASCII file.

The export files are not created when you use one of those commands interactively because this might use too much overhead. Instead, there is a special command to produce all specified files in one step:

e (org-store-agenda-views)
Export all agenda views that have export file names associated with them.

You can use the options section of the custom agenda commands to also set options for the export commands. For example:

(setq org-agenda-custom-commands
      '(("X" agenda ""
         ((ps-number-of-columns 2)
          (ps-landscape-mode t)
          (org-agenda-prefix-format " [ ] ")
          (org-agenda-with-colors nil)
          (org-agenda-remove-tags t))
         ("theagenda.ps"))))
This command sets two options for the Postscript exporter, to make it print in two columns in landscape format—the resulting page can be cut in two and then used in a paper agenda. The remaining settings modify the agenda prefix to omit category and scheduling information, and instead include a checkbox to check off items. We also remove the tags to make the lines compact, and we do not want to use colors for the black-and-white printer. Settings specified in org-agenda-exporter-settings also apply, e.g.,

(setq org-agenda-exporter-settings
      '((ps-number-of-columns 2)
        (ps-landscape-mode t)
        (org-agenda-add-entry-text-maxlines 5)
        (htmlize-output-type 'css)))
but the settings in org-agenda-custom-commands take precedence.

From the command line you may also use:

emacs -eval (org-batch-store-agenda-views) -kill
or, if you need to modify some parameters106

emacs -eval '(org-batch-store-agenda-views                      \
              org-agenda-span (quote month)                     \
              org-agenda-start-day "2007-11-01"                 \
              org-agenda-include-diary nil                      \
              org-agenda-files (quote ("~/org/project.org")))'  \
      -kill
which creates the agenda views restricted to the file ‘~/org/project.org’, without diary entries and with a 30-day extent.

You can also extract agenda information in a way that allows further processing by other programs. See Extracting Agenda Information, for more information.

Footnotes
(103)
For HTML you need to install Hrvoje Nikšić’s ‘htmlize.el’ as an Emacs package from NonGNU ELPA or from Hrvoje Nikšić’s repository.

(104)
To create PDF output, the Ghostscript ps2pdf utility must be installed on the system. Selecting a PDF file also creates the postscript file.

(105)
If you want to store standard views like the weekly agenda or the global TODO list as well, you need to define custom commands for them in order to be able to specify file names.

(106)
Quoting depends on the system you use, please check the FAQ for examples.


**** Using Column View in the Agenda

Column view (see Column View) is normally used to view and edit properties embedded in the hierarchical structure of an Org file. It can be quite useful to use column view also from the agenda, where entries are collected by certain criteria.

C-c C-x C-c (org-agenda-columns)
Turn on column view in the agenda.

To understand how to use this properly, it is important to realize that the entries in the agenda are no longer in their proper outline environment. This causes the following issues:

Org needs to make a decision which columns format to use. Since the entries in the agenda are collected from different files, and different files may have different columns formats, this is a non-trivial problem. Org first checks if org-overriding-columns-format is currently set, and if so, takes the format from there. You should set this variable only in the local settings section of a custom agenda command (see Custom Agenda Views) to make it valid for that specific agenda view. If no such binding exists, it checks, in sequence, org-columns-default-format-for-agenda, the format associated with the first item in the agenda (through a property or a ‘#+COLUMNS’ setting in that buffer) and finally org-columns-default-format.
If any of the columns has a summary type defined (see Column attributes), turning on column view in the agenda visits all relevant agenda files and make sure that the computations of this property are up to date. This is also true for the special ‘CLOCKSUM’ property. Org then sums the values displayed in the agenda. In the daily/weekly agenda, the sums cover a single day; in all other views they cover the entire block.
It is important to realize that the agenda may show the same entry twice—for example as scheduled and as a deadline—and it may show two entries from the same hierarchy (for example a parent and its child). In these cases, the summation in the agenda leads to incorrect results because some values count double.

When the column view in the agenda shows the ‘CLOCKSUM’ property, that is always the entire clocked time for this item. So even in the daily/weekly agenda, the clocksum listed in column view may originate from times outside the current view. This has the advantage that you can compare these values with a column listing the planned total effort for a task—one of the major applications for column view in the agenda. If you want information about clocked time in the displayed period use clock table mode (press R in the agenda).
When the column view in the agenda shows the ‘CLOCKSUM_T’ property, that is always today’s clocked time for this item. So even in the weekly agenda, the clocksum listed in column view only originates from today. This lets you compare the time you spent on a task for today, with the time already spent—via ‘CLOCKSUM’—and with the planned total effort for it.


*** Markup for Rich Contents

Org is primarily about organizing and searching through your plain-text notes. However, it also provides a lightweight yet robust markup language for rich text formatting and more. For instance, you may want to center or emphasize text. Or you may need to insert a formula or image in your writing. Org offers syntax for all of this and more. Used in conjunction with the export framework (see Exporting), you can author beautiful documents in Org—like the fine manual you are currently reading.

**** Paragraphs

Paragraphs are separated by at least one empty line. If you need to enforce a line break within a paragraph, use ‘\\’ at the end of a line.

To preserve the line breaks, indentation and blank lines in a region, but otherwise use normal formatting, you can use this construct, which can also be used to format poetry.

#+BEGIN_VERSE
 Great clouds overhead
 Tiny black birds rise and fall
 Snow covers Emacs

    ---AlexSchroeder
#+END_VERSE
When quoting a passage from another document, it is customary to format this as a paragraph that is indented on both the left and the right margin. You can include quotations in Org documents like this:

#+BEGIN_QUOTE
Everything should be made as simple as possible,
but not any simpler ---Albert Einstein
#+END_QUOTE
If you would like to center some text, do it like this:

#+BEGIN_CENTER
Everything should be made as simple as possible, \\
but not any simpler
#+END_CENTER


**** Emphasis and Monospace

You can make words ‘*bold*’, ‘/italic/’, ‘_underlined_’, ‘=verbatim=’ and ‘~code~’, and, if you must, ‘+strike-through+’. Text in the code and verbatim string is not processed for Org specific syntax; it is exported verbatim. Org provides a single command as entry point for inserting the marker character.

C-c C-x C-f (org-emphasize)
Prompt for a marker character and insert or change an emphasis. If there is an active region, change that region to a new emphasis. If there is no region, just insert the marker characters and position the cursor between them.

To turn off fontification for marked up text, you can set org-fontify-emphasized-text to nil. To narrow down the list of the fontified markup syntax, you can customize org-emphasis-alist107.

To hide the emphasis markup characters in your buffers, set org-hide-emphasis-markers to t.

Sometimes, when marked text also contains the marker character itself, the result may be unsettling. For example,

/One may expect this whole sentence to be italicized, but the
following ~user/?variable~ contains =/= character, which effectively
stops emphasis there./
You can use zero width space to help Org sorting out the ambiguity. See Escape Character for more details.

Footnotes
(107)
The markup will still be recognized. Just not highlighted visually in Emacs.


**** Subscripts and Superscripts

‘^’ and ‘_’ are used to indicate super- and subscripts. To increase the readability of ASCII text, it is not necessary, but OK, to surround multi-character sub- and superscripts with curly braces. For example

The radius of the sun is R_sun = 6.96 x 10^8 m.  On the other hand,
the radius of Alpha Centauri is R_{Alpha Centauri} = 1.28 x R_{sun}.
If you write a text where the underscore is often used in a different context, Org’s convention to always interpret these as subscripts can get in your way. Configure the variable org-use-sub-superscripts and/or org-export-with-sub-superscripts to change this convention. For example, when setting these variables to {}, ‘a_b’ is not displayed/exported108 as a subscript, but ‘a_{b}’ is.

You can set both org-use-sub-superscripts org-export-with-sub-superscripts in a file using the export option ‘^:’ (see Export Settings). For example, ‘#+OPTIONS: ^:{}’ sets the two options to {} and limits super- and subscripts to the curly bracket notation.

You can also toggle the visual display of super- and subscripts:

C-c C-x \ (org-toggle-pretty-entities)
This command formats sub- and superscripts in a WYSIWYM way.

Set both org-pretty-entities and org-pretty-entities-include-sub-superscripts to t to start with super- and subscripts visually interpreted as specified by the option org-use-sub-superscripts.

Footnotes
(108)
The underlying markup still remains a sub/superscript. Only the visual display and export behavior changes.


**** Special Symbols

You can use LaTeX-like syntax to insert special symbols—named entities—like ‘\alpha’ to indicate the Greek letter, or ‘\to’ to indicate an arrow. Completion for these symbols is available, just type ‘\’ and maybe a few letters, and press M-TAB to see possible completions. If you need such a symbol inside a word, terminate it with a pair of curly brackets. For example

Pro tip: Given a circle \Gamma of diameter d, the length of its
circumference is \pi{}d.
A large number of entities is provided, with names taken from both HTML and LaTeX; you can comfortably browse the complete list from a dedicated buffer using the command org-entities-help. It is also possible to provide your own special symbols in the variable org-entities-user.

During export, these symbols are transformed into the native format of the exporter backend. Strings like ‘\alpha’ are exported as ‘&alpha;’ in the HTML output, and as ‘\(\alpha\)’ in the LaTeX output. Similarly, ‘\nbsp’ becomes ‘&nbsp;’ in HTML and ‘~’ in LaTeX.

If you would like to see entities displayed as UTF-8 characters, use the following command109:

C-c C-x \ (org-toggle-pretty-entities)
Toggle display of entities as UTF-8 characters. This does not change the buffer content which remains plain ASCII, but it overlays the UTF-8 character for display purposes only.

In addition to regular entities defined above, Org exports in a special way110 the following commonly used character combinations: ‘\-’ is treated as a shy hyphen, ‘--’ and ‘---’ are converted into dashes, and ‘...’ becomes a compact set of dots.

Footnotes
(109)
You can turn this on by default by setting the variable org-pretty-entities, or on a per-file base with the ‘STARTUP’ option ‘entitiespretty’.

(110)
This behavior can be disabled with ‘-’ export setting (see Export Settings).


**** Embedded LaTeX

Plain ASCII is normally sufficient for almost all note taking. Exceptions include scientific notes, which often require mathematical symbols and the occasional formula. LaTeX111 is widely used to typeset scientific documents. Org mode supports embedding LaTeX code into its files, because many academics are used to writing and reading LaTeX source code, and because it can be readily processed to produce pretty output for a number of export backends.

***** LaTeX fragments

Org mode can contain LaTeX math fragments, and it supports ways to process these for several export backends. When exporting to LaTeX, the code is left as it is. When exporting to HTML, Org can use either MathJax (see Math formatting in HTML export) or transcode the math into images (see Previewing LaTeX fragments).

LaTeX fragments do not need any special marking at all. The following snippets are identified as LaTeX source code:

Environments of any kind112. The only requirement is that the ‘\begin’ statement appears on a new line, preceded by only whitespace.
Text within the usual LaTeX math delimiters. Prefer ‘\(...\)’ for inline fragments. The ‘$...$’ alternative has some restrictions and may be a source of confusion. To avoid conflicts with currency specifications, single ‘$’ characters are only recognized as math delimiters if the enclosed text contains at most two line breaks, is directly attached to the ‘$’ characters with no whitespace in between, and if the closing ‘$’ is followed by whitespace or punctuation (but not a dash).
Sometimes, it may necessary to have a literal dollar symbol even when it is recognized as LaTeX math delimiter. Org provides ‘\dollar’ and ‘\USD’ entities (see Special Symbols) that are rendered as ‘$’ for such scenarios. Also, see Escape Character.

For example:

\begin{equation}                        % arbitrary environments,
x=\sqrt{b}                              % even tables, figures, etc
\end{equation}

If $a^2=b$ and \( b=2 \), then the solution must be
either $$ a=+\sqrt{2} $$ or \[ a=-\sqrt{2} \].
LaTeX processing can be configured with the variable org-export-with-latex. The default setting is t which means MathJax for HTML, and no processing for ASCII and LaTeX backends. You can also set this variable on a per-file basis using one of these lines:

‘#+OPTIONS: tex:t’	Do the right thing automatically (MathJax)
‘#+OPTIONS: tex:nil’	Do not process LaTeX fragments at all
‘#+OPTIONS: tex:verbatim’	Verbatim export, for jsMath or so
Footnotes
(112)
When MathJax is used, only the environments recognized by MathJax are processed. When dvipng, dvisvgm, or ImageMagick suite is used to create images, any LaTeX environment is handled.


***** Previewing LaTeX fragments

If you have a working LaTeX installation and ‘dvipng’, ‘dvisvgm’ or ‘convert’ installed113, LaTeX fragments can be processed to produce images of the typeset expressions to be used for inclusion while exporting to HTML (see LaTeX fragments), or for inline previewing within Org mode.

You can customize the variables org-format-latex-options and org-format-latex-header to influence some aspects of the preview. In particular, the :scale (and for HTML export, :html-scale) property of the former can be used to adjust the size of the preview images.

C-c C-x C-l (org-latex-preview)
Produce a preview image of the LaTeX fragment at point and overlay it over the source code. If there is no fragment at point, process all fragments in the current entry—between two headlines.

When called with a single prefix argument, clear all images in the current entry. Two prefix arguments produce a preview image for all fragments in the buffer, while three of them clear all the images in that buffer.

You can turn on the previewing of all LaTeX fragments in a file with

#+STARTUP: latexpreview
To disable it, simply use

#+STARTUP: nolatexpreview
Footnotes
(113)
These are respectively available at https://sourceforge.net/projects/dvipng/, http://dvisvgm.bplaced.net/ and from the ImageMagick suite. Choose the converter by setting the variable org-preview-latex-default-process accordingly.


***** Using CDLaTeX to enter math

CDLaTeX mode is a minor mode that is normally used in combination with a major LaTeX mode like AUCTeX in order to speed-up insertion of environments and math templates. Inside Org mode, you can make use of some of the features of CDLaTeX mode. You need to install ‘cdlatex.el’ and ‘texmathp.el’ (the latter comes also with AUCTeX) from NonGNU ELPA with the Emacs packaging system or alternatively from https://staff.fnwi.uva.nl/c.dominik/Tools/cdlatex/. Do not use CDLaTeX mode itself under Org mode, but use the special version Org CDLaTeX minor mode that comes as part of Org. Turn it on for the current buffer with M-x org-cdlatex-mode, or for all Org files with

(add-hook 'org-mode-hook #'turn-on-org-cdlatex)
When this mode is enabled, the following features are present (for more details see the documentation of CDLaTeX mode):

C-c {
Insert an environment template.

TAB
The TAB key expands the template if point is inside a LaTeX fragment114. For example, TAB expands ‘fr’ to ‘\frac{}{}’ and position point correctly inside the first brace. Another TAB gets you into the second brace.

Even outside fragments, TAB expands environment abbreviations at the beginning of a line. For example, if you write ‘equ’ at the beginning of a line and press TAB, this abbreviation is expanded to an ‘equation’ environment. To get a list of all abbreviations, type M-x cdlatex-command-help.

^
_
Pressing _ and ^ inside a LaTeX fragment inserts these characters together with a pair of braces. If you use TAB to move out of the braces, and if the braces surround only a single character or macro, they are removed again (depending on the variable cdlatex-simplify-sub-super-scripts).

`
Pressing the backquote followed by a character inserts math macros, also outside LaTeX fragments. If you wait more than 1.5 seconds after the backquote, a help window pops up.

'
Pressing the single-quote followed by another character modifies the LaTeX symbol before point with an accent or a font. If you wait more than 1.5 seconds after the single-quote, a help window pops up. Character modification works only inside LaTeX fragments; outside the quote is normal.

Footnotes
(114)
Org mode has a method to test if point is inside such a fragment, see the documentation of the function org-inside-LaTeX-fragment-p.


**** Literal Examples

You can include literal examples that should not be subjected to markup. Such examples are typeset in monospace, so this is well suited for source code and similar examples.

#+BEGIN_EXAMPLE
  Some example from a text file.
#+END_EXAMPLE
There is one limitation, however. You must insert a comma right before lines starting with either ‘*’, ‘,*’, ‘#+’ or ‘,#+’, as those may be interpreted as outlines nodes or some other special syntax. Org transparently strips these additional commas whenever it accesses the contents of the block.

#+BEGIN_EXAMPLE
,* I am no real headline
#+END_EXAMPLE
For simplicity when using small examples, you can also start the example lines with a colon followed by a space. There may also be additional whitespace before the colon:

Here is an example
   : Some example from a text file.
If the example is source code from a programming language, or any other text that can be marked up by Font Lock in Emacs, you can ask for the example to look like the fontified Emacs buffer115. This is done with the code block, where you also need to specify the name of the major mode that should be used to fontify the example116, see Structure Templates for shortcuts to easily insert code blocks.

#+BEGIN_SRC emacs-lisp
  (defun org-xor (a b)
    "Exclusive or."
    (if a (not b) b))
#+END_SRC
Both in ‘example’ and in ‘src’ snippets, you can add a ‘-n’ switch to the ‘#+BEGIN’ line117, to get the lines of the example numbered. The ‘-n’ takes an optional numeric argument specifying the starting line number of the block. If you use a ‘+n’ switch, the numbering from the previous numbered snippet is continued in the current one. The ‘+n’ switch can also take a numeric argument. This adds the value of the argument to the last line of the previous block to determine the starting line number.

#+BEGIN_SRC emacs-lisp -n 20
  ;; This exports with line number 20.
  (message "This is line 21")
#+END_SRC

#+BEGIN_SRC emacs-lisp +n 10
  ;; This is listed as line 31.
  (message "This is line 32")
#+END_SRC
In literal examples, Org interprets strings like ‘(ref:name)’ as labels, and use them as targets for special hyperlinks like ‘[[(name)]]’—i.e., the reference name enclosed in single parentheses. In HTML, hovering the mouse over such a link remote-highlights the corresponding code line118, which is kind of cool.

You can also add a ‘-r’ switch which removes the labels from the source code119. With the ‘-n’ switch, links to these references are labeled by the line numbers from the code listing. Otherwise links use the labels with no parentheses. Here is an example:

#+BEGIN_SRC emacs-lisp -n -r
  (save-excursion                 (ref:sc)
     (goto-char (point-min))      (ref:jump)
#+END_SRC
In line [[(sc)]] we remember the current position. [[(jump)][Line (jump)]]
jumps to point-min.
Source code and examples may be indented in order to align nicely with the surrounding text, and in particular with plain list structure (see Plain Lists). By default, Org only retains the relative indentation between lines, e.g., when exporting the contents of the block. However, you can use the ‘-i’ switch to also preserve the global indentation, if it does matter. See Editing Source Code.

If the syntax for the label format conflicts with the language syntax, use a ‘-l’ switch to change the format, for example

#+BEGIN_SRC pascal -n -r -l "((%s))"
See also the variable org-coderef-label-format.

HTML export also allows examples to be published as text areas (see Text areas in HTML export).

Because the ‘#+BEGIN’ … ‘#+END’ patterns need to be added so often, a shortcut is provided (see Structure Templates).

C-c ' (org-edit-special)
Edit the source code example at point in its native mode. This works by switching to a temporary buffer with the source code. You need to exit by pressing C-c ' again. The edited version then replaces the old version in the Org buffer. Fixed-width regions—where each line starts with a colon followed by a space—are edited using Artist mode120 to allow creating ASCII drawings easily. Using this command in an empty line creates a new fixed-width region.

Calling org-store-link (see Handling Links) while editing a source code example in a temporary buffer created with C-c ' prompts for a label. Make sure that it is unique in the current buffer, and insert it with the proper formatting like ‘(ref:label)’ at the end of the current line. Then the label is stored as a link ‘(label)’, for retrieval with C-c C-l.

Footnotes
(115)
This works automatically for the HTML backend (it requires version 1.34 of the ‘htmlize.el’ package, which you need to install). Fontified code chunks in LaTeX can be achieved using either the listings LaTeX package, minted LaTeX package, or by using engrave-faces . Refer to org-latex-src-block-backend for details.

(116)
Source code in code blocks may also be evaluated either interactively or on export. See Working with Source Code for more information on evaluating code blocks.

(117)
In the ‘src’ snippets, switches must be placed right after the language name and before the header arguments

(118)
This requires some Javascript which is not automatically included in the HTML output: you have to customize the variable ‘org-html-head-include-scripts’ to t to have it included (it is nil by default).

(119)
Adding ‘-k’ to ‘-n -r’ keeps the labels in the source code while using line numbers for the links, which might be useful to explain those in an Org mode example code.

(120)
You may select a different mode with the variable org-edit-fixed-width-region-mode.


**** Images

An image is a link to an image file121 that does not have a description part, for example

./img/cat.jpg
If you wish to define a caption for the image (see Captions) and maybe a label for internal cross-references (see Internal Links), make sure that the link is on a line by itself and precede it with ‘CAPTION’ and ‘NAME’ keywords as follows:

#+CAPTION: This is the caption for the next figure link (or table)
#+NAME:   fig:SED-HR4049
[[./img/a.jpg]]
Such images can be displayed within the buffer with the following command:

C-c C-x C-v (org-toggle-inline-images)
Toggle the inline display of linked images. When called with a prefix argument, also display images that do have a link description. You can ask for inline images to be displayed at startup by configuring the variable org-startup-with-inline-images122.

By default, Org mode displays inline images according to their actual width, but no wider than fill-column characters.

You can customize the displayed image width using org-image-actual-width variable (globally) or ‘ORG-IMAGE-ACTUAL-WIDTH’ property (subtree-level)123. Their value can be the following:

(default) Non-nil, use the actual width of images when inlining them. If the actual width is too wide, limit it according to org-image-max-width.
When set to a number, use imagemagick (when available) to set the image’s width to this value.
When set to a number in a list, try to get the width from any ‘#+ATTR.*’ keyword if it matches a width specification like:
#+ATTR_HTML: :width 300px
and fall back on that number if none is found.

When set to nil, try to get the width from an ‘#+ATTR.*’ keyword and fall back on the original width or org-image-max-width if none is found.
org-image-max-width limits the maximum displayed image width, but only when the image width is not set explicitly. Possible maximum width can be set to:

(default) fill-column, limit width to fill-column number of characters.
window, limit width to current window width.
integer number, limit width to that specified number of pixels.
nil, do not limit the width.
Org mode can left-align, center or right-align the display of inline images. This setting is controlled (globally) by org-image-align. Only standalone images are affected, corresponding to links with no surrounding text in their paragraph except for whitespace. Its value can be the following:

(default) The symbol left, which inserts the image where the link appears in the buffer.
The symbol center, which will preview links centered in the Emacs window.
The symbol right, which will preview links right-aligned in the Emacs window.
Inline image alignment can be specified for each link using the ‘#+ATTR.*’ keyword if it matches an alignment specification like:

#+ATTR_HTML: :align center
Org will use the alignment specification from any ‘#+ATTR.*’ keyword, such as ‘#+ATTR_HTML’ or ‘#+ATTR_LATEX’, but ‘#+ATTR_ORG’ (if present) will override the others. For instance, this link

#+ATTR_HTML: :align right
#+ATTR_ORG: :align center
[[/path/to/image/file.png]]
will be displayed centered in Emacs but exported right-aligned to HTML.

When ‘#+ATTR_ORG’ is not set, inline image alignment is also read from the ‘:center’ attribute supported by some export backends (like HTML, LaTeX and Beamer.)

Inline images can also be displayed when cycling the folding state. When custom option org-cycle-inline-images-display is set, the visible inline images under subtree will be displayed automatically.

Footnotes
(121)
What Emacs considers to be an image depends on image-file-name-extensions and image-file-name-regexps.

(122)
The variable org-startup-with-inline-images can be set within a buffer with the ‘STARTUP’ options ‘inlineimages’ and ‘noinlineimages’.

(123)
The width can be customized in Emacs >= 24.1, built with imagemagick support.


**** Captions

You can assign a caption to a specific part of a document by inserting a ‘CAPTION’ keyword immediately before it:

#+CAPTION: This is the caption for the next table (or link)
| ... | ... |
|-----+-----|
Optionally, the caption can take the form:

#+CAPTION[Short caption]: Longer caption.
Even though images and tables are prominent examples of captioned structures, the same caption mechanism can apply to many others—e.g., LaTeX equations, source code blocks. Depending on the export backend, those may or may not be handled.


**** Horizontal Rules

A line consisting of only dashes, and at least 5 of them, is exported as a horizontal line.


**** Creating Footnotes

A footnote is started by a footnote marker in square brackets in column 0, no indentation allowed. It ends at the next footnote definition, headline, or after two consecutive empty lines. The footnote reference is simply the marker in square brackets, inside text. Markers always start with ‘fn:’. For example:

The Org website[fn:1] now looks a lot better than it used to.
...
[fn:50] The link is: https://orgmode.org
Org mode extends the number-based syntax to named footnotes and optional inline definition. Here are the valid references:

‘[fn:NAME]’
A named footnote reference, where NAME is a unique label word, or, for simplicity of automatic creation, a number.

‘[fn:: This is the inline definition of this footnote]’
An anonymous footnote where the definition is given directly at the reference point.

‘[fn:NAME: a definition]’
An inline definition of a footnote, which also specifies a name for the note. Since Org allows multiple references to the same note, you can then use ‘[fn:NAME]’ to create additional references.

Footnote labels can be created automatically, or you can create names yourself. This is handled by the variable org-footnote-auto-label and its corresponding ‘STARTUP’ keywords. See the docstring of that variable for details.

The following command handles footnotes:

C-c C-x f
The footnote action command.

When point is on a footnote reference, jump to the definition. When it is at a definition, jump to the—first—reference.

Otherwise, create a new footnote. Depending on the variable org-footnote-define-inline124, the definition is placed right into the text as part of the reference, or separately into the location determined by the variable org-footnote-section.

When this command is called with a prefix argument, a menu of additional options is offered:

s	Sort the footnote definitions by reference sequence.
r	Renumber the simple ‘fn:N’ footnotes.
S	Short for first r, then s action.
n	Rename all footnotes into a ‘fn:1’ … ‘fn:n’ sequence.
d	Delete the footnote at point, including definition and references.
Depending on the variable org-footnote-auto-adjust125, renumbering and sorting footnotes can be automatic after each insertion or deletion.

C-c C-c
If point is on a footnote reference, jump to the definition. If it is at the definition, jump back to the reference. When called at a footnote location with a prefix argument, offer the same menu as C-c C-x f.

C-c C-o or mouse-1/2
Footnote labels are also links to the corresponding definition or reference, and you can use the usual commands to follow these links.

Footnotes
(124)
The corresponding in-buffer setting is: ‘#+STARTUP: fninline’ or ‘#+STARTUP: nofninline’.

(125)
The corresponding in-buffer options are ‘#+STARTUP: fnadjust’ and ‘#+STARTUP: nofnadjust’.


*** Exporting ( check macro replacement ) 

At some point you might want to print your notes, publish them on the web, or share them with people not using Org. Org can convert and export documents to a variety of other formats while retaining as much structure (see Document Structure) and markup (see Markup for Rich Contents) as possible.

The libraries responsible for translating Org files to other formats are called backends. Org ships with support for the following backends:

ascii (ASCII format)
beamer (LaTeX Beamer format)
html (HTML format)
icalendar (iCalendar format)
latex (LaTeX format)
md (Markdown format)
odt (OpenDocument Text format)
org (Org format)
texinfo (Texinfo format)
man (Man page format)
Users can install libraries for additional formats from the Emacs packaging system. For easy discovery, these packages have a common naming scheme: ox-NAME, where NAME is a format. For example, ox-koma-letter for koma-letter backend. More libraries can be found in the ‘org-contrib’ repository (see Installation).

Org only loads backends for the following formats by default: ASCII, HTML, iCalendar, LaTeX, and ODT. Additional backends can be loaded in either of two ways: by configuring the org-export-backends variable, or by requiring libraries in the Emacs init file. For example, to load the Markdown backend, add this to your Emacs config:

(require 'ox-md)

**** The Export Dispatcher

The export dispatcher is the main interface for Org’s exports. A hierarchical menu presents the currently configured export formats. Options are shown as easy toggle switches on the same screen.

Org also has a minimal prompt interface for the export dispatcher. When the variable org-export-dispatch-use-expert-ui is set to a non-nil value, Org prompts in the minibuffer. To switch back to the hierarchical menu, press ?.

C-c C-e (org-export-dispatch)
Invokes the export dispatcher interface. The options show default settings. The C-u prefix argument preserves options from the previous export, including any subtree selections.

Org exports the entire buffer by default. If the Org buffer has an active region, then Org exports just that region.

Within the dispatcher interface, the following key combinations can further alter what is exported, and how.

C-a
Toggle asynchronous export. Asynchronous export uses an external Emacs process with a specially configured initialization file to complete the exporting process in the background, without tying-up Emacs. This is particularly useful when exporting long documents.

Output from an asynchronous export is saved on the export stack. To view this stack, call the export dispatcher with a double C-u prefix argument. If already in the export dispatcher menu, & displays the stack.

You can make asynchronous export the default by setting org-export-in-background.

You can set the initialization file used by the background process by setting org-export-async-init-file.

C-b
Toggle body-only export. Useful for excluding headers and footers in the export. Affects only those backend formats that have sections like ‘<head>...</head>’ in HTML.

To make body-only export the default, customize the variable org-export-body-only.

C-f
Toggle force-publishing export. Publish functions normally only publish changed files (see [BROKEN LINK: **Triggering Publication]). Forced publishing causes files to be published even if their timestamps do not indicate the file has been changed.

To make forced publishing the default, customize the variable org-export-force-publishing. (This is similar to org-publish-use-timestamps-flag, but only affects the export dispatcher.)

C-s
Toggle subtree export. When turned on, Org exports only the subtree starting from point position at the time the export dispatcher was invoked. Org uses the top heading of this subtree as the document’s title. If point is not on a heading, Org uses the nearest enclosing header. If point is in the document preamble, Org signals an error and aborts export.

To make subtree export the default, customize the variable org-export-initial-scope.

C-v
Toggle visible-only export. This is useful for exporting only certain parts of an Org document by adjusting the visibility of particular headings. See also Sparse Trees.

To make visible-only export the default, customize the variable org-export-visible-only.


**** Export Settings

Export options can be set: globally with variables; for an individual file by making variables buffer-local with in-buffer settings (see Summary of In-Buffer Settings); by setting individual keywords or specifying them in compact form with the ‘OPTIONS’ keyword; or for a tree by setting properties (see Properties and Columns). Options set at a specific level override options set at a more general level.

In-buffer settings may appear anywhere in the file, either directly or indirectly through a file included using ‘#+SETUPFILE: filename or URL’ syntax. Option keyword sets tailored to a particular backend can be inserted from the export dispatcher (see The Export Dispatcher) using the ‘Insert template’ command by pressing #. To insert keywords individually, a good way to make sure the keyword is correct is to type ‘#+’ and then to use M-TAB126 for completion.

The export keywords available for every backend, and their equivalent global variables, include:

‘AUTHOR’
The document author (user-full-name).

‘CREATOR’
Entity responsible for output generation (org-export-creator-string).

‘DATE’
A date or a timestamp127.

‘EMAIL’
The email address (user-mail-address).

‘LANGUAGE’
Language to use for translating certain strings (org-export-default-language). With ‘#+LANGUAGE: fr’, for example, Org translates ‘Table of contents’ to the French ‘Table des matières’128.

‘SELECT_TAGS’
List of tags that will, if present, be selected for export. The default value is org-export-select-tags ‘("export")’. When a tree is tagged with ‘export’, Org selects that tree and its subtrees for export, ignoring all the other sections that do not possess the ‘export’ tag.

When selectively exporting files with ‘export’ tags set, Org does not export any text that appears before the first headline.

Note that a file without the ‘export’ tags will export all its sections.

To select non-default tags for export, customize org-export-select-tags (globally) or add ‘#+SELECT_TAGS: tag1 tag2’ to the document.

‘EXCLUDE_TAGS’
List of tags that will be excluded from export. The default value is org-export-exclude-tags ‘("noexport")’. When a tree is tagged with ‘noexport’, Org excludes that tree and its subtrees from export.

Entries tagged with ‘noexport’ are unconditionally excluded from the export, even if they have an ‘export’ tag. Even if a subtree is not exported, Org executes any code blocks contained there.

To select non-default tags for the exclusion, customize org-export-exclude-tags (globally) or add ‘#+EXCLUDE_TAGS: tag1 tag2’ to the document.

‘TITLE’
Org displays this title. For long titles, use multiple ‘#+TITLE’ lines.

‘EXPORT_FILE_NAME’
The name of the output file to be generated. Otherwise, Org generates the file name based on the buffer name and the extension based on the backend format.

The ‘OPTIONS’ keyword is a compact form. To configure multiple options, use several ‘OPTIONS’ lines. ‘OPTIONS’ recognizes the following arguments.

'
Toggle smart quotes (org-export-with-smart-quotes). Depending on the language used, when activated, Org treats pairs of double quotes as primary quotes, pairs of single quotes as secondary quotes, and single quote marks as apostrophes.

*
Toggle emphasized text (org-export-with-emphasize).

-
Toggle conversion of special strings (org-export-with-special-strings).

:
Toggle fixed-width sections (org-export-with-fixed-width).

<
Toggle inclusion of time/date active/inactive stamps (org-export-with-timestamps).

\n
Toggles whether to preserve line breaks (org-export-preserve-breaks).

^
Toggle TeX-like syntax for sub- and superscripts. If you write ‘^:{}’, ‘a_{b}’ is interpreted, but the simple ‘a_b’ is left as it is (org-export-with-sub-superscripts).

arch
Configure how archived trees are exported. When set to headline, the export process skips the contents and processes only the headlines (org-export-with-archived-trees).

author
Toggle inclusion of author name into exported file (org-export-with-author).

expand-links
Toggle expansion of environment variables in file paths (org-export-expand-links).

broken-links
Toggles if Org should continue exporting upon finding a broken internal link. When set to mark, Org clearly marks the problem link in the output (org-export-with-broken-links).

c
Toggle inclusion of ‘CLOCK’ keywords (org-export-with-clocks).

creator
Toggle inclusion of creator information in the exported file (org-export-with-creator).

d
Toggles inclusion of drawers, or list of drawers to include, or list of drawers to exclude (org-export-with-drawers).

date
Toggle inclusion of a date into exported file (org-export-with-date).

e
Toggle inclusion of entities (org-export-with-entities).

email
Toggle inclusion of the author’s e-mail into exported file (org-export-with-email).

f
Toggle the inclusion of footnotes (org-export-with-footnotes).

H
Set the number of headline levels for export (org-export-headline-levels). Below that level, headlines are treated differently. In most backends, they become list items.

inline
Toggle inclusion of inlinetasks (org-export-with-inlinetasks).

num
Toggle section-numbers (org-export-with-section-numbers). When set to number N, Org numbers only those headlines at level N or above. Set ‘UNNUMBERED’ property to non-nil to disable numbering of heading and subheadings entirely. Moreover, when the value is ‘notoc’ the headline, and all its children, do not appear in the table of contents either (see Table of Contents).

p
Toggle export of planning information (org-export-with-planning). “Planning information” comes from lines located right after the headline and contain any combination of these cookies: ‘SCHEDULED’, ‘DEADLINE’, or ‘CLOSED’.

pri
Toggle inclusion of priority cookies (org-export-with-priority).

prop
Toggle inclusion of property drawers, or list the properties to include (org-export-with-properties).

stat
Toggle inclusion of statistics cookies (org-export-with-statistics-cookies).

tags
Toggle inclusion of tags, may also be not-in-toc (org-export-with-tags).

tasks
Toggle inclusion of tasks (TODO items); or nil to remove all tasks; or todo to remove done tasks; or list the keywords to keep (org-export-with-tasks).

tex
nil does not export; t exports; verbatim keeps everything in verbatim (org-export-with-latex).

timestamp
Toggle inclusion of the creation time in the exported file (org-export-timestamp-file).

title
Toggle inclusion of title (org-export-with-title).

toc
Toggle inclusion of the table of contents, or set the level limit (org-export-with-toc).

todo
Toggle inclusion of TODO keywords into exported text (org-export-with-todo-keywords).

|
Toggle inclusion of tables (org-export-with-tables).

When exporting subtrees, special node properties can override the above keywords. These properties have an ‘EXPORT_’ prefix. For example, ‘DATE’ becomes, ‘EXPORT_DATE’ when used for a specific subtree. Except for ‘SETUPFILE’, all other keywords listed above have an ‘EXPORT_’ equivalent.

If org-export-allow-bind-keywords is non-nil, Emacs variables can become buffer-local during export by using the ‘BIND’ keyword. Its syntax is ‘#+BIND: variable value’. This is particularly useful for in-buffer settings that cannot be changed using keywords.

Footnotes
(126)
Many desktops intercept M-TAB to switch windows. Use C-M-i or ESC TAB instead.

(127)
The variable org-export-date-timestamp-format defines how this timestamp are exported.

(128)
For export to LaTeX format—or LaTeX-related formats such as Beamer—, the ‘org-latex-package-alist’ variable needs further configuration. See LaTeX specific export settings.


**** Table of Contents

The table of contents includes all headlines in the document. Its depth is therefore the same as the headline levels in the file. If you need to use a different depth, or turn it off entirely, set the org-export-with-toc variable accordingly. You can achieve the same on a per file basis, using the following ‘toc’ item in ‘OPTIONS’ keyword:

#+OPTIONS: toc:2          (only include two levels in TOC)
#+OPTIONS: toc:nil        (no default TOC at all)
Org includes both numbered and unnumbered headlines in the table of contents129. If you need to exclude an unnumbered headline, along with all its children, set the ‘UNNUMBERED’ property to ‘notoc’ value.

;* Subtree not numbered, not in table of contents either
  :PROPERTIES:
  :UNNUMBERED: notoc
  :END:
Org normally inserts the table of contents in front of the exported document. To move the table of contents to a different location, first turn off the default with org-export-with-toc variable or with ‘#+OPTIONS: toc:nil’. Then insert ‘#+TOC: headlines N’ at the desired location(s).

#+OPTIONS: toc:nil
...
#+TOC: headlines 2
To adjust the table of contents depth for a specific section of the Org document, append an additional ‘local’ parameter. This parameter becomes a relative depth for the current level. The following example inserts a local table of contents, with direct children only.

;* Section
#+TOC: headlines 1 local
Note that for this feature to work properly in LaTeX export, the Org file requires the inclusion of the titletoc package. Because of compatibility issues, titletoc has to be loaded before hyperref. Customize the org-latex-default-packages-alist variable.

The following example inserts a table of contents that links to the children of the specified target.

;* Target
  :PROPERTIES:
  :CUSTOM_ID: TargetSection
  :END:
;** Heading A
;** Heading B
;* Another section
#+TOC: headlines 1 :target #TargetSection
The ‘:target’ attribute is supported in HTML, Markdown, ODT, and ASCII export.

Use the ‘TOC’ keyword to generate list of tables—respectively, all listings—with captions.

#+TOC: listings
#+TOC: tables
Normally Org uses the headline for its entry in the table of contents. But with ‘ALT_TITLE’ property, a different entry can be specified for the table of contents.

Footnotes
(129)
At the moment, some export backends do not obey this specification. For example, LaTeX export excludes every unnumbered headline from the table of contents.


**** Include Files

During export, you can include the content of another file. For example, to include your ‘.emacs’ file, you could use:

#+INCLUDE: "~/.emacs" src emacs-lisp
There are three positional arguments after the include keyword, they are:

The file name, this is the sole mandatory argument. Org neither checks for correctness or validates the content in any way.
The block name to wrap the file content in. When this is ‘example’, ‘export’, or ‘src’ the content is escaped by org-escape-code-in-string. Arbitrary block names may be given, however block names starting with ‘:’ must be quoted, i.e. ‘":name"’.
The source code language to use for formatting the contents. This is relevant to both ‘export’ and ‘src’ block types.
If an included file is not specified as having any markup language, Org assumes it be in Org format and proceeds as usual with a few exceptions. Org makes the footnote labels (see Creating Footnotes) in the included file local to that file. The contents of the included file belong to the same structure—headline, item—containing the ‘INCLUDE’ keyword. In particular, headlines within the file become children of the current section. That behavior can be changed by providing an additional keyword parameter, ‘:minlevel’. It shifts the headlines in the included file to become the lowest level. For example, this syntax makes the included file a sibling of the current top-level headline:

#+INCLUDE: "~/my-book/chapter2.org" :minlevel 1
Inclusion of only portions of files are specified using ranges parameter with ‘:lines’ keyword. The line at the upper end of the range will not be included. The start and/or the end of the range may be omitted to use the obvious defaults.

‘#+INCLUDE: "~/.emacs" :lines "5-10"’	Include lines 5 to 10, 10 excluded
‘#+INCLUDE: "~/.emacs" :lines "-10"’	Include lines 1 to 10, 10 excluded
‘#+INCLUDE: "~/.emacs" :lines "10-"’	Include lines from 10 to EOF
Inclusions may specify a file-link to extract an object matched by org-link-search130 (see Search Options in File Links). The ranges for ‘:lines’ keyword are relative to the requested element. Therefore,

#+INCLUDE: "./paper.org::*conclusion" :lines "1-20"
includes the first 20 lines of the headline named ‘conclusion’.

To extract only the contents of the matched object, set ‘:only-contents’ property to non-nil. This omits any planning lines or property drawers. For example, to include the body of the heading with the custom ID ‘theory’, you can use

#+INCLUDE: "./paper.org::#theory" :only-contents t
The following command allows navigating to the included document:

C-c ' (org-edit-special)
Visit the included file at point.

Footnotes
(130)
Note that org-link-search-must-match-exact-headline is locally bound to non-nil. Therefore, org-link-search only matches headlines and named elements.


**** Macro Replacement

Macros replace text snippets during export. Macros are defined globally in org-export-global-macros, or document-wise with the following syntax:

#+MACRO: name   replacement text; $1, $2 are arguments
which can be referenced using ‘{{{name(arg1, arg2)}}}’131. For example

#+MACRO: poem Rose is $1, violet's $2. Life's ordered: Org assists you.
{{{poem(red,blue)}}}
becomes

Rose is red, violet's blue.  Life's ordered: Org assists you.
As a special case, Org parses any replacement text starting with ‘(eval’ as an Emacs Lisp expression and evaluates it accordingly. Within such templates, arguments become strings. Thus, the following macro

#+MACRO: gnustamp (eval (concat "GNU/" (capitalize $1)))
turns ‘{{{gnustamp(linux)}}}’ into ‘GNU/Linux’ during export.

Org recognizes macro references in following Org markup areas: paragraphs, headlines, verse blocks, tables cells and lists. Org also recognizes macro references in keywords, such as ‘CAPTION’, ‘TITLE’, ‘AUTHOR’, ‘DATE’, and for some backend specific export options.

Org comes with following pre-defined macros:

‘{{{keyword(NAME)}}}’
‘{{{title}}}’
‘{{{author}}}’
‘{{{email}}}’
The ‘keyword’ macro collects all values from NAME keywords throughout the buffer, separated with white space. ‘title’, ‘author’ and ‘email’ macros are shortcuts for, respectively, ‘{{{keyword(TITLE)}}}’, ‘{{{keyword(AUTHOR)}}}’ and ‘{{{keyword(EMAIL)}}}’.

‘{{{date}}}’
‘{{{date(FORMAT)}}}’
This macro refers to the ‘DATE’ keyword. FORMAT is an optional argument to the ‘date’ macro that is used only if ‘DATE’ is a single timestamp. FORMAT should be a format string understood by format-time-string.

‘{{{time(FORMAT)}}}’
‘{{{modification-time(FORMAT, VC)}}}’
These macros refer to the document’s date and time of export and date and time of modification. FORMAT is a string understood by format-time-string. If the second argument to the modification-time macro is non-nil, Org uses ‘vc.el’ to retrieve the document’s modification time from the version control system. Otherwise Org reads the file attributes.

‘{{{input-file}}}’
This macro refers to the filename of the exported file.

‘{{{property(PROPERTY-NAME)}}}’
‘{{{property(PROPERTY-NAME, SEARCH OPTION)}}}’
This macro returns the value of property PROPERTY-NAME in the current entry. If SEARCH-OPTION (see Search Options in File Links) refers to a remote entry, use it instead.

‘{{{n}}}’
‘{{{n(NAME)}}}’
‘{{{n(NAME, ACTION)}}}’
This macro implements custom counters by returning the number of times the macro has been expanded so far while exporting the buffer. You can create more than one counter using different NAME values. If ACTION is ‘-’, previous value of the counter is held, i.e., the specified counter is not incremented. If the value is a number, the specified counter is set to that value. If it is any other non-empty string, the specified counter is reset to 1. You may leave NAME empty to reset the default counter.

Moreover, inline source blocks (see Structure of Code Blocks) use the special ‘results’ macro to mark their output. As such, you are advised against re-defining it, unless you know what you are doing.

The surrounding brackets can be made invisible by setting org-hide-macro-markers to a non-nil value.

Org expands macros at the very beginning of the export process.

Footnotes
(131)
Since commas separate the arguments, commas within arguments have to be escaped with the backslash character. So only those backslash characters before a comma need escaping with another backslash character.


**** Comment Lines

Lines starting with zero or more whitespace characters followed by one ‘#’ and a whitespace are treated as comments and, as such, are not exported.

Likewise, regions surrounded by ‘#+BEGIN_COMMENT’ … ‘#+END_COMMENT’ are not exported.

Finally, a ‘COMMENT’ keyword at the beginning of an entry, but after any other keyword or priority cookie, comments out the entire subtree. In this case, the subtree is not exported and no code block within it is executed either132. The command below helps changing the comment status of a headline.

C-c ; (org-toggle-comment)
Toggle the ‘COMMENT’ keyword at the beginning of an entry.

Footnotes
(132)
For a less drastic behavior, consider using a select tag (see Export Settings) instead.


**** ASCII/Latin-1/UTF-8 export

ASCII export produces an output file containing only plain ASCII characters. This is the simplest and most direct text output. It does not contain any Org markup. Latin-1 and UTF-8 export use additional characters and symbols available in these encoding standards. All three of these export formats offer the most basic of text output for maximum portability.

On export, Org fills and justifies text according to the text width set in org-ascii-text-width.

Org exports links using a footnote-like style where the descriptive part is in the text and the link is in a note before the next heading. See the variable org-ascii-links-to-notes for details.

ASCII export commands
C-c C-e t a (org-ascii-export-to-ascii)
C-c C-e t l
C-c C-e t u
Export as an ASCII file with a ‘.txt’ extension. For ‘myfile.org’, Org exports to ‘myfile.txt’, overwriting without warning. For ‘myfile.txt’, Org exports to ‘myfile.txt.txt’ in order to prevent data loss.

C-c C-e t A (org-ascii-export-to-ascii)
C-c C-e t L
C-c C-e t U
Export to a temporary buffer. Does not create a file.

ASCII specific export settings
The ASCII export backend has one extra keyword for customizing ASCII output. Setting this keyword works similar to the general options (see Export Settings).

‘SUBTITLE’
The document subtitle. For long subtitles, use multiple ‘#+SUBTITLE’ lines in the Org file. Org prints them on one continuous line, wrapping into multiple lines if necessary.

Header and sectioning structure
Org converts the first three outline levels into headlines for ASCII export. The remaining levels are turned into lists. To change this cut-off point where levels become lists, see Export Settings.

Quoting ASCII text
To insert text within the Org file by the ASCII backend, use one the following constructs, inline, keyword, or export block:

Inline text @@ascii:and additional text@@ within a paragraph.

#+ASCII: Some text

#+BEGIN_EXPORT ascii
Org exports text in this block only when using ASCII backend.
#+END_EXPORT
ASCII specific attributes
ASCII backend recognizes only one attribute, ‘:width’, which specifies the width of a horizontal rule in number of characters. The keyword and syntax for specifying widths is:

#+ATTR_ASCII: :width 10
-----
ASCII special blocks
Besides ‘#+BEGIN_CENTER’ blocks (see Paragraphs), ASCII backend has these two left and right justification blocks:

#+BEGIN_JUSTIFYLEFT
It's just a jump to the left...
#+END_JUSTIFYLEFT

#+BEGIN_JUSTIFYRIGHT
...and then a step to the right.
#+END_JUSTIFYRIGHT


**** Beamer Export

Org uses Beamer export to convert an Org file tree structure into high-quality interactive slides for presentations. Beamer is a LaTeX document class for creating presentations in PDF, HTML, and other popular display formats.

***** Beamer export commands

C-c C-e l b (org-beamer-export-to-latex)
Export as LaTeX file with a ‘.tex’ extension. For ‘myfile.org’, Org exports to ‘myfile.tex’, overwriting without warning.

C-c C-e l B (org-beamer-export-as-latex)
Export to a temporary buffer. Does not create a file.

C-c C-e l P (org-beamer-export-to-pdf)
Export as LaTeX file and then convert it to PDF format.

C-c C-e l O
Export as LaTeX file, convert it to PDF format, and then open the PDF file.


***** Beamer specific export settings

Beamer export backend has several additional keywords for customizing Beamer output. These keywords work similar to the general options settings (see Export Settings).

‘BEAMER_THEME’
The Beamer layout theme (org-beamer-theme). Use square brackets for options. For example:

#+BEAMER_THEME: Rochester [height=20pt]
‘BEAMER_FONT_THEME’
The Beamer font theme.

‘BEAMER_INNER_THEME’
The Beamer inner theme.

‘BEAMER_OUTER_THEME’
The Beamer outer theme.

‘BEAMER_HEADER’
Arbitrary lines inserted in the preamble, just before the ‘hyperref’ settings.

‘DESCRIPTION’
The document description. For long descriptions, use multiple ‘DESCRIPTION’ keywords. By default, ‘hyperref’ inserts ‘DESCRIPTION’ as metadata. Use org-latex-hyperref-template to configure document metadata. Use org-latex-title-command to configure typesetting of description as part of front matter.

‘KEYWORDS’
The keywords for defining the contents of the document. Use multiple ‘KEYWORDS’ lines if necessary. By default, ‘hyperref’ inserts ‘KEYWORDS’ as metadata. Use org-latex-hyperref-template to configure document metadata. Use org-latex-title-command to configure typesetting of keywords as part of front matter.

‘SUBTITLE’
Document’s subtitle. For typesetting, use org-beamer-subtitle-format string. Use org-latex-hyperref-template to configure document metadata. Use org-latex-title-command to configure typesetting of subtitle as part of front matter.


***** Frames and Blocks in Beamer

Org transforms heading levels into Beamer’s sectioning elements, frames and blocks. Any Org tree with a not-too-deep-level nesting should in principle be exportable as a Beamer presentation.

Org headlines become Beamer frames when the heading level in Org is equal to org-beamer-frame-level or ‘H’ value in a ‘OPTIONS’ line (see Export Settings).
Org overrides headlines to frames conversion for the current tree of an Org file if it encounters the ‘BEAMER_ENV’ property set to ‘frame’ or ‘fullframe’. Org ignores whatever org-beamer-frame-level happens to be for that headline level in the Org tree. In Beamer terminology, a full frame is a frame without its title.

Org exports a Beamer frame’s objects as block environments. Org can enforce wrapping in special block types when ‘BEAMER_ENV’ property is set133. For valid values see org-beamer-environments-default. To add more values, see org-beamer-environments-extra.
If ‘BEAMER_ENV’ is set to ‘appendix’, Org exports the entry as an appendix. When set to ‘note’, Org exports the entry as a note within the frame or between frames, depending on the entry’s heading level. When set to ‘noteNH’, Org exports the entry as a note without its title. When set to ‘againframe’, Org exports the entry with ‘\againframe’ command, which makes setting the ‘BEAMER_REF’ property mandatory because ‘\againframe’ needs frame to resume.
When ‘ignoreheading’ is set, Org export ignores the entry’s headline but not its content. This is useful for inserting content between frames. It is also useful for properly closing a ‘column’ environment.

When ‘BEAMER_ACT’ is set for a headline, Org export translates that headline as an overlay or action specification. When enclosed in square brackets, Org export makes the overlay specification a default. Use ‘BEAMER_OPT’ to set any options applicable to the current Beamer frame or block. The Beamer export backend wraps with appropriate angular or square brackets. It also adds the ‘fragile’ option for any code that may require a verbatim block.

To create a column on the Beamer slide, use the ‘BEAMER_COL’ property for its headline in the Org file. Set the value of ‘BEAMER_COL’ to a decimal number representing the fraction of the total text width. Beamer export uses this value to set the column’s width and fills the column with the contents of the Org entry. If the Org entry has no specific environment defined, Beamer export ignores the heading. If the Org entry has a defined environment, Beamer export uses the heading as title. Behind the scenes, Beamer export automatically handles LaTeX column separations for contiguous headlines. To manually adjust them for any unique configurations needs, use the ‘BEAMER_ENV’ property.

Footnotes
(133)
If ‘BEAMER_ENV’ is set, Org export adds ‘B_environment’ tag to make it visible. The tag serves as a visual aid and has no semantic relevance.


***** Beamer specific syntax

Since Org’s Beamer export backend is an extension of the LaTeX backend, it recognizes other LaTeX specific syntax—for example, ‘#+LATEX:’ or ‘#+ATTR_LATEX:’. See LaTeX Export, for details.

Beamer export wraps the table of contents generated with ‘toc:t’ ‘OPTION’ keyword in a ‘frame’ environment. Beamer export does not wrap the table of contents generated with ‘TOC’ keyword (see Table of Contents). Use square brackets for specifying options.

#+TOC: headlines [currentsection]
Insert Beamer-specific code using the following constructs:

#+BEAMER: \pause

#+BEGIN_EXPORT beamer
  Only Beamer export backend exports this.
#+END_EXPORT

Text @@beamer:some code@@ within a paragraph.
Inline constructs, such as the last one above, are useful for adding overlay specifications to objects with bold, item, link, radio-target and target types. Enclose the value in angular brackets and place the specification at the beginning of the object as shown in this example:

A *@@beamer:<2->@@useful* feature
Beamer export recognizes the ‘ATTR_BEAMER’ keyword with the following attributes from Beamer configurations: ‘:environment’ for changing local Beamer environment, ‘:overlay’ for specifying Beamer overlays in angular or square brackets, and ‘:options’ for inserting optional arguments.

#+ATTR_BEAMER: :environment nonindentlist
- item 1, not indented
- item 2, not indented
- item 3, not indented
#+ATTR_BEAMER: :overlay <+->
- item 1
- item 2
#+ATTR_BEAMER: :options [Lagrange]
Let $G$ be a finite group, and let $H$ be
a subgroup of $G$.  Then the order of $H$ divides the order of $G$.


***** Editing support

Org Beamer mode is a special minor mode for faster editing of Beamer documents.

#+STARTUP: beamer
C-c C-b (org-beamer-select-environment)
Org Beamer mode provides this key for quicker selections in Beamer normal environments, and for selecting the ‘BEAMER_COL’ property.


***** A Beamer example

Here is an example of an Org document ready for Beamer export.
#+begin_src

# #+TITLE: Example Presentation
# #+AUTHOR: Carsten Dominik
# #+OPTIONS: H:2 toc:t num:t
# #+LATEX_CLASS: beamer
# #+LATEX_CLASS_OPTIONS: [presentation]
# #+BEAMER_THEME: Madrid
# #+COLUMNS: %45ITEM %10BEAMER_ENV(Env) %10BEAMER_ACT(Act) %4BEAMER_COL(Col)

# * This is the first structural section

# ** Frame 1
# *** Thanks to Eric Fraga                                           :B_block:
#     :PROPERTIES:
#     :BEAMER_COL: 0.48
#     :BEAMER_ENV: block
#     :END:
#     for the first viable Beamer setup in Org
# *** Thanks to everyone else                                        :B_block:
#     :PROPERTIES:
#     :BEAMER_COL: 0.48
#     :BEAMER_ACT: <2->
#     :BEAMER_ENV: block
#     :END:
#     for contributing to the discussion
# **** This will be formatted as a beamer note                       :B_note:
#      :PROPERTIES:
#      :BEAMER_env: note
#      :END:
# ** Frame 2 (where we will not use columns)
# *** Request
#     Please test this stuff!
    
#+end_src


**** HTML Export

Org mode contains an HTML exporter with extensive HTML formatting compatible with XHTML 1.0 strict standard.

***** HTML export commands

C-c C-e h h (org-html-export-to-html)
Export as HTML file with a ‘.html’ extension. For ‘myfile.org’, Org exports to ‘myfile.html’, overwriting without warning. C-c C-e h o exports to HTML and opens it in a web browser.

C-c C-e h H (org-html-export-as-html)
Exports to a temporary buffer. Does not create a file.


***** HTML specific export settings

HTML export has a number of keywords, similar to the general options settings described in Export Settings.

‘DESCRIPTION’
This is the document’s description, which the HTML exporter inserts it as a HTML meta tag in the HTML file. For long descriptions, use multiple ‘DESCRIPTION’ lines. The exporter takes care of wrapping the lines properly.

The exporter includes a number of other meta tags, which can be customized by modifying org-html-meta-tags.

‘HTML_DOCTYPE’
Specify the document type, for example: HTML5 (org-html-doctype).

‘HTML_CONTAINER’
Specify the HTML container, such as ‘div’, for wrapping sections and elements (org-html-container-element).

‘HTML_LINK_HOME’
The URL for home link (org-html-link-home).

‘HTML_LINK_UP’
The URL for the up link of exported HTML pages (org-html-link-up).

‘HTML_MATHJAX’
Options for MathJax (org-html-mathjax-options). MathJax is used to typeset LaTeX math in HTML documents. See Math formatting in HTML export, for an example.

‘HTML_HEAD’
Arbitrary lines for appending to the HTML document’s head (org-html-head).

‘HTML_HEAD_EXTRA’
More arbitrary lines for appending to the HTML document’s head (org-html-head-extra).

‘KEYWORDS’
Keywords to describe the document’s content. HTML exporter inserts these keywords as HTML meta tags. For long keywords, use multiple ‘KEYWORDS’ lines.

‘LATEX_HEADER’
Arbitrary lines for appending to the preamble; HTML exporter appends when transcoding LaTeX fragments to images (see Math formatting in HTML export).

‘SUBTITLE’
The document’s subtitle. HTML exporter formats subtitle if document type is ‘HTML5’ and the CSS has a ‘subtitle’ class.

Some of these keywords are explained in more detail in the following sections of the manual.


***** HTML doctypes

Org can export to various (X)HTML flavors.

Set the org-html-doctype variable for different (X)HTML variants. Depending on the variant, the HTML exporter adjusts the syntax of HTML conversion accordingly. Org includes the following ready-made variants:

"html4-strict"
"html4-transitional"
"html4-frameset"
"xhtml-strict"
"xhtml-transitional"
"xhtml-frameset"
"xhtml-11"
"html5"
"xhtml5"
See the variable org-html-doctype-alist for details. The default is "xhtml-strict".

Org’s HTML exporter does not by default enable new block elements introduced with the HTML5 standard. To enable them, set org-html-html5-fancy to non-nil. Or use an ‘OPTIONS’ line in the file to set ‘html5-fancy’.

HTML5 documents can have arbitrary ‘#+BEGIN’ … ‘#+END’ blocks. For example:

#+BEGIN_aside
  Lorem ipsum
#+END_aside
exports to:

<aside>
  <p>Lorem ipsum</p>
</aside>
while this:

#+ATTR_HTML: :controls controls :width 350
#+BEGIN_video
#+HTML: <source src="movie.mp4" type="video/mp4">
#+HTML: <source src="movie.ogg" type="video/ogg">
Your browser does not support the video tag.
#+END_video
exports to:

<video controls="controls" width="350">
  <source src="movie.mp4" type="video/mp4">
  <source src="movie.ogg" type="video/ogg">
  <p>Your browser does not support the video tag.</p>
</video>
When special blocks do not have a corresponding HTML5 element, the HTML exporter reverts to standard translation (see org-html-html5-elements). For example, ‘#+BEGIN_lederhosen’ exports to <div class="lederhosen">.

Special blocks cannot have headlines. For the HTML exporter to wrap the headline and its contents in <section> or <article> tags, set the ‘HTML_CONTAINER’ property for the headline.


***** HTML preamble and postamble

The HTML exporter has delineations for preamble and postamble. The default value for org-html-preamble is t, which makes the HTML exporter insert the preamble. See the variable org-html-preamble-format for the format string.

Set org-html-preamble to a string to override the default format string. If set to a function, the HTML exporter expects the function to return a string upon execution. The HTML exporter inserts this string in the preamble. The HTML exporter does not insert a preamble if org-html-preamble is set nil.

The above also applies to org-html-postamble and org-html-postamble-format. In addition, org-html-postamble can be set to auto (its default value), which makes the HTML exporter build a postamble from looking up author’s name, email address, creator’s name, and date.


***** Exporting to minimal HTML

If you want to output a minimal HTML file, with no CSS, no Javascript, no preamble or postamble, here are the variable you would need to set:

(setq org-html-head ""
      org-html-head-extra ""
      org-html-head-include-default-style nil
      org-html-head-include-scripts nil
      org-html-preamble nil
      org-html-postamble nil
      org-html-use-infojs nil)


***** Quoting HTML tags

The HTML export backend transforms ‘<’ and ‘>’ to ‘&lt;’ and ‘&gt;’. To include raw HTML code in the Org file so the HTML export backend can insert that HTML code in the output, use this inline syntax: ‘@@html:...@@’. For example:

@@html:<b>@@bold text@@html:</b>@@
For larger raw HTML code blocks, use these HTML export code blocks:

#+HTML: Literal HTML code for export

#+BEGIN_EXPORT html
  All lines between these markers are exported literally
#+END_EXPORT


***** Headlines in HTML export

Headlines are exported to ‘<h1>’, ‘<h2>’, etc. Each headline gets the ‘id’ attribute from ‘CUSTOM_ID’ property, or a unique generated value, see Internal Links.

When org-html-self-link-headlines is set to a non-nil value, the text of the headlines is also wrapped in ‘<a>’ tags. These tags have a ‘href’ attribute making the headlines link to themselves.


***** Links in HTML export

The HTML export backend transforms Org’s internal links (see Internal Links) to equivalent HTML links in the output. The backend similarly handles Org’s automatic links created by radio targets (see Radio Targets) similarly. For Org links to external files, the backend transforms the links to relative paths.

For Org links to other ‘.org’ files, the backend automatically changes the file extension to ‘.html’ and makes file paths relative. If the ‘.org’ files have an equivalent ‘.html’ version at the same location, then the converted links should work without any further manual intervention. However, to disable this automatic path translation, set org-html-link-org-files-as-html to nil. When disabled, the HTML export backend substitutes the ID-based links in the HTML output. For more about linking files when publishing to a directory, see Publishing links.

Org files can also have special directives to the HTML export backend. For example, by using ‘#+ATTR_HTML’ lines to specify new format attributes to <a> or <img> tags. This example shows changing the link’s title and style:

#+ATTR_HTML: :title The Org mode website :style color:red;
[[https://orgmode.org]]


***** Tables in HTML export

The HTML export backend uses org-html-table-default-attributes when exporting Org tables to HTML. By default, the exporter does not draw frames and cell borders. To change for this for a table, use the following lines before the table in the Org file:

#+CAPTION: This is a table with lines around and between cells
#+ATTR_HTML: :border 2 :rules all :frame border
The HTML export backend preserves column groupings in Org tables (see Column Groups) when exporting to HTML.

Additional options for customizing tables for HTML export.

org-html-table-align-individual-fields
Non-nil attaches style attributes for alignment to each table field.

org-html-table-caption-above
Non-nil places caption string at the beginning of the table.

org-html-table-data-tags
Opening and ending tags for table data fields.

org-html-table-default-attributes
Default attributes and values for table tags.

org-html-table-header-tags
Opening and ending tags for table’s header fields.

org-html-table-row-tags
Opening and ending tags for table rows.

org-html-table-use-header-tags-for-first-column
Non-nil formats column one in tables with header tags.


***** Images in HTML export

The HTML export backend has features to convert Org image links to HTML inline images and HTML clickable image links.

When the link in the Org file has no description, the HTML export backend by default in-lines that image. For example: ‘[[file:myimg.jpg]]’ is in-lined, while ‘[[file:myimg.jpg][the image]]’ links to the text, ‘the image’. For more details, see the variable org-html-inline-images.

On the other hand, if the description part of the Org link is itself another link, such as ‘file:’ or ‘http:’ URL pointing to an image, the HTML export backend in-lines this image and links to the main image. This Org syntax enables the backend to link low-resolution thumbnail to the high-resolution version of the image, as shown in this example:

[[file:highres.jpg][file:thumb.jpg]]
To change attributes of in-lined images, use ‘#+ATTR_HTML’ lines in the Org file. This example shows realignment to right, and adds alt and title attributes in support of text viewers and modern web accessibility standards.

#+CAPTION: A black cat stalking a spider
#+ATTR_HTML: :alt cat/spider image :title Action! :align right
[[./img/a.jpg]]
The HTML export backend copies the ‘http’ links from the Org file as-is.


***** Math formatting in HTML export

LaTeX math snippets (see LaTeX fragments) can be displayed in two different ways on HTML pages. The default is to use the MathJax, which should work out of the box with Org134135. Some MathJax display options can be configured via org-html-mathjax-options, or in the buffer. For example, with the following settings,

#+HTML_MATHJAX: align: left indent: 5em tagside: left
equation labels are displayed on the left margin and equations are five em from the left margin.

See the docstring of org-html-mathjax-options for all supported variables. The MathJax template can be configure via org-html-mathjax-template.

If you prefer, you can also request that LaTeX fragments are processed into small images that will be inserted into the browser page. Before the availability of MathJax, this was the default method for Org files. This method requires that the dvipng program, dvisvgm or ImageMagick suite is available on your system. You can still get this processing with

#+OPTIONS: tex:dvipng
#+OPTIONS: tex:dvisvgm
or

#+OPTIONS: tex:imagemagick
Footnotes
(134)
By default, Org loads MathJax from jsDelivr, as recommended in Getting Started with MathJax Components.

(135)
Please note that exported formulas are part of an HTML document, and that signs such as ‘<’, ‘>’, or ‘&’ have special meanings. See MathJax TeX and LaTeX in HTML documents.


***** Text areas in HTML export

Before Org mode’s Babel, one popular approach to publishing code in HTML was by using ‘:textarea’. The advantage of this approach was that copying and pasting was built into browsers with simple JavaScript commands. Even editing before pasting was made simple.

The HTML export backend can create such text areas. It requires an ‘#+ATTR_HTML’ line as shown in the example below with the ‘:textarea’ option. This must be followed by either an example or a source code block. Other Org block types do not honor the ‘:textarea’ option.

By default, the HTML export backend creates a text area 80 characters wide and height just enough to fit the content. Override these defaults with ‘:width’ and ‘:height’ options on the ‘#+ATTR_HTML’ line.

#+ATTR_HTML: :textarea t :width 40
#+BEGIN_EXAMPLE
  (defun org-xor (a b)
     "Exclusive or."
     (if a (not b) b))
#+END_EXAMPLE


***** CSS support

You can modify the CSS style definitions for the exported file. The HTML exporter assigns the following special CSS classes136 to appropriate parts of the document—your style specifications may change these, in addition to any of the standard classes like for headlines, tables, etc.

p.author	author information, including email
p.date	publishing date
p.creator	creator info, about org mode version
.title	document title
.subtitle	document subtitle
.todo	TODO keywords, all not-done states
.done	the DONE keywords, all states that count as done
.WAITING	each TODO keyword also uses a class named after itself
.timestamp	timestamp
.timestamp-kwd	keyword associated with a timestamp, like ‘SCHEDULED’
.timestamp-wrapper	span around keyword plus timestamp
.tag	tag in a headline
._HOME	each tag uses itself as a class, “@” replaced by “_”
.target	target for links
.linenr	the line number in a code example
.code-highlighted	for highlighting referenced code lines
div.outline-N	div for outline level N (headline plus text)
div.outline-text-N	extra div for text at outline level N
.section-number-N	section number in headlines, different for each level
.figure-number	label like “Figure 1:”
.table-number	label like “Table 1:”
.listing-number	label like “Listing 1:”
div.figure	how to format an in-lined image
pre.src	formatted source code
pre.example	normal example
p.verse	verse paragraph
div.footnotes	footnote section headline
p.footnote	footnote definition paragraph, containing a footnote
.footref	a footnote reference number (always a <sup>)
.footnum	footnote number in footnote definition (always <sup>)
.org-svg	default class for a linked ‘.svg’ image
The HTML export backend includes a compact default style in each exported HTML file. To override the default style with another style, use these keywords in the Org file. They will replace the global defaults the HTML exporter uses.

#+HTML_HEAD: <link rel="stylesheet" type="text/css" href="style1.css" />
#+HTML_HEAD_EXTRA: <link rel="alternate stylesheet" type="text/css" href="style2.css" />
To just turn off the default style, customize org-html-head-include-default-style variable, or use this option line in the Org file.

#+OPTIONS: html-style:nil
For longer style definitions, either use several ‘HTML_HEAD’ and ‘HTML_HEAD_EXTRA’ keywords, or use <style> ... </style> blocks around them. Both of these approaches can avoid referring to an external file.

In order to add styles to a subtree, use the ‘HTML_CONTAINER_CLASS’ property to assign a class to the tree. In order to specify CSS styles for a particular headline, you can use the ID specified in a ‘CUSTOM_ID’ property. You can also assign a specific class to a headline with the ‘HTML_HEADLINE_CLASS’ property.

Never change the org-html-style-default constant. Instead use other simpler ways of customizing as described above.

Footnotes
(136)
If the classes on TODO keywords and tags lead to conflicts, use the variables org-html-todo-kwd-class-prefix and org-html-tag-class-prefix to make them unique.


***** JavaScript supported display of web pages

Sebastian Rose has written a JavaScript program especially designed to allow two different ways of viewing HTML files created with Org. One is an Info-like mode where each section is displayed separately and navigation can be done with the n and p keys, and some other keys as well, press ? for an overview of the available keys. The second one has a folding view, much like Org provides inside Emacs. The script is available at https://orgmode.org/org-info.js and the documentation at https://orgmode.org/worg/code/org-info-js/. The script is hosted on https://orgmode.org, but for reliability, prefer installing it on your own web server.

To use this program, just add this line to the Org file:

#+INFOJS_OPT: view:info toc:nil
The HTML header now has the code needed to automatically invoke the script. For setting options, use the syntax from the above line for options described below:

‘path:’
The path to the script. The default is to grab the script from https://orgmode.org/org-info.js, but you might want to have a local copy and use a path like ‘../scripts/org-info.js’.

‘view:’
Initial view when the website is first shown. Possible values are:

‘info’	Info-like interface with one section per page
‘overview’	Folding interface, initially showing only top-level
‘content’	Folding interface, starting with all headlines visible
‘showall’	Folding interface, all headlines and text visible
‘sdepth:’
Maximum headline level still considered as an independent section for info and folding modes. The default is taken from org-export-headline-levels, i.e., the ‘H’ switch in ‘OPTIONS’. If this is smaller than in org-export-headline-levels, each info/folding section can still contain child headlines.

‘toc:’
Should the table of contents initially be visible? Even when ‘nil’, you can always get to the “toc” with i.

‘tdepth:’
The depth of the table of contents. The defaults are taken from the variables org-export-headline-levels and org-export-with-toc.

‘ftoc:’
Does the CSS of the page specify a fixed position for the “toc”? If yes, the toc is displayed as a section.

‘ltoc:’
Should there be short contents (children) in each section? Make this ‘above’ if the section should be above initial text.

‘mouse:’
Headings are highlighted when the mouse is over them. Should be ‘underline’ (default) or a background color like ‘#cccccc’.

‘buttons:’
Should view-toggle buttons be everywhere? When ‘nil’ (the default), only one such button is present.

You can choose default values for these options by customizing the variable org-infojs-options. If you always want to apply the script to your pages, configure the variable org-export-html-use-infojs.


**** LaTeX Export

The LaTeX export backend can handle complex documents, incorporate standard or custom LaTeX document classes, generate documents using alternate LaTeX engines, and produce fully linked PDF files with indexes, bibliographies, and tables of contents, destined for interactive online viewing or high-quality print publication.

While the details are covered in-depth in this section, here are some quick references to variables for the impatient: for engines, see org-latex-compiler; for build sequences, see org-latex-pdf-process; for packages, see org-latex-default-packages-alist and org-latex-packages-alist.

An important note about the LaTeX export backend: it is sensitive to blank lines in the Org document. That’s because LaTeX itself depends on blank lines to tell apart syntactical elements, such as paragraphs.

The following sections expect users to be familiar with common LaTeX terminology. You may refer to https://tug.org/begin.html to get familiar with LaTeX basics. Users with LaTeX installed may also run ‘texdoc latex’ from terminal to open LaTeX introduction 137

***** LaTeX/PDF export commands

C-c C-e l l (org-latex-export-to-latex)
Export to a LaTeX file with a ‘.tex’ extension. For ‘myfile.org’, Org exports to ‘myfile.tex’, overwriting without warning.

C-c C-e l L (org-latex-export-as-latex)
Export to a temporary buffer. Do not create a file.

C-c C-e l p (org-latex-export-to-pdf)
Export as LaTeX file and convert it to PDF file.

C-c C-e l o
Export as LaTeX file and convert it to PDF, then open the PDF using the default viewer.

M-x org-export-region-as-latex
Convert the region to LaTeX under the assumption that it was in Org mode syntax before. This is a global command that can be invoked in any buffer.

The LaTeX export backend can use any of these LaTeX engines: ‘pdflatex’, ‘xelatex’, and ‘lualatex’. These engines compile LaTeX files with different compilers, packages, and output options. The LaTeX export backend finds the compiler version to use from org-latex-compiler variable or the ‘#+LATEX_COMPILER’ keyword in the Org file. See the docstring for the org-latex-default-packages-alist for loading packages with certain compilers. Also see org-latex-bibtex-compiler to set the bibliography compiler138.

Footnotes
(138)
This does not allow setting different bibliography compilers for different files. However, “smart” LaTeX compilation systems, such as latexmk, can select the correct bibliography compiler.


***** LaTeX specific export settings

The LaTeX export backend has several additional keywords for customizing LaTeX output. Setting these keywords works similar to the general options (see Export Settings).

‘DESCRIPTION’
The document’s description. The description along with author name, keywords, and related file metadata are inserted in the output file by the hyperref package. See org-latex-hyperref-template for customizing metadata items. See org-latex-title-command for typesetting description into the document’s front matter. Use multiple ‘DESCRIPTION’ keywords for long descriptions.

‘LANGUAGE’
Language code of the primary document language. When ‘LANGUAGE’ keyword is not not specified use the value of org-export-default-language (by default - ‘en’, American English)

The list of language codes supported by Org is stored in the variable org-latex-language-alist.

In order to be effective, the ‘babel’ or ‘polyglossia’ packages—according to the LaTeX compiler used—must be loaded with the appropriate language as argument. This can be accomplished by modifying the org-latex-packages-alist variable, e.g., with the following snippet (note that ‘polyglossia’ does not work with pdfLaTeX):

(add-to-list 'org-latex-packages-alist
             '("AUTO" "babel" t ("pdflatex" "xelatex" "lualatex")))
(add-to-list 'org-latex-packages-alist
             '("AUTO" "polyglossia" t ("xelatex" "lualatex")))
‘LATEX_CLASS’
This is LaTeX document class, such as article, report, book, and so on, which contain predefined preamble and headline level mapping that the LaTeX export backend needs. The backend reads the default class name from the org-latex-default-class variable. Org has article as the default class. A valid default class must be an element of org-latex-classes.

‘LATEX_CLASS_OPTIONS’
Options the LaTeX export backend uses when calling the LaTeX document class.

‘LATEX_COMPILER’
The compiler, such as ‘pdflatex’, ‘xelatex’, ‘lualatex’, for producing the PDF. See org-latex-compiler.

‘LATEX_HEADER’
‘LATEX_HEADER_EXTRA’
Arbitrary lines to add to the document’s preamble, before the hyperref settings. See org-latex-classes for adjusting the structure and order of the LaTeX headers.

‘KEYWORDS’
The keywords for the document. The description along with author name, keywords, and related file metadata are inserted in the output file by the hyperref package. See org-latex-hyperref-template for customizing metadata items. See org-latex-title-command for typesetting description into the document’s front matter. Use multiple ‘KEYWORDS’ lines if necessary.

‘SUBTITLE’
The document’s subtitle. It is typeset as per org-latex-subtitle-format. If org-latex-subtitle-separate is non-nil, it is typed outside of the \title macro. See org-latex-hyperref-template for customizing metadata items. See org-latex-title-command for typesetting description into the document’s front matter.

The following sections have further details.


***** LaTeX header and sectioning structure

The LaTeX export backend converts the first three of Org’s outline levels into LaTeX headlines. The remaining Org levels are exported as lists. To change this globally for the cut-off point between levels and lists, (see Export Settings).

By default, the LaTeX export backend uses the article class.

To change the default class globally, edit org-latex-default-class. To change the default class locally in an Org file, add option lines ‘#+LATEX_CLASS: myclass’. To change the default class for just a part of the Org file, set a subtree property, ‘EXPORT_LATEX_CLASS’. The class name entered here must be valid member of org-latex-classes. This variable defines a header template for each class into which the exporter splices the values of org-latex-default-packages-alist and org-latex-packages-alist. Use the same three variables to define custom sectioning or custom classes.

The LaTeX export backend sends the ‘LATEX_CLASS_OPTIONS’ keyword and ‘EXPORT_LATEX_CLASS_OPTIONS’ property as options to the LaTeX \documentclass macro. The options and the syntax for specifying them, including enclosing them in square brackets, follow LaTeX conventions.

#+LATEX_CLASS_OPTIONS: [a4paper,11pt,twoside,twocolumn]
The LaTeX export backend appends values from ‘LATEX_HEADER’ and ‘LATEX_HEADER_EXTRA’ keywords to the LaTeX header. The docstring for org-latex-classes explains in more detail. Also note that LaTeX export backend does not append ‘LATEX_HEADER_EXTRA’ to the header when previewing LaTeX snippets (see Previewing LaTeX fragments).

A sample Org file with the above headers:

#+LATEX_CLASS: article
#+LATEX_CLASS_OPTIONS: [a4paper]
#+LATEX_HEADER: \usepackage{xyz}

;* Headline 1
  some text
;* Headline 2
  some more text
LaTeX packages ‘babel’ or ‘polyglossia’ can also be loaded in a document. The “AUTO” string will be replaced in both cases by the appropriate value for the ‘LANGUAGE’ keyword, if present in the document, or by the value of org-export-default-language. Let’s see some examples in one or another case.

‘Babel’ accepts the classic syntax and (in addition) the new syntax with the ‘\babelprovide’ command to load the languages using the new ‘INI’ files procedure. Keep in mind that there are a number of languages that are only served in babel using ‘INI’ files, so they cannot be declared using the classic syntax, but only using the ‘\babelprovide’ command (see https://mirrors.ctan.org/macros/latex/required/babel/base/babel.pdf). Valid usage examples could be:

#+LATEX_HEADER: \usepackage[french,italian,AUTO]{babel}
where “AUTO” is the main language. But it can also be loaded using the ‘\babelprovide’ command:

#+LATEX_HEADER: \usepackage[french,italian]{babel}
#+LATEX_HEADER: \babelprovide[import, main]{AUTO}
‘Polyglossia’, for this procedure to be effective, must be loaded using the same ‘babel’ classic syntax (but note that this is not the actual polyglossia syntax). For example, suppose a document declares Polytonic Greek as the primary language, and French as the secondary language. In this case, it would be expressed as:

#+LANGUAGE: el-polyton
#+LATEX_HEADER: \usepackage[french,AUTO]{polyglossia}
This would produce in LaTeX (with the actual ‘polyglossia’ syntax):

\usepackage{polyglossia}
\setmainlanguage[variant=polytonic]{greek}
\setotherlanguage{french}


***** Quoting LaTeX code

When the available LaTeX export customizations are not sufficient to fine-tune the desired output, it is possible to insert any arbitrary LaTeX code (see Embedded LaTeX). There are three ways to embed such code in the Org file and they all use different quoting syntax.

Inserting in-line quoted with @ symbols:

Code embedded in-line @@latex:any arbitrary LaTeX code@@ in a paragraph.
Inserting as one or more keyword lines in the Org file:

#+LATEX: any arbitrary LaTeX code
Inserting as an export block in the Org file, where the backend exports any code between begin and end markers:

#+BEGIN_EXPORT latex
  any arbitrary LaTeX code
#+END_EXPORT


***** Tables in LaTeX export

The LaTeX export backend can pass several LaTeX attributes for table contents and layout. Besides specifying a label (see Internal Links) and a caption (see Captions), the other valid LaTeX attributes include:

‘:mode’
The LaTeX export backend wraps the table differently depending on the mode for accurate rendering of math symbols. Mode is either ‘table’, ‘math’, ‘inline-math’, ‘verbatim’ or ‘tabbing’.

For ‘math’ or ‘inline-math’ mode, LaTeX export backend wraps the table in a math environment, but every cell in it is exported as-is. For ‘tabbing’ the LaTeX tabbing environment is used and the correct tabbing delimiters ‘\>’ are used. The LaTeX export backend determines the default mode from org-latex-default-table-mode. The LaTeX export backend merges contiguous tables in the same mode into a single environment.

‘:environment’
Set the default LaTeX table environment for the LaTeX export backend to use when exporting Org tables. Common LaTeX table environments are provided by these packages: tabularx, longtable, array, tabu, and bmatrix. For packages, such as tabularx and tabu, or any newer replacements, include them in the org-latex-packages-alist variable so the LaTeX export backend can insert the appropriate load package headers in the converted LaTeX file. Look in the docstring for the org-latex-packages-alist variable for configuring these packages for LaTeX snippet previews, if any.

‘:caption’
Use ‘CAPTION’ keyword to set a simple caption for a table (see Captions). For custom captions, use ‘:caption’ attribute, which accepts raw LaTeX code. ‘:caption’ value overrides ‘CAPTION’ value.

‘:float’
‘:placement’
The table environments by default are not floats in LaTeX. To make them floating objects use ‘:float’ with one of the following options: ‘t’ (for a default ‘table’ environment), ‘sideways’ (for a ‘sidewaystable’ environment), ‘multicolumn’ (to span the table across multiple columns of a page in a ‘table*’ environment) and ‘nil’. In addition to these three values, ‘:float’ can pass through any arbitrary value, for example a user-defined float type with the ‘float’ LaTeX package.

LaTeX floats can also have additional layout ‘:placement’ attributes. These are the usual ‘[h t b p ! H]’ permissions specified in square brackets. Note that for ‘:float sideways’ tables, the LaTeX export backend ignores ‘:placement’ attributes.

‘:align’
‘:font’
‘:width’
The LaTeX export backend uses these attributes for regular tables to set their alignments, fonts, and widths.

‘:options’
The ‘:options’ attribute allows adding an optional argument with a list of various table options (between brackets in LaTeX export), since certain tabular environments, such as longtblr of the tabularray LaTeX package, provides this structure. For example: ‘:options remark{Note}={note},remark{Source}={source}’.

‘:spread’
When ‘:spread’ is non-nil, the LaTeX export backend spreads or shrinks the table by the ‘:width’ for tabu and longtabu environments. ‘:spread’ has no effect if ‘:width’ is not set.

‘:booktabs’
‘:center’
‘:rmlines’
All three commands are toggles. ‘:booktabs’ brings in modern typesetting enhancements to regular tables. The booktabs package has to be loaded through org-latex-packages-alist. ‘:center’ is for centering the table. ‘:rmlines’ removes all but the very first horizontal line made of ASCII characters from “table.el” tables only.

‘:math-prefix’
‘:math-suffix’
‘:math-arguments’
The LaTeX export backend inserts ‘:math-prefix’ string value in a math environment before the table. The LaTeX export backend inserts ‘:math-suffix’ string value in a math environment after the table. The LaTeX export backend inserts ‘:math-arguments’ string value between the macro name and the table’s contents. ‘:math-arguments’ comes in use for matrix macros that require more than one argument, such as ‘qbordermatrix’.

LaTeX table attributes help formatting tables for a wide range of situations, such as matrix product or spanning multiple pages:

#+ATTR_LATEX: :environment longtable :align l|lp{3cm}r|l
| ... | ... |
| ... | ... |

#+ATTR_LATEX: :mode math :environment bmatrix :math-suffix \times
| a | b |
| c | d |
#+ATTR_LATEX: :mode math :environment bmatrix
| 1 | 2 |
| 3 | 4 |
Set the caption with the LaTeX command ‘\bicaption{HeadingA}{HeadingB}’:

#+ATTR_LATEX: :caption \bicaption{HeadingA}{HeadingB}
| ... | ... |
| ... | ... |


***** Images in LaTeX export

The LaTeX export backend processes image links in Org files that do not have descriptions, such as these links ‘[[file:img.jpg]]’ or ‘[[./img.jpg]]’, as direct image insertions in the final PDF output. In the PDF, they are no longer links but actual images embedded on the page. The LaTeX export backend uses ‘\includegraphics’ macro to insert the image. But for TikZ (https://sourceforge.net/projects/pgf/) images, the backend uses an \input macro wrapped within a tikzpicture environment.

For specifying image ‘:width’, ‘:height’, ‘:scale’ and other ‘:options’, use this syntax:

#+ATTR_LATEX: :width 5cm :options angle=90
[[./img/sed-hr4049.pdf]]
A ‘:scale’ attribute overrides both ‘:width’ and ‘:height’ attributes.

For custom commands for captions, use the ‘:caption’ attribute. It overrides the default ‘#+CAPTION’ value:

#+ATTR_LATEX: :caption \bicaption{HeadingA}{HeadingB}
[[./img/sed-hr4049.pdf]]
When captions follow the method as described in Captions, the LaTeX export backend wraps the picture in a floating ‘figure’ environment. To float an image without specifying a caption, set the ‘:float’ attribute to one of the following:

‘t’
For a default ‘figure’ environment.

‘multicolumn’
To span the image across multiple columns of a page; the backend wraps the image in a ‘figure*’ environment.

‘wrap’
For text to flow around the image on the right; the figure occupies the left half of the page.

‘sideways’
For a new page with the image sideways, rotated ninety degrees, in a ‘sidewaysfigure’ environment; overrides ‘:placement’ setting.

‘nil’
To avoid a ‘:float’ even if using a caption.

Any arbitrary value
For example, a user-defined float type with the ‘float’ LaTeX package.

Use the ‘placement’ attribute to modify a floating environment’s placement.

#+ATTR_LATEX: :float wrap :width 0.38\textwidth :placement {r}{0.4\textwidth}
[[./img/hst.png]]
The LaTeX export backend centers all images by default. Setting ‘:center’ to ‘nil’ disables centering. To disable centering globally, set org-latex-images-centered to ‘nil’.

Set the ‘:comment-include’ attribute to non-nil value for the LaTeX export backend to comment out the ‘\includegraphics’ macro.


***** Plain lists in LaTeX export

The LaTeX export backend accepts the ‘environment’ and ‘options’ attributes for plain lists. Both attributes work together for customizing lists, as shown in the examples:

#+LATEX_HEADER: \usepackage[inline]{enumitem}
Some ways to say "Hello":
#+ATTR_LATEX: :environment itemize*
#+ATTR_LATEX: :options [label={}, itemjoin={,}, itemjoin*={, and}]
- Hola
- Bonjour
- Guten Tag.
Since LaTeX supports only four levels of nesting for lists, use an external package, such as ‘enumitem’ in LaTeX, for levels deeper than four:

#+LATEX_HEADER: \usepackage{enumitem}
#+LATEX_HEADER: \renewlist{itemize}{itemize}{9}
#+LATEX_HEADER: \setlist[itemize]{label=$\circ$}
- One
  - Two
    - Three
      - Four
        - Five

***** Source blocks in LaTeX export

LaTeX export backend provides multiple ways to render src blocks in LaTeX, according to the value of org-latex-src-block-backend. The default value ‘verbatim’ renders the src code verbatim, without any extra styling. Alternative values allow more colorful styling, but require additional LaTeX (‘listings’, ‘minted’), system (‘minted’), or Emacs (‘engraved’) packages. See the org-latex-src-block-backend docstring for more details.

The LaTeX export backend can make source code blocks into floating objects through the attributes ‘:float’ and ‘:options’. For ‘:float’:

‘t’
Makes a source block float; by default floats any source block with a caption.

‘multicolumn’
Spans the source block across multiple columns of a page.

‘nil’
Avoids a ‘:float’ even if using a caption; useful for source code blocks that may not fit on a page.

#+ATTR_LATEX: :float nil
#+BEGIN_SRC emacs-lisp
  Lisp code that may not fit in a single page.
#+END_SRC
The LaTeX export backend passes string values in ‘:options’ to LaTeX packages for customization of that specific source block. In the example below, the ‘:options’ are set for Engraved or Minted. Minted is a source code highlighting LaTeX package with many configurable options139. Both Minted and Engraved are built on fvextra, and so support many of the same options.

#+ATTR_LATEX: :options mathescape
#+BEGIN_SRC emacs-lisp
  (defun Fib (n) ; $n_i = n_{i-2} + n_{i-1}$
    (if (< n 2) n (+ (Fib (- n 1)) (Fib (- n 2)))))
#+END_SRC
To apply similar configuration options for all source blocks in a file, use the org-latex-listings-options, org-latex-engraved-options, and org-latex-minted-options variables.

Footnotes
(139)
Minted uses an external Python package for code highlighting, which requires the flag ‘-shell-escape’ to be added to org-latex-pdf-process.


***** Example blocks in LaTeX export

The LaTeX export backend wraps the contents of example blocks in a ‘verbatim’ environment. To change this behavior to use another environment globally, specify an appropriate export filter (see Advanced Export Configuration). To change this behavior to use another environment for each block, use the ‘:environment’ parameter to specify a custom environment.

#+ATTR_LATEX: :environment myverbatim
#+BEGIN_EXAMPLE
  This sentence is false.
#+END_EXAMPLE


***** Special blocks in LaTeX export

For other special blocks in the Org file, the LaTeX export backend makes a special environment of the same name. The backend also takes ‘:options’, if any, and appends as-is to that environment’s opening string. For example:

#+BEGIN_abstract
  We demonstrate how to solve the Syracuse problem.
#+END_abstract

#+ATTR_LATEX: :options [Proof of important theorem]
#+BEGIN_proof
  ...
  Therefore, any even number greater than 2 is the sum of two primes.
#+END_proof
exports to

\begin{abstract}
  We demonstrate how to solve the Syracuse problem.
\end{abstract}

\begin{proof}[Proof of important theorem]
  ...
  Therefore, any even number greater than 2 is the sum of two primes.
\end{proof}
If you need to insert a specific caption command, use ‘:caption’ attribute. It overrides standard ‘CAPTION’ value, if any. For example:

#+ATTR_LATEX: :caption \MyCaption{HeadingA}
#+BEGIN_proof
  ...
#+END_proof

***** Horizontal rules in LaTeX export

The LaTeX export backend converts horizontal rules by the specified ‘:width’ and ‘:thickness’ attributes. For example:

#+ATTR_LATEX: :width .6\textwidth :thickness 0.8pt
-----

***** Verse blocks in LaTeX export

The LaTeX export backend accepts five attributes for verse blocks: ‘:lines’, ‘:center’, ‘:versewidth’, ‘:latexcode’ and ‘:literal’. The three first require the external LaTeX package ‘verse.sty’, which is an extension of the standard LaTeX environment.

‘:lines’
To add marginal verse numbering. Its value is an integer, the sequence in which the verses should be numbered.

‘:center’
With value ‘t’ all the verses on the page are optically centered (a typographic convention for poetry), taking as a reference the longest verse, which must be indicated by the attribute ‘:versewidth’.

‘:versewidth’
Its value is a literal text string with the longest verse.

‘:latexcode’
It accepts any arbitrary LaTeX code that can be included within a LaTeX ‘verse’ environment.

‘:literal’
With value t, all blank lines are preserved and exported as ‘\vspace*{\baselineskip}’, including the blank lines before or after contents. Note that without the ‘:literal’ attribute, one or more blank lines between stanzas are exported as a single blank line, and any blank lines before or after the content are removed, which is more consistent with the syntax of the LaTeX ‘verse’ environment, and the one provided by the ‘verse’ package. If the ‘verse’ package is loaded, the vertical spacing between all stanzas can be controlled by the global length ‘\stanzaskip’ (see https://www.ctan.org/pkg/verse).

A complete example with Shakespeare’s first sonnet:

#+ATTR_LATEX: :center t :latexcode \color{red} :lines 5
#+ATTR_LATEX: :versewidth Feed’st thy light’s flame with self-substantial fuel,
#+BEGIN_VERSE
From fairest creatures we desire increase,
That thereby beauty’s rose might never die,
But as the riper should by time decease
His tender heir might bear his memory
But thou, contracted to thine own bright eyes,
Feed’st thy light’s flame with self-substantial fuel,
Making a famine where abundance lies,
Thyself thy foe, to thy sweet self too cruel.
Thou that art now the world’s fresh ornament,
And only herald to the gaudy spring,
Within thine own bud buriest thy content,
And, tender churl, mak’st waste in niggardly.
Pity the world, or else this glutton be,
To eat the world’s due, by the grave and thee.
#+END_VERSE


***** Quote blocks in LaTeX export

The LaTeX export backend accepts two attributes for quote blocks: ‘:environment’, for an arbitrary quoting environment (the default value is that of org-latex-default-quote-environment: "quote") and ‘:options’. For example, to choose the environment ‘quotation’, included as an alternative to ‘quote’ in standard LaTeX classes:

#+ATTR_LATEX: :environment quotation
#+BEGIN_QUOTE
some text...
#+END_QUOTE
To choose the ‘foreigndisplayquote’ environment, included in the LaTeX package ‘csquotes’, with the ‘german’ option, use this syntax:

#+LATEX_HEADER:\usepackage[autostyle=true]{csquotes}
#+ATTR_LATEX: :environment foreigndisplayquote :options {german}
#+BEGIN_QUOTE
some text in German...
#+END_QUOTE
which is exported to LaTeX as

\begin{foreigndisplayquote}{german}
some text in German...
\end{foreigndisplayquote}

**** Markdown Export

The Markdown export backend, “md”, converts an Org file to Markdown format, as defined at https://daringfireball.net/projects/markdown/. This is the original Markdown specification, developed by John Gruber and Aaron Swartz.

Since “md” backend is built on top of the HTML backend (see HTML Export), it converts every Org construct not defined in Markdown syntax, such as tables, to HTML.

Do note that the original markdown syntax has differences with other commonly used Markdown flavors. See https://en.wikipedia.org/wiki/Markdown for more details.

Markdown export commands
C-c C-e m m (org-md-export-to-markdown)
Export to a text file with Markdown syntax. For ‘myfile.org’, Org exports to ‘myfile.md’, overwritten without warning.

C-c C-e m M (org-md-export-as-markdown)
Export to a temporary buffer. Does not create a file.

C-c C-e m o
Export as a text file with Markdown syntax, then open it.

Header and sectioning structure
Based on org-md-headline-style, Markdown export can generate headlines of both atx and setext types. setext limits headline levels to two whereas atx limits headline levels to six. mixed exports headline levels one and two in setext-style, and headline levels three through six as atx-style headlines. Beyond these limits, the export backend converts headlines to lists. To set a limit to a level before the absolute limit (see Export Settings).


**** OpenDocument Text Export

The ODT export backend handles creating of OpenDocument Text (ODT) format. Documents created by this exporter use the OpenDocument-v1.2 specification140 and are compatible with LibreOffice 3.4.

***** Pre-requisites for ODT export

The ODT export backend relies on the zip program to create the final compressed ODT output. Check if ‘zip’ is locally available and executable. Without it, export cannot finish.


***** ODT export commands

C-c C-e o o (org-odt-export-to-odt)
Export as OpenDocument Text file.

If org-odt-preferred-output-format is specified, the ODT export backend automatically converts the exported file to that format.

For ‘myfile.org’, Org exports to ‘myfile.odt’, overwriting without warning. The ODT export backend exports a region only if a region was active.

If the selected region is a single tree, the ODT export backend makes the tree head the document title. Incidentally, C-c @ selects the current subtree. If the tree head entry has, or inherits, an ‘EXPORT_FILE_NAME’ property, the ODT export backend uses that for file name.

C-c C-e o O
Export as an OpenDocument Text file and open the resulting file.

If org-export-odt-preferred-output-format is specified, open the converted file instead. See Automatically exporting to other formats.


***** ODT specific export settings

The ODT export backend has several additional keywords for customizing ODT output. Setting these keywords works similar to the general options (see Export Settings).

‘DESCRIPTION’
This is the document’s description, which the ODT export backend inserts as document metadata. For long descriptions, use multiple lines, prefixed with ‘DESCRIPTION’.

‘KEYWORDS’
The keywords for the document. The ODT export backend inserts the description along with author name, keywords, and related file metadata as metadata in the output file. Use multiple ‘KEYWORDS’ if necessary.

‘ODT_STYLES_FILE’
The ODT export backend uses the org-odt-styles-file by default. See Applying custom styles for details.

‘SUBTITLE’
The document subtitle.


***** Extending ODT export

The ODT export backend can produce documents in other formats besides ODT using a specialized ODT converter process. Its common interface works with popular converters to produce formats such as ‘doc’, or convert a document from one format, say ‘csv’, to another format, say ‘xls’.

Customize org-odt-convert-process variable to point to ‘unoconv’, which is the ODT’s preferred converter. Working installations of LibreOffice would already have ‘unoconv’ installed. Alternatively, other converters may be substituted here. See Configuring a document converter.

Automatically exporting to other formats
If ODT format is just an intermediate step to get to other formats, such as ‘doc’, ‘docx’, ‘rtf’, or ‘pdf’, etc., then extend the ODT export backend to directly produce that format. Specify the final format in the org-odt-preferred-output-format variable. This is one way to extend (see ODT export commands).

Converting between document formats
The Org export backend is made to be inter-operable with a wide range of text document format converters. Newer generation converters, such as LibreOffice and Pandoc, can handle hundreds of formats at once. Org provides a consistent interaction with whatever converter is installed. Here are some generic commands:

M-x org-odt-convert
Convert an existing document from one format to another. With a prefix argument, opens the newly produced file.


***** Applying custom styles

The ODT export backend comes with many OpenDocument styles (see Working with OpenDocument style files). To expand or further customize these built-in style sheets, either edit the style sheets directly or generate them using an application such as LibreOffice. The example here shows creating a style using LibreOffice.

Applying custom styles: the easy way
Create a sample ‘example.org’ file with settings as shown below, and export it to ODT format.
#+OPTIONS: H:10 num:t
Open the above ‘example.odt’ using LibreOffice. Use the Stylist to locate the target styles, which typically have the “Org” prefix. Open one, modify, and save as either OpenDocument Text (ODT) or OpenDocument Template (OTT) file.
Customize the variable org-odt-styles-file and point it to the newly created file. For additional configuration options, see Overriding factory styles.
To apply an ODT style to a particular file, use the ‘ODT_STYLES_FILE’ keyword as shown in the example below:

#+ODT_STYLES_FILE: "/path/to/example.ott"
or

#+ODT_STYLES_FILE: ("/path/to/file.ott" ("styles.xml" "image/hdr.png"))
Using third-party styles and templates
The ODT export backend relies on many templates and style names. Using third-party styles and templates can lead to mismatches. Templates derived from built-in ODT templates and styles seem to have fewer problems.


***** Links in ODT export

ODT exporter creates native cross-references for internal links. It creates Internet-style links for all other links.

A link with no description and pointing to a regular, un-itemized, outline heading is replaced with a cross-reference and section number of the heading.

A ‘\ref{label}’-style reference to an image, table etc., is replaced with a cross-reference and sequence number of the labeled entity. See Labels and captions in ODT export.


***** Tables in ODT export

The ODT export backend handles native Org mode tables (see Tables) and simple ‘table.el’ tables. Complex ‘table.el’ tables having column or row spans are not supported. Such tables are stripped from the exported document.

By default, the ODT export backend exports a table with top and bottom frames and with ruled lines separating row and column groups (see Column Groups). All tables are typeset to occupy the same width. The ODT export backend honors any table alignments and relative widths for columns (see Column Width and Alignment).

Note that the ODT export backend interprets column widths as weighted ratios, the default weight being 1.

Specifying ‘:rel-width’ property on an ‘ATTR_ODT’ line controls the width of the table. For example:

#+ATTR_ODT: :rel-width 50
| Area/Month    |   Jan |   Feb |   Mar |   Sum |
|---------------+-------+-------+-------+-------|
| /             |     < |       |       |     < |
| <l13>         |  <r5> |  <r5> |  <r5> |  <r6> |
| North America |     1 |    21 |   926 |   948 |
| Middle East   |     6 |    75 |   844 |   925 |
| Asia Pacific  |     9 |    27 |   790 |   826 |
|---------------+-------+-------+-------+-------|
| Sum           |    16 |   123 |  2560 |  2699 |
On export, the above table takes 50% of text width area. The exporter sizes the columns in the ratio: 13:5:5:5:6. The first column is left-aligned and rest of the columns, right-aligned. Vertical rules separate the header and the last column. Horizontal rules separate the header and the last row.

For even more customization, create custom table styles and associate them with a table using the ‘ATTR_ODT’ keyword. See Customizing tables in ODT export.


***** Images in ODT export

Embedding images
The ODT export backend processes image links in Org files that do not have descriptions, such as these links ‘[[file:img.jpg]]’ or ‘[[./img.jpg]]’, as direct image insertions in the final output. Either of these examples works:

[[file:img.png]]
[[./img.png]]
Embedding clickable images
For clickable images, provide a link whose description is another link to an image file. For example, to embed an image ‘org-mode-unicorn.png’ which when clicked jumps to https://orgmode.org website, do the following

[[https://orgmode.org][./org-mode-unicorn.png]]
Sizing and scaling of embedded images
Control the size and scale of the embedded images with the ‘ATTR_ODT’ attribute.

The ODT export backend starts with establishing the size of the image in the final document. The dimensions of this size are measured in centimeters. The backend then queries the image file for its dimensions measured in pixels. For this measurement, the backend relies on ImageMagick’s identify program or Emacs create-image and image-size API. ImageMagick is the preferred choice for large file sizes or frequent batch operations. The backend then converts the pixel dimensions using org-odt-pixels-per-inch into the familiar 72 dpi or 96 dpi. The default value for this is in display-pixels-per-inch, which can be tweaked for better results based on the capabilities of the output device. Here are some common image scaling operations:

Explicitly size the image
To embed ‘img.png’ as a 10 cm x 10 cm image, do the following:

#+ATTR_ODT: :width 10 :height 10
[[./img.png]]
Scale the image
To embed ‘img.png’ at half its size, do the following:

#+ATTR_ODT: :scale 0.5
[[./img.png]]
Scale the image to a specific width
To embed ‘img.png’ with a width of 10 cm while retaining the original height:width ratio, do the following:

#+ATTR_ODT: :width 10
[[./img.png]]
Scale the image to a specific height
To embed ‘img.png’ with a height of 10 cm while retaining the original height:width ratio, do the following:

#+ATTR_ODT: :height 10
[[./img.png]]
Anchoring of images
The ODT export backend can anchor images to ‘as-char’, ‘paragraph’, or ‘page’. Set the preferred anchor using the ‘:anchor’ property of the ‘ATTR_ODT’ line.

To create an image that is anchored to a page:

#+ATTR_ODT: :anchor page
[[./img.png]]


***** Math formatting in ODT export

The ODT exporter has special support for handling math.

****** LaTeX math snippets

LaTeX math snippets (see LaTeX fragments) can be embedded in the ODT document in one of the following ways:

MathML
Add this line to the Org file. This option is activated on a per-file basis.

#+OPTIONS: tex:t
With this option, LaTeX fragments are first converted into MathML fragments using an external LaTeX-to-MathML converter program. The resulting MathML fragments are then embedded as an OpenDocument Formula in the exported document.

You can specify the LaTeX-to-MathML converter by customizing the variables org-latex-to-mathml-convert-command and org-latex-to-mathml-jar-file.

If you prefer to use MathToWeb141 as your converter, you can configure the above variables as shown below.

(setq org-latex-to-mathml-convert-command
      "java -jar %j -unicode -force -df %o %I"
      org-latex-to-mathml-jar-file
      "/path/to/mathtoweb.jar")
or, to use LaTeX​ML142 instead,

(setq org-latex-to-mathml-convert-command
      "latexmlmath %i --presentationmathml=%o")
To quickly verify the reliability of the LaTeX-to-MathML converter, use the following commands:

M-x org-export-as-odf
Convert a LaTeX math snippet to an OpenDocument formula (‘.odf’) file.

M-x org-export-as-odf-and-open
Convert a LaTeX math snippet to an OpenDocument formula (‘.odf’) file and open the formula file with the system-registered application.

PNG images
Add this line to the Org file. This option is activated on a per-file basis.

#+OPTIONS: tex:dvipng
#+OPTIONS: tex:dvisvgm
or

#+OPTIONS: tex:imagemagick
Under this option, LaTeX fragments are processed into PNG or SVG images and the resulting images are embedded in the exported document. This method requires dvipng program, dvisvgm or ImageMagick programs.

Footnotes
(141)
See MathToWeb.

(142)
See https://dlmf.nist.gov/LaTeXML/.


****** MathML and OpenDocument formula files

When embedding LaTeX math snippets in ODT documents is not reliable, there is one more option to try. Embed an equation by linking to its MathML (‘.mml’) source or its OpenDocument formula (‘.odf’) file as shown below:

[[./equation.mml]]
or

[[./equation.odf]]


***** Labels and captions in ODT export

ODT format handles labeling and captioning of objects based on their types. Inline images, tables, LaTeX fragments, and Math formulas are numbered and captioned separately. Each object also gets a unique sequence number based on its order of first appearance in the Org file. Each category has its own sequence. A caption is just a label applied to these objects.

#+CAPTION: Bell curve
#+NAME:   fig:SED-HR4049
[[./img/a.png]]
When rendered, it may show as follows in the exported document:

Figure 2: Bell curve
To modify the category component of the caption, customize the option org-odt-category-map-alist. For example, to tag embedded images with the string “Illustration” instead of the default string “Figure”, use the following setting:

(setq org-odt-category-map-alist
      '(("__Figure__" "Illustration" "value" "Figure" org-odt--enumerable-image-p)))
With the above modification, the previous example changes to:

Illustration 2: Bell curve


***** Literal examples in ODT export

The ODT export backend supports literal examples (see Literal Examples) with full fontification. Internally, the ODT export backend relies on ‘htmlfontify.el’ to generate the style definitions needed for fancy listings. The auto-generated styles get ‘OrgSrc’ prefix and inherit colors from the faces used by Emacs Font Lock library for that source language.

For custom fontification styles, customize the org-odt-create-custom-styles-for-srcblocks option.

To turn off fontification of literal examples, customize the org-odt-fontify-srcblocks option.


***** Advanced topics in ODT export

The ODT export backend has extensive features useful for power users and frequent uses of ODT formats.

Configuring a document converter
The ODT export backend works with popular converters with little or no extra configuration. See Extending ODT export. The following is for unsupported converters or tweaking existing defaults.

Register the converter
Add the name of the converter to the org-odt-convert-processes variable. Note that it also requires how the converter is invoked on the command line. See the variable’s docstring for details.

Configure its capabilities
Specify which formats the converter can handle by customizing the variable org-odt-convert-capabilities. Use the entry for the default values in this variable for configuring the new converter. Also see its docstring for details.

Choose the converter
Select the newly added converter as the preferred one by customizing the option org-odt-convert-process.

Working with OpenDocument style files
This section explores the internals of the ODT exporter; the means by which it produces styled documents; the use of automatic and custom OpenDocument styles.

The ODT exporter relies on two files for generating its output. These files are bundled with the distribution under the directory pointed to by the variable org-odt-styles-dir. The two files are:

‘OrgOdtStyles.xml’
This file contributes to the ‘styles.xml’ file of the final ODT document. This file gets modified for the following purposes:

To control outline numbering based on user settings;
To add styles generated by ‘htmlfontify.el’ for fontification of code blocks.
‘OrgOdtContentTemplate.xml’
This file contributes to the ‘content.xml’ file of the final ODT document. The contents of the Org outline are inserted between the ‘<office:text>’ … ‘</office:text>’ elements of this file.

Apart from serving as a template file for the final ‘content.xml’, the file serves the following purposes:

It contains automatic styles for formatting of tables which are referenced by the exporter;
It contains ‘<text:sequence-decl>’ … ‘</text:sequence-decl>’ elements that control numbering of tables, images, equations, and similar entities.
The following two variables control the location from where the ODT exporter picks up the custom styles and content template files. Customize these variables to override the factory styles used by the exporter.

org-odt-styles-file
The ODT export backend uses the file pointed to by this variable, such as ‘styles.xml’, for the final output. It can take one of the following values:

‘FILE.xml’
Use this file instead of the default ‘styles.xml’

‘FILE.odt’ or ‘FILE.ott’
Use the ‘styles.xml’ contained in the specified OpenDocument Text or Template file

‘FILE.odt’ or ‘FILE.ott’ and a subset of included files
Use the ‘styles.xml’ contained in the specified OpenDocument Text or Template file. Additionally extract the specified member files and embed those within the final ODT document.

Use this option if the ‘styles.xml’ file references additional files like header and footer images.

nil
Use the default ‘styles.xml’.

org-odt-content-template-file
Use this variable to specify the blank ‘content.xml’ used in the final output.

Creating one-off styles
The ODT export backend can read embedded raw OpenDocument XML from the Org file. Such direct formatting is useful for one-off instances.

Embedding ODT tags as part of regular text
Enclose OpenDocument syntax in ‘@@odt:...@@’ for inline markup. For example, to highlight a region of text do the following:

@@odt:<text:span text:style-name="Highlight">This is highlighted
text</text:span>@@.  But this is regular text.
Hint: To see the above example in action, edit the ‘styles.xml’ (see Factory styles) and add a custom Highlight style as shown below:

<style:style style:name="Highlight" style:family="text">
  <style:text-properties fo:background-color="#ff0000"/>
</style:style>
Embedding a one-line OpenDocument XML
The ODT export backend can read one-liner options with ‘#+ODT:’ in the Org file. For example, to force a page break:

#+ODT: <text:p text:style-name="PageBreak"/>
Hint: To see the above example in action, edit your ‘styles.xml’ (see Factory styles) and add a custom ‘PageBreak’ style as shown below.

<style:style style:name="PageBreak" style:family="paragraph"
             style:parent-style-name="Text_20_body">
  <style:paragraph-properties fo:break-before="page"/>
</style:style>
Embedding a block of OpenDocument XML
The ODT export backend can also read ODT export blocks for OpenDocument XML. Such blocks use the ‘#+BEGIN_EXPORT odt’ … ‘#+END_EXPORT’ constructs.

For example, to create a one-off paragraph that uses bold text, do the following:

#+BEGIN_EXPORT odt
  <text:p text:style-name="Text_20_body_20_bold">
  This paragraph is specially formatted and uses bold text.
  </text:p>
#+END_EXPORT
Customizing tables in ODT export
Override the default table format by specifying a custom table style with the ‘#+ATTR_ODT’ line. For a discussion on default formatting of tables, see Tables in ODT export.

This feature closely mimics the way table templates are defined in the OpenDocument-v1.2 specification143.

For quick preview of this feature, install the settings below and export the table that follows:

(setq org-export-odt-table-styles
      (append org-export-odt-table-styles
              '(("TableWithHeaderRowAndColumn" "Custom"
                 ((use-first-row-styles . t)
                  (use-first-column-styles . t)))
                ("TableWithFirstRowandLastRow" "Custom"
                 ((use-first-row-styles . t)
                  (use-last-row-styles . t))))))
#+ATTR_ODT: :style TableWithHeaderRowAndColumn
| Name  | Phone | Age |
| Peter |  1234 |  17 |
| Anna  |  4321 |  25 |
The example above used ‘Custom’ template and installed two table styles ‘TableWithHeaderRowAndColumn’ and ‘TableWithFirstRowandLastRow’. Important: The OpenDocument styles needed for producing the above template were pre-defined. They are available in the section marked ‘Custom Table Template’ in ‘OrgOdtContentTemplate.xml’ (see Factory styles). For adding new templates, define new styles there.

To use this feature proceed as follows:

Create a table template144.
A table template is set of ‘table-cell’ and ‘paragraph’ styles for each of the following table cell categories:

Body
First column
Last column
First row
Last row
Even row
Odd row
Even column
Odd Column
The names for the above styles must be chosen based on the name of the table template using a well-defined convention.

The naming convention is better illustrated with an example. For a table template with the name ‘Custom’, the needed style names are listed in the following table.

Cell type	Cell style	Paragraph style
Body	‘CustomTableCell’	‘CustomTableParagraph’
First column	‘CustomFirstColumnTableCell’	‘CustomFirstColumnTableParagraph’
Last column	‘CustomLastColumnTableCell’	‘CustomLastColumnTableParagraph’
First row	‘CustomFirstRowTableCell’	‘CustomFirstRowTableParagraph’
Last row	‘CustomLastRowTableCell’	‘CustomLastRowTableParagraph’
Even row	‘CustomEvenRowTableCell’	‘CustomEvenRowTableParagraph’
Odd row	‘CustomOddRowTableCell’	‘CustomOddRowTableParagraph’
Even column	‘CustomEvenColumnTableCell’	‘CustomEvenColumnTableParagraph’
Odd column	‘CustomOddColumnTableCell’	‘CustomOddColumnTableParagraph’
To create a table template with the name ‘Custom’, define the above styles in the ‘<office:automatic-styles>’ … ‘</office:automatic-styles>’ element of the content template file (see Factory styles).

Define a table style145.
To define a table style, create an entry for the style in the variable org-odt-table-styles and specify the following:

the name of the table template created in step (1),
the set of cell styles in that template that are to be activated.
For example, the entry below defines two different table styles ‘TableWithHeaderRowAndColumn’ and ‘TableWithFirstRowandLastRow’ based on the same template ‘Custom’. The styles achieve their intended effect by selectively activating the individual cell styles in that template.

(setq org-export-odt-table-styles
      (append org-export-odt-table-styles
              '(("TableWithHeaderRowAndColumn" "Custom"
                 ((use-first-row-styles . t)
                  (use-first-column-styles . t)))
                ("TableWithFirstRowandLastRow" "Custom"
                 ((use-first-row-styles . t)
                  (use-last-row-styles . t))))))
Associate a table with the table style.
To do this, specify the table style created in step (2) as part of the ‘ATTR_ODT’ line as shown below.

#+ATTR_ODT: :style TableWithHeaderRowAndColumn
| Name  | Phone | Age |
| Peter |  1234 |  17 |
| Anna  |  4321 |  25 |
Validating OpenDocument XML
Sometimes ODT format files may not open due to ‘.odt’ file corruption. To verify if such a file is corrupt, validate it against the OpenDocument Relax NG Compact (RNC) syntax schema. But first the ‘.odt’ files have to be decompressed using ‘zip’. Note that ‘.odt’ files are ZIP archives: (emacs)File Archives. The contents of ODT files are in XML. For general help with validation—and schema-sensitive editing—of XML files: (nxml-mode)Introduction.

Customize org-odt-schema-dir to point to a directory with OpenDocument RNC files and the needed schema-locating rules. The ODT export backend takes care of updating the rng-schema-locating-files.

Footnotes
(143)
OpenDocument-v1.2 Specification

(144)
See the ‘<table:table-template>’ element of the OpenDocument-v1.2 specification.

(145)
See the attributes ‘table:template-name’, ‘table:use-first-row-styles’, ‘table:use-last-row-styles’, ‘table:use-first-column-styles’, ‘table:use-last-column-styles’, ‘table:use-banding-rows-styles’, and ‘table:use-banding-column-styles’ of the ‘<table:table>’ element in the OpenDocument-v1.2 specification.


**** Org Export

org export backend creates a normalized version of the Org document in current buffer. The exporter evaluates Babel code (see Evaluating Code Blocks) and removes content specific to other backends.

Org export commands
C-c C-e O o (org-org-export-to-org)
Export as an Org file with a ‘.org’ extension. For ‘myfile.org’, Org exports to ‘myfile.org.org’, overwriting without warning.

C-c C-e O v (~~)
Export to an Org file, then open it.


**** Texinfo Export

***** Texinfo export commands

C-c C-e i t (org-texinfo-export-to-texinfo)
Export as a Texinfo file with ‘.texi’ extension. For ‘myfile.org’, Org exports to ‘myfile.texi’, overwriting without warning.

C-c C-e i i (org-texinfo-export-to-info)
Export to Texinfo format first and then process it to make an Info file. To generate other formats, such as DocBook, customize the org-texinfo-info-process variable.


***** Texinfo specific export settings

The Texinfo export backend has several additional keywords for customizing Texinfo output. Setting these keywords works similar to the general options (see Export Settings).

‘SUBTITLE’
The document subtitle.

‘SUBAUTHOR’
Additional authors for the document.

‘TEXINFO_FILENAME’
The Texinfo filename.

‘TEXINFO_CLASS’
The default document class (org-texinfo-default-class), which must be a member of org-texinfo-classes.

‘TEXINFO_HEADER’
Arbitrary lines inserted at the end of the header.

‘TEXINFO_POST_HEADER’
Arbitrary lines inserted after the end of the header.

‘TEXINFO_DIR_CATEGORY’
The directory category of the document. Defaults to Misc.

‘TEXINFO_DIR_NAME’
The directory name of the document. This is the short name under which the m command will find your manual in the main Info directory. It defaults to the base name of the Texinfo file.

The full form of the Texinfo entry is * DIRNAME: NODE. where NODE is usually just (FILENAME). Normally this option only provides the DIRNAME part, but if you need more control, it can also be the full entry (recognized by the presence of parentheses or a leading ~* ~).

‘TEXINFO_DIR_DESC’
The directory description of the document. Defaults to the title of the document.

‘TEXINFO_PRINTED_TITLE’
The printed title of the document.


***** Texinfo file header

After creating the header for a Texinfo file, the Texinfo backend automatically generates a name and destination path for the Info file. To override this default with a more sensible path and name, specify the ‘TEXINFO_FILENAME’ keyword.

Along with the output’s file name, the Texinfo header also contains language details (see Export Settings) and encoding system as set in the org-texinfo-coding-system variable. Insert ‘TEXINFO_HEADER’ keywords for each additional command in the header, for example:

#+TEXINFO_HEADER: @synindex
Instead of repeatedly installing the same set of commands, define a class in org-texinfo-classes once, and then activate it in the document by setting the ‘TEXINFO_CLASS’ keyword to that class.


***** Texinfo title and copyright page

The default template for hard copy output has a title page with ‘TITLE’ and ‘AUTHOR’ keywords (see Export Settings). To replace the regular title with something different for the printed version, use the ‘TEXINFO_PRINTED_TITLE’ and ‘SUBTITLE’ keywords. Both expect raw Texinfo code for setting their values.

If one ‘AUTHOR’ line is not sufficient, add multiple ‘SUBAUTHOR’ keywords. They have to be set in raw Texinfo code.

#+AUTHOR: Jane Smith
#+SUBAUTHOR: John Doe
#+TEXINFO_PRINTED_TITLE: This Long Title@@inlinefmt{tex,@*} Is Broken in @TeX{}
Copying material is defined in a dedicated headline with a non-nil ‘COPYING’ property. The backend inserts the contents within a ‘@copying’ command at the beginning of the document. The heading itself does not appear in the structure of the document.

Copyright information is printed on the back of the title page.

;* Legalese
  :PROPERTIES:
  :COPYING: t
  :END:

  This is a short example of a complete Texinfo file, version 1.0.

  Copyright \copy 2016 Free Software Foundation, Inc.


***** Info directory file

The end result of the Texinfo export process is the creation of an Info file. This Info file’s metadata has variables for category, title, and description: ‘TEXINFO_DIR_CATEGORY’, ‘TEXINFO_DIR_NAME’, and ‘TEXINFO_DIR_DESC’ keywords that establish where in the Info hierarchy the file fits.

Here is an example that writes to the Info directory file:

#+TEXINFO_DIR_CATEGORY: Emacs
#+TEXINFO_DIR_NAME: Org Mode
#+TEXINFO_DIR_DESC: Outline-based notes management and organizer


***** Headings and sectioning structure

The Texinfo export backend uses a pre-defined scheme to convert Org headlines to equivalent Texinfo structuring commands. A scheme like this maps top-level headlines to numbered chapters tagged as @chapter and lower-level headlines to unnumbered chapters tagged as @unnumbered. To override such mappings to introduce @part or other Texinfo structuring commands, define a new class in org-texinfo-classes. Activate the new class with the ‘TEXINFO_CLASS’ keyword. When no new class is defined and activated, the Texinfo export backend defaults to the org-texinfo-default-class.

If an Org headline’s level has no associated Texinfo structuring command, or is below a certain threshold (see Export Settings), then the Texinfo export backend makes it into a list item.

The Texinfo export backend makes any headline with a non-nil ‘APPENDIX’ property into an appendix. This happens independent of the Org headline level or the ‘TEXINFO_CLASS’ keyword.

The Texinfo export backend creates a menu entry after the Org headline for each regular sectioning structure. To override this with a shorter menu entry, use the ‘ALT_TITLE’ property (see Table of Contents). Texinfo menu entries also have an option for a longer ‘DESCRIPTION’ property. Here’s an example that uses both to override the default menu entry:

;* Controlling Screen Display
  :PROPERTIES:
  :ALT_TITLE: Display
  :DESCRIPTION: Controlling Screen Display
  :END:
The text before the first headline belongs to the Top node, i.e., the node in which a reader enters an Info manual. As such, it is expected not to appear in printed output generated from the ‘.texi’ file. See (texinfo)The Top Node, for more information.


***** Indices

The Texinfo export backend recognizes these indexing keywords if used in the Org file: ‘CINDEX’, ‘FINDEX’, ‘KINDEX’, ‘PINDEX’, ‘TINDEX’ and ‘VINDEX’. Write their value as verbatim Texinfo code; in particular, ‘{’, ‘}’ and ‘@’ characters need to be escaped with ‘@’ if they do not belong to a Texinfo command.

#+CINDEX: Defining indexing entries
For the backend to generate an index entry for a headline, set the ‘INDEX’ property to ‘cp’ or ‘vr’. These abbreviations come from Texinfo that stand for concept index and variable index. The Texinfo manual has abbreviations for all other kinds of indexes. The backend exports the headline as an unnumbered chapter or section command, and then inserts the index after its contents.

;* Concept Index
  :PROPERTIES:
  :INDEX: cp
  :END:

***** Quoting Texinfo code

Use any of the following three methods to insert or escape raw Texinfo code:

Richard @@texinfo:@sc{@@Stallman@@texinfo:}@@ commence' GNU.

#+TEXINFO: @need800
This paragraph is preceded by...

#+BEGIN_EXPORT texinfo
  @auindex Johnson, Mark
  @auindex Lakoff, George
#+END_EXPORT


***** Plain lists in Texinfo export

The Texinfo export backend converts unordered and ordered lists in the Org file using the default command ‘@itemize’.

Ordered lists are numbered when exported to Texinfo format. Such numbering obeys any counter (see Plain Lists) in the first item of the list. The ‘:enum’ attribute also let you start the list at a specific number, or switch to a lettered list, as illustrated here:

#+ATTR_TEXINFO: :enum A
1. Alpha
2. Bravo
3. Charlie
The Texinfo export backend by default converts description lists in the Org file using the default command ‘@table’, which results in a table with two columns. To change this behavior, set ‘:table-type’ attribute to either ‘ftable’ or ‘vtable’ value. For more information, see (texinfo)Two-column Tables.

The Texinfo export backend by default also applies a text highlight based on the defaults stored in org-texinfo-table-default-markup. To override the default highlight command, specify another one with the ‘:indic’ attribute.

Org syntax is limited to one entry per list item. Nevertheless, the Texinfo export backend can split that entry according to any text provided through the ‘:sep’ attribute. Each part then becomes a new entry in the first column of the table.

The following example illustrates all the attributes above:

#+ATTR_TEXINFO: :table-type vtable :sep , :indic asis
- foo, bar :: This is the common text for variables foo and bar.
becomes

@vtable @asis
@item foo
@itemx bar
This is the common text for variables foo and bar.
@end table
The ‘:compact’ attribute is an alternative to the ‘:sep’ attribute, which allows writing each entry on its own line. If this attribute is non-nil and an item in a description list has no body but is followed by another item, then the second item is transcoded to ‘@itemx’. This example is transcoded to the same output as above.

#+ATTR_TEXINFO: :table-type vtable :indic asis :compact t
- foo ::
- bar ::
  This is the common text for variables foo and bar.
Support for this compact syntax can also be enabled for all lists in a file using the ‘compact-itemx’ export option, or globally using the variable org-texinfo-compact-itemx.

The Texinfo export backend also supports two approaches to writing Texinfo definition commands (see (texinfo)Definition Commands). One of them uses description lists and is described below, the other relies on special blocks (see Special blocks in Texinfo export).

Items in a description list in an Org file that begin with ‘Function:’ or certain other prefixes are converted using Texinfo definition commands. This works even if other items in the same list do not have such a prefix; if necessary a single description list is converted using multiple tables (such as ‘@vtable’) and definition commands (such as ‘@defun’).

- Function: org-texinfo-drawer drawer contents info ::
  Transcode a DRAWER element from Org to Texinfo.
becomes

@defun org-texinfo-drawer drawer contents info ::
  Transcode a DRAWER element from Org to Texinfo.
@end defun
The recognized prefixes are ‘Command:’, ‘Function:’, ‘Macro:’, ‘Special Form:’, ‘Variable:’ and ‘User Option:’. These are the same prefixes that appear in the Info file for the respective definition commands. For example a ‘Function:’ item in the Org file is converted to a ‘@defun’ command in the Texinfo file, which in turn is converted to a definition prefixed with ‘-- Function:’ in the Info file.

As a special case the prefix ‘Key:’ is also recognized. No Texinfo definition command exists for key bindings and the output in Info files also lacks the ‘Key:’ prefix. Even so this special case is supported because it provides a convenient shorthand, as illustrated here:

- Key: C-c C-c (do-something) ::
  This command does something.

- User Option: do-something-somehow ::
  This option controls how exactly ~do-something~ does its thing.
becomes

@table @asis
@item @kbd{C-c C-c} (@code{do-something})
@kindex C-c C-c
@findex do-something
This command does something.
@end table

@defopt do-something-somehow
This option controls how exactly @code{do-something} does its thing.
@end defopt
Command in parenthesis, as done above, is optional.


***** Tables in Texinfo export

When exporting tables, the Texinfo export backend uses the widest cell width in each column. To override this and instead specify as fractions of line length, use the ‘:columns’ attribute. See example below.

#+ATTR_TEXINFO: :columns .5 .5
| a cell | another cell |


***** Images in Texinfo export

Insert a file link to the image in the Org file, and the Texinfo export backend inserts the image. These links must have the usual supported image extensions and no descriptions. To scale the image, use ‘:width’ and ‘:height’ attributes. For alternate text, use ‘:alt’ and specify the text using Texinfo code, as shown in the example:

#+ATTR_TEXINFO: :width 1in :alt Alternate @i{text}
[[ridt.pdf]]


***** Quotations in Texinfo export

You can write the text of a quotation within a quote block (see Paragraphs). You may also emphasize some text at the beginning of the quotation with the ‘:tag’ attribute.

#+ATTR_TEXINFO: :tag Warning
#+BEGIN_QUOTE
Striking your thumb with a hammer may cause severe pain and discomfort.
#+END_QUOTE
To specify the author of the quotation, use the ‘:author’ attribute.

#+ATTR_TEXINFO: :author King Arthur
#+BEGIN_QUOTE
The Lady of the Lake, her arm clad in the purest shimmering samite,
held aloft Excalibur from the bosom of the water, signifying by divine
providence that I, Arthur, was to carry Excalibur.  That is why I am
your king.
#+END_QUOTE


***** Key bindings in Texinfo export

Org does not provide any markup for key bindings that corresponds to Texinfo’s @kbd and @key commands. One way to deal with this is to fall back to code syntax. ‘~C-x SPC~’, for example, is transcoded to @code{C-x SPC}.

A better approach is to define and use an Org macro named kbd. To make that easier the function org-texinfo-kbd-macro is provided, which is intended to be used like this:

#+macro: kbd (eval (org-texinfo-kbd-macro $1))

Type {{{kbd(C-c SPC)}}}.
which becomes

Type @kbd{C-c @key{SPC}}.


***** Special blocks in Texinfo export

The Texinfo export backend supports two approaches to writing Texinfo definition commands. One of them is described here, the other in Plain lists in Texinfo export.

The Texinfo export backend converts special blocks to commands with the same name. It also adds any ‘:options’ attributes to the end of the command, as shown in this example:

#+ATTR_TEXINFO: :options org-org-export-to-org ...
#+BEGIN_defun
  A somewhat obsessive function name.
#+END_defun
becomes

@defun org-org-export-to-org ...
  A somewhat obsessive function name.
@end defun


***** A Texinfo example

Here is a more detailed example Org file. See (texinfo)GNU Sample Texts for an equivalent example using Texinfo code.

#+title:      Emacs manual
#+SUBTITLE: for version {{{version}}}, {{{updated}}}
#+AUTHOR: A.U. Thor
#+EMAIL: bug-sample@gnu.org

#+OPTIONS: ':t toc:t author:t email:t
#+LANGUAGE: en

#+MACRO: version 2.0
#+MACRO: updated last updated 4 March 2014

#+TEXINFO_FILENAME: sample.info
#+TEXINFO_HEADER: @syncodeindex pg cp

#+TEXINFO_DIR_CATEGORY: Texinfo documentation system
#+TEXINFO_DIR_NAME: sample
#+TEXINFO_DIR_DESC: Invoking sample

#+TEXINFO_PRINTED_TITLE: GNU Sample

This manual is for GNU Sample (version {{{version}}},
{{{updated}}}).

;* Copying
  :PROPERTIES:
  :COPYING:  t
  :END:

  This manual is for GNU Sample (version {{{version}}},
  {{{updated}}}), which is an example in the Texinfo documentation.

  Copyright \copy 2016 Free Software Foundation, Inc.

  #+BEGIN_QUOTE
  Permission is granted to copy, distribute and/or modify this
  document under the terms of the GNU Free Documentation License,
  Version 1.3 or any later version published by the Free Software
  Foundation; with no Invariant Sections, with no Front-Cover Texts,
  and with no Back-Cover Texts.  A copy of the license is included in
  the section entitled "GNU Free Documentation License".
  #+END_QUOTE

;* Invoking sample

  #+PINDEX: sample
  #+CINDEX: invoking @command{sample}

  This is a sample manual.  There is no sample program to invoke, but
  if there were, you could see its basic usage and command line
  options here.

;* GNU Free Documentation License
  :PROPERTIES:
  :APPENDIX: t
  :END:

  #+INCLUDE: fdl.org

;* Index
  :PROPERTIES:
  :INDEX:    cp
  :END:


**** iCalendar Export

A large part of Org mode’s interoperability success is its ability to easily export to or import from external applications. The iCalendar export backend takes calendar data from Org files and exports to the standard iCalendar format.

By default, iCalendar export only includes headings that contain active timestamps or diary sexps146.

The iCalendar export backend can also incorporate TODO entries based on the configuration of the org-icalendar-include-todo variable. The backend exports plain timestamps as ‘VEVENT’, TODO items as ‘VTODO’, and also create events from deadlines that are in non-TODO items.

The backend uses the deadlines and scheduling dates in Org TODO items for setting the start and due dates for the iCalendar TODO entry. Consult the org-icalendar-use-deadline, org-icalendar-use-scheduled, and org-icalendar-todo-unscheduled-start variables for more details.

For tags on the headline, the iCalendar export backend makes them into iCalendar categories. To tweak the inheritance of tags and TODO states, configure the variable org-icalendar-categories. To assign clock alarms based on time, configure the org-icalendar-alarm-time variable.

The iCalendar format standard requires globally unique identifier—or UID—for each entry. The iCalendar export backend creates UIDs during export. To save a copy of the UID in the Org file set the variable org-icalendar-store-UID. The backend looks for the ‘ID’ property of the entry for reusing the same UID for subsequent exports.

Since a single Org entry can result in multiple iCalendar entries—timestamp, deadline, scheduled item, or TODO item—Org adds prefixes to the UID, depending on which part of the Org entry triggered the creation of the iCalendar entry. Prefixing ensures UIDs remains unique, yet enable synchronization programs trace the connections.

C-c C-e c f (org-icalendar-export-to-ics)
Create iCalendar entries from the current Org buffer and store them in the same directory, using a file extension ‘.ics’.

C-c C-e c a (org-icalendar-export-agenda-files)
Create iCalendar entries from Org files in org-agenda-files and store in a separate iCalendar file for each Org file.

C-c C-e c c (org-icalendar-combine-agenda-files)
Create a combined iCalendar file from Org files in org-agenda-files and write it to org-icalendar-combined-agenda-file file name.

The iCalendar export backend includes ‘SUMMARY’, ‘DESCRIPTION’, ‘LOCATION’, ‘TIMEZONE’ and ‘CLASS’ properties from the Org entries when exporting. To force the backend to inherit the ‘LOCATION’, ‘TIMEZONE’ and ‘CLASS’ properties, configure the org-use-property-inheritance variable.

‘SUMMARY’, ‘LOCATION’, and ‘DESCRIPTION’ properties can define multi-line summary, location, or description using ‘<PROPERTY>+’ syntax (see Property Syntax):

;* Meeting at location with multi-line address
<2024-01-08 Mon 14:20-15:00>
:PROPERTIES:
:LOCATION:  Someplace
:LOCATION+: Some Street 5
:LOCATION+: 12345 Small Town
:END:
When Org entries do not have ‘SUMMARY’, ‘DESCRIPTION’, ‘LOCATION’ and ‘CLASS’ properties, the iCalendar export backend derives the summary from the headline, and derives the description from the body of the Org item. The org-icalendar-include-body variable limits the maximum number of characters of the content are turned into its description.

The ‘TIMEZONE’ property can be used to specify a per-entry time zone, and is applied to any entry with timestamp information. Time zones should be specified as per the IANA time zone database format, e.g., ‘Asia/Almaty’. Alternately, the property value can be ‘UTC’, to force UTC time for this entry only.

The ‘CLASS’ property can be used to specify a per-entry visibility class or access restrictions, and is applied to any entry with class information. The iCalendar standard defines three visibility classes:

‘PUBLIC’
The entry is publicly visible (this is the default).

‘CONFIDENTIAL’
Only a limited group of clients get access to the event.

‘PRIVATE’
The entry can be retrieved only by its owner.

The server should treat unknown class properties the same as ‘PRIVATE’.

The exported iCalendar file can advise clients how often to check for updates. This duration can be set globally with the org-icalendar-ttl variable, or on a per-document basis with the ‘ICAL-TTL’ keyword. This option should be set using the iCalendar notation for time durations; consult the docstring of org-icalendar-ttl for more details.

Exporting to iCalendar format depends in large part on the capabilities of the destination application. Some are more lenient than others. Consult the Org mode FAQ for advice on specific applications.

Footnotes
(146)
Diary sexp events, except certain built-in types (see icalendar-export-sexp-enumerate-all), are exported up to icalendar-export-sexp-enumeration-days into future.


**** Other Built-in Backends

Other export backends included with Org are:

‘ox-man.el’: Export to a man page.
To activate such backends, either customize org-export-backends or load directly with ‘(require 'ox-man)’. On successful load, the backend adds new keys in the export dispatcher (see The Export Dispatcher).

Follow the comment section of such files, for example, ‘ox-man.el’, for usage and configuration details.


**** Advanced Export Configuration

Export hooks
The export process executes two hooks before the actual exporting begins. The first hook, org-export-before-processing-functions, runs before any expansions of macros, Babel code, and include keywords in the buffer. The second hook, org-export-before-parsing-functions, runs before the buffer is parsed.

Functions added to these hooks are called with a single argument: the export backend actually used, as a symbol. You may use them for heavy duty structural modifications of the document. For example, you can remove every headline in the buffer during export like this:

(defun my-headline-removal (backend)
  "Remove all headlines in the current buffer.
BACKEND is the export backend being used, as a symbol."
  (org-map-entries
   (lambda ()
     (delete-region (point) (line-beginning-position 2))
     ;; We need to tell `org-map-entries' to not skip over heading at
     ;; point.  Otherwise, it would continue from _next_ heading.  See
     ;; the docstring of `org-map-entries' for details.
     (setq org-map-continue-from (point)))))

(add-hook 'org-export-before-parsing-functions #'my-headline-removal)
Filters
Filters are lists of functions to be applied to certain parts for a given backend. The output from the first function in the filter is passed on to the next function in the filter. The final output is the output from the final function in the filter.

The Org export process has many filter sets applicable to different types of objects, plain text, parse trees, export options, and final output formats. The filters are named after the element type or object type: org-export-filter-TYPE-functions, where TYPE is the type targeted by the filter. Valid types are:

body	bold	babel-call
center-block	clock	code
diary-sexp	drawer	dynamic-block
entity	example-block	export-block
export-snippet	final-output	fixed-width
footnote-definition	footnote-reference	headline
horizontal-rule	inline-babel-call	inline-src-block
inlinetask	italic	item
keyword	latex-environment	latex-fragment
line-break	link	node-property
options	paragraph	parse-tree
plain-list	plain-text	planning
property-drawer	quote-block	radio-target
section	special-block	src-block
statistics-cookie	strike-through	subscript
superscript	table	table-cell
table-row	target	timestamp
underline	verbatim	verse-block
Here is an example filter that replaces non-breaking spaces ~ ~ in the Org buffer with ‘~’ for the LaTeX backend.

(defun my-latex-filter-nobreaks (text backend info)
  "Ensure \" \" are properly handled in LaTeX export."
  (when (org-export-derived-backend-p backend 'latex)
    (replace-regexp-in-string " " "~" text)))

(add-to-list 'org-export-filter-plain-text-functions
             'my-latex-filter-nobreaks)
A filter requires three arguments: the code to be transformed, the name of the backend, and some optional information about the export process. The third argument can be safely ignored. Note the use of org-export-derived-backend-p predicate that tests for latex backend or any other backend, such as beamer, derived from latex.

Defining filters for individual files
The Org export can filter not just for backends, but also for specific files through the ‘BIND’ keyword. Here is an example with two filters; one removes brackets from time stamps, and the other removes strike-through text. The filter functions are defined in a code block in the same Org file, which is a handy location for debugging.

#+BIND: org-export-filter-timestamp-functions (tmp-f-timestamp)
#+BIND: org-export-filter-strike-through-functions (tmp-f-strike-through)
#+BEGIN_SRC emacs-lisp :exports results :results none
  (defun tmp-f-timestamp (s backend info)
    (replace-regexp-in-string "&[lg]t;\\|[][]" "" s))
  (defun tmp-f-strike-through (s backend info) "")
#+END_SRC
Summary of the export process
Org mode export is a multi-step process that works on a temporary copy of the buffer. The export process consists of 4 major steps:

Process the temporary copy, making necessary changes to the buffer text;
Parse the buffer, converting plain Org markup into an abstract syntax tree (AST);
Convert the AST to text, as prescribed by the selected export backend;
Post-process the resulting exported text.
Process temporary copy of the source Org buffer 147:

Execute org-export-before-processing-functions (see Export hooks);
Expand ‘#+include’ keywords in the whole buffer (see Include Files);
Remove commented subtrees in the whole buffer (see Comment Lines);
Replace macros in the whole buffer (see Macro Replacement);
When org-export-use-babel is non-nil (default), process code blocks:
Leave code blocks inside archived subtrees (see Internal archiving) as is;
Evaluate all the other code blocks according to code block headers (see Limit code block evaluation);
Remove code, results of evaluation, both, or neither according to ‘:exports’ header argument (see Exporting Code Blocks).
Parse the temporary buffer, creating AST:

Execute org-export-before-parsing-functions (see Export hooks). The hook functions may still modify the buffer;
Calculate export option values according to subtree-specific export settings, in-buffer keywords, ‘#+BIND’ keywords, and buffer-local and global customization. The whole buffer is considered;
When org-org-with-cite-processors is non-nil (default), determine contributing bibliographies and record them into export options (see Citations). The whole buffer is considered;
Execute org-export-filter-options-functions;
Parse the accessible portion of the temporary buffer to generate an AST. The AST is a nested list of lists representing Org syntax elements (see Org Element API for more details):
(org-data ...
 (heading
  (section
   (paragraph (plain-text) (bold (plain-text))))
  (heading)
  (heading (section ...))))
Past this point, modifications to the temporary buffer no longer affect the export; Org export works only with the AST;

Remove elements that are not exported from the AST:
Headings according to ‘SELECT_TAGS’ and ‘EXCLUDE_TAGS’ export keywords; ‘task’, ‘inline’, ‘arch’ export options (see Export Settings);
Comments;
Clocks, drawers, fixed-width environments, footnotes, LaTeX environments and fragments, node properties, planning lines, property drawers, statistics cookies, timestamps, etc according to ‘#+OPTIONS’ keyword (see Export Settings);
Table rows containing width and alignment markers, unless the selected export backend changes :with-special-rows export option to non-nil (see Column Width and Alignment);
Table columns containing recalc marks (see Advanced features).
Expand environment variables in file link AST nodes according to the ‘expand-links’ export option (see Export Settings);
Execute org-export-filter-parse-tree-functions. These functions can modify the AST by side effects;
When org-org-with-cite-processors is non-nil (default), replace citation AST nodes and ‘#+print_bibliography’ keyword AST nodes as prescribed by the selected citation export processor (see Citation export processors).
Convert the AST to text by traversing the AST nodes, depth-first:

Convert the leaf nodes (without children) to text as prescribed by “transcoders” in the selected export backend 148;
Pass the converted nodes through the corresponding export filters (see Filters);
Concatenate all the converted child nodes to produce parent node contents;
Convert the nodes with children to text, passing the nodes themselves and their exported contents to the corresponding transcoders and then to the export filters (see Filters).
Post-process the exported text:

Post-process the converted AST, as prescribed by the export backend. 149 This step usually adds generated content (like Table of Contents) to the exported text;
Execute org-export-filter-body-functions;
Unless body-only export is selected (see The Export Dispatcher), add the necessary metadata to the final document, as prescribed by the export backend. Examples: Document author/title; HTML headers/footers; LaTeX preamble;
When org-org-with-cite-processors is non-nil (default), add bibliography metadata, as prescribed by the citation export processor;
Execute org-export-filter-final-output-functions.
Extending an existing backend
Some parts of the conversion process can be extended for certain elements so as to introduce a new or revised translation. That is how the HTML export backend was extended to handle Markdown format. The extensions work seamlessly so any aspect of filtering not done by the extended backend is handled by the original backend. Of all the export customization in Org, extending is very powerful as it operates at the parser level.

For this example, make the ascii backend display the language used in a source code block. Also make it display only when some attribute is non-nil, like the following:

#+ATTR_ASCII: :language t
Then extend ASCII backend with a custom “my-ascii” backend.

(defun my-ascii-src-block (src-block contents info)
  "Transcode a SRC-BLOCK element from Org to ASCII.
CONTENTS is nil.  INFO is a plist used as a communication
channel."
  (if (not (org-export-read-attribute :attr_ascii src-block :language))
      (org-export-with-backend 'ascii src-block contents info)
    (concat
     (format ",--[ %s ]--\n%s`----"
             (org-element-property :language src-block)
             (replace-regexp-in-string
              "^" "| "
              (org-element-normalize-string
               (org-export-format-code-default src-block info)))))))

(org-export-define-derived-backend 'my-ascii 'ascii
  :translate-alist '((src-block . my-ascii-src-block)))
The my-ascii-src-block function looks at the attribute above the current element. If not true, hands over to ascii backend. If true, which it is in this example, it creates a box around the code and leaves room for the inserting a string for language. The last form creates the new backend that springs to action only when translating src-block type elements.

To use the newly defined backend, evaluate the following from an Org buffer:

(org-export-to-buffer 'my-ascii "*Org MY-ASCII Export*")
Further steps to consider would be an interactive function, self-installing an item in the export dispatcher menu, and other user-friendly improvements. See https://orgmode.org/worg/dev/org-export-reference.html for more details.

Footnotes
(147)
Unless otherwise specified, each step of the export process only operates on the accessible portion of the buffer. When subtree export is selected (see The Export Dispatcher), the buffer is narrowed to the body of the selected subtree, so that the rest of the buffer text, except export keywords, does not contribute to the export output.

(148)
See transcoders and :translate-alist in the docstrings of org-export-define-backend and org-export-define-derived-backend.

(149)
See inner-template in the docstring of org-export-define-backend.


**** Export Region

Some export backends include commands to convert a region of Org formatted text to another format, such as HTML or LaTeX. The conversion replaces the original source. Here are such commands:

org-export-region-to-ascii
Convert the selected region into ASCII.

org-export-region-to-utf8
Convert the selected region into UTF-8.

org-export-region-to-html
Convert the selected region into HTML.

org-export-region-to-latex
Convert the selected region into LaTeX.

org-export-region-to-texinfo
Convert the selected region into Texinfo.

org-export-region-to-md
Convert the selected region into Markdown.

The in-place conversion is particularly handy for quick conversion of tables and lists in non-Org buffers. For example, in an HTML buffer, write a list in Org syntax, select it, and convert it to HTML with M-x org-html-convert-region-to-html.


*** Publishing

Org includes a publishing management system that allows you to configure automatic HTML conversion of projects composed of interlinked Org files. You can also configure Org to automatically upload your exported HTML pages and related attachments, such as images and source code files, to a web server.

You can also use Org to convert files into PDF, or even combine HTML and PDF conversion so that files are available in both formats on the server.

Publishing has been contributed to Org by David O’Toole.

**** Configuration

Publishing needs significant configuration to specify files, destination and many other properties of a project.

***** The variable org-publish-project-alist

Publishing is configured almost entirely through setting the value of one variable, called org-publish-project-alist. Each element of the list configures one project, and may be in one of the two following forms:

("project-name" :property value :property value ...)
i.e., a well-formed property list with alternating keys and values, or:

("project-name" :components ("project-name" "project-name" ...))
In both cases, projects are configured by specifying property values. A project defines the set of files that are to be published, as well as the publishing configuration to use when publishing those files. When a project takes the second form listed above, the individual members of the :components property are taken to be sub-projects, which group together files requiring different publishing options. When you publish such a “meta-project”, all the components are also published, in the sequence given.


***** Sources and destinations for files

Most properties are optional, but some should always be set. In particular, Org needs to know where to look for source files, and where to put published files.

:base-directory
Directory containing publishing source files.

:publishing-directory
Directory where output files are published. You can directly publish to a webserver using a file name syntax appropriate for the Emacs tramp package. Or you can publish to a local directory and use external tools to upload your website (see Uploading Files).

:preparation-function
Function or list of functions to be called before starting the publishing process, for example, to run ‘make’ for updating files to be published. Each preparation function is called with a single argument, the project property list.

:completion-function
Function or list of functions called after finishing the publishing process, for example, to change permissions of the resulting files. Each completion function is called with a single argument, the project property list.


***** Selecting files

By default, all files with extension ‘.org’ in the base directory are considered part of the project. This can be modified by setting the following properties

:base-extension
Extension—without the dot—of source files. This actually is a regular expression. Set this to the symbol any if you want to get all files in :base-directory, even without extension.

:exclude
Regular expression to match file names that should not be published, even though they have been selected on the basis of their extension.

:include
List of files to be included regardless of :base-extension and :exclude.

:recursive
Non-nil means, check base-directory recursively for files to publish.


***** Publishing action

Publishing means that a file is copied to the destination directory and possibly transformed in the process. The default transformation is to export Org files as HTML files, and this is done by the function org-html-publish-to-html which calls the HTML exporter (see HTML Export). But you can also publish your content as PDF files using org-latex-publish-to-pdf, or as ASCII, Texinfo, etc., using the corresponding functions.

If you want to publish the Org file as an ‘.org’ file but with archived, commented, and tag-excluded trees removed, use org-org-publish-to-org. This produces ‘file.org’ and puts it in the publishing directory. If you want a htmlized version of this file, set the parameter :htmlized-source to t. It produces ‘file.org.html’ in the publishing directory150.

Other files like images only need to be copied to the publishing destination; for this you can use org-publish-attachment. For non-Org files, you always need to specify the publishing function:

:publishing-function
Function executing the publication of a file. This may also be a list of functions, which are all called in turn.

:htmlized-source
Non-nil means, publish htmlized source.

The function must accept three arguments: a property list containing at least a :publishing-directory property, the name of the file to be published, and the path to the publishing directory of the output file. It should take the specified file, make the necessary transformation, if any, and place the result into the destination folder.

Footnotes
(150)
If the publishing directory is the same as the source directory, ‘file.org’ is exported as ‘file.org.org’, so you probably do not want to do this.


***** Options for the exporters

The property list can be used to set many export options for the HTML and LaTeX exporters. In most cases, these properties correspond to user variables in Org. The table below lists these properties along with the variable they belong to. See the documentation string for the respective variable for details.

When a property is given a value in org-publish-project-alist, its setting overrides the value of the corresponding user variable, if any, during publishing. Options set within a file (see Export Settings), however, override everything.

Generic properties
:author	user-full-name
:email	user-mail-address
:language	org-export-default-language
:select-tags	org-export-select-tags
:exclude-tags	org-export-exclude-tags
:creator	org-export-creator-string
:headline-levels	org-export-headline-levels
:preserve-breaks	org-export-preserve-breaks
:section-numbers	org-export-with-section-numbers
:time-stamp-file	org-export-timestamp-file
:with-archived-trees	org-export-with-archived-trees
:with-author	org-export-with-author
:expand-links	org-export-expand-links
:with-broken-links	org-export-with-broken-links
:with-clocks	org-export-with-clocks
:with-creator	org-export-with-creator
:with-date	org-export-with-date
:with-drawers	org-export-with-drawers
:with-email	org-export-with-email
:with-emphasize	org-export-with-emphasize
:with-entities	org-export-with-entities
:with-fixed-width	org-export-with-fixed-width
:with-footnotes	org-export-with-footnotes
:with-inlinetasks	org-export-with-inlinetasks
:with-latex	org-export-with-latex
:with-planning	org-export-with-planning
:with-priority	org-export-with-priority
:with-properties	org-export-with-properties
:with-smart-quotes	org-export-with-smart-quotes
:with-special-strings	org-export-with-special-strings
:with-statistics-cookies	org-export-with-statistics-cookies
:with-sub-superscript	org-export-with-sub-superscripts
:with-toc	org-export-with-toc
:with-tables	org-export-with-tables
:with-tags	org-export-with-tags
:with-tasks	org-export-with-tasks
:with-timestamps	org-export-with-timestamps
:with-title	org-export-with-title
:with-todo-keywords	org-export-with-todo-keywords
:with-cite-processors	org-export-process-citations
:cite-export	org-cite-export-processors
ASCII specific properties
:ascii-bullets	org-ascii-bullets
:ascii-caption-above	org-ascii-caption-above
:ascii-charset	org-ascii-charset
:ascii-global-margin	org-ascii-global-margin
:ascii-format-drawer-function	org-ascii-format-drawer-function
:ascii-format-inlinetask-function	org-ascii-format-inlinetask-function
:ascii-headline-spacing	org-ascii-headline-spacing
:ascii-indented-line-width	org-ascii-indented-line-width
:ascii-inlinetask-width	org-ascii-inlinetask-width
:ascii-inner-margin	org-ascii-inner-margin
:ascii-links-to-notes	org-ascii-links-to-notes
:ascii-list-margin	org-ascii-list-margin
:ascii-paragraph-spacing	org-ascii-paragraph-spacing
:ascii-quote-margin	org-ascii-quote-margin
:ascii-table-keep-all-vertical-lines	org-ascii-table-keep-all-vertical-lines
:ascii-table-use-ascii-art	org-ascii-table-use-ascii-art
:ascii-table-widen-columns	org-ascii-table-widen-columns
:ascii-text-width	org-ascii-text-width
:ascii-underline	org-ascii-underline
:ascii-verbatim-format	org-ascii-verbatim-format
Beamer specific properties
:headline-levels	org-beamer-frame-level
:beamer-subtitle-format	org-beamer-subtitle-format
:beamer-column-view-format	org-beamer-column-view-format
:beamer-theme	org-beamer-theme
:beamer-environments-extra	org-beamer-environments-extra
:beamer-frame-default-options	org-beamer-frame-default-options
:beamer-outline-frame-options	org-beamer-outline-frame-options
:beamer-outline-frame-title	org-beamer-outline-frame-title
HTML specific properties
:html-doctype	org-html-doctype
:html-container	org-html-container-element
:html-content-class	org-html-content-class
:html-html5-fancy	org-html-html5-fancy
:html-link-use-abs-url	org-html-link-use-abs-url
:html-link-home	org-html-link-home
:html-link-up	org-html-link-up
:html-equation-reference-format	org-html-equation-reference-format
:html-postamble	org-html-postamble
:html-preamble	org-html-preamble
:html-head	org-html-head
:html-head-extra	org-html-head-extra
:html-head-include-default-style	org-html-head-include-default-style
:html-head-include-scripts	org-html-head-include-scripts
:html-allow-name-attribute-in-anchors	org-html-allow-name-attribute-in-anchors
:html-divs	org-html-divs
:html-checkbox-type	org-html-checkbox-type
:html-extension	org-html-extension
:html-footnote-format	org-html-footnote-format
:html-footnote-separator	org-html-footnote-separator
:html-footnotes-section	org-html-footnotes-section
:html-format-drawer-function	org-html-format-drawer-function
:html-format-headline-function	org-html-format-headline-function
:html-format-inlinetask-function	org-html-format-inlinetask-function
:html-home/up-format	org-html-home/up-format
:html-indent	org-html-indent
:html-infojs-options	org-html-infojs-options
:html-infojs-template	org-html-infojs-template
:html-inline-image-rules	org-html-inline-image-rules
:html-link-org-files-as-html	org-html-link-org-files-as-html
:html-mathjax-options	org-html-mathjax-options
:html-mathjax-template	org-html-mathjax-template
:html-metadata-timestamp-format	org-html-metadata-timestamp-format
:html-postamble-format	org-html-postamble-format
:html-preamble-format	org-html-preamble-format
:html-prefer-user-labels	org-html-prefer-user-labels
:html-self-link-headlines	org-html-self-link-headlines
:html-table-align-individual-fields	org-html-table-align-individual-fields
:html-table-caption-above	org-html-table-caption-above
:html-table-data-tags	org-html-table-data-tags
:html-table-header-tags	org-html-table-header-tags
:html-table-use-header-tags-for-first-column	org-html-table-use-header-tags-for-first-column
:html-tag-class-prefix	org-html-tag-class-prefix
:html-text-markup-alist	org-html-text-markup-alist
:html-todo-kwd-class-prefix	org-html-todo-kwd-class-prefix
:html-toplevel-hlevel	org-html-toplevel-hlevel
:html-use-infojs	org-html-use-infojs
:html-validation-link	org-html-validation-link
:html-viewport	org-html-viewport
:html-inline-images	org-html-inline-images
:html-table-attributes	org-html-table-default-attributes
:html-table-row-open-tag	org-html-table-row-open-tag
:html-table-row-close-tag	org-html-table-row-close-tag
:html-xml-declaration	org-html-xml-declaration
:html-wrap-src-lines	org-html-wrap-src-lines
:html-klipsify-src	org-html-klipsify-src
:html-klipse-css	org-html-klipse-css
:html-klipse-js	org-html-klipse-js
:html-klipse-selection-script	org-html-klipse-selection-script
:creator	org-html-creator-string
:with-latex	org-html-with-latex
LaTeX specific properties
:latex-class	org-latex-default-class
:latex-active-timestamp-format	org-latex-active-timestamp-format
:latex-caption-above	org-latex-caption-above
:latex-classes	org-latex-classes
:latex-default-figure-position	org-latex-default-figure-position
:latex-default-table-environment	org-latex-default-table-environment
:latex-default-quote-environment	org-latex-default-quote-environment
:latex-default-table-mode	org-latex-default-table-mode
:latex-default-footnote-command	org-latex-default-footnote-command
:latex-diary-timestamp-format	org-latex-diary-timestamp-format
:latex-engraved-options	org-latex-engraved-options
:latex-engraved-preamble	org-latex-engraved-preamble
:latex-engraved-theme	org-latex-engraved-theme
:latex-footnote-defined-format	org-latex-footnote-defined-format
:latex-footnote-separator	org-latex-footnote-separator
:latex-format-drawer-function	org-latex-format-drawer-function
:latex-format-headline-function	org-latex-format-headline-function
:latex-format-inlinetask-function	org-latex-format-inlinetask-function
:latex-hyperref-template	org-latex-hyperref-template
:latex-image-default-scale	org-latex-image-default-scale
:latex-image-default-height	org-latex-image-default-height
:latex-image-default-option	org-latex-image-default-option
:latex-image-default-width	org-latex-image-default-width
:latex-images-centered	org-latex-images-centered
:latex-inactive-timestamp-format	org-latex-inactive-timestamp-format
:latex-inline-image-rules	org-latex-inline-image-rules
:latex-link-with-unknown-path-format	org-latex-link-with-unknown-path-format
:latex-src-block-backend	org-latex-src-block-backend
:latex-listings-langs	org-latex-listings-langs
:latex-listings-options	org-latex-listings-options
:latex-listings-src-omit-language	org-latex-listings-src-omit-language
:latex-minted-langs	org-latex-minted-langs
:latex-minted-options	org-latex-minted-options
:latex-prefer-user-labels	org-latex-prefer-user-labels
:latex-subtitle-format	org-latex-subtitle-format
:latex-subtitle-separate	org-latex-subtitle-separate
:latex-table-scientific-notation	org-latex-table-scientific-notation
:latex-tables-booktabs	org-latex-tables-booktabs
:latex-tables-centered	org-latex-tables-centered
:latex-text-markup-alist	org-latex-text-markup-alist
:latex-title-command	org-latex-title-command
:latex-toc-command	org-latex-toc-command
:latex-compiler	org-latex-compiler
Markdown specific properties
:md-footnote-format	org-md-footnote-format
:md-footnotes-section	org-md-footnotes-section
:md-headline-style	org-md-headline-style
:md-toplevel-hlevel	org-md-toplevel-hlevel
ODT specific properties
:odt-styles-file	org-odt-styles-file
:odt-content-template-file	org-odt-content-template-file
:odt-display-outline-level	org-odt-display-outline-level
:odt-fontify-srcblocks	org-odt-fontify-srcblocks
:odt-format-drawer-function	org-odt-format-drawer-function
:odt-format-headline-function	org-odt-format-headline-function
:odt-format-inlinetask-function	org-odt-format-inlinetask-function
:odt-inline-formula-rules	org-odt-inline-formula-rules
:odt-inline-image-rules	org-odt-inline-image-rules
:odt-pixels-per-inch	org-odt-pixels-per-inch
:odt-table-styles	org-odt-table-styles
:odt-use-date-fields	org-odt-use-date-fields
:with-latex	org-odt-with-latex
Texinfo specific properties
:texinfo-class	org-texinfo-default-class
:texinfo-classes	org-texinfo-classes
:texinfo-format-headline-function	org-texinfo-format-headline-function
:texinfo-node-description-column	org-texinfo-node-description-column
:texinfo-active-timestamp-format	org-texinfo-active-timestamp-format
:texinfo-inactive-timestamp-format	org-texinfo-inactive-timestamp-format
:texinfo-diary-timestamp-format	org-texinfo-diary-timestamp-format
:texinfo-link-with-unknown-path-format	org-texinfo-link-with-unknown-path-format
:texinfo-tables-verbatim	org-texinfo-tables-verbatim
:texinfo-table-scientific-notation	org-texinfo-table-scientific-notation
:texinfo-table-default-markup	org-texinfo-table-default-markup
:texinfo-text-markup-alist	org-texinfo-text-markup-alist
:texinfo-format-drawer-function	org-texinfo-format-drawer-function
:texinfo-format-inlinetask-function	org-texinfo-format-inlinetask-function
:texinfo-compact-itemx	org-texinfo-compact-itemx
:with-latex	org-texinfo-with-latex


***** Publishing links

To create a link from one Org file to another, you would use something like ‘[[file:foo.org][The foo]]’ or simply ‘[[file:foo.org]]’ (see External Links). When published, this link becomes a link to ‘foo.html’. You can thus interlink the pages of your “Org web” project and the links will work as expected when you publish them to HTML. If you also publish the Org source file and want to link to it, use an ‘http’ link instead of a ‘file:’ link, because ‘file’ links are converted to link to the corresponding ‘.html’ file.

Links to encrypted Org files, like ‘[[file:foo.org.gpg]]’ are also supported.

You may also link to related files, such as images. Provided you are careful with relative file names, and provided you have also configured Org to upload the related files, these links will work too. See Example: complex publishing configuration, for an example of this usage.

Links between published documents can contain some search options (see Search Options in File Links), which will be resolved to the appropriate location in the linked file. For example, once published to HTML, the following links all point to a dedicated anchor in ‘foo.html’.

[[file:foo.org::*heading]]
[[file:foo.org::#custom-id]]
[[file:foo.org::target]]


***** Generating a sitemap

The following properties may be used to control publishing of a map of files for a given project.

:auto-sitemap
When non-nil, publish a sitemap during org-publish-current-project or org-publish-all.

:sitemap-filename
Filename for output of sitemap. Defaults to ‘sitemap.org’, which becomes ‘sitemap.html’.

:sitemap-title
Title of sitemap page. Defaults to name of file.

:sitemap-style
Can be list (site-map is just an itemized list of the titles of the files involved) or tree (the directory structure of the source files is reflected in the site-map). Defaults to tree.

:sitemap-format-entry
With this option one can tell how a site-map entry is formatted in the site-map. It is a function called with three arguments: the file or directory name relative to base directory of the project, the site-map style and the current project. It is expected to return a string. Default value turns file names into links and use document titles as descriptions. For specific formatting needs, one can use org-publish-find-date, org-publish-find-title and org-publish-find-property, to retrieve additional information about published documents.

:sitemap-function
Plug-in function to use for generation of the sitemap. It is called with two arguments: the title of the site-map and a representation of the files and directories involved in the project as a nested list, which can further be transformed using org-list-to-generic, org-list-to-subtree and alike. Default value generates a plain list of links to all files in the project.

:sitemap-sort-folders
Where folders should appear in the sitemap. Set this to first (default) or last to display folders first or last, respectively. When set to ignore, folders are ignored altogether. Any other value mixes files and folders. This variable has no effect when site-map style is tree.

:sitemap-sort-files
How the files are sorted in the site map. Set this to alphabetically (default), chronologically or anti-chronologically. chronologically sorts the files with older date first while anti-chronologically sorts the files with newer date first. alphabetically sorts the files alphabetically. The date of a file is retrieved with org-publish-find-date.

:sitemap-ignore-case
Should sorting be case-sensitive? Default nil.


***** Generating an index

Org mode can generate an index across the files of a publishing project.

:makeindex
When non-nil, generate in index in the file ‘theindex.org’ and publish it as ‘theindex.html’.

The file is created when first publishing a project with the :makeindex set. The file only contains a statement ‘#+INCLUDE: "theindex.inc"’. You can then build around this include statement by adding a title, style information, etc.

Index entries are specified with ‘INDEX’ keyword. An entry that contains an exclamation mark creates a sub item.

;*** Curriculum Vitae
#+INDEX: CV
#+INDEX: Application!CV


**** Uploading Files

For those people already utilizing third party sync tools such as Rsync or Unison, it might be preferable not to use the built-in remote publishing facilities of Org mode which rely heavily on Tramp. Tramp, while very useful and powerful, tends not to be so efficient for multiple file transfer and has been known to cause problems under heavy usage.

Specialized synchronization utilities offer several advantages. In addition to timestamp comparison, they also do content and permissions/attribute checks. For this reason you might prefer to publish your web to a local directory—possibly even in place with your Org files—and then use Unison or Rsync to do the synchronization with the remote host.

Since Unison, for example, can be configured as to which files to transfer to a certain remote destination, it can greatly simplify the project publishing definition. Simply keep all files in the correct location, process your Org files with org-publish and let the synchronization tool do the rest. You do not need, in this scenario, to include attachments such as JPG, CSS or PNG files in the project definition since the third-party tool syncs them.

Publishing to a local directory is also much faster than to a remote one, so that you can afford more easily to republish entire projects. If you set org-publish-use-timestamps-flag to nil, you gain the main benefit of re-including any changed external files such as source example files you might include with ‘INCLUDE’ keyword. The timestamp mechanism in Org is not smart enough to detect if included files have been modified.


**** Sample Configuration

Below we provide two example configurations. The first one is a simple project publishing only a set of Org files. The second example is more complex, with a multi-component project.

***** Example: simple publishing configuration

This example publishes a set of Org files to the ‘public_html’ directory on the local machine.

(setq org-publish-project-alist
      '(("org"
         :base-directory "~/org/"
         :publishing-function org-html-publish-to-html
         :publishing-directory "~/public_html"
         :section-numbers nil
         :with-toc nil
         :html-head "<link rel=\"stylesheet\"
                    href=\"../other/mystyle.css\"
                    type=\"text/css\"/>")))


***** Example: complex publishing configuration

This more complicated example publishes an entire website, including Org files converted to HTML, image files, Emacs Lisp source code, and style sheets. The publishing directory is remote and private files are excluded.

To ensure that links are preserved, care should be taken to replicate your directory structure on the web server, and to use relative file paths. For example, if your Org files are kept in ‘~/org/’ and your publishable images in ‘~/images/’, you would link to an image with

file:../images/myimage.png
On the web server, the relative path to the image should be the same. You can accomplish this by setting up an ‘images/’ folder in the right place on the web server, and publishing images to it.

(setq org-publish-project-alist
      `(("orgfiles"
         :base-directory "~/org/"
         :base-extension "org"
         :publishing-directory "/ssh:user@host:~/html/notebook/"
         :publishing-function org-html-publish-to-html
         :exclude ,(rx (or "PrivateFile.org" (seq line-start "private/"))) ;; regexp
         :headline-levels 3
         :section-numbers nil
         :with-toc nil
         :html-head "<link rel=\"stylesheet\"
                  href=\"../other/mystyle.css\" type=\"text/css\"/>"
         :html-preamble t)

        ("images"
         :base-directory "~/images/"
         :base-extension "jpg\\|gif\\|png"
         :publishing-directory "/ssh:user@host:~/html/images/"
         :publishing-function org-publish-attachment)

        ("other"
         :base-directory "~/other/"
         :base-extension "css\\|el"
         :publishing-directory "/ssh:user@host:~/html/other/"
         :publishing-function org-publish-attachment)
        ("website" :components ("orgfiles" "images" "other"))))

**** Triggering Publication

Once properly configured, Org can publish with the following commands:

C-c C-e P x (org-publish)
Prompt for a specific project and publish all files that belong to it.

C-c C-e P p (org-publish-current-project)
Publish the project containing the current file.

C-c C-e P f (org-publish-current-file)
Publish only the current file.

C-c C-e P a (org-publish-all)
Publish every project.

Org uses timestamps to track when a file has changed. The above functions normally only publish changed files. You can override this and force publishing of all files by giving a prefix argument to any of the commands above, or by customizing the variable org-publish-use-timestamps-flag. This may be necessary in particular if files include other files via ‘SETUPFILE’ or ‘INCLUDE’ keywords.


*** Citation handling

While links (see Hyperlinks) are often sufficient to refer to external or internal information from Org, they have their limitations when referring to multiple targets or typesetting printed publications.

Org mode provides a more sophisticated markup to “cite” external resources. For example, consider the following Org mode snippet

#+bibliography: citationdata.bib

Org mode is used by various communities [cite:teaching: @orgteaching;
and TeX: @orgtex].  [cite/author/caps:@orgtex] uses Org mode to simplify
writing scientific publications, while [cite/author/caps:@orgteaching]
experiment with Org babel to improve teaching.

#+print_bibliography:
Org mode will gather citation metadata from the ‘#+bibliography’ database and use it to typeset the exported document in arbitrary formats. For example, the snippet below shows ASCII export output.

Org mode is used by various communities (teaching: Birkenkrahe, Marcus,
2023, and TeX: Somma, Emmanuele F, 2023).  Somma, Emmanuele F uses Org
mode to simplify writing scientific publications, while Birkenkrahe,
Marcus experiment with Org babel to improve teaching.

Birkenkrahe, Marcus (2023). /Teaching Data Science with Literate
Programming Tools/, MDPI.

Somma, Emmanuele F (2023). /Simplifying LaTeX with ORG-mode in Emacs/,
TUGboat volume.
In addition to export, users can use completion to search and insert citations from the bibliography (via org-cite-insert). Citations also act like ordinary links, jumping to the citation metadata when “following” them using org-open-at-point.

You can customize every aspect (capability) of citation handling using built-in or external citation processors.

Org mode ships with several built-in citation processors tailored to work with LaTeX export and BibTeX bibliographies (‘bibtex’, ‘biblatex’, and ‘natbib’ processors), or with more generic formats described using Citation Style Language (‘csl’ processor). The default citation processor is ‘basic’ - it works with arbitrary export formats and recognizes both BibTeX and CSL bibliographies. More citation processors are distributed as Emacs packages.

Multiple citation processors can be mixed to meet your preferences. Configure org-cite-activate-processor, org-cite-follow-processor, org-cite-insert-processor, and org-cite-export-processors to select which processor to use for every citation capability:

activate
Fontification, tooltip preview, etc.

follow
At-point actions on citations via org-open-at-point.

insert
Add and edit citations via org-cite-insert.

export
Via different libraries for different target formats.

**** Citations

Before adding citations, first set one-or-more bibliographies, either globally with org-cite-global-bibliography, or locally using one or more “bibliography” keywords.

#+bibliography: SomeFile.bib
#+bibliography: /some/other/file.json
#+bibliography: "/some/file/with spaces/in its name.bib"
Org mode uses all the local and global bibliographies combined to search for citation keys.

One can then insert and edit citations using org-cite-insert, called with C-c C-x @.

A citation requires one or more citation key(s), elements identifying a reference in the bibliography.

Each citation is surrounded by brackets and uses the ‘cite’ type.
Each key starts with the character ‘@’.
[cite:@key]
Each key can be qualified by a prefix (e.g. “see ”) and/or a suffix (e.g. “p. 123”), giving information useful or necessary for the comprehension of the citation but not included in the reference.
[cite:see @key p. 123]
A single citation can cite more than one reference ; the keys are separated by semicolons ; the formatting of such citation groups is specified by the style.
[cite:@key1;@key2;@key3]
One can also specify a stylistic variation for the citations by inserting a ‘/’ and a style name between the ‘cite’ keyword and the colon; this usually makes sense only for the author-year styles.
[cite/style:common prefix ;prefix @key suffix; ... ; common suffix]
When ‘style’ is not specified, one of the two default styles are used

either the default style specified in the ‘CITE_EXPORT’ keyword (see Citation export processors)
#+cite_export: basic numeric noauthor/bare
[cite:@key] is the same as [cite/noauthor/bare:@key]
or, if ‘CITE_EXPORT’ is not set, using the default ‘nil’ style
[cite:@key] is the same as [cite/nil:@key]
The only mandatory elements are:

The ‘cite’ keyword and the colon.
The ‘@’ character immediately preceding each key.
The brackets surrounding the citation(s) (group).


**** Citation export processors

Org currently includes the following export processors:

Two processors can export to a variety of formats, including ‘latex’ (and therefore ‘pdf’), ‘html’, ‘odt’ and plain (UTF8) text:
basic
a basic export processor, well adapted to situations where backward compatibility is not a requirement and formatting needs are minimal;

csl
this export processor uses format files written in Citation Style Language via citeproc-el;

In contrast, three other processors target LaTeX and LaTeX-derived formats exclusively:
bibtex
this export processor uses BibTeX, the historical bibliographic processor used with LaTeX, thus allowing the use of data and style files compatible with this processor (including a large number of publishers’ styles). It only supports LaTeX’s ‘\cite’ and ‘\nocite’ commands.

natbib
as with the bibtex processor, but using the LaTeX package ‘natbib’, allowing more stylistic variants that LaTeX’s ‘\cite’ command.

biblatex
this backend allows the use of data and formats prepared for BibLaTeX, an alternate bibliographic processor used with LaTeX, which overcomes some serious BibTeX limitations, but has not (yet?) been widely adopted by publishers.

The ‘CITE_EXPORT’ keyword specifies the export processor, citation style, and bibliography style; for example (all arguments are optional)

#+cite_export: [export processor name] [bibliography style] [default citation style]
#+cite_export: basic author-year author
specifies the ‘basic’ export processor with citations inserted as author’s name and references indexed by author’s names and year;

#+cite_export: csl /some/path/to/vancouver-brackets.csl
specifies the ‘csl’ processor and CSL style, which in this case defines numeric citations and numeric references according to the ‘Vancouver’ specification (as style used in many medical journals), following a typesetting variation putting citations between brackets;

#+cite_export: natbib kluwer
specifies the ‘natbib’ export processor with a label citation style conformant to the Harvard style and the specification of the Wolkers-Kluwer publisher; since it relies on the bibtex processor of your LaTeX installation, it won’t export to anything but PDF.

#+cite_export: biblatex numeric,backend=bibtex
specifies the ‘biblatex’ export processor with the default ‘numeric’ style and the ‘bibtex’ backend. Always define the style first and then the rest of load-time options for the ‘biblatex’ package. Alternatively, you can use the key=val,key=val format for the options as documented in the ‘biblatex’ package documentation:

#+cite_export: biblatex backend=bibtex,style=numeric
The org-cite-biblatex-options variable in your Emacs configuration uses this format. It will only export to PDF, since it relies on the biblatex processor of your LaTeX installation.


**** Bibliography printing

The ‘PRINT_BIBLIOGRAPHY’ keyword specifies where the bibliography should be printed (note the colon):

#+print_bibliography:
The bibliography printed by the LaTeX-based export processors ‘bibtex’, ‘natbib’ and ‘biblatex’ has a chapter or section heading by default, while the ‘basic’ and ‘csl’ processors print the list of bibliography entries without a heading.

A document may contain more than one ‘PRINT_BIBLIOGRAPHY’ keywords. Each of the keywords will trigger printing the bibliography.

The keywords can be used with or without additional options. Options can be used, for example, to print only entries that belong to a certain category or to control formatting. The set of supported ‘PRINT_BIBLIOGRAPHY’ options and their interpretation varies between the different citation export processors. Some export processors do not support passing options.

Bibliography options in the ‘biblatex’ and ‘csl’ export processors

***** Bibliography options in the ‘biblatex’ and ‘csl’ export processors

The ‘biblatex’ and ‘csl’ export processors support bibliography options through a property list attached to the ‘PRINT_BIBLIOGRAPHY’ keyword. For example,

#+print_bibliography: :keyword algebra :type book
Values including spaces must be surrounded with double quotes. If you need to use a key multiple times, you can separate its values with commas, but without any space in-between:

#+print_bibliography: :keyword "algebraic logic" :nottype article,book
The ‘biblatex’ export processor accepts all options supported by BibLaTeX’s \printbibliography command.

The ‘csl’ processor accepts the following options:

‘:keyword <keyword(,keyword2...)>’
Print only entries whose keyword field contains all given keywords.

‘:notkeyword <keyword(,keyword2...)>’
Print only entries whose keyword field does not contain any of the given keywords.

‘:type <entrytype>’
Print only entries whose type is ‘<entrytype>’. Entry type is the BibTeX/BibLaTeX entry type if this information is available (the entry was read from a BibTeX/BibLaTeX bibliography) and the CSL entry type otherwise.

‘:nottype <entrytype(,entrytype2...)>’
Print only entries whose type is not among the given entry types. Entry type is determined as in the case of ‘:type’.

‘:csltype <entrytype>’
Print only entries whose CSL entry type (possibly based on a conversion from BibTeX/BibLaTeX to CSL) is ‘<entrytype>’.

‘:notcsltype <entrytype(,entrytype2...)>’
Print only entries whose CSL entry type (possibly based on a conversion from BibTeX/BibLaTeX to CSL) is not among the listed entry types.

‘:filter <predicate>’
Print only entries for which the given Emacs Lisp predicate returns a non-nil value.


*** Working with Source Code

Source code here refers to any plain text collection of computer instructions, possibly with comments, written using a human-readable programming language. Org can manage source code in an Org document when the source code is identified with begin and end markers. Working with source code begins with identifying source code blocks. A source code block can be placed almost anywhere in an Org document; it is not restricted to the preamble or the end of the document. However, Org cannot manage a source code block if it is placed inside an Org comment or within a fixed width section.

Here is an example source code block in the Emacs Lisp language:

#+BEGIN_SRC emacs-lisp
  (defun org-xor (a b)
     "Exclusive or."
     (if a (not b) b))
#+END_SRC
Source code blocks are one of many Org block types, which also include “center”, “comment”, “dynamic”, “example”, “export”, “quote”, “special”, and “verse”. This section pertains to blocks between ‘#+BEGIN_SRC’ and ‘#+END_SRC’.

Details of Org’s facilities for working with source code are described in the following sections.

**** Features Overview

Org can manage the source code in the block delimited by ‘#+BEGIN_SRC’ … ‘#+END_SRC’ in several ways that can simplify housekeeping tasks essential to modern source code maintenance. Org can edit, format, extract, export, and publish source code blocks. Org can also compile and execute a source code block, then capture the results. The Org mode literature sometimes refers to source code blocks as live code blocks because they can alter the content of the Org document or the material that it exports. Users can control the “liveliness” of each source code block by tweaking the header arguments (see Using Header Arguments) for compiling, execution, extraction, and exporting.

For editing and formatting a source code block, Org uses an appropriate Emacs major mode that includes features specifically designed for source code in that language.

Org can extract one or more source code blocks and write them to one or more source files—a process known as tangling in literate programming terminology.

For exporting and publishing, Org’s backends can format a source code block appropriately, often with native syntax highlighting.

For executing and compiling a source code block, the user can configure Org to select the appropriate compiler. Org provides facilities to collect the result of the execution or compiler output, insert it into the Org document, and/or export it. In addition to text results, Org can insert links to other data types, including audio, video, and graphics. Org can also link a compiler error message to the appropriate line in the source code block.

An important feature of Org’s management of source code blocks is the ability to pass variables, functions, and results to one another using a common syntax for source code blocks in any language. Although most literate programming facilities are restricted to one language or another, Org’s language-agnostic approach lets the literate programmer match each programming task with the appropriate computer language and to mix them all together in a single Org document. This interoperability among languages explains why Org’s source code management facility was named Org Babel by its originators, Eric Schulte and Dan Davison.

Org mode fulfills the promise of easy verification and maintenance of publishing reproducible research by keeping text, data, code, configuration settings of the execution environment, the results of the execution, and associated narratives, claims, references, and internal and external links in a single Org document.


**** Structure of Code Blocks

Org offers two ways to structure source code in Org documents: in a source code block, and directly inline. Both specifications are shown below.

A source code block conforms to this structure:

#+NAME: <name>
#+BEGIN_SRC <language> <switches> <header arguments>
  <body>
#+END_SRC
Do not be put-off by having to remember the source block syntax. Org mode offers a command for wrapping existing text in a block (see Structure Templates). Org also works with other completion systems in Emacs, some of which predate Org and have custom domain-specific languages for defining templates. Regular use of templates reduces errors, increases accuracy, and maintains consistency.

An inline code block conforms to this structure:

src_<language>{<body>}
or

src_<language>[<header arguments>]{<body>}
‘#+NAME: <name>’
Optional. Names the source block so it can be called, like a function, from other source blocks or inline code to evaluate or to capture the results. Code from other blocks, other files, and from table formulas (see The Spreadsheet) can use the name to reference a source block. This naming serves the same purpose as naming Org tables. Org mode requires unique names. For duplicate names, Org mode’s behavior is undefined. Inline code blocks cannot have a name.

‘#+BEGIN_SRC’ … ‘#+END_SRC’
Mandatory. They mark the start and end of a block that Org requires. The ‘#+BEGIN_SRC’ line takes additional arguments, as described next.

‘<language>’
Optional. It is the identifier of the source code language in the block. See Languages, for identifiers of supported languages.

When ‘<language>’ identifier is omitted, the block also cannot have ‘<switches>’ and ‘<header arguments>’.

Language identifier is also used to fontify code blocks in Org buffers, when org-src-fontify-natively is set to non-nil. See Editing Source Code.

‘<switches>’
Optional. Switches provide finer control of the code execution, export, and format (see the discussion of switches in Literal Examples).

‘<header arguments>’
Optional. Heading arguments control many aspects of evaluation, export and tangling of code blocks (see Using Header Arguments). Using Org’s properties feature, header arguments can be selectively applied to the entire buffer or specific subtrees of the Org document.

‘<body>’
Source code in the dialect of the specified language identifier.


**** Using Header Arguments

Org comes with many header arguments common to all languages. New header arguments are added for specific languages as they become available for use in source code blocks. A header argument is specified with an initial colon followed by the argument’s name in lowercase.

Since header arguments can be set in several ways, Org prioritizes them in case of overlaps or conflicts by giving local settings a higher priority. Header values in function calls, for example, override header values from global defaults.

System-wide header arguments
System-wide values of header arguments can be specified by customizing the org-babel-default-header-args variable, which defaults to the following values:

:session    => "none"
:results    => "replace"
:exports    => "code"
:cache      => "no"
:noweb      => "no"
:hlines     => "no"
:tangle     => "no"
Inline source blocks (see Structure of Code Blocks) use slightly different default header arguments defined in org-babel-default-inline-header-args:

:session    => "none"
:results    => "replace"
:exports    => "results"
:hlines     => "yes"
The most notable difference between default header arguments for inline and normal source blocks is ‘:exports’ argument. For inline source blocks, results of evaluation are exported by default; not the code.

Unlike the default values, header arguments set using Org mode properties (see Header arguments in Org mode properties) do apply to both the normal source blocks and inline source blocks.

The example below sets ‘:noweb’ header arguments to ‘yes’, which makes Org expand ‘:noweb’ references by default.

(setq org-babel-default-header-args
      (cons '(:noweb . "yes")
            (assq-delete-all :noweb org-babel-default-header-args)))
Each language can have separate default header arguments by customizing the variable org-babel-default-header-args:<LANG>, where <LANG> is the name of the language. For details, see the language-specific online documentation at https://orgmode.org/worg/org-contrib/babel/.

Header arguments in Org mode properties
For header arguments applicable to the buffer, use ‘PROPERTY’ keyword anywhere in the Org file (see Property Syntax).

The following example makes all the R code blocks execute in the same session. Setting ‘:results’ to ‘silent’ ignores the results of executions for all blocks, not just R code blocks; no results inserted for any block.

#+PROPERTY: header-args:R  :session *R*
#+PROPERTY: header-args    :results silent
Header arguments set through Org’s property drawers (see Property Syntax) apply at the subtree level on down. Since these property drawers can appear anywhere in the file hierarchy, Org uses outermost call or source block to resolve the values. Org ignores org-use-property-inheritance setting.

In this example, ‘:cache’ defaults to ‘yes’ for all code blocks in the subtree.

;* sample header
  :PROPERTIES:
  :header-args:    :cache yes
  :END:
Properties defined through org-set-property function, bound to C-c C-x p, apply to all active languages. They override properties set in org-babel-default-header-args.

Language-specific header arguments are also read from properties ‘header-args:<LANG>’ where <LANG> is the language identifier. For example,

;* Heading
  :PROPERTIES:
  :header-args:clojure:    :session *clojure-1*
  :header-args:R:          :session *R*
  :END:
;** Subheading
  :PROPERTIES:
  :header-args:clojure:    :session *clojure-2*
  :END:
would force separate sessions for Clojure blocks in ‘Heading’ and ‘Subheading’, but use the same session for all R blocks. Blocks in ‘Subheading’ inherit settings from ‘Heading’.

Code block specific header arguments
Header arguments are most commonly set at the source code block level, on the ‘#+BEGIN_SRC’ line. Arguments set at this level take precedence over those set in the org-babel-default-header-args variable, and also those set as header properties.

In the following example, setting ‘:results’ to ‘silent’ makes it ignore results of the code execution. Setting ‘:exports’ to ‘code’ exports only the body of the code block to HTML or LaTeX.

#+NAME: factorial
#+BEGIN_SRC haskell :results silent :exports code :var n=0
  fac 0 = 1
  fac n = n * fac (n-1)
#+END_SRC
The same header arguments in an inline code block:

src_haskell[:exports both]{fac 5}
Code block header arguments can span multiple lines using ‘#+HEADER:’ on each line. Note that Org currently accepts the plural spelling of ‘#+HEADER:’ only as a convenience for backward-compatibility. It may be removed at some point.

Multi-line header arguments on an unnamed code block:

#+HEADER: :var data1=1
#+BEGIN_SRC emacs-lisp :var data2=2
   (message "data1:%S, data2:%S" data1 data2)
#+END_SRC

#+RESULTS:
: data1:1, data2:2
Multi-line header arguments on a named code block:

#+NAME: named-block
#+HEADER: :var data=2
#+BEGIN_SRC emacs-lisp
  (message "data:%S" data)
#+END_SRC

#+RESULTS: named-block
  : data:2
Header arguments in function calls
Header arguments in function calls are the most specific and override all other settings in case of an overlap. They get the highest priority. Two ‘#+CALL:’ examples are shown below. For the complete syntax of ‘CALL’ keyword, see Evaluating Code Blocks.

In this example, ‘:exports results’ header argument is applied to the evaluation of the ‘#+CALL:’ line.

#+CALL: factorial(n=5) :exports results
In this example, ‘:session special’ header argument is applied to the evaluation of ‘factorial’ code block.

#+CALL: factorial[:session special](n=5)


**** Environment of a Code Block

Passing arguments
Use ‘var’ for passing arguments to source code blocks. The specifics of variables in code blocks vary by the source language and are covered in the language-specific documentation. The syntax for ‘var’, however, is the same for all languages. This includes declaring a variable, and assigning a default value.

The following syntax is used to pass arguments to code blocks using the ‘var’ header argument.

:var NAME=ASSIGN
NAME is the name of the variable bound in the code block body. ASSIGN is a literal value, such as a string, a number, a reference to a table, a list, a literal example, another code block—with or without arguments—or the results of evaluating a code block. ASSIGN may specify a filename for references to elements in a different file, using a ‘:’ to separate the filename from the reference.

:var NAME=FILE:REFERENCE
When ‘FILE’ does not exist, the reference is searched in the current file, using the verbatim reference. This way, ‘:var table=tbl:example’ will be searched inside the current buffer.

Here are examples of passing values by reference:

table
A table named with a ‘NAME’ keyword.

#+NAME: example-table
| 1 |
| 2 |
| 3 |
| 4 |

#+NAME: table-length
#+BEGIN_SRC emacs-lisp :var table=example-table
  (length table)
#+END_SRC

#+RESULTS: table-length
: 4
When passing a table, you can treat specially the row, or the column, containing labels for the columns, or the rows, in the table.

The ‘colnames’ header argument accepts ‘yes’, ‘no’, or ‘nil’ values. The default value is ‘nil’: if an input table has column names—because the second row is a horizontal rule—then Org removes the column names, processes the table, puts back the column names, and then writes the table to the results block. Using ‘yes’, Org does the same to the first non-hline row, even if the initial table does not contain any horizontal rule. When set to ‘no’, Org does not pre-process column names at all.

#+NAME: less-cols
| a |
|---|
| b |
| c |

#+BEGIN_SRC python :var tab=less-cols :colnames nil
return [[val + '*' for val in row] for row in tab]
#+END_SRC

#+RESULTS:
| a  |
|----|
| b* |
| c* |
Similarly, the ‘rownames’ header argument can take two values: ‘yes’ or ‘no’. When set to ‘yes’, Org removes the first column, processes the table, puts back the first column, and then writes the table to the results block. The default is ‘no’, which means Org does not pre-process the first column. Note that Emacs Lisp code blocks ignore ‘rownames’ header argument because of the ease of table-handling in Emacs.

#+NAME: with-rownames
| one | 1 | 2 | 3 | 4 |  5 |
| two | 6 | 7 | 8 | 9 | 10 |

#+BEGIN_SRC python :var tab=with-rownames :rownames yes
return [[val + 10 for val in row] for row in tab]
#+END_SRC

#+RESULTS:
| one | 11 | 12 | 13 | 14 | 15 |
| two | 16 | 17 | 18 | 19 | 20 |
To refer to a table in another file, join the filename and table name with a colon, for example: ‘:var table=other-file.org:example-table’.

list
A simple named list.

#+NAME: example-list
- simple
  - not
  - nested
- list

#+BEGIN_SRC emacs-lisp :var x=example-list
  (print x)
#+END_SRC

#+RESULTS:
| simple | list |
Note that only the top level list items are passed along. Nested list items are ignored.

code block without arguments
A code block name, as assigned by ‘NAME’ keyword from the example above, optionally followed by parentheses.

#+BEGIN_SRC emacs-lisp :var length=table-length()
  (* 2 length)
#+END_SRC

#+RESULTS:
: 8
code block with arguments
A code block name, as assigned by ‘NAME’ keyword, followed by parentheses and optional arguments passed within the parentheses. The block is evaluated with point at its location.

#+NAME: double
#+BEGIN_SRC emacs-lisp :var input=8
  (* 2 input)
#+END_SRC

#+RESULTS: double
: 16

#+NAME: squared
#+BEGIN_SRC emacs-lisp :var input=double(input=1)
  (* input input)
#+END_SRC

#+RESULTS: squared
: 4
literal example, or code block contents
A code block or literal example block named with a ‘NAME’ keyword, followed by brackets (optional for example blocks).

#+NAME: literal-example
#+BEGIN_EXAMPLE
  A literal example
  on two lines
#+END_EXAMPLE

#+NAME: read-literal-example
#+BEGIN_SRC emacs-lisp :var x=literal-example[]
  (concatenate #'string x " for you.")
#+END_SRC

#+RESULTS: read-literal-example
: A literal example
: on two lines for you.
Indexing variable values enables referencing portions of a variable. Indexes are 0 based with negative values counting backwards from the end. If an index is separated by commas then each subsequent section indexes as the next dimension. Note that this indexing occurs before other table-related header arguments are applied, such as ‘hlines’, ‘colnames’ and ‘rownames’. The following example assigns the last cell of the first row the table ‘example-table’ to the variable ‘data’:

#+NAME: example-table
| 1 | a |
| 2 | b |
| 3 | c |
| 4 | d |

#+BEGIN_SRC emacs-lisp :var data=example-table[0,-1]
  data
#+END_SRC

#+RESULTS:
: a
Two integers separated by a colon reference a range of variable values. In that case the entire inclusive range is referenced. For example the following assigns the middle three rows of ‘example-table’ to ‘data’.

#+NAME: example-table
| 1 | a |
| 2 | b |
| 3 | c |
| 4 | d |
| 5 | 3 |

#+BEGIN_SRC emacs-lisp :var data=example-table[1:3]
  data
#+END_SRC

#+RESULTS:
| 2 | b |
| 3 | c |
| 4 | d |
To pick the entire range, use an empty index, or the single character ‘*’. ‘0:-1’ does the same thing. Example below shows how to reference the first column only.

#+NAME: example-table
| 1 | a |
| 2 | b |
| 3 | c |
| 4 | d |

#+BEGIN_SRC emacs-lisp :var data=example-table[,0]
  data
#+END_SRC

#+RESULTS:
| 1 | 2 | 3 | 4 |
Index referencing can be used for tables and code blocks. Index referencing can handle any number of dimensions. Commas delimit multiple dimensions, as shown below.

#+NAME: 3D
#+BEGIN_SRC emacs-lisp
  '(((1  2  3)  (4  5  6)  (7  8  9))
    ((10 11 12) (13 14 15) (16 17 18))
    ((19 20 21) (22 23 24) (25 26 27)))
#+END_SRC

#+BEGIN_SRC emacs-lisp :var data=3D[1,,1]
  data
#+END_SRC

#+RESULTS:
| 11 | 14 | 17 |
Note that row names and column names are not removed prior to variable indexing. You need to take them into account, even when ‘colnames’ or ‘rownames’ header arguments remove them.

Emacs lisp code can also set the values for variables. To differentiate a value from Lisp code, Org interprets any value starting with ‘(’, ‘[’, ‘'’ or ‘`’ as Emacs Lisp code. The result of evaluating that code is then assigned to the value of that variable. The following example shows how to reliably query and pass the file name of the Org mode buffer to a code block using headers. We need reliability here because the file’s name could change once the code in the block starts executing.

#+BEGIN_SRC sh :var filename=(buffer-file-name) :exports both
  wc -w $filename
#+END_SRC
Note that values read from tables and lists are not mistakenly evaluated as Emacs Lisp code, as illustrated in the following example.

#+NAME: table
| (a b c) |

#+HEADER: :var data=table[0,0]
#+BEGIN_SRC perl
  $data
#+END_SRC

#+RESULTS:
: (a b c)
Using sessions
Two code blocks can share the same environment. The ‘session’ header argument is for running multiple source code blocks under one session. Org runs code blocks with the same session name in the same interpreter process.

‘none’
Default. Each code block gets a new interpreter process to execute. The process terminates once the block is evaluated.

STRING
Any string besides ‘none’ turns that string into the name of that session. For example, ‘:session STRING’ names it ‘STRING’. If ‘session’ has no value, then the session name is derived from the source language identifier. Subsequent blocks with the same source code language use the same session. Depending on the language, state variables, code from other blocks, and the overall interpreted environment may be shared. Some interpreted languages support concurrent sessions when subsequent source code language blocks change session names.

Only languages that provide interactive evaluation can have session support. Not all languages provide this support, such as C and ditaa. Even languages, such as Python and Haskell, that do support interactive evaluation impose limitations on allowable language constructs that can run interactively. Org inherits those limitations for those code blocks running in a session.

Choosing a working directory
The ‘dir’ header argument specifies the default directory during code block execution. If it is absent, then the directory associated with the current buffer is used. In other words, supplying ‘:dir DIRECTORY’ temporarily has the same effect as changing the current directory with M-x cd RET DIRECTORY, and then not setting ‘dir’. Under the surface, ‘dir’ simply sets the value of the Emacs variable default-directory. Setting ‘mkdirp’ header argument to a non-nil value creates the directory, if necessary.

Setting ‘dir’ to the symbol attach or the string "'attach" will set ‘dir’ to the directory returned by (org-attach-dir), set ‘:mkdir yes’, and insert any file paths, as when using ‘:results file’, which are under the node’s attachment directory using ‘attachment:’ links instead of the usual ‘file:’ links. Any returned path outside of the attachment directory will use ‘file:’ links as per usual.

For example, to save the plot file in the ‘Work/’ folder of the home directory—notice tilde is expanded:

#+BEGIN_SRC R :file myplot.png :dir ~/Work
  matplot(matrix(rnorm(100), 10), type="l")
#+END_SRC
To evaluate the code block on a remote machine, supply a remote directory name using Tramp syntax. For example:

#+BEGIN_SRC R :file plot.png :dir /scp:dand@yakuba.princeton.edu:
  plot(1:10, main=system("hostname", intern=TRUE))
#+END_SRC
Org first captures the text results as usual for insertion in the Org file. Then Org also inserts a link to the remote file, thanks to Emacs Tramp. Org constructs the remote path to the file name from ‘dir’ and default-directory, as illustrated here:

[[file:/scp:dand@yakuba.princeton.edu:/home/dand/plot.png][plot.png]]
When ‘dir’ is used with ‘session’, Org sets the starting directory for a new session. But Org does not alter the directory of an already existing session.

Do not use ‘dir’ with ‘:exports results’ or with ‘:exports both’ to avoid Org inserting incorrect links to remote files. That is because Org does not expand default directory to avoid some underlying portability issues.

Inserting headers and footers
The ‘prologue’ header argument is for appending to the top of the code block for execution, like a reset instruction. For example, you may use ‘:prologue "reset"’ in a Gnuplot code block or, for every such block:

(add-to-list 'org-babel-default-header-args:gnuplot
             '((:prologue . "reset")))

Likewise, the value of the ‘epilogue’ header argument is for appending to the end of the code block for execution.


**** Evaluating Code Blocks

A note about security: With code evaluation comes the risk of harm. Org safeguards by prompting for user’s permission before executing any code in the source block. To customize this safeguard, or disable it, see Code Evaluation and Security Issues.

How to evaluate source code
Org captures the results of the code block evaluation and inserts them in the Org file, right after the code block. The insertion point is after a newline and the ‘RESULTS’ keyword. Org creates the ‘RESULTS’ keyword if one is not already there. More details in Results of Evaluation.

By default, Org enables only Emacs Lisp code blocks for execution. See Languages to enable other languages.

Org provides many ways to execute code blocks. C-c C-c or C-c C-v e with the point on a code block151 calls the org-babel-execute-src-block function, which executes the code in the block, collects the results, and inserts them in the buffer.

By calling a named code block152 from an Org mode buffer or a table. Org can call the named code blocks from the current Org mode buffer or from the “Library of Babel” (see Library of Babel).

The syntax for ‘CALL’ keyword is:

#+CALL: <name>(<arguments>)
#+CALL: <name>[<inside header arguments>](<arguments>) <end header arguments>
The syntax for inline named code blocks is:

... call_<name>(<arguments>) ...
... call_<name>[<inside header arguments>](<arguments>)[<end header arguments>] ...
When inline syntax is used, the result is wrapped based on the variable org-babel-inline-result-wrap, which by default is set to "=%s=" to produce verbatim text suitable for markup.

‘<name>’
This is the name of the code block (see Structure of Code Blocks) to be evaluated in the current document. If the block is located in another file, start ‘<name>’ with the file name followed by a colon. For example, in order to execute a block named ‘clear-data’ in ‘file.org’, you can write the following:

#+CALL: file.org:clear-data()
‘<arguments>’
Org passes arguments to the code block using standard function call syntax. For example, a ‘#+CALL:’ line that passes ‘4’ to a code block named ‘double’, which declares the header argument ‘:var n=2’, would be written as:

#+CALL: double(n=4)
Note how this function call syntax is different from the header argument syntax.

‘<inside header arguments>’
Org passes inside header arguments to the named code block using the header argument syntax. Inside header arguments apply to code block evaluation. For example, ‘[:results output]’ collects results printed to stdout during code execution of that block. Note how this header argument syntax is different from the function call syntax.

‘<end header arguments>’
End header arguments affect the results returned by the code block. For example, ‘:results html’ wraps the results in a ‘#+BEGIN_EXPORT html’ block before inserting the results in the Org buffer.

Limit code block evaluation
The ‘eval’ header argument can limit evaluation of specific code blocks and ‘CALL’ keyword. It is useful for protection against evaluating untrusted code blocks by prompting for a confirmation.

‘yes’
Org evaluates the source code, possibly asking permission according to org-confirm-babel-evaluate.

‘never’ or ‘no’
Org never evaluates the source code.

‘query’
Org prompts the user for permission to evaluate the source code.

‘never-export’ or ‘no-export’
Org does not evaluate the source code when exporting, yet the user can evaluate it interactively.

‘query-export’
Org prompts the user for permission to evaluate the source code during export.

If ‘eval’ header argument is not set, then Org determines whether to evaluate the source code from the org-confirm-babel-evaluate variable (see Code Evaluation and Security Issues).

Cache results of evaluation
The ‘cache’ header argument is for caching results of evaluating code blocks. Caching results can avoid re-evaluating a code block that have not changed since the previous run. To benefit from the cache and avoid redundant evaluations, the source block must have a result already present in the buffer, and neither the header arguments—including the value of ‘var’ references—nor the text of the block itself has changed since the result was last computed. This feature greatly helps avoid long-running calculations. For some edge cases, however, the cached results may not be reliable.

The caching feature is best for when code blocks are pure functions, that is functions that return the same value for the same input arguments (see Environment of a Code Block), and that do not have side effects, and do not rely on external variables other than the input arguments. Functions that depend on a timer, file system objects, and random number generators are clearly unsuitable for caching.

A note of warning: when ‘cache’ is used in a session, caching may cause unexpected results.

When the caching mechanism tests for any source code changes, it does not expand noweb style references (see Noweb Reference Syntax).

The ‘cache’ header argument can have one of two values: ‘yes’ or ‘no’.

‘no’
Default. No caching of results; code block evaluated every time.

‘yes’
Whether to run the code or return the cached results is determined by comparing the SHA1 hash value of the combined code block and arguments passed to it. This hash value is packed on the ‘#+RESULTS:’ line from previous evaluation. When hash values match, Org does not evaluate the code block. When hash values mismatch, Org evaluates the code block, inserts the results, recalculates the hash value, and updates ‘#+RESULTS:’ line.

In this example, both functions are cached. But ‘caller’ runs only if the result from ‘random’ has changed since the last run.

#+NAME: random
#+BEGIN_SRC R :cache yes
  runif(+1)
#+END_SRC

#+RESULTS[a2a72cd647ad44515fab62e144796432793d68e1]: random
0.4659510825295

#+NAME: caller
#+BEGIN_SRC emacs-lisp :var x=random :cache yes
  x
#+END_SRC

#+RESULTS[bec9c8724e397d5df3b696502df3ed7892fc4f5f]: caller
0.254227238707244
Footnotes
(151)
The option org-babel-no-eval-on-ctrl-c-ctrl-c can be used to remove code evaluation from the C-c C-c key binding.

(152)
Actually, the constructs ‘call_<name>()’ and ‘src_<lang>{}’ are not evaluated when they appear in a keyword (see Summary of In-Buffer Settings).


**** Results of Evaluation

How Org handles results of a code block execution depends on many header arguments working together. The primary determinant, however, is the ‘results’ header argument. It accepts four classes of options. Each code block can take only one option per class:

Collection
For how the results should be collected from the code block;

Type
For which type of result the code block will return; affects how Org processes and inserts results in the Org buffer;

Format
For the result; affects how Org processes results;

Handling
For inserting results once they are properly formatted.

Collection
Collection options specify the results. Choose one of the options; they are mutually exclusive.

‘value’
Default for most Babel libraries153. Functional mode. Org gets the value by wrapping the code in a function definition in the language of the source block. That is why when using ‘:results value’, code should execute like a function and return a value. For languages like Python, an explicit return statement is mandatory when using ‘:results value’. Result is the value returned by the last statement in the code block.

When evaluating the code block in a session (see Environment of a Code Block), Org passes the code to an interpreter running as an interactive Emacs inferior process. Org gets the value from the source code interpreter’s last statement output. Org has to use language-specific methods to obtain the value. For example, from the variable _ in Ruby, and the value of .Last.value in R.

‘output’
Scripting mode. Org passes the code to an external process running the interpreter. Org returns the contents of the standard output stream as text results.

When using a session, Org passes the code to the interpreter running as an interactive Emacs inferior process. Org concatenates any text output from the interpreter and returns the collection as a result.

Type
Type tells what result types to expect from the execution of the code block. Choose one of the options; they are mutually exclusive.

The default behavior is to automatically determine the result type. The result type detection depends on the code block language, as described in the documentation for individual languages. See Languages.

‘table’
‘vector’
Interpret the results as an Org table. If the result is a single value, create a table with one row and one column. Usage example: ‘:results value table’.

In-between each table row or below the table headings, sometimes results have horizontal lines, which are also known as “hlines”. The ‘hlines’ argument with the default ‘no’ value strips such lines from the input table. For most code, this is desirable, or else those ‘hline’ symbols raise unbound variable errors. A ‘yes’ accepts such lines, as demonstrated in the following example.

#+NAME: many-cols
| a | b | c |
|---+---+---|
| d | e | f |
|---+---+---|
| g | h | i |

#+NAME: no-hline
#+BEGIN_SRC python :var tab=many-cols :hlines no
return tab
#+END_SRC

#+RESULTS: no-hline
| a | b | c |
| d | e | f |
| g | h | i |

#+NAME: hlines
#+BEGIN_SRC python :var tab=many-cols :hlines yes
return tab
#+END_SRC

#+RESULTS: hlines
| a | b | c |
|---+---+---|
| d | e | f |
|---+---+---|
| g | h | i |
‘list’
Interpret the results as an Org list. If the result is a single value, create a list of one element.

‘scalar’
‘verbatim’
Interpret literally and insert as quoted text. Do not create a table. Usage example: ‘:results value verbatim’.

‘file’
Interpret as a filename. Save the results of execution of the code block to that file, then insert a link to it. You can control both the filename and the description associated to the link.

Org first tries to generate the filename from the value of the ‘file’ header argument and the directory specified using the ‘output-dir’ header arguments. If ‘output-dir’ is not specified, Org assumes it is the current directory.

#+BEGIN_SRC asymptote :results value file :file circle.pdf :output-dir img/
  size(2cm);
  draw(unitcircle);
#+END_SRC
If ‘file’ header argument is missing, Org generates the base name of the output file from the name of the code block, and its extension from the ‘file-ext’ header argument. In that case, both the name and the extension are mandatory.

Result can also be interpreted as path to file. See ‘:results link’.

#+name: circle
#+BEGIN_SRC asymptote :results value file :file-ext pdf
  size(2cm);
  draw(unitcircle);
#+END_SRC
The ‘file-desc’ header argument defines the description (see Link Format) for the link. If ‘file-desc’ is present but has no value, the ‘file’ value is used as the link description. When this argument is not present, the description is omitted. If you want to provide the ‘file-desc’ argument but omit the description, you can provide it with an empty vector (i.e., :file-desc []).

By default, Org assumes that a table written to a file has TAB-delimited output. You can choose a different separator with the ‘sep’ header argument.

The ‘file-mode’ header argument defines the file permissions. To make it executable, use ‘:file-mode (identity #o755)’.

#+BEGIN_SRC shell :results file :file script.sh :file-mode (identity #o755)
  echo "#!/bin/bash"
  echo "echo Hello World"
#+END_SRC
Format
Format pertains to the type of the result returned by the code block. Choose one of the options; they are mutually exclusive. The default follows from the type specified above.

‘raw’
Interpreted as raw Org mode. Inserted directly into the buffer. Aligned if it is a table. Usage example: ‘:results value raw’.

‘code’
Result enclosed in a code block. Useful for parsing. Usage example: ‘:results value code’.

‘drawer’
Results are added directly to the Org file as with ‘raw’, but are wrapped in a ‘RESULTS’ drawer or results macro (for inline code blocks), for later scripting and automated processing. Usage example: ‘:results value drawer’.

‘html’
Results enclosed in a ‘BEGIN_EXPORT html’ block. Usage example: ‘:results value html’.

‘latex’
Results enclosed in a ‘BEGIN_EXPORT latex’ block. Usage example: ‘:results value latex’.

‘link’
‘graphics’
When used along with ‘file’ type, the result is a link to the file specified in ‘:file’ header argument. However, unlike plain ‘file’ type, code block output is not written to the disk. The block is expected to generate the file by its side-effects only, as in the following example:

#+begin_src shell :results file link :file "org-mode-unicorn.svg"
  wget -c "https://orgmode.org/resources/img/org-mode-unicorn.svg"
#+end_src

#+RESULTS:
[[file:org-mode-unicorn.svg]]
If ‘:file’ header argument is omitted, interpret source block result as the file path.

‘org’
Results enclosed in a ‘BEGIN_SRC org’ block. For comma-escape, either TAB in the block, or export the file. Usage example: ‘:results value org’.

‘pp’
Result converted to pretty-print source code. Enclosed in a code block. Languages supported: Emacs Lisp, Python, and Ruby. Usage example: ‘:results value pp’.

The ‘wrap’ header argument unconditionally marks the results block by appending strings to ‘#+BEGIN_’ and ‘#+END_’. If no string is specified, Org wraps the results in a ‘#+BEGIN_results’ … ‘#+END_results’ block. It takes precedent over the ‘results’ value listed above. E.g.,

#+BEGIN_SRC emacs-lisp :results html :wrap EXPORT markdown
"<blink>Welcome back to the 90's</blink>"
#+END_SRC

#+RESULTS:
#+BEGIN_EXPORT markdown
<blink>Welcome back to the 90's</blink>
#+END_EXPORT
Handling
Handling options after collecting the results. Choose one of the options; they are mutually exclusive.

‘replace’
Default. Insert results in the Org buffer. Remove previous results. Usage example: ‘:results output replace’.

‘silent’
Do not insert results in the Org mode buffer, but echo them in the minibuffer. Usage example: ‘:results output silent’.

‘none’
Compute results, but do not do anything with them. No inserting in the Org mode buffer nor echo them in the minibuffer. The results can still be used when referenced from another code block. Usage example: ‘:results none’.

‘discard’
Ignore the results completely. This option is similar to ‘none’, but no processing is performed on the return value. Calling the code block programmatically (see How to evaluate source code) or by reference (see Passing arguments and Noweb Reference Syntax) will always yield nil.

‘append’
Append results to the Org buffer. Latest results are at the bottom. Does not remove previous results. Usage example: ‘:results output append’.

‘prepend’
Prepend results to the Org buffer. Latest results are at the top. Does not remove previous results. Usage example: ‘:results output prepend’.

Post-processing
The ‘post’ header argument is for post-processing results from block evaluation. When ‘post’ has any value, Org binds the results to *this* variable for easy passing to ‘var’ header argument specifications (see Environment of a Code Block). That makes results available to other code blocks, or even for direct Emacs Lisp code execution.

The following two examples illustrate ‘post’ header argument in action. The first one shows how to attach an ‘ATTR_LATEX’ keyword using ‘post’.

#+NAME: attr_wrap
#+BEGIN_SRC sh :var data="" :var width="\\textwidth" :results output
  echo "#+ATTR_LATEX: :width $width"
  echo "$data"
#+END_SRC

#+HEADER: :file /tmp/it.png
#+BEGIN_SRC dot :post attr_wrap(width="5cm", data=*this*) :results drawer
  digraph{
          a -> b;
          b -> c;
          c -> a;
  }
#+end_src

#+RESULTS:
:RESULTS:
#+ATTR_LATEX :width 5cm
[[file:/tmp/it.png]]
:END:
The second example shows use of ‘colnames’ header argument in ‘post’ to pass data between code blocks.

#+NAME: round-tbl
#+BEGIN_SRC emacs-lisp :var tbl="" fmt="%.3f"
  (mapcar (lambda (row)
            (mapcar (lambda (cell)
                      (if (numberp cell)
                          (format fmt cell)
                        cell))
                    row))
          tbl)
#+end_src

#+BEGIN_SRC R :colnames yes :post round-tbl[:colnames yes](*this*)
  set.seed(42)
  data.frame(foo=rnorm(1))
#+END_SRC

#+RESULTS:
|   foo |
|-------|
| 1.371 |
Footnotes
(153)
Actually, the constructs ‘call_<name>()’ and ‘src_<lang>{}’ are not evaluated when they appear in a keyword (see Summary of In-Buffer Settings).


**** Exporting Code Blocks

It is possible to export the code of code blocks, the results of code block evaluation, both the code and the results of code block evaluation, or none. Org defaults to exporting code for most languages and results for inline code blocks. For some languages, such as ditaa, Org defaults to results both in ordinary source blocks and in inline source blocks. To export just the body of code blocks, see Literal Examples. To selectively export subtrees of an Org document, see Exporting.

The ‘exports’ header argument is to specify if that part of the Org file is exported to, say, HTML or LaTeX formats.

‘code’
The default. The body of code is included into the exported file. Example: ‘:exports code’.

‘results’
The results of evaluation of the code is included in the exported file. Example: ‘:exports results’.

‘both’
Both the code and results of evaluation are included in the exported file. Example: ‘:exports both’.

‘none’
Neither the code nor the results of evaluation is included in the exported file. Whether the code is evaluated at all depends on other options. Example: ‘:exports none’.

If a source block is named using ‘NAME’ keyword, the same name will be assigned to the results of evaluation. This way, fuzzy links pointing to the named source blocks exported using ‘:exports results’ will remain valid and point to the results of evaluation.

Results of evaluation of a named block can also be explicitly named using a separate ‘NAME’ keyword. The name value set via ‘NAME’ keyword will be preferred over the parent source block.

#+NAME: code name
#+BEGIN_SRC emacs-lisp :exports both value
(+ 1 2)
#+END_SRC

#+NAME: results name
#+RESULTS: code name
3

This [[code name][link]] will point to the code block.
Another [[results name][link]] will point to the results.
Explicit setting of the result name may be necessary when a named code block is exported using ‘:exports both’. Links to such block may arbitrarily point either to the code block or to its results when results do not have a distinct name.

Note that all the links pointing to a source block exported using ‘:exports none’ will be broken. This will make export process fail, unless broken links are allowed during export (see Export Settings).

To stop Org from evaluating code blocks to speed exports, use the header argument ‘:eval never-export’ (see Evaluating Code Blocks). To stop Org from evaluating code blocks for greater security, set the org-export-use-babel variable to nil, but understand that header arguments will have no effect.

Turning off evaluation comes in handy when batch processing. For example, markup languages for wikis, which have a high risk of untrusted code. Stopping code block evaluation also stops evaluation of all header arguments of the code block. This may not be desirable in some circumstances. So during export, to allow evaluation of just the header arguments but not any code evaluation in the source block, set ‘:eval never-export’ (see Evaluating Code Blocks).

Org never evaluates code blocks in commented subtrees when exporting (see Comment Lines). On the other hand, Org does evaluate code blocks in subtrees excluded from export (see Export Settings).


**** Extracting Source Code

Extracting source code from code blocks is a basic task in literate programming. Org has features to make this easy. In literate programming parlance, documents on creation are woven with code and documentation, and on export, the code is tangled for execution by a computer. Org facilitates weaving and tangling for producing, maintaining, sharing, and exporting literate programming documents. Org provides extensive customization options for extracting source code.

When Org tangles code blocks, it expands, merges, and transforms them. Then Org recomposes them into one or more separate files, as configured through the options. During this tangling process, Org expands variables in the source code, and resolves any noweb style references (see Noweb Reference Syntax).

Header arguments
The ‘tangle’ header argument specifies if the code block is exported to source file(s).

‘yes’
Export the code block to source file. The file name for the source file is derived from the name of the Org file, and the file extension is derived from the source code language identifier. Example: ‘:tangle yes’.

‘no’
The default. Do not extract the code in a source code file. Example: ‘:tangle no’.

FILENAME
Export the code block to source file whose file name is derived from any string passed to the ‘tangle’ header argument. Org derives the file name as being relative to the directory of the Org file’s location. Example: ‘:tangle FILENAME’.

The ‘mkdirp’ header argument creates parent directories for tangled files if the directory does not exist. A ‘yes’ value enables directory creation whereas ‘no’ inhibits it.

The ‘comments’ header argument controls inserting comments into tangled files. These are above and beyond whatever comments may already exist in the code block.

‘no’
The default. Do not insert any extra comments during tangling.

‘link’
Wrap the code block in comments. Include links pointing back to the place in the Org file from where the code was tangled.

‘yes’
Kept for backward compatibility; same as ‘link’.

‘org’
Nearest headline text from Org file is inserted as comment. The exact text that is inserted is picked from the leading context of the source block.

‘both’
Includes both ‘link’ and ‘org’ options.

‘noweb’
Includes ‘link’ option, expands noweb references (see Noweb Reference Syntax), and wraps them in link comments inside the body of the code block.

The ‘padline’ header argument controls insertion of newlines to pad source code in the tangled file.

‘yes’
Default. Insert a newline before and after each code block in the tangled file.

‘no’
Do not insert newlines to pad the tangled code blocks.

The ‘shebang’ header argument can turn results into executable script files. By setting it to a string value—for example, ‘:shebang "#!/bin/bash"’—Org inserts that string as the first line of the tangled file that the code block is extracted to. Org then turns on the tangled file’s executable permission.

The ‘tangle-mode’ header argument specifies what permissions to set for tangled files by set-file-modes. Permissions are given by an octal value, which can be provided calling the identity function on an elisp octal value. For instance, to create a read-only file one may use ‘:tangle-mode (identity #o444)’. To reduce the verbosity required, a octal shorthand is defined, ‘oXXX’ (‘o’ for octal). Using this, our read-only example is ‘:tangle-mode o444’. Omitting the ‘o’ prefix will cause the argument to be interpreted as an integer, which can lead to unexpected results (‘444’ is the same as ‘o674’). Two other shorthands are recognized, ls-style strings like ‘rw-r--r--’, and chmod-style permissions like ‘g+w’. Note that chmod-style permissions are based on org-babel-tangle-default-file-mode, which is ‘#o544’ by default.

When ‘:tangle-mode’ and ‘:shebang’ are both specified, the give ‘:tangle-mode’ will override the permissions from ‘:shebang’. When multiple source code blocks tangle to a single file with conflicting ‘:tangle-mode’ header arguments, Org’s behavior is undefined.

By default Org expands code blocks during tangling. The ‘no-expand’ header argument turns off such expansions. Note that one side-effect of expansion by org-babel-expand-src-block also assigns values (see Environment of a Code Block) to variables. Expansions also replace noweb references with their targets (see Noweb Reference Syntax). Some of these expansions may cause premature assignment, hence this option. This option makes a difference only for tangling. It has no effect when exporting since code blocks for execution have to be expanded anyway.

Functions
org-babel-tangle
Tangle the current file. Bound to C-c C-v t.

With prefix argument only tangle the current code block.

org-babel-tangle-file
Choose a file to tangle. Bound to C-c C-v f.

Tangle hooks
org-babel-pre-tangle-hook
This hook is run before the tangle process begins. The active buffer is buffer to be tangled.

org-babel-tangle-body-hook
This hook is run from a temporary buffer containing expanded code of every tangled code block. The hook can modify the expanded code as needed. The contents of the current buffer will be used as actual code block expansion.

org-babel-post-tangle-hook
This hook is run from within code files tangled by org-babel-tangle, making it suitable for post-processing, compilation, and evaluation of code in the tangled files.

org-babel-tangle-finished-hook
This hook is run after post-tangle hooks, in the original buffer.

Jumping between code and Org
Debuggers normally link errors and messages back to the source code. But for tangled files, we want to link back to the Org file, not to the tangled source file. To make this extra jump, Org uses org-babel-tangle-jump-to-org function with two additional source code block header arguments:

Set ‘padline’ to true—this is the default setting.
Set ‘comments’ to ‘link’, which makes Org insert links to the Org file.


**** Languages

Code blocks in dozens of languages are supported. See Worg website for language specific documentation.

By default, only Emacs Lisp is enabled for evaluation. To enable or disable other languages, customize the org-babel-load-languages variable either through the Emacs customization interface, or by adding code to the init file as shown next.

In this example, evaluation is disabled for Emacs Lisp, and enabled for R.

(org-babel-do-load-languages
 'org-babel-load-languages
 '((emacs-lisp . nil)
   (R . t)))
Note that this is not the only way to enable a language. Org also enables languages when loaded with require statement. For example, the following enables execution of Clojure code blocks:

(require 'ob-clojure)


**** Editing Source Code

Use C-c ' to edit the current code block. It opens a new major mode edit buffer containing the body of the source code block, ready for any edits. Use C-c ' again to close the buffer and return to the Org buffer.

C-x C-s saves the buffer and updates the contents of the Org buffer. Set org-edit-src-auto-save-idle-delay to save the base buffer after a certain idle delay time. Set org-edit-src-turn-on-auto-save to auto-save this buffer into a separate file using Auto-save mode.

While editing the source code in the major mode, the Org Src minor mode remains active. It provides these customization variables as described below. For even more variables, look in the customization group org-edit-structure.

org-src-lang-modes
If an Emacs major-mode named <LANG>-mode exists, where <LANG> is the language identifier from code block’s header line, then the edit buffer uses that major mode. Use this variable to arbitrarily map language identifiers to major modes.

When language identifier is omitted in the src block, Org mode’s behavior is undefined.

org-src-window-setup
For specifying Emacs window arrangement when the new edit buffer is created.

org-src-preserve-indentation
Default is nil. Source code is indented. This indentation applies during export or tangling, and depending on the context, may alter leading spaces and tabs. When non-nil, source code is aligned with the leftmost column. No lines are modified during export or tangling, which is very useful for white-space sensitive languages, such as Python.

org-src-ask-before-returning-to-edit-buffer
When nil, Org returns to the edit buffer without further prompts. The default prompts for a confirmation.

Fontification of code blocks can give visual separation of text and code on the display page. Set org-src-fontify-natively to non-nil to turn on native code fontification in the Org buffer. The fontification follows the major mode used to edit the code block (see org-src-lang-modes above).

To further customize the appearance of org-block for specific languages, customize org-src-block-faces. The following example shades the background of regular blocks, and colors source blocks only for Python and Emacs Lisp languages.

(require 'color)
(set-face-attribute 'org-block nil :background
                    (color-darken-name
                     (face-attribute 'default :background) 3))

(setq org-src-block-faces '(("emacs-lisp" (:background "#EEE2FF"))
                            ("python" (:background "#E5FFB8"))))


**** Noweb Reference Syntax

Source code blocks can include references to other source code blocks, using a noweb154 style syntax:

<<CODE-BLOCK-ID>>
where CODE-BLOCK-ID refers to either the ‘NAME’ of a single source code block, or a collection of one or more source code blocks sharing the same ‘noweb-ref’ header argument (see Using Header Arguments). Org can replace such references with the source code of the block or blocks being referenced, or, in the case of a single source code block named with ‘NAME’, with the results of an evaluation of that block.

The ‘noweb’ header argument controls expansion of noweb syntax references. Expansions occur when source code blocks are evaluated, tangled, or exported.

‘no’
Default. No expansion of noweb syntax references in the body of the code when evaluating, tangling, or exporting.

‘yes’
Expansion of noweb syntax references in the body of the code block when evaluating, tangling, or exporting.

‘tangle’
Expansion of noweb syntax references in the body of the code block when tangling. No expansion when evaluating or exporting.

‘strip-tangle’
Expansion of noweb syntax references in the body of the code block when evaluating or exporting. Removes noweb syntax references when exporting.

‘no-export’
Expansion of noweb syntax references in the body of the code block when evaluating or tangling. No expansion when exporting.

‘strip-export’
Expansion of noweb syntax references in the body of the code block when expanding prior to evaluating or tangling. Removes noweb syntax references when exporting.

‘eval’
Expansion of noweb syntax references in the body of the code block only before evaluating.

In the most simple case, the contents of a single source block is inserted within other blocks. Thus, in following example,

#+NAME: initialization
#+BEGIN_SRC emacs-lisp
  (setq sentence "Never a foot too far, even.")
#+END_SRC

#+BEGIN_SRC emacs-lisp :noweb yes
  <<initialization>>
  (reverse sentence)
#+END_SRC
the second code block is expanded as

#+BEGIN_SRC emacs-lisp :noweb yes
  (setq sentence "Never a foot too far, even.")
  (reverse sentence)
#+END_SRC
Note that noweb expansion does not automatically carry over ‘:var’ header arguments155.

You may also include the contents of multiple blocks sharing a common ‘noweb-ref’ header argument, which can be set at the file, subtree, or code block level. In the example Org file shown next, the body of the source code in each block is extracted for concatenation to a pure code file when tangled.

#+BEGIN_SRC sh :tangle yes :noweb yes :shebang #!/bin/sh
  <<fullest-disk>>
#+END_SRC
;* the mount point of the fullest disk
  :PROPERTIES:
  :header-args: :noweb-ref fullest-disk
  :END:

;** query all mounted disks
#+BEGIN_SRC sh
  df \
#+END_SRC

;** strip the header row
#+BEGIN_SRC sh
  |sed '1d' \
#+END_SRC

;** output mount point of fullest disk
#+BEGIN_SRC sh
  |awk '{if (u < +$5) {u = +$5; m = $6}} END {print m}'
#+END_SRC
By default a newline separates each noweb reference concatenation. To use a different separator, edit the ‘noweb-sep’ header argument.

Alternatively, Org can include the results of evaluation of a single code block rather than its body [156. Evaluation occurs when parentheses, possibly including arguments, are appended to the code block name, as shown below.

<<NAME(optional arguments)>>
Note that in this case, a code block name set by ‘NAME’ keyword is required; the reference set by ‘noweb-ref’ will not work when evaluation is desired.

Here is an example that demonstrates how the exported content changes when noweb style references are used with parentheses versus without. Given:

#+NAME: some-code
#+BEGIN_SRC python :var num=0 :results output :exports none
print(num*10)
#+END_SRC
this code block:

#+BEGIN_SRC text :noweb yes
  <<some-code>>
#+END_SRC
expands to:

print(num*10)
Below, a similar noweb style reference is used, but with parentheses, while setting a variable ‘num’ to 10:

#+BEGIN_SRC text :noweb yes
  <<some-code(num=10)>>
#+END_SRC
Note that the expansion now contains the results of the code block ‘some-code’, not the code block itself:

100
Noweb insertions honor prefix characters that appear before the noweb syntax reference. This behavior is illustrated in the following example. Because the ‘<<example>>’ noweb reference appears behind the SQL comment syntax, each line of the expanded noweb reference is commented. With:

#+NAME: example
#+BEGIN_SRC text
  this is the
  multi-line body of example
#+END_SRC
this code block:

#+BEGIN_SRC sql :noweb yes
 ---<<example>>
#+END_SRC
expands to:

#+BEGIN_SRC sql :noweb yes
 ---this is the
 ---multi-line body of example
#+END_SRC
Since this change does not affect noweb replacement text without newlines in them, inline noweb references are acceptable.

This feature can also be used for management of indentation in exported code snippets. With:

#+NAME: if-true
#+BEGIN_SRC python :exports none
print('do things when true')
#+end_src

#+name: if-false
#+begin_src python :exports none
print('do things when false')
#+end_src
this code block:

#+begin_src python :noweb yes :results output
if true:
    <<if-true>>
else:
    <<if-false>>
#+end_src
expands to:

if true:
    print('do things when true')
else:
    print('do things when false')
This prefix behavior can be turned off in a block by setting the ‘noweb-prefix’ header argument to ‘no’, as in:

#+BEGIN_SRC elisp :noweb-prefix no
  (setq example-data "<<example>>")
#+END_SRC
which expands to:

(setq example-data "this is the
multi-line body of example")
When in doubt about the outcome of a source code block expansion, you can preview the results with the following command:

C-c C-v v or C-c C-v C-v (org-babel-expand-src-block)
Expand the current source code block according to its header arguments and pop open the results in a preview buffer.

Footnotes
(154)
For noweb literate programming details, see https://www.cs.tufts.edu/~nr/noweb/.

(155)
In the following example, attempting to evaluate the second code block will give an error, because the variables defined in the first code block will not be defined in the second block.

#+NAME: get-prompt
#+BEGIN_SRC emacs-lisp :var prompt="root> " :var command="ls"
  (concat prompt command)
#+END_SRC
#+RESULTS: get-prompt
: root> ls
#+BEGIN_SRC emacs-lisp :noweb yes
  <<get-prompt>>
#+END_SRC
The previous block is expanded without setting prompt and command values.

#+BEGIN_SRC emacs-lisp
  (concat prompt command)
#+END_SRC
(156)
The reference is evaluated with point at the referenced block, using its header arguments (including inherited)


**** Library of Babel

The “Library of Babel” is a collection of code blocks. Like a function library, these code blocks can be called from other Org files. A collection of useful code blocks is available on Worg. For remote code block evaluation syntax, see Evaluating Code Blocks.

For any user to add code to the library, first save the code in regular code blocks of an Org file, and then load the Org file with org-babel-lob-ingest, which is bound to C-c C-v i.


**** Key bindings and Useful Functions

Many common Org mode key sequences are re-bound depending on the context.

Active key bindings in code blocks:

Key binding	Function
C-c C-c	org-babel-execute-src-block
C-c C-o	org-babel-open-src-block-result
M-UP	org-babel-load-in-session
M-DOWN	org-babel-pop-to-session
Active key bindings in Org mode buffer:

Key binding	Function
C-c C-v p or C-c C-v C-p	org-babel-previous-src-block
C-c C-v n or C-c C-v C-n	org-babel-next-src-block
C-c C-v e or C-c C-v C-e	org-babel-execute-maybe
C-c C-v o or C-c C-v C-o	org-babel-open-src-block-result
C-c C-v v or C-c C-v C-v	org-babel-expand-src-block
C-c C-v u or C-c C-v C-u	org-babel-goto-src-block-head
C-c C-v g or C-c C-v C-g	org-babel-goto-named-src-block
C-c C-v r or C-c C-v C-r	org-babel-goto-named-result
C-c C-v b or C-c C-v C-b	org-babel-execute-buffer
C-c C-v s or C-c C-v C-s	org-babel-execute-subtree
C-c C-v d or C-c C-v C-d	org-babel-demarcate-block
C-c C-v t or C-c C-v C-t	org-babel-tangle
C-c C-v f or C-c C-v C-f	org-babel-tangle-file
C-c C-v c or C-c C-v C-c	org-babel-check-src-block
C-c C-v j or C-c C-v C-j	org-babel-insert-header-arg
C-c C-v l or C-c C-v C-l	org-babel-load-in-session
C-c C-v i or C-c C-v C-i	org-babel-lob-ingest
C-c C-v I or C-c C-v C-I	org-babel-view-src-block-info
C-c C-v z or C-c C-v C-z	org-babel-switch-to-session-with-code
C-c C-v a or C-c C-v C-a	org-babel-sha1-hash
C-c C-v h or C-c C-v C-h	org-babel-describe-bindings
C-c C-v x or C-c C-v C-x	org-babel-do-key-sequence-in-edit-buffer

**** Batch Execution

Org mode features, including working with source code facilities can be invoked from the command line. This enables building shell scripts for batch processing, running automated system tasks, and expanding Org mode’s usefulness.

The sample script shows batch processing of multiple files using org-babel-tangle.

#!/bin/sh
# Tangle files with Org mode
#
emacs -Q --batch --eval "
    (progn
      (require 'ob-tangle)
      (dolist (file command-line-args-left)
        (with-current-buffer (find-file-noselect file)
          (org-babel-tangle))))
  " "$@"


*** Miscellaneous

**** Completion

Org has in-buffer completions. Unlike minibuffer completions, which are useful for quick command interactions, Org’s in-buffer completions are more suitable for content creation in Org documents. Type one or more letters and invoke the hot key to complete the text in-place. Depending on the context and the keys, Org offers different types of completions. No minibuffer is involved. Such mode-specific hot keys have become an integral part of Emacs and Org provides several shortcuts.

M-TAB
Complete word at point.

At the beginning of an empty headline, complete TODO keywords.
After ‘\’, complete TeX symbols supported by the exporter.
After ‘:’ in a headline, complete tags. Org deduces the list of tags from the ‘TAGS’ in-buffer option (see Setting Tags), the variable org-tag-alist, or from all tags used in the current buffer.
After ‘:’ and not in a headline, complete property keys. The list of keys is constructed dynamically from all keys used in the current buffer.
After ‘[[’, complete link abbreviations (see Link Abbreviations).
After ‘[[*’, complete headlines in the current buffer so that they can be used in search links like: ‘[[*find this headline]]’
After ‘#+’, complete the special keywords like ‘TYP_TODO’ or file-specific ‘OPTIONS’. After option keyword is complete, pressing M-TAB again inserts example settings for this keyword.
After ‘STARTUP’ keyword, complete startup items.

**** Structure Templates

With just a few keystrokes, it is possible to insert empty structural blocks, such as ‘#+BEGIN_SRC’ … ‘#+END_SRC’, or to wrap existing text in such a block.

C-c C-, (org-insert-structure-template)
Prompt for a type of block structure, and insert the block at point. If the region is active, it is wrapped in the block. First prompts the user for keys, which are used to look up a structure type from the variable below. If the key is TAB, RET, or SPC, the user is prompted to enter a block type.

Available structure types are defined in org-structure-template-alist, see the docstring for adding or changing values.

Org Tempo expands snippets to structures defined in org-structure-template-alist and org-tempo-keywords-alist. For example, < s TAB creates a code block. Enable it by customizing org-modules or add ‘(require 'org-tempo)’ to your Emacs init file157.

a	‘#+BEGIN_EXPORT ascii’ … ‘#+END_EXPORT’
c	‘#+BEGIN_CENTER’ … ‘#+END_CENTER’
C	‘#+BEGIN_COMMENT’ … ‘#+END_COMMENT’
e	‘#+BEGIN_EXAMPLE’ … ‘#+END_EXAMPLE’
E	‘#+BEGIN_EXPORT’ … ‘#+END_EXPORT’
h	‘#+BEGIN_EXPORT html’ … ‘#+END_EXPORT’
l	‘#+BEGIN_EXPORT latex’ … ‘#+END_EXPORT’
q	‘#+BEGIN_QUOTE’ … ‘#+END_QUOTE’
s	‘#+BEGIN_SRC’ … ‘#+END_SRC’
v	‘#+BEGIN_VERSE’ … ‘#+END_VERSE’
Footnotes
(157)
For more information, please refer to the commentary section in ‘org-tempo.el’.

**** Speed Keys

Single keystrokes can execute custom commands in an Org file when point is on a headline. Without the extra burden of a meta or modifier key, Speed Keys can speed navigation or execute custom commands. Besides faster navigation, Speed Keys may come in handy on small mobile devices that do not have full keyboards. Speed Keys may also work on TTY devices known for their problems when entering Emacs key chords.

By default, Org has Speed Keys disabled. To activate Speed Keys, set the variable org-use-speed-commands to a non-nil value. To trigger a Speed Key, point must be at the beginning of an Org headline, before any of the stars.

Org comes with a pre-defined list of Speed Keys. To add or modify Speed Keys, customize the option org-speed-commands. For more details, see the variable’s docstring. With Speed Keys activated, M-x org-speed-command-help, or ? when point is at the beginning of an Org headline, shows currently active Speed Keys, including the user-defined ones.


**** A Cleaner Outline View

Org’s outline with stars and no indents can look cluttered for short documents. For book-like long documents, the effect is not as noticeable. Org provides an alternate stars and indentation scheme, as shown on the right in the following table. It displays only one star and indents text to line up with the heading:

;* Top level headline             |    * Top level headline
;** Second level                  |      * Second level
;*** Third level                  |        * Third level
some text                        |          some text
;*** Third level                  |        * Third level
more text                        |          more text
;* Another top level headline     |    * Another top level headline
Org can achieve this in two ways, (1) by just displaying the buffer in this way without changing it, or (2) by actually indenting every line in the desired amount with hard spaces and hiding leading stars.

***** Org Indent Mode

To display the buffer in the indented view, activate Org Indent minor mode, using M-x org-indent-mode. Text lines that are not headlines are prefixed with virtual spaces to vertically align with the headline text158.

To make more horizontal space, the headlines are shifted by two characters. Configure org-indent-indentation-per-level variable for a different number.

By default, Org Indent mode turns off org-adapt-indentation and does hide leading stars by locally setting org-hide-leading-stars to t: only one star on each headline is visible, the rest are masked with the same font color as the background. If you want to customize this default behavior, see org-indent-mode-turns-on-hiding-stars and org-indent-mode-turns-off-org-adapt-indentation.

To globally turn on Org Indent mode for all files, customize the variable org-startup-indented. To control it for individual files, use ‘STARTUP’ keyword as follows:

#+STARTUP: indent
#+STARTUP: noindent
Footnotes
(158)
Org Indent mode also sets wrap-prefix correctly for indenting and wrapping long lines of headlines or text. This minor mode also handles Visual Line mode and directly applied settings through word-wrap.


***** Hard indentation

It is possible to use hard spaces to achieve the indentation instead, if the bare ASCII file should have the indented look also outside Emacs159. With Org’s support, you have to indent all lines to line up with the outline headers. You would use these settings160:

(setq org-adapt-indentation t
      org-hide-leading-stars t
      org-odd-levels-only t)
Indentation of text below headlines (org-adapt-indentation)
The first setting modifies paragraph filling, line wrapping, and structure editing commands to preserving or adapting the indentation as appropriate.

Hiding leading stars (org-hide-leading-stars)
The second setting makes leading stars invisible by applying the face org-hide to them. For per-file preference, use these file ‘STARTUP’ options:

#+STARTUP: hidestars
#+STARTUP: showstars
Odd levels (org-odd-levels-only)
The third setting makes Org use only odd levels, 1, 3, 5, …, in the outline to create more indentation. On a per-file level, control this with:

#+STARTUP: odd
#+STARTUP: oddeven
To convert a file between single and double stars layouts, use M-x org-convert-to-odd-levels and M-x org-convert-to-oddeven-levels.

Footnotes
(159)
This works, but requires extra effort. Org Indent mode is more convenient for most applications.

(160)
org-adapt-indentation can also be set to ‘'headline-data’, in which case only data lines below the headline will be indented.


**** Execute commands in the active region

When in an Org buffer and the region is active, some commands will apply to all the subtrees in the active region. For example, hitting C-c C-s when multiple headlines are within the active region will successively prompt you for a new schedule date and time. To disable this, set the option org-loop-over-headlines-in-active-region to non-t, activate the region and run the command normally.

org-agenda-loop-over-headlines-in-active-region is the equivalent option of the agenda buffer, where you can also use bulk editing of selected entries.

Not all commands can loop in the active region and what subtrees or headlines are considered can be refined: see the docstrings of these options for more details.


**** Dynamic Headline Numbering

The Org Num minor mode, toggled with M-x org-num-mode, displays outline numbering on top of headlines. It also updates it automatically upon changes to the structure of the document.

By default, all headlines are numbered. You can limit numbering to specific headlines according to their level, tags, ‘COMMENT’ keyword, or ‘UNNUMBERED’ property. Set org-num-max-level, org-num-skip-tags, org-num-skip-commented, org-num-skip-unnumbered, or org-num-skip-footnotes accordingly.

If org-num-skip-footnotes is non-nil, footnotes sections (see Creating Footnotes) are not numbered either.

You can control how the numbering is displayed by setting org-num-face and org-num-format-function.

You can also turn this mode globally for all Org files by setting the option org-startup-numerated to ‘t’, or locally on a file by using ‘#+startup: num’.


**** The Very Busy C-c C-c Key

The C-c C-c key in Org serves many purposes depending on the context. It is probably the most over-worked, multi-purpose key combination in Org. Its uses are well documented throughout this manual, but here is a consolidated list for easy reference.

If column view (see Column View) is on, exit column view.
If any highlights shown in the buffer from the creation of a sparse tree, or from clock display, remove such highlights.
If point is in one of the special ‘KEYWORD’ lines, scan the buffer for these lines and update the information. Also reset the Org file cache used to temporary store the contents of URLs used as values for keywords like ‘SETUPFILE’.
If point is inside a table, realign the table.
If point is on a ‘TBLFM’ keyword, re-apply the formulas to the entire table.
If the current buffer is a capture buffer, close the note and file it. With a prefix argument, also jump to the target location after saving the note.
If point is on a ‘<<<target>>>’, update radio targets and corresponding links in this buffer.
If point is on a property line or at the start or end of a property drawer, offer property commands.
If point is at a footnote reference, go to the corresponding definition, and vice versa.
If point is on a statistics cookie, update it.
If point is in a plain list item with a checkbox, toggle the status of the checkbox.
If point is on a numbered item in a plain list, renumber the ordered list.
If point is on the ‘#+BEGIN’ line of a dynamic block, the block is updated.
If point is at a timestamp, fix the day name in the timestamp.


**** Summary of In-Buffer Settings

In-buffer settings start with ‘#+’, followed by a keyword, a colon, one or more spaces, and then a word for each setting. Org accepts multiple settings on the same line. Org also accepts multiple lines for a keyword. This manual describes these settings throughout. A summary follows here.

C-c C-c activates any changes to the in-buffer settings. Closing and reopening the Org file in Emacs also activates the changes.

‘#+ARCHIVE: %s_done::’
Sets the archive location of the agenda file. The corresponding variable is org-archive-location.

‘#+CATEGORY’
Sets the category of the agenda file, which applies to the entire document.

‘#+COLUMNS: %25ITEM ...’
Set the default format for columns view. This format applies when columns view is invoked in locations where no ‘COLUMNS’ property applies.

‘#+CONSTANTS: name1=value1 ...’
Set file-local values for constants that table formulas can use. This line sets the local variable org-table-formula-constants-local. The global version of this variable is org-table-formula-constants.

‘#+FILETAGS: :tag1:tag2:tag3:’
Set tags that all entries in the file inherit from, including the top-level entries.

‘#+LINK: linkword replace’
Each line specifies one abbreviation for one link. Use multiple ‘LINK’ keywords for more, see Link Abbreviations. The corresponding variable is org-link-abbrev-alist.

‘#+PRIORITIES: highest lowest default’
This line sets the limits and the default for the priorities. All three must be either letters A–Z or numbers 0–9. The highest priority must have a lower ASCII number than the lowest priority.

‘#+PROPERTY: Property_Name Value’
This line sets a default inheritance value for entries in the current buffer, most useful for specifying the allowed values of a property.

‘#+SETUPFILE: file’
The setup file or a URL pointing to such file is for additional in-buffer settings. Org loads this file and parses it for any settings in it when Org opens the main file. If URL is specified, the contents are downloaded and stored in a temporary file cache. C-c C-c on the settings line re-parses and re-loads the file, and also resets the temporary file cache.

Org also parses and loads in-buffer settings from the setup file during normal exporting process. Org parses the in-buffer settings as if it was included in the containing Org buffer. The rest of the contents of setup file is ignored.

To visit the setup file—not a URL—use C-c ' while point is on the line with the setup file name.

‘#+STARTUP:’
Startup options Org uses when first visiting a file.

The first set of options deals with the initial visibility of the outline tree. The corresponding variable for global default settings is org-startup-folded with a default value of showeverything.

‘overview’	Top-level headlines only.
‘content’	All headlines.
‘showall’	No folding on any entry.
‘show2levels’	Headline levels 1-2.
‘show3levels’	Headline levels 1-3.
‘show4levels’	Headline levels 1-4.
‘show5levels’	Headline levels 1-5.
‘showeverything’	Show even drawer contents.
Dynamic virtual indentation is controlled by the variable org-startup-indented161.

‘indent’	Start with Org Indent mode turned on.
‘noindent’	Start with Org Indent mode turned off.
Dynamic virtual numeration of headlines is controlled by the variable org-startup-numerated.

‘num’	Start with Org num mode turned on.
‘nonum’	Start with Org num mode turned off.
Aligns tables consistently upon visiting a file. The corresponding variable is org-startup-align-all-tables with nil as default value.

‘align’	Align all tables.
‘noalign’	Do not align tables on startup.
Shrink table columns with a width cookie. The corresponding variable is org-startup-shrink-all-tables with nil as default value.

When visiting a file, inline images can be automatically displayed. The corresponding variable is org-startup-with-inline-images, with a default value nil to avoid delays when visiting a file.

‘inlineimages’	Show inline images.
‘noinlineimages’	Do not show inline images on startup.
Bracket links in Org buffers are displayed hiding the link path and brackets. For example, ‘[[https://orgmode.org][Org Website]]’ is, by default, displayed as “Org Website”, hiding the link itself and just displaying its description. Alternatively, the links can be displayed in full. The corresponding variable is org-link-descriptive.

‘descriptivelinks’	Hide path and brackets in links.
‘literallinks’	Do not hide anything.
Logging the closing and reopening of TODO items and clock intervals can be configured using these options (see variables org-log-done, org-log-note-clock-out, and org-log-repeat).

‘logdone’	Record a timestamp when an item is marked as done.
‘lognotedone’	Record timestamp and a note when DONE.
‘nologdone’	Do not record when items are marked as done.
‘logrepeat’	Record a time when reinstating a repeating item.
‘lognoterepeat’	Record a note when reinstating a repeating item.
‘nologrepeat’	Do not record when reinstating repeating item.
‘lognoteclock-out’	Record a note when clocking out.
‘nolognoteclock-out’	Do not record a note when clocking out.
‘logreschedule’	Record a timestamp when scheduling time changes.
‘lognotereschedule’	Record a note when scheduling time changes.
‘nologreschedule’	Do not record when a scheduling date changes.
‘logredeadline’	Record a timestamp when deadline changes.
‘lognoteredeadline’	Record a note when deadline changes.
‘nologredeadline’	Do not record when a deadline date changes.
‘logrefile’	Record a timestamp when refiling.
‘lognoterefile’	Record a note when refiling.
‘nologrefile’	Do not record when refiling.
Here are the options for hiding leading stars in outline headings, and for indenting outlines. The corresponding variables are org-hide-leading-stars and org-odd-levels-only, both with a default setting nil (meaning ‘showstars’ and ‘oddeven’).

‘hidestars’	Make all but one of the stars starting a headline invisible.
‘showstars’	Show all stars starting a headline.
‘indent’	Virtual indentation according to outline level.
‘noindent’	No virtual indentation according to outline level.
‘odd’	Allow only odd outline levels (1, 3, …).
‘oddeven’	Allow all outline levels.
To turn on custom format overlays over timestamps (variables org-display-custom-times and org-timestamp-custom-formats), use:

‘customtime’	Overlay custom time format.
The following options influence the table spreadsheet (variable constants-unit-system).

‘constcgs’	‘constants.el’ should use the c-g-s unit system.
‘constSI’	‘constants.el’ should use the SI unit system.
To influence footnote settings, use the following keywords. The corresponding variables are org-footnote-define-inline, org-footnote-auto-label, and org-footnote-auto-adjust.

‘fninline’	Define footnotes inline.
‘fnnoinline’	Define footnotes in separate section.
‘fnlocal’	Define footnotes near first reference, but not inline.
‘fnprompt’	Prompt for footnote labels.
‘fnauto’	Create ‘[fn:1]’-like labels automatically (default).
‘fnconfirm’	Offer automatic label for editing or confirmation.
‘fnadjust’	Automatically renumber and sort footnotes.
‘nofnadjust’	Do not renumber and sort automatically.
‘fnanon’	Create anonymous footnotes with org-footnote-new.
To hide blocks or drawers on startup, use these keywords. The corresponding variables are org-hide-block-startup and org-hide-drawer-startup.

‘hideblocks’	Hide all begin/end blocks on startup.
‘nohideblocks’	Do not hide blocks on startup.
‘hidedrawers’	Hide all begin/end blocks on startup.
‘nohidedrawers’	Do not hide blocks on startup.
The display of entities as UTF-8 characters is governed by the variable org-pretty-entities and the keywords

‘entitiespretty’	Show entities as UTF-8 characters where possible.
‘entitiesplain’	Leave entities plain.
‘#+TAGS: TAG1(c1) TAG2(c2)’
These lines (several such lines are allowed) specify the valid tags in this file, and (potentially) the corresponding fast tag selection keys. The corresponding variable is org-tag-alist.

‘#+TODO:’, ‘#+SEQ_TODO:’, ‘#+TYP_TODO:’
These lines set the TODO keywords and their interpretation in the current file. The corresponding variable is org-todo-keywords.

Footnotes
(161)
Note that Org Indent mode also sets the wrap-prefix property, such that Visual Line mode (or purely setting word-wrap) wraps long lines, including headlines, correctly indented.


**** Regular Expressions

Org, as an Emacs mode, makes use of Elisp regular expressions for searching, matching and filtering. Elisp regular expressions have a somewhat different syntax then some common standards. Most notably, alternation is indicated using ‘\|’ and matching groups are denoted by ‘\(...\)’. For example the string ‘home\|work’ matches either ‘home’ or ‘work’.

For more information, see Regular Expressions in Emacs.


**** Org Syntax

A reference document providing a formal description of Org’s syntax is available as a draft on Worg, initially written by Nicolas Goaziou. It defines Org’s core internal concepts such as “headlines”, “sections”, “affiliated keywords”, “(greater) elements” and “objects”. Each part of an Org document belongs to one of the previous categories.

To explore the abstract structure of an Org buffer, run this in a buffer:

M-: (org-element-parse-buffer) <RET>
It outputs a list containing the buffer’s content represented as an abstract structure. The export engine relies on the information stored in this list. Most interactive commands—e.g., for structure editing—also rely on the syntactic meaning of the surrounding context.

You can probe the syntax of your documents with the command

M-x org-lint <RET>
It runs a number of checks to find common mistakes. It then displays their location in a dedicated buffer, along with a description and a “trust level”, since false-positive are possible. From there, you can operate on the reports with the following keys:

C-j, TAB	Display the offending line
RET	Move point to the offending line
g	Check the document again
h	Hide all reports from the same checker
i	Also remove them from all subsequent checks
S	Sort reports by the column at point


**** Context Dependent Documentation

C-c C-x I in an Org file tries to open a suitable section of the Org manual depending on the syntax at point. For example, using it on a headline displays “Document Structure” section.

q closes the Info window.


**** Escape Character

You may sometimes want to write text that looks like Org syntax, but should really read as plain text. Org may use a specific escape character in some situations, i.e., a backslash in macros (see Macro Replacement) and links (see Link Format), or a comma in source and example blocks (see Literal Examples). In the general case, however, we suggest to use the zero width space. You can insert one with any of the following:

C-x 8 <RET> zero width space <RET>
C-x 8 <RET> 200B <RET>
For example, in order to write ‘[[1,2]]’ as-is in your document, you may write instead

[X[1,2]]
where ‘X’ denotes the zero width space character.


**** Code Evaluation and Security Issues

Unlike plain text, running code comes with risk. Each source code block, in terms of risk, is equivalent to an executable file. Org therefore puts a few confirmation prompts by default. This is to alert the casual user from accidentally running untrusted code.

For users who do not run code blocks or write code regularly, Org’s default settings should suffice. However, some users may want to tweak the prompts for fewer interruptions. To weigh the risks of automatic execution of code blocks, here are some details about code evaluation.

Org evaluates code in the following circumstances:

Source code blocks
Org evaluates source code blocks in an Org file during export. Org also evaluates a source code block with the C-c C-c key chord. Users exporting or running code blocks must load files only from trusted sources. Be wary of customizing variables that remove or alter default security measures.

User Option: org-confirm-babel-evaluate
When t, Org prompts the user for confirmation before executing each code block. When nil, Org executes code blocks without prompting the user for confirmation. When this option is set to a custom function, Org invokes the function with these two arguments: the source code language and the body of the code block. The custom function must return either a t or nil, which determines if the user is prompted. Each source code language can be handled separately through this function argument.

For example, here is how to execute ditaa code blocks without prompting:

(defun my-org-confirm-babel-evaluate (lang body)
  (not (string= lang "ditaa")))  ;don't ask for ditaa
(setq org-confirm-babel-evaluate #'my-org-confirm-babel-evaluate)
Following ‘shell’ and ‘elisp’ links
Org has two link types that can directly evaluate code (see External Links). Because such code is not visible, these links have a potential risk. Org therefore prompts the user when it encounters such links. The customization variables are:

User Option: org-link-shell-confirm-function
Function that prompts the user before executing a shell link.

User Option: org-link-elisp-confirm-function
Function that prompts the user before executing an Emacs Lisp link.

Formulas in tables
Formulas in tables (see The Spreadsheet) are code that is evaluated either by the Calc interpreter, or by the Emacs Lisp interpreter.


**** Interaction with Other Packages

Org’s compatibility and the level of interaction with other Emacs packages are documented here.

***** Packages that Org cooperates with

‘calc.el’ by Dave Gillespie
Org uses the Calc package for implementing spreadsheet functionality in its tables (see The Spreadsheet). Org also uses Calc for embedded calculations. See GNU Emacs Calc Manual.

‘constants.el’ by Carsten Dominik
Org can use names for constants in formulas in tables. Org can also use calculation suffixes for units, such as ‘M’ for ‘Mega’. For a standard collection of such constants, install the ‘constants’ package. Install version 2.0 of this package, available at https://github.com/cdominik/constants-for-Emacs. Org checks if the function constants-get has been autoloaded. Installation instructions are in the file ‘constants.el’.

‘cdlatex.el’ by Carsten Dominik
Org mode can make use of the CDLaTeX package to efficiently enter LaTeX fragments into Org files. See Using CDLaTeX to enter math.

‘imenu.el’ by Ake Stenhoff and Lars Lindberg
Imenu creates dynamic menus based on an index of items in a file. Org mode supports Imenu menus. Enable it with a mode hook as follows:

(add-hook 'org-mode-hook
          (lambda () (imenu-add-to-menubar "Imenu")))
By default the index is two levels deep—you can modify the depth using the option org-imenu-depth.

Org activates Imenu support only in the buffers opened after loading Imenu library. To enable Imenu support in an already opened Org buffer, reload Org.

‘speedbar.el’ by Eric M. Ludlam
Speedbar package creates a special Emacs frame for displaying files and index items in files. Org mode supports Speedbar; users can drill into Org files directly from the Speedbar. The < in the Speedbar frame tweaks the agenda commands to that file or to a subtree.

‘table.el’ by Takaaki Ota
Complex ASCII tables with automatic line wrapping, column- and row-spanning, and alignment can be created using the Emacs table package by Takaaki Ota. Org mode recognizes such tables and exports them properly. C-c ' to edit these tables in a special buffer, much like Org’s code blocks. Because of interference with other Org mode functionality, Takaaki Ota tables cannot be edited directly in the Org buffer.

C-c ' (org-edit-special)
Edit a ‘table.el’ table. Works when point is in a ‘table.el’ table.

C-c ~​ (org-table-create-with-table.el)
Insert a ‘table.el’ table. If there is already a table at point, this command converts it between the ‘table.el’ format and the Org mode format. See the documentation string of the command org-convert-table for the restrictions under which this is possible.


***** Packages that conflict with Org mode

In Emacs, shift-selection combines motions of point with shift key to enlarge regions. Emacs sets this mode by default. This conflicts with Org’s use of S-<cursor> commands to change timestamps, TODO keywords, priorities, and item bullet types, etc. Since S-<cursor> commands outside of specific contexts do not do anything, Org offers the variable org-support-shift-select for customization. Org mode accommodates shift selection by (i) making it available outside of the special contexts where special commands apply, and (ii) extending an existing active region even if point moves across a special context.

‘cua.el’ by Kim F. Storm
Org key bindings conflict with S-<cursor> keys used by CUA mode. For Org to relinquish these bindings to CUA mode, configure the variable org-replace-disputed-keys. When set, Org moves the following key bindings in Org files, and in the agenda buffer—but not during date selection.

S-UP ⇒ M-p	S-DOWN ⇒ M-n
S-LEFT ⇒ M--	S-RIGHT ⇒ M-+
C-S-LEFT ⇒ M-S--	C-S-RIGHT ⇒ M-S-+
Yes, these are unfortunately more difficult to remember. If you want to have other replacement keys, look at the variable org-disputed-keys.

‘ecomplete.el’ by Lars Magne Ingebrigtsen
Ecomplete provides “electric” address completion in address header lines in message buffers. Sadly Orgtbl mode cuts Ecomplete’s power supply: no completion happens when Orgtbl mode is enabled in message buffers while entering text in address header lines. If one wants to use ecomplete one should not follow the advice to automagically turn on Orgtbl mode in message buffers (see The Orgtbl Minor Mode), but instead—after filling in the message headers—turn on Orgtbl mode manually when needed in the messages body.

‘filladapt.el’ by Kyle Jones
Org mode tries to do the right thing when filling paragraphs, list items and other elements. Many users reported problems using both ‘filladapt.el’ and Org mode, so a safe thing to do is to disable filladapt like this:

(add-hook 'org-mode-hook 'turn-off-filladapt-mode)
‘viper.el’ by Michael Kifer
Viper uses C-c / and therefore makes this key not access the corresponding Org mode command org-sparse-tree. You need to find another key for this command, or override the key in viper-vi-global-user-map with

(define-key viper-vi-global-user-map "C-c /" 'org-sparse-tree)
‘windmove.el’ by Hovav Shacham
This package also uses the S-<cursor> keys, so everything written in the paragraph above about CUA mode also applies here. If you want to make the windmove function active in locations where Org mode does not have special functionality on S-<cursor>, add this to your configuration:

;; Make windmove work in Org mode:
(add-hook 'org-shiftup-final-hook 'windmove-up)
(add-hook 'org-shiftleft-final-hook 'windmove-left)
(add-hook 'org-shiftdown-final-hook 'windmove-down)
(add-hook 'org-shiftright-final-hook 'windmove-right)
‘yasnippet.el’
The way Org mode binds the TAB key (binding to [tab] instead of "\t") overrules YASnippet’s access to this key. The following code fixed this problem:

(add-hook 'org-mode-hook
          (lambda ()
            (setq-local yas/trigger-key [tab])
            (define-key yas/keymap [tab] 'yas/next-field-or-maybe-expand)))
The latest version of YASnippet does not play well with Org mode. If the above code does not fix the conflict, start by defining the following function:

(defun yas/org-very-safe-expand ()
  (let ((yas/fallback-behavior 'return-nil)) (yas/expand)))
Then, tell Org mode to use that function:

(add-hook 'org-mode-hook
          (lambda ()
            (make-variable-buffer-local 'yas/trigger-key)
            (setq yas/trigger-key [tab])
            (add-to-list 'org-tab-first-hook 'yas/org-very-safe-expand)
            (define-key yas/keymap [tab] 'yas/next-field)))

**** Using Org on a TTY

Org provides alternative key bindings for TTY and modern mobile devices that cannot perform movement commands on point and key bindings with modifier keys. Some of these workarounds may be more cumbersome than necessary. Users should look into customizing these further based on their usage needs. For example, the normal S-<cursor> for editing timestamp might be better with C-c . chord.

Default	Alternative 1	Speed key	Alternative 2
S-TAB	C-u TAB	C	
M-LEFT	C-c C-x l	l	Esc LEFT
M-S-LEFT	C-c C-x L	L	
M-RIGHT	C-c C-x r	r	Esc RIGHT
M-S-RIGHT	C-c C-x R	R	
M-UP	C-c C-x u		Esc UP
M-S-UP	C-c C-x U	U	
M-DOWN	C-c C-x d		Esc DOWN
M-S-DOWN	C-c C-x D	D	
S-RET	C-c C-x c		
M-RET	C-c C-x m		Esc RET
M-S-RET	C-c C-x M		
S-LEFT	C-c LEFT		
S-RIGHT	C-c RIGHT		
S-UP	C-c UP		
S-DOWN	C-c DOWN		
C-S-LEFT	C-c C-x LEFT		
C-S-RIGHT	C-c C-x RIGHT		
C-c C-,	C-c C-x s		

**** Protocols for External Access

Org protocol is a tool to trigger custom actions in Emacs from external applications. Any application that supports calling external programs with an URL as argument may be used with this functionality. For example, you can configure bookmarks in your web browser to send a link to the current page to Org and create a note from it using capture (see Capture). You can also create a bookmark that tells Emacs to open the local source file of a remote website you are browsing.

In order to use Org protocol from an application, you need to register ‘org-protocol://’ as a valid scheme-handler. External calls are passed to Emacs through the ‘emacsclient’ command, so you also need to ensure an Emacs server is running. More precisely, when the application calls

emacsclient "org-protocol://PROTOCOL?key1=val1&key2=val2"
Emacs calls the handler associated to PROTOCOL with argument ‘(:key1 val1 :key2 val2)’.

Org protocol comes with three predefined protocols, detailed in the following sections. Configure org-protocol-protocol-alist to define your own.

***** The store-link protocol

Using the store-link handler, you can copy links, to that they can be inserted using M-x org-insert-link or yanking. More precisely, the command

emacsclient "org-protocol://store-link?url=URL&title=TITLE"
stores the following link:

[[URL][TITLE]]
In addition, URL is pushed on the kill-ring for yanking. You need to encode URL and TITLE if they contain slashes, and probably quote those for the shell.

To use this feature from a browser, add a bookmark with an arbitrary name, e.g., ‘Org: store-link’ and enter this as Location:

javascript:location.href='org-protocol://store-link?' +
      new URLSearchParams({url:location.href, title:document.title});
Title is an optional parameter. Another expression was recommended earlier:

javascript:location.href='org-protocol://store-link?url='+
      encodeURIComponent(location.href);
The latter form is compatible with older Org versions from 9.0 to 9.4.


***** The capture protocol

Activating the “capture” handler pops up a ‘Capture’ buffer in Emacs, using acapture template.

emacsclient "org-protocol://capture?template=X&url=URL&title=TITLE&body=BODY"
To use this feature, add a bookmark with an arbitrary name, e.g., ‘Org: capture’, and enter this as ‘Location’:

javascript:location.href='org-protocol://capture?' +
      new URLSearchParams({
            template: 'x', url: window.location.href,
            title: document.title, body: window.getSelection()});
You might have seen another expression:

javascript:location.href='org-protocol://capture?template=x'+
      '&url='+encodeURIComponent(window.location.href)+
      '&title='+encodeURIComponent(document.title)+
      '&body='+encodeURIComponent(window.getSelection());
It is a bit more cluttered than the former one, but it is compatible with previous Org versions 9.0-9.4. In these versions encoding of space as “+” character was not supported by URI decoder.

The capture template to be used can be specified in the bookmark (like ‘X’ above). If unspecified, the template key is set in the variable org-protocol-default-template-key. The following template placeholders are available:

%:link          The URL
%:description   The webpage title
%:annotation    Equivalent to [[%:link][%:description]]
%i              The selected text

***** The open-source protocol

The open-source handler is designed to help with editing local sources when reading a document. To that effect, you can use a bookmark with the following location:

javascript:location.href='org-protocol://open-source?&url='+
      encodeURIComponent(location.href)
The variable org-protocol-project-alist maps URLs to local file names, by stripping URL parameters from the end and replacing the :base-url with :working-directory and :online-suffix with :working-suffix. For example, assuming you own a local copy of ‘https://orgmode.org/worg/’ contents at ‘/home/user/worg’, you can set org-protocol-project-alist to the following

(setq org-protocol-project-alist
      '(("Worg"
         :base-url "https://orgmode.org/worg/"
         :working-directory "/home/user/worg/"
         :online-suffix ".html"
         :working-suffix ".org")))
If you are now browsing ‘https://orgmode.org/worg/org-contrib/org-protocol.html’ and find a typo or have an idea about how to enhance the documentation, simply click the bookmark and start editing.

However, such mapping may not always yield the desired results. Suppose you maintain an online store located at ‘https://example.com/’. The local sources reside in ‘/home/user/example/’. It is common practice to serve all products in such a store through one file and rewrite URLs that do not match an existing file on the server. That way, a request to ‘https://example.com/print/posters.html’ might be rewritten on the server to something like ‘https://example.com/shop/products.php/posters.html.php’. The open-source handler probably cannot find a file named ‘/home/user/example/print/posters.html.php’ and fails.

Such an entry in org-protocol-project-alist may hold an additional property :rewrites. This property is a list of cons cells, each of which maps a regular expression to a path relative to the :working-directory.

Now map the URL to the path ‘/home/user/example/products.php’ by adding :rewrites rules like this:

(setq org-protocol-project-alist
      '(("example.com"
         :base-url "https://example.com/"
         :working-directory "/home/user/example/"
         :online-suffix ".php"
         :working-suffix ".php"
         :rewrites (("example.com/print/" . "products.php")
                    ("example.com/$" . "index.php")))))
Since ‘example.com/$’ is used as a regular expression, it maps ‘https://example.com/’, ‘https://example.com’, ‘https://www.example.com/’ and similar to ‘/home/user/example/index.php’.

The :rewrites rules are searched as a last resort if and only if no existing file name is matched.

Two functions can help you filling org-protocol-project-alist with valid contents: org-protocol-create and org-protocol-create-for-org. The latter is of use if you’re editing an Org file that is part of a publishing project.


**** Org Crypt

Org Crypt encrypts the text of an entry, but not the headline, or properties. Behind the scene, it uses the Emacs EasyPG Library to encrypt and decrypt files, and EasyPG needs a correct GnuPG setup.

Any text below a headline that has a ‘crypt’ tag is automatically encrypted when the file is saved. To use a different tag, customize the org-crypt-tag-matcher setting.

Here is a suggestion for Org Crypt settings in Emacs init file:

(require 'org-crypt)
(org-crypt-use-before-save-magic)
(setq org-tags-exclude-from-inheritance '("crypt"))

(setq org-crypt-key nil)
;; GPG key to use for encryption.
;; nil means  use symmetric encryption unconditionally.
;; "" means use symmetric encryption unless heading sets CRYPTKEY property.

(setq auto-save-default nil)
;; Auto-saving does not cooperate with org-crypt.el: so you need to
;; turn it off if you plan to use org-crypt.el quite often.  Otherwise,
;; you'll get an (annoying) message each time you start Org.

;; To turn it off only locally, you can insert this:
;;
;; # -*- buffer-auto-save-file-name: nil; -*-
It’s possible to use different keys for different headings by specifying the respective key as property ‘CRYPTKEY’, e.g.:

;* Totally secret :crypt:
  :PROPERTIES:
  :CRYPTKEY: 0x0123456789012345678901234567890123456789
  :END:
Note that the ‘CRYPTKEY’ property is only effective when org-crypt-key is non-nil. If org-crypt-key is nil, Org uses symmetric encryption unconditionally.

Excluding the ‘crypt’ tag from inheritance prevents already encrypted text from being encrypted again.


**** Org Mobile

Org Mobile is a protocol for synchronizing Org files between Emacs and other applications, e.g., on mobile devices. It enables offline-views and capture support for an Org mode system that is rooted on a “real” computer. The external application can also record changes to existing entries.

This appendix describes Org’s support for agenda view formats compatible with Org Mobile. It also describes synchronizing changes, such as to notes, between the mobile application and the computer.

To change tags and TODO states in the mobile application, first customize the variables org-todo-keywords, org-tag-alist and org-tag-persistent-alist. These should cover all the important tags and TODO keywords, even if Org files use only some of them. Though the mobile application is expected to support in-buffer settings, it is required to understand TODO states sets (see Setting up keywords for individual files) and mutually exclusive tags (see Setting Tags) only for those set in these variables.

***** Setting up the staging area

The mobile application needs access to a file directory on a server162 to interact with Emacs. Pass its location through the org-mobile-directory variable. If you can mount that directory locally just set the variable to point to that directory:

(setq org-mobile-directory "~/orgmobile/")
Alternatively, by using TRAMP (see TRAMP User Manual), org-mobile-directory may point to a remote directory accessible through, for example, SSH, SCP, or DAVS:

(setq org-mobile-directory "/davs:user@remote.host:/org/webdav/")
With a public server, consider encrypting the files. Org also requires OpenSSL installed on the local computer. To turn on encryption, set the same password in the mobile application and in Emacs. Set the password in the variable org-mobile-use-encryption163. Note that even after the mobile application encrypts the file contents, the file name remains visible on the file systems of the local computer, the server, and the mobile device.

Footnotes
(162)
For a server to host files, consider using a WebDAV server, such as Nextcloud. Additional help is at this FAQ entry.

(163)
If Emacs is configured for safe storing of passwords, then configure the variable org-mobile-encryption-password; please read the docstring of that variable.


***** Pushing to the mobile application

The command org-mobile-push copies files listed in org-mobile-files into the staging area. Files include agenda files (as listed in org-agenda-files). Customize org-mobile-files to add other files. File names are staged with paths relative to org-directory, so all files should be inside this directory164.

Push creates a special Org file ‘agendas.org’ with custom agenda views defined by the user165.

Finally, Org writes the file ‘index.org’, containing links to other files. The mobile application reads this file first from the server to determine what other files to download for agendas. For faster downloads, it is expected to only read files whose checksums166 have changed.

Footnotes
(164)
Symbolic links in org-directory need to have the same name as their targets.

(165)
While creating the agendas, Org mode forces ‘ID’ properties on all referenced entries, so that these entries can be uniquely identified if Org Mobile flags them for further action. To avoid setting properties configure the variable org-mobile-force-id-on-agenda-items to nil. Org mode then relies on outline paths, assuming they are unique.

(166)
Checksums are stored automatically in the file ‘checksums.dat’.


***** Pulling from the mobile application

The command org-mobile-pull synchronizes changes with the server. More specifically, it first pulls the Org files for viewing. It then appends captured entries and pointers to flagged or changed entries to the file ‘mobileorg.org’ on the server. Org ultimately integrates its data in an inbox file format, through the following steps:

Org moves all entries found in ‘mobileorg.org’167 and appends them to the file pointed to by the variable org-mobile-inbox-for-pull. It should reside neither in the staging area nor on the server. Each captured entry and each editing event is a top-level entry in the inbox file.
After moving the entries, Org processes changes to the shared files. Some of them are applied directly and without user interaction. Examples include changes to tags, TODO state, headline and body text. Entries requiring further action are tagged as ‘FLAGGED’. Org marks entries with problems with an error message in the inbox. They have to be resolved manually.
Org generates an agenda view for flagged entries for user intervention to clean up. For notes stored in flagged entries, Org displays them in the echo area when point is on the corresponding agenda item.
?
Pressing ? displays the entire flagged note in another window. Org also pushes it to the kill ring. To store flagged note as a normal note, use ? z C-y C-c C-c. Pressing ? twice does these things: first it removes the ‘FLAGGED’ tag; second, it removes the flagged note from the property drawer; third, it signals that manual editing of the flagged entry is now finished.

From the agenda dispatcher, ? returns to the view to finish processing flagged entries. Note that these entries may not be the most recent since the mobile application searches files that were last pulled. To get an updated agenda view with changes since the last pull, pull again.

Footnotes
(167)
The file will be empty after this operation.


**** Drag and Drop & yank-media

Org mode supports drag and drop (DnD) of files. By default, Org asks the user what must be done with the dropped file: attach it, insert ‘file:’ link, or open the file. Customize org-yank-dnd-method to set the default DnD action.

When DnD method is “attach”, Org mode first consults DnD metadata to decide the attach method. For example, when file/files are dragged from a file manager, Org may attach by copying or by moving.

If Org cannot figure out which attachment method to use from the metadata, it defaults to org-yank-dnd-default-attach-method 168

Starting from Emacs 29, Org mode supports yank-media command to yank images from the clipboard and files from a file manager.

When yanking images from clipboard, Org saves the image on disk and inserts the image link to Org buffer. Images are either saved as attachments to heading (default) or to a globally defined directory. The save location is controlled by org-yank-image-save-method.

The yanked images are saved under automatically generated name. You can customize org-yank-image-file-name-function to make Org query the image names or change the naming scheme.

When yanking files copied from a file manager, Org respects the value of org-yank-dnd-method. Image files pasted this way also respect the value of org-yank-image-save-method when the action to perform is ‘attach’.

Footnotes
(168)
By default, org-yank-dnd-default-attach-method is set to nil – use the same value as org-attach-method (cp by default).


*** Appendix A Hacking !!!!

This appendix describes some ways a user can extend the functionality of Org.

**** Hooks

Org has a large number of hook variables for adding functionality. A complete list of hooks with documentation is maintained by the Worg project at https://orgmode.org/worg/doc.html#hooks.


**** Add-on Packages

Various authors wrote a large number of add-on packages for Org. Some of these packages used to be part of the ‘org-mode’ repository but are now hosted in a separate ‘org-contrib’ repository here. A Worg page with more information is at: https://orgmode.org/worg/org-contrib/.


**** Adding Hyperlink Types

Org has many built-in hyperlink types (see Hyperlinks), and an interface for adding new link types. The following example shows the process of adding Org links to Unix man pages, which look like this

[[man:printf][The printf manual]]
The following ‘ol-man.el’ file implements it

;;; ol-man.el - Support for links to man pages in Org mode
(require 'ol)

(org-link-set-parameters "man"
                         :follow #'org-man-open
                         :export #'org-man-export
                         :store #'org-man-store-link)

(defcustom org-man-command 'man
  "The Emacs command to be used to display a man page."
  :group 'org-link
  :type '(choice (const man) (const woman)))

(defun org-man-open (path _)
  "Visit the manpage on PATH.
PATH should be a topic that can be thrown at the man command."
  (funcall org-man-command path))

(defun org-man-store-link (&optional _interactive?)
  "Store a link to a man page."
  (when (memq major-mode '(Man-mode woman-mode))
    ;; This is a man page, we do make this link.
    (let* ((page (org-man-get-page-name))
           (link (concat "man:" page))
           (description (format "Man page for %s" page)))
      (org-link-store-props
       :type "man"
       :link link
       :description description))))

(defun org-man-get-page-name ()
  "Extract the page name from the buffer name."
  ;; This works for both `Man-mode' and `woman-mode'.
  (if (string-match " \\(\\S-+\\)\\*" (buffer-name))
      (match-string 1 (buffer-name))
    (error "Cannot create link to this man page")))

(defun org-man-export (link description format _)
  "Export a man page link from Org files."
  (let ((path (format "http://man.he.net/?topic=%s&section=all" link))
        (desc (or description link)))
    (pcase format
      (`html (format "<a target=\"_blank\" href=\"%s\">%s</a>" path desc))
      (`latex (format "\\href{%s}{%s}" path desc))
      (`texinfo (format "@uref{%s,%s}" path desc))
      (`ascii (format "%s (%s)" desc path))
      (t path))))

(provide ol-man)
;;; ol-man.el ends here
To activate links to man pages in Org, enter this in the Emacs init file:

(require 'ol-man)
A review of ‘ol-man.el’:

First, ‘(require 'ol)’ ensures that ‘ol.el’ is loaded.
Then org-link-set-parameters defines a new link type with ‘man’ prefix and associates functions for following, exporting and storing such links. See the variable org-link-parameters for a complete list of possible associations.
The rest of the file implements necessary variables and functions.
For example, org-man-store-link is responsible for storing a link when org-store-link (see Handling Links) is called from a buffer displaying a man page. It is passed an argument interactive? which this function does not use, but other store functions use to behave differently when a link is stored interactively by the user. It first checks if the major mode is appropriate. If check fails, the function returns nil, which means it isn’t responsible for creating a link to the current buffer. Otherwise the function makes a link string by combining the ‘man:’ prefix with the man topic. It also provides a default description. The function org-insert-link can insert it back into an Org buffer later on.


**** Adding Export Backends

Org’s export engine makes it easy for writing new backends. The framework on which the engine was built makes it easy to derive new backends from existing ones.

The two main entry points to the export engine are: org-export-define-backend and org-export-define-derived-backend. To grok these functions, see ‘ox-latex.el’ for an example of defining a new backend from scratch, and ‘ox-beamer.el’ for an example of deriving from an existing engine.

For creating a new backend from scratch, first set its name as a symbol in an alist consisting of elements and export functions. To make the backend visible to the export dispatcher, set :menu-entry keyword. For export options specific to this backend, set the :options-alist.

For creating a new backend from an existing one, set :translate-alist to an alist of export functions. This alist replaces the parent backend functions.

For complete documentation, see the Org Export Reference on Worg.


**** Tables in Arbitrary Syntax

Due to Org’s success in handling tables with Orgtbl, a frequently requested feature is the use of Org’s table functions in other modes, e.g., LaTeX. This would be hard to do in a general way without complicated customization nightmares. Moreover, that would take Org away from its simplicity roots that Orgtbl has proven. There is, however, an alternate approach to accomplishing the same.

This approach involves implementing a custom translate function that operates on a native Org source table to produce a table in another format. This strategy would keep the excellently working Orgtbl simple and isolate complications, if any, confined to the translate function. To add more alien table formats, we just add more translate functions. Also the burden of developing custom translate functions for new table formats is in the hands of those who know those formats best.

***** Radio tables

Radio tables are target locations for translated tables that are not near their source. Org finds the target location and inserts the translated table.

The key to finding the target location is the magic words ‘BEGIN/END RECEIVE ORGTBL’. They have to appear as comments in the current mode. If the mode is C, then:

/* BEGIN RECEIVE ORGTBL table_name */
/* END RECEIVE ORGTBL table_name */
At the location of source, Org needs a special line to direct Orgtbl to translate and to find the target for inserting the translated table. For example:

#+ORGTBL: SEND table_name translation_function arguments ...
‘table_name’ is the table’s reference name, which is also used in the receiver lines, and the ‘translation_function’ is the Lisp function that translates. This line, in addition, may also contain alternating key and value arguments at the end. The translation function gets these values as a property list. A few standard parameters are already recognized and acted upon before the translation function is called:

‘:skip N’
Skip the first N lines of the table. Hlines do count; include them if they are to be skipped.

‘:skipcols (n1 n2 ...)’
List of columns to be skipped. First Org automatically discards columns with calculation marks and then sends the table to the translator function, which then skips columns as specified in ‘skipcols’.

To keep the source table intact in the buffer without being disturbed when the source file is compiled or otherwise being worked on, use one of these strategies:

Place the table in a block comment. For example, in C mode you could wrap the table between ‘/*’ and ‘*/’ lines.
Put the table after an “end” statement. For example \bye in TeX and \end{document} in LaTeX.
Comment and un-comment each line of the table during edits. The M-x orgtbl-toggle-comment command makes toggling easy.


***** A LaTeX example of radio tables

To wrap a source table in LaTeX, use the ‘comment’ environment provided by ‘comment.sty’169. To activate it, put \usepackage{comment} in the document header. Orgtbl mode inserts a radio table skeleton170 with the command M-x orgtbl-insert-radio-table, which prompts for a table name. For example, if ‘salesfigures’ is the name, the template inserts:

% BEGIN RECEIVE ORGTBL salesfigures
% END RECEIVE ORGTBL salesfigures
\begin{comment}
#+ORGTBL: SEND salesfigures orgtbl-to-latex
| | |
\end{comment}
The line ‘#+ORGTBL: SEND’ tells Orgtbl mode to use the function orgtbl-to-latex to convert the table to LaTeX format, then insert the table at the target (receive) location named ‘salesfigures’. Now the table is ready for data entry. It can even use spreadsheet features171:

% BEGIN RECEIVE ORGTBL salesfigures
% END RECEIVE ORGTBL salesfigures
\begin{comment}
#+ORGTBL: SEND salesfigures orgtbl-to-latex
| Month | Days | Nr sold | per day |
|-------+------+---------+---------|
| Jan   |   23 |      55 |     2.4 |
| Feb   |   21 |      16 |     0.8 |
| March |   22 |     278 |    12.6 |
#+TBLFM: $4=$3/$2;%.1f
% $ (optional extra dollar to keep Font Lock happy, see footnote)
\end{comment}
After editing, C-c C-c inserts the translated table at the target location, between the two marker lines.

For hand-made custom tables, note that the translator needs to skip the first two lines of the source table. Also the command has to splice out the target table without the header and footer.

\begin{tabular}{lrrr}
Month & \multicolumn{1}{c}{Days} & Nr.\ sold & per day\\
% BEGIN RECEIVE ORGTBL salesfigures
% END RECEIVE ORGTBL salesfigures
\end{tabular}
%
\begin{comment}
#+ORGTBL: SEND salesfigures orgtbl-to-latex :splice t :skip 2
| Month | Days | Nr sold | per day |
|-------+------+---------+---------|
| Jan   |   23 |      55 |     2.4 |
| Feb   |   21 |      16 |     0.8 |
| March |   22 |     278 |    12.6 |
#+TBLFM: $4=$3/$2;%.1f
\end{comment}
The LaTeX translator function orgtbl-to-latex is already part of Orgtbl mode and uses a ‘tabular’ environment to typeset the table and marks horizontal lines with \hline. For additional parameters to control output, see Translator functions:

‘:splice BOOLEAN’
When {{{var(BOOLEAN}}} is non-nil, return only table body lines; i.e., not wrapped in ‘tabular’ environment. Default is nil.

‘:fmt FMT’
Format string to warp each field. It should contain ‘%s’ for the original field value. For example, to wrap each field value in dollar symbol, you could use ‘:fmt "$%s$"’. Format can also wrap a property list with column numbers and formats, for example ‘:fmt (2 "$%s$" 4 "%s\\%%")’. In place of a string, a function of one argument can be used; the function must return a formatted string.

‘:efmt EFMT’
Format numbers as exponentials. The spec should have ‘%s’ twice for inserting mantissa and exponent, for example ‘"%s\\times10^{%s}"’. This may also be a property list with column numbers and formats, for example ‘:efmt (2 "$%s\\times10^{%s}$" 4 "$%s\\cdot10^{%s}$")’. After EFMT has been applied to a value, FMT—see above—is also applied. Functions with two arguments can be supplied instead of strings. By default, no special formatting is applied.

Footnotes
(169)
https://www.ctan.org/pkg/comment

(170)
By default this works only for LaTeX, HTML, and Texinfo. Configure the variable orgtbl-radio-table-templates to install templates for other modes.

(171)
If the ‘TBLFM’ keyword contains an odd number of dollar characters, this may cause problems with Font Lock in LaTeX mode. As shown in the example you can fix this by adding an extra line inside the ‘comment’ environment that is used to balance the dollar expressions. If you are using AUCTeX with the font-latex library, a much better solution is to add the ‘comment’ environment to the variable LaTeX-verbatim-environments.


***** Translator functions

Orgtbl mode has built-in translator functions: orgtbl-to-csv (comma-separated values), orgtbl-to-tsv (TAB-separated values), orgtbl-to-latex, orgtbl-to-html, orgtbl-to-texinfo, orgtbl-to-unicode and orgtbl-to-orgtbl. They use the generic translator, orgtbl-to-generic, which delegates translations to various export backends.

Properties passed to the function through the ‘ORGTBL SEND’ line take precedence over properties defined inside the function. For example, this overrides the default LaTeX line endings, \\, with \\[2mm]:

#+ORGTBL: SEND test orgtbl-to-latex :lend " \\\\[2mm]"
For a new language translator, define a converter function. It can be a generic function, such as shown in this example. It marks a beginning and ending of a table with ‘!BTBL!’ and ‘!ETBL!’; a beginning and ending of lines with ‘!BL!’ and ‘!EL!’; and uses a TAB for a field separator:

(defun orgtbl-to-language (table params)
  "Convert the orgtbl-mode TABLE to language."
  (orgtbl-to-generic
   table
   (org-combine-plists
    '(:tstart "!BTBL!" :tend "!ETBL!" :lstart "!BL!" :lend "!EL!" :sep "\t")
    params)))
The documentation for the orgtbl-to-generic function shows a complete list of parameters, each of which can be passed through to orgtbl-to-latex, orgtbl-to-texinfo, and any other function using that generic function.

For complicated translations the generic translator function could be replaced by a custom translator function. Such a custom function must take two arguments and return a single string containing the formatted table. The first argument is the table whose lines are a list of fields or the symbol hline. The second argument is the property list consisting of parameters specified in the ‘#+ORGTBL: SEND’ line. Please share your translator functions by posting them to the Org users mailing list, at mailto:emacs-orgmode@gnu.org.


**** Dynamic Blocks

Org supports dynamic blocks in Org documents. They are inserted with begin and end markers like any other code block, but the contents are updated automatically by a user function.

You can insert a dynamic block with org-dynamic-block-insert-dblock, which is bound to C-c C-x x by default. For example, C-c C-x x c l o c k t a b l e RET inserts a table that updates the work time (see Clocking Work Time).

Dynamic blocks can have names and function parameters. The syntax is similar to source code block specifications:

#+BEGIN: myblock :parameter1 value1 :parameter2 value2 ...
  ...
#+END:
These commands update dynamic blocks:

C-c C-x C-u (org-dblock-update)
Update dynamic block at point.

C-u C-c C-x C-u
Update all dynamic blocks in the current file.

Before updating a dynamic block, Org removes content between the ‘BEGIN’ and ‘END’ markers. Org then reads the parameters on the ‘BEGIN’ line for passing to the writer function as a plist. The previous content of the dynamic block becomes erased from the buffer and appended to the plist under :content.

The syntax for naming a writer function with a dynamic block labeled ‘myblock’ is: org-dblock-write:myblock.

The following is an example of a dynamic block and a block writer function that updates the time when the function was last run:

#+BEGIN: block-update-time :format "on %m/%d/%Y at %H:%M"
  ...
#+END:
The dynamic block’s writer function:

(defun org-dblock-write:block-update-time (params)
  (let ((fmt (or (plist-get params :format) "%d. %m. %Y")))
    (insert "Last block update at: "
            (format-time-string fmt))))
To keep dynamic blocks up-to-date in an Org file, use the function, org-update-all-dblocks in hook, such as before-save-hook. The org-update-all-dblocks function does not run if the file is not in Org mode.

Dynamic blocks, like any other block, can be narrowed with org-narrow-to-block.


**** Special Agenda Views

Org provides a special hook to further limit items in agenda views: agenda, agenda*172, todo, alltodo, tags, tags-todo, tags-tree. Specify a custom function that tests inclusion of every matched item in the view. This function can also skip as much as is needed.

For a global condition applicable to agenda views, use the org-agenda-skip-function-global variable. Org uses a global condition with org-agenda-skip-function for custom searching.

This example defines a function for a custom view showing TODO items with ‘waiting’ status. Manually this is a multi-step search process, but with a custom view, this can be automated as follows:

The custom function searches the subtree for the ‘waiting’ tag and returns nil on match. Otherwise it gives the location from where the search continues.

(defun my-skip-unless-waiting ()
  "Skip trees that are not waiting"
  (let ((subtree-end (save-excursion (org-end-of-subtree t))))
    (if (re-search-forward ":waiting:" subtree-end t)
        nil          ; tag found, do not skip
      subtree-end))) ; tag not found, continue after end of subtree
To use this custom function in a custom agenda command:

(org-add-agenda-custom-command
 '("b" todo "PROJECT"
   ((org-agenda-skip-function 'my-skip-unless-waiting)
    (org-agenda-overriding-header "Projects waiting for something: "))))
Note that this also binds org-agenda-overriding-header to a more meaningful string suitable for the agenda view.

Search for entries with a limit set on levels for the custom search. This is a general approach to creating custom searches in Org. To include all levels, use ‘LEVEL>0’173. Then to selectively pick the matched entries, use org-agenda-skip-function, which also accepts Lisp forms, such as org-agenda-skip-entry-if and org-agenda-skip-subtree-if. For example:

‘(org-agenda-skip-entry-if 'scheduled)’
Skip current entry if it has been scheduled.

‘(org-agenda-skip-entry-if 'notscheduled)’
Skip current entry if it has not been scheduled.

‘(org-agenda-skip-entry-if 'deadline)’
Skip current entry if it has a deadline.

‘(org-agenda-skip-entry-if 'scheduled 'deadline)’
Skip current entry if it has a deadline, or if it is scheduled.

‘(org-agenda-skip-entry-if 'todo '("TODO" "WAITING"))’
Skip current entry if the TODO keyword is TODO or WAITING.

‘(org-agenda-skip-entry-if 'todo 'done)’
Skip current entry if the TODO keyword marks a DONE state.

‘(org-agenda-skip-entry-if 'timestamp)’
Skip current entry if it has any timestamp, may also be deadline or scheduled.

‘(org-agenda-skip-entry-if 'regexp "regular expression")’
Skip current entry if the regular expression matches in the entry.

‘(org-agenda-skip-entry-if 'notregexp "regular expression")’
Skip current entry unless the regular expression matches.

‘(org-agenda-skip-subtree-if 'regexp "regular expression")’
Same as above, but check and skip the entire subtree.

The following is an example of a search for ‘waiting’ without the special function:

(org-add-agenda-custom-command
 '("b" todo "PROJECT"
   ((org-agenda-skip-function '(org-agenda-skip-subtree-if
                                'regexp ":waiting:"))
    (org-agenda-overriding-header "Projects waiting for something: "))))
Footnotes
(172)
The agenda* view is the same as agenda except that it only considers appointments, i.e., scheduled and deadline items that have a time specification ‘[h]h:mm’ in their timestamps.

(173)
Note that, for org-odd-levels-only, a level number corresponds to order in the hierarchy, not to the number of stars.


**** Speeding Up Your Agendas

Some agenda commands slow down when the Org files grow in size or number. Here are tips to speed up:

Reduce the number of Org agenda files to avoid slowdowns due to hard drive accesses.
Reduce the number of DONE and archived headlines so agenda operations that skip over these can finish faster.
Do not dim blocked tasks:
(setq org-agenda-dim-blocked-tasks nil)
Stop preparing agenda buffers on startup:
(setq org-agenda-inhibit-startup t)
Disable tag inheritance for agendas:
(setq org-agenda-use-tag-inheritance nil)
Disable parsing of some properties:
(setq org-agenda-ignore-properties '(stats))
This will disable parsing and updating statistic cookies.

These options can be applied to selected agenda views. For more details about generation of agenda views, see the docstrings for the relevant variables, and this dedicated Worg page for agenda optimization.


**** Extracting Agenda Information

Org provides commands to access agendas through Emacs batch mode. Through this command-line interface, agendas are automated for further processing or printing.

org-batch-agenda creates an agenda view in ASCII and outputs to standard output. This command takes one string parameter. When string consists of a single character, Org uses it as a key to org-agenda-custom-commands. These are the same ones available through the agenda dispatcher (see The Agenda Dispatcher).

This example command line directly prints the TODO list to the printer:

emacs -batch -l ~/.emacs -eval '(org-batch-agenda "t")' | lpr
When the string parameter length is two or more characters, Org matches it with tags/TODO strings. For example, this example command line prints items tagged with ‘shop’, but excludes items tagged with ‘NewYork’:

emacs -batch -l ~/.emacs                                      \
      -eval '(org-batch-agenda "+shop-NewYork")' | lpr
An example showing on-the-fly parameter modifications:

emacs -batch -l ~/.emacs                                      \
   -eval '(org-batch-agenda "a"                               \
           org-agenda-span (quote month)                      \
           org-agenda-include-diary nil                       \
           org-agenda-files (quote ("~/org/project.org")))'   \
   | lpr
which produces an agenda for the next 30 days from just the ‘~/org/projects.org’ file.

For structured processing of agenda output, use org-batch-agenda-csv with the following fields:

category
The category of the item

head
The headline, without TODO keyword, TAGS and PRIORITY

type
The type of the agenda entry, can be

todo	selected in TODO match
tagsmatch	selected in tags match
diary	imported from diary
deadline	a deadline
scheduled	scheduled
timestamp	appointment, selected by timestamp
closed	entry was closed on date
upcoming-deadline	warning about nearing deadline
past-scheduled	forwarded scheduled item
block	entry has date block including date
todo
The TODO keyword, if any

tags
All tags including inherited ones, separated by colons

date
The relevant date, like ‘2007-2-14’

time
The time, like ‘15:00-16:50’

extra
String with extra planning info

priority-l
The priority letter if any was given

priority-n
The computed numerical priority

If the selection of the agenda item was based on a timestamp, including those items with ‘DEADLINE’ and ‘SCHEDULED’ keywords, then Org includes date and time in the output.

If the selection of the agenda item was based on a timestamp (or deadline/scheduled), then Org includes date and time in the output.

Here is an example of a post-processing script in Perl. It takes the CSV output from Emacs and prints with a checkbox:

#!/usr/bin/perl

# define the Emacs command to run
$cmd = "emacs -batch -l ~/.emacs -eval '(org-batch-agenda-csv \"t\")'";

# run it and capture the output
$agenda = qx{$cmd 2>/dev/null};

# loop over all lines
foreach $line (split(/\n/,$agenda)) {
    # get the individual values
    ($category,$head,$type,$todo,$tags,$date,$time,$extra,
     $priority_l,$priority_n) = split(/,/,$line);
    # process and print
    print "[ ] $head\n";
}

**** Using the Property API

Here is a description of the functions that can be used to work with properties.

Function: org-entry-properties &optional pom which
Get all properties of the entry at point-or-marker POM. This includes the TODO keyword, the tags, time strings for deadline, scheduled, and clocking, and any additional properties defined in the entry. The return value is an alist. Keys may occur multiple times if the property key was used several times. POM may also be nil, in which case the current entry is used. If WHICH is nil or all, get all properties. If WHICH is special or standard, only get that subclass.

Function: org-entry-get pom property &optional inherit
Get value of PROPERTY for entry at point-or-marker POM. By default, this only looks at properties defined locally in the entry. If INHERIT is non-nil and the entry does not have the property, then also check higher levels of the hierarchy. If INHERIT is the symbol selective, use inheritance if and only if the setting of org-use-property-inheritance selects PROPERTY for inheritance.

Function: org-entry-delete pom property
Delete the property PROPERTY from entry at point-or-marker POM.

Function: org-entry-put pom property value
Set PROPERTY to VALUES for entry at point-or-marker POM.

Function: org-buffer-property-keys &optional include-specials
Get all property keys in the current buffer.

Function: org-insert-property-drawer
Insert a property drawer for the current entry.

Function: org-entry-put-multivalued-property pom property &rest values
Set PROPERTY at point-or-marker POM to VALUES. VALUES should be a list of strings. They are concatenated, with spaces as separators.

Function: org-entry-get-multivalued-property pom property
Treat the value of the property PROPERTY as a whitespace-separated list of values and return the values as a list of strings.

Function: org-entry-add-to-multivalued-property pom property value
Treat the value of the property PROPERTY as a whitespace-separated list of values and make sure that VALUE is in this list.

Function: org-entry-remove-from-multivalued-property pom property value
Treat the value of the property PROPERTY as a whitespace-separated list of values and make sure that VALUE is not in this list.

Function: org-entry-member-in-multivalued-property pom property value
Treat the value of the property PROPERTY as a whitespace-separated list of values and check if VALUE is in this list.

User Option: org-property-allowed-value-functions
Hook for functions supplying allowed values for a specific property. The functions must take a single argument, the name of the property, and return a flat list of allowed values. If ‘:ETC’ is one of the values, use the values as completion help, but allow also other values to be entered. The functions must return nil if they are not responsible for this property.


**** Using the Mapping API

Org has sophisticated mapping capabilities to find all entries satisfying certain criteria. Internally, this functionality is used to produce agenda views, but there is also an API that can be used to execute arbitrary functions for each or selected entries. The main entry point for this API is:

Function: org-map-entries func &optional match scope &rest skip
Call FUNC at each headline selected by MATCH in SCOPE.

FUNC is a function or a Lisp form. With point positioned at the beginning of the headline, call the function without arguments. Org returns a list of return values of calls to the function.

To avoid preserving point, Org wraps the call to FUNC in save-excursion form. After evaluation, Org moves point to the end of the line that was just processed. Search continues from that point forward. This may not always work as expected under some conditions, such as if the current subtree was removed by a previous archiving operation. In such rare circumstances, Org skips the next entry entirely when it should not. To stop Org from such skips, make FUNC set the variable org-map-continue-from to a specific buffer position.

MATCH is a tags/property/TODO match. Org iterates only matched headlines. Org iterates over all headlines when MATCH is nil or t.

SCOPE determines the scope of this command. It can be any of:

nil
The current buffer, respecting the restriction, if any.

tree
The subtree started with the entry at point.

region
The entries within the active region, if any.

file
The current buffer, without restriction.

file-with-archives
The current buffer, and any archives associated with it.

agenda
All agenda files.

agenda-with-archives
All agenda files with any archive files associated with them.

list of filenames
If this is a list, all files in the list are scanned.

The remaining arguments are treated as settings for the scanner’s skipping facilities. Valid arguments are:

archive
Skip trees with the ‘ARCHIVE’ tag.

comment
Skip trees with the COMMENT keyword.

function or Lisp form
Used as value for org-agenda-skip-function, so whenever the function returns t, FUNC is called for that entry and search continues from the point where the function leaves it.

The mapping routine can call any arbitrary function, even functions that change meta data or query the property API (see Using the Property API). Here are some handy functions:

Function: org-todo &optional arg
Change the TODO state of the entry. See the docstring of the functions for the many possible values for the argument ARG.

Function: org-priority &optional action
Change the priority of the entry. See the docstring of this function for the possible values for ACTION.

Function: org-toggle-tag tag &optional onoff
Toggle the tag TAG in the current entry. Setting ONOFF to either on or off does not toggle tag, but ensure that it is either on or off.

Function: org-promote
Promote the current entry.

Function: org-demote
Demote the current entry.

This example turns all entries tagged with ‘TOMORROW’ into TODO entries with keyword ‘UPCOMING’. Org ignores entries in comment trees and archive trees.

(length (org-map-entries t "/+WAITING" 'agenda))

(org-map-entries '(org-todo "UPCOMING")
                 "+TOMORROW" 'file 'archive 'comment)
The following example counts the number of entries with TODO keyword ‘WAITING’, in all agenda files.

** Printing Hard Copies

Emacs provides commands for printing hardcopies of either an entire buffer or part of one. You can invoke the printing commands directly, as detailed below, or using the ‘File’ menu on the menu bar.

Aside from the commands described in this section, you can also print hardcopies from Dired (see Operating on Files) and the diary (see Displaying the Diary). You can also “print” an Emacs buffer to HTML with the command M-x htmlfontify-buffer, which converts the current buffer to a HTML file, replacing Emacs faces with CSS-based markup. Furthermore, Org mode allows you to print Org files to a variety of formats, such as PDF (see Org Mode).

M-x print-buffer
Print hardcopy of current buffer with page headings containing the file name and page number.

M-x lpr-buffer
Print hardcopy of current buffer without page headings.

M-x print-region
Like print-buffer but print only the current region.

M-x lpr-region
Like lpr-buffer but print only the current region.

On most operating systems, the above hardcopy commands submit files for printing by calling the lpr program. To change the printer program, customize the variable lpr-command. To specify extra switches to give the printer program, customize the list variable lpr-switches. Its value should be a list of option strings, each of which should start with ‘-’ (e.g., the option string "-w80" specifies a line width of 80 columns). The default is the empty list, nil.

To specify the printer to use, set the variable printer-name. The default, nil, specifies the default printer. If you set it to a printer name (a string), that name is passed to lpr with the ‘-P’ switch; if you are not using lpr, you should specify the switch with lpr-printer-switch.

The variable lpr-headers-switches similarly specifies the extra switches to use to make page headers. The variable lpr-add-switches controls whether to supply ‘-T’ and ‘-J’ options (suitable for lpr) to the printer program: nil means don’t add them (this should be the value if your printer program is not compatible with lpr).

*** PostScript Hardcopy

These commands convert buffer contents to PostScript, either printing it or leaving it in another Emacs buffer.

M-x ps-print-buffer
Print hardcopy of the current buffer in PostScript form.

M-x ps-print-region
Print hardcopy of the current region in PostScript form.

M-x ps-print-buffer-with-faces
Print hardcopy of the current buffer in PostScript form, showing the faces used in the text by means of PostScript features.

M-x ps-print-region-with-faces
Print hardcopy of the current region in PostScript form, showing the faces used in the text.

M-x ps-spool-buffer
Generate and spool a PostScript image for the current buffer text.

M-x ps-spool-region
Generate and spool a PostScript image for the current region.

M-x ps-spool-buffer-with-faces
Generate and spool a PostScript image for the current buffer, showing the faces used.

M-x ps-spool-region-with-faces
Generate and spool a PostScript image for the current region, showing the faces used.

M-x ps-despool
Send the spooled PostScript to the printer.

M-x handwrite
Generate/print PostScript for the current buffer as if handwritten.

The ps-print-buffer and ps-print-region commands print buffer contents in PostScript form. One command prints the entire buffer; the other, just the region. The commands ps-print-buffer-with-faces and ps-print-region-with-faces behave similarly, but use PostScript features to show the faces (fonts and colors) of the buffer text.

Interactively, when you use a prefix argument (C-u), these commands prompt the user for a file name, and save the PostScript image in that file instead of sending it to the printer.

The commands whose names have ‘spool’ instead of ‘print’, generate the PostScript output in an Emacs buffer instead of sending it to the printer.

Use the command ps-despool to send the spooled images to the printer. This command sends the PostScript generated by ‘-spool-’ commands (see commands above) to the printer. With a prefix argument (C-u), it prompts for a file name, and saves the spooled PostScript image in that file instead of sending it to the printer.

M-x handwrite is more frivolous. It generates a PostScript rendition of the current buffer as a cursive handwritten document. It can be customized in group handwrite. This function only supports ISO 8859-1 characters.


*** Variables for PostScript Hardcopy

All the PostScript hardcopy commands use the variables ps-lpr-command and ps-lpr-switches to specify how to print the output. ps-lpr-command specifies the command name to run, ps-lpr-switches specifies command line options to use, and ps-printer-name specifies the printer. If you don’t set the first two variables yourself, they take their initial values from lpr-command and lpr-switches. If ps-printer-name is nil, printer-name is used.

The variable ps-print-header controls whether these commands add header lines to each page—set it to nil to turn headers off.

If your printer doesn’t support colors, you should turn off color processing by setting ps-print-color-p to nil. By default, if the display supports colors, Emacs produces hardcopy output with color information; on black-and-white printers, colors are emulated with shades of gray. This might produce barely-readable or even illegible output, even if your screen colors only use shades of gray.

Alternatively, you can set ps-print-color-p to black-white to have colors display better on black/white printers. This works by using information in ps-black-white-faces to express colors by customizable list of shades of gray, augmented by bold and italic face attributes.

By default, PostScript printing ignores the background colors of the faces, unless the variable ps-use-face-background is non-nil. This is to avoid unwanted interference with the zebra stripes and background image/text.

The variable ps-paper-type specifies which size of paper to format for; legitimate values include a4, a3, a4small, b4, b5, executive, ledger, legal, letter, letter-small, statement, tabloid. The default is letter. You can define additional paper sizes by changing the variable ps-page-dimensions-database.

The variable ps-landscape-mode specifies the orientation of printing on the page. The default is nil, which stands for portrait mode. Any non-nil value specifies landscape mode.

The variable ps-number-of-columns specifies the number of columns; it takes effect in both landscape and portrait mode. The default is 1.

The variable ps-font-family specifies which font family to use for printing ordinary text. Legitimate values include Courier, Helvetica, NewCenturySchlbk, Palatino and Times. The variable ps-font-size specifies the size of the font for ordinary text and defaults to 8.5 points. The value of ps-font-size can also be a cons of 2 floats: one for landscape mode, the other for portrait mode.

Emacs supports more scripts and characters than a typical PostScript printer. Thus, some of the characters in your buffer might not be printable using the fonts built into your printer. You can augment the fonts supplied with the printer with those from the GNU Intlfonts package, or you can instruct Emacs to use Intlfonts exclusively. The variable ps-multibyte-buffer controls this: the default value, nil, is appropriate for printing ASCII and Latin-1 characters; a value of non-latin-printer is for printers which have the fonts for ASCII, Latin-1, Japanese, and Korean characters built into them. A value of bdf-font arranges for the BDF fonts from the Intlfonts package to be used for all characters. Finally, a value of bdf-font-except-latin instructs the printer to use built-in fonts for ASCII and Latin-1 characters, and Intlfonts BDF fonts for the rest.

To be able to use the BDF fonts, Emacs needs to know where to find them. The variable bdf-directory-list holds the list of directories where Emacs should look for the fonts; the default value includes a single directory /usr/local/share/emacs/fonts/bdf.

Many other customization variables for these commands are defined and described in the Lisp files ps-print.el and ps-mule.el.


*** Printing Package

The basic Emacs facilities for printing hardcopy can be extended using the Printing package. This provides an easy-to-use interface for choosing what to print, previewing PostScript files before printing, and setting various printing options such as print headers, landscape or portrait modes, duplex modes, and so forth. On GNU/Linux or Unix systems, the Printing package relies on the gs and gv utilities, which are distributed as part of the GhostScript program. On MS-Windows, the gstools port of Ghostscript can be used.

To use the Printing package, add (require 'printing) to your init file (see The Emacs Initialization File), followed by (pr-update-menus). This function replaces the usual printing commands in the menu bar with a ‘Printing’ submenu that contains various printing options. You can also type M-x pr-interface RET; this creates a *Printing Interface* buffer, similar to a customization buffer, where you can set the printing options. After selecting what and how to print, you start the print job using the ‘Print’ button (click mouse-2 on it, or move point over it and type RET). For further information on the various options, use the ‘Interface Help’ button.




** Editing Binary Files

There is a special major mode for editing binary files: Hexl mode. To use it, use M-x hexl-find-file instead of C-x C-f to visit the file. This command converts the file’s contents to hexadecimal and lets you edit the translation. When you save the file, it is converted automatically back to binary.

You can also use M-x hexl-mode to translate an existing buffer into hex. This is useful if you visit a file normally and then discover it is a binary file.

Inserting text always overwrites in Hexl mode. This is to reduce the risk of accidentally spoiling the alignment of data in the file. Ordinary text characters insert themselves (i.e., overwrite with themselves). There are commands for insertion of special characters by their code. Most cursor motion keys, as well as C-x C-s, are bound in Hexl mode to commands that produce the same effect. Here is a list of other important commands special to Hexl mode:

C-M-d
Insert a byte with a code typed in decimal.

C-M-o
Insert a byte with a code typed in octal.

C-M-x
Insert a byte with a code typed in hex.

C-M-a
Move to the beginning of a 512-byte page.

C-M-e
Move to the end of a 512-byte page.

C-x [
Move to the beginning of a 1k-byte page.

C-x ]
Move to the end of a 1k-byte page.

M-g
Move to an address specified in hex.

M-j
Move to an address specified in decimal.

C-c C-c
Leave Hexl mode, going back to the major mode this buffer had before you invoked hexl-mode.

Other Hexl commands let you insert strings (sequences) of binary bytes, move by shorts or ints, etc.; type C-h a hexl- TAB for details.

Hexl mode can also be used for editing text files. This could come in handy if the text file includes unusual characters or uses unusual encoding (see Coding Systems). For this purpose, Hexl commands that insert bytes can also insert ASCII and non-ASCII characters, including multibyte characters. To edit a text file with Hexl, visit the file as usual, and then type M-x hexl-mode RET to switch to Hexl mode. You can now insert text characters by typing them. However, inserting multibyte characters requires special care, to avoid the danger of creating invalid multibyte sequences: you should start typing such characters when point is on the first byte of a multibyte sequence in the file.



* Magit

Magit is an interface to the version control system Git, implemented as an Emacs package. Magit aspires to be a complete Git porcelain. While we cannot (yet) claim that Magit wraps and improves upon each and every Git command, it is complete enough to allow even experienced Git users to perform almost all of their daily version control tasks directly from within Emacs. While many fine Git clients exist, only Magit and Git itself deserve to be called porcelains.


** Introduction

Magit is an interface to the version control system Git, implemented as an Emacs package. Magit aspires to be a complete Git porcelain. While we cannot (yet) claim that Magit wraps and improves upon each and every Git command, it is complete enough to allow even experienced Git users to perform almost all of their daily version control tasks directly from within Emacs. While many fine Git clients exist, only Magit and Git itself deserve to be called porcelains.

Staging and otherwise applying changes is one of the most important features in a Git porcelain and here Magit outshines anything else, including Git itself. Git’s own staging interface (git add --patch) is so cumbersome that many users only use it in exceptional cases. In Magit staging a hunk or even just part of a hunk is as trivial as staging all changes made to a file.

The most visible part of Magit’s interface is the status buffer, which displays information about the current repository. Its content is created by running several Git commands and making their output actionable. Among other things, it displays information about the current branch, lists unpulled and unpushed changes and contains sections displaying the staged and unstaged changes. That might sound noisy, but, since sections are collapsible, it’s not.

To stage or unstage a change one places the cursor on the change and then types s or u. The change can be a file or a hunk, or when the region is active (i.e., when there is a selection) several files or hunks, or even just part of a hunk. The change or changes that these commands - and many others - would act on are highlighted.

Magit also implements several other "apply variants" in addition to staging and unstaging. One can discard or reverse a change, or apply it to the working tree. Git’s own porcelain only supports this for staging and unstaging and you would have to do something like git diff ... | ??? | git apply ... to discard, revert, or apply a single hunk on the command line. In fact that’s exactly what Magit does internally (which is what lead to the term "apply variants").

Magit isn’t just for Git experts, but it does assume some prior experience with Git as well as Emacs. That being said, many users have reported that using Magit was what finally taught them what Git is capable of and how to use it to its fullest. Other users wished they had switched to Emacs sooner so that they would have gotten their hands on Magit earlier.

While one has to know the basic features of Emacs to be able to make full use of Magit, acquiring just enough Emacs skills doesn’t take long and is worth it, even for users who prefer other editors. Vim users are advised to give Evil, the "Extensible VI Layer for Emacs", and Spacemacs, an "Emacs starter-kit focused on Evil" a try.

Magit provides a consistent and efficient Git porcelain. After a short learning period, you will be able to perform most of your daily version control tasks faster than you would on the command line. You will likely also start using features that seemed too daunting in the past.

Magit fully embraces Git. It exposes many advanced features using a simple but flexible interface instead of only wrapping the trivial ones like many GUI clients do. Of course Magit supports logging, cloning, pushing, and other commands that usually don’t fail in spectacular ways; but it also supports tasks that often cannot be completed in a single step. Magit fully supports tasks such as merging, rebasing, cherry-picking, reverting, and blaming by not only providing a command to initiate these tasks but also by displaying context sensitive information along the way and providing commands that are useful for resolving conflicts and resuming the sequence after doing so.

Magit wraps and in many cases improves upon at least the following Git porcelain commands: add, am, bisect, blame, branch, checkout, cherry, cherry-pick, clean, clone, commit, config, describe, diff, fetch, format-patch, init, log, merge, merge-tree, mv, notes, pull, rebase, reflog, remote, request-pull, reset, revert, rm, show, stash, submodule, subtree, tag, and worktree. Many more Magit porcelain commands are implemented on top of Git plumbing commands.


** Getting Started

This short tutorial describes the most essential features that many Magitians use on a daily basis. It only scratches the surface but should be enough to get you started.

IMPORTANT: It is safest if you clone some repository just for this tutorial. Alternatively you can use an existing local repository, but if you do that, then you should commit all uncommitted changes before proceeding.

Type C-x g to display information about the current Git repository in a dedicated buffer, called the status buffer.

Most Magit commands are commonly invoked from the status buffer. It can be considered the primary interface for interacting with Git using Magit. Many other Magit buffers may exist at a given time, but they are often created from this buffer.

Depending on what state your repository is in, this buffer may contain sections titled "Staged changes", "Unstaged changes", "Unmerged into origin/master", "Unpushed to origin/master", and many others.

Since we are starting from a safe state, which you can easily return to (by doing a git reset --hard PRE-MAGIT-STATE), there currently are no staged or unstaged changes. Edit some files and save the changes. Then go back to the status buffer, while at the same time refreshing it, by typing C-x g. (When the status buffer, or any Magit buffer for that matter, is the current buffer, then you can also use just g to refresh it).

Move between sections using p and n. Note that the bodies of some sections are hidden. Type TAB to expand or collapse the section at point. You can also use C-tab to cycle the visibility of the current section and its children. Move to a file section inside the section named "Unstaged changes" and type s to stage the changes you have made to that file. That file now appears under "Staged changes".

Magit can stage and unstage individual hunks, not just complete files. Move to the file you have just staged, expand it using TAB, move to one of the hunks using n, and unstage just that by typing u. Note how the staging (s) and unstaging (u) commands operate on the change at point. Many other commands behave the same way.

You can also un-/stage just part of a hunk. Inside the body of a hunk section (move there using C-n), set the mark using C-SPC and move down until some added and/or removed lines fall inside the region but not all of them. Again type s to stage.

It is also possible to un-/stage multiple files at once. Move to a file section, type C-SPC, move to the next file using n, and then s to stage both files. Note that both the mark and point have to be on the headings of sibling sections for this to work. If the region looks like it does in other buffers, then it doesn’t select Magit sections that can be acted on as a unit.

And then of course you want to commit your changes. Type c. This shows the available commit commands and arguments in a buffer at the bottom of the frame. Each command and argument is prefixed with the key that invokes/sets it. Do not worry about this for now. We want to create a "normal" commit, which is done by typing c again.

Now two new buffers appear. One is for writing the commit message, the other shows a diff with the changes that you are about to commit. Write a message and then type C-c C-c to actually create the commit.

You probably don’t want to push the commit you just created because you just committed some random changes, but if that is not the case you could push it by typing P to show all the available push commands and arguments and then p to push to a branch with the same name as the local branch onto the remote configured as the push-remote. (If the push-remote is not configured yet, then you would first be prompted for the remote to push to.)

So far we have mentioned the commit and push menu commands. These are probably among the menus you will be using the most, but many others exist. To show a menu that lists all other menus (as well as the various apply commands and some other essential commands), type h. Try a few. (Such menus are also called "transient prefix commands" or just "transients".)

The key bindings in that menu correspond to the bindings in Magit buffers, including but not limited to the status buffer. So you could type h d to bring up the diff menu, but once you remember that "d" stands for "diff", you would usually do so by just typing d.

This "prefix of prefixes" is useful even once you have memorized all the bindings, as it can provide easy access to Magit commands from non-Magit buffers. So, by default, it is globally bound to C-x M-g.

A similar menu featuring (for the most part) commands that act on just the file being visited in the current buffer, is globally bound to C-c M-g. That binding can also be used in buffers, which do not visit a file, but then only a subset of the commands is available.

The global key bindings mentioned in the previous two paragraphs are quite inconvenient. We recommend using C-c g and C-c f instead, but cannot use those key sequences by default because they are strictly reserved for bindings added by the user. See Global Bindings, if you want to explicitly opt-in to the recommended key bindings.

Magit also provides context menus and other mouse commands, see Mouse Support.

It is not necessary that you do so now, but if you stick with Magit, then it is highly recommended that you read the next section too.


** Interface Concepts

*** Modes and Buffers

Magit provides several major-modes. For each of these modes there usually exists only one buffer per repository. Separate modes and thus buffers exist for commits, diffs, logs, and some other things.

Besides these special purpose buffers, there also exists an overview buffer, called the status buffer. It’s usually from this buffer that the user invokes Git commands, or creates or visits other buffers.

In this manual we often speak about "Magit buffers". By that we mean buffers whose major-modes derive from magit-mode.

M-x magit-toggle-buffer-lock
This command locks the current buffer to its value or if the buffer is already locked, then it unlocks it.

Locking a buffer to its value prevents it from being reused to display another value. The name of a locked buffer contains its value, which allows telling it apart from other locked buffers and the unlocked buffer.

Not all Magit buffers can be locked to their values; for example, it wouldn’t make sense to lock a status buffer.

There can only be a single unlocked buffer using a certain major-mode per repository. So when a buffer is being unlocked and another unlocked buffer already exists for that mode and repository, then the former buffer is instead deleted and the latter is displayed in its place.

**** Switching Buffers

Function: magit-display-buffer buffer &optional display-function
This function is a wrapper around display-buffer and is used to display any Magit buffer. It displays BUFFER in some window and, unlike display-buffer, also selects that window, provided magit-display-buffer-noselect is nil. It also runs the hooks mentioned below.

If optional DISPLAY-FUNCTION is non-nil, then that is used to display the buffer. Usually that is nil and the function specified by magit-display-buffer-function is used.

Variable: magit-display-buffer-noselect
When this is non-nil, then magit-display-buffer only displays the buffer but forgoes also selecting the window. This variable should not be set globally, it is only intended to be let-bound, by code that automatically updates "the other window". This is used for example when the revision buffer is updated when you move inside the log buffer.

User Option: magit-display-buffer-function
The function specified here is called by magit-display-buffer with one argument, a buffer, to actually display that buffer. This function should call display-buffer with that buffer as first and a list of display actions as second argument.

Magit provides several functions, listed below, that are suitable values for this option. If you want to use different rules, then a good way of doing that is to start with a copy of one of these functions and then adjust it to your needs.

Instead of using a wrapper around display-buffer, that function itself can be used here, in which case the display actions have to be specified by adding them to display-buffer-alist instead.

To learn about display actions, see (elisp)Choosing Window.

Function: magit-display-buffer-traditional buffer
This function is the current default value of the option magit-display-buffer-function. Before that option and this function were added, the behavior was hard-coded in many places all over the code base but now all the rules are contained in this one function (except for the "noselect" special case mentioned above).

Function: magit-display-buffer-same-window-except-diff-v1
This function displays most buffers in the currently selected window. If a buffer’s mode derives from magit-diff-mode or magit-process-mode, it is displayed in another window.

Function: magit-display-buffer-fullframe-status-v1
This function fills the entire frame when displaying a status buffer. Otherwise, it behaves like magit-display-buffer-traditional.

Function: magit-display-buffer-fullframe-status-topleft-v1
This function fills the entire frame when displaying a status buffer. It behaves like magit-display-buffer-fullframe-status-v1 except that it displays buffers that derive from magit-diff-mode or magit-process-mode to the top or left of the current buffer rather than to the bottom or right. As a result, Magit buffers tend to pop up on the same side as they would if magit-display-buffer-traditional were in use.

Function: magit-display-buffer-fullcolumn-most-v1
This function displays most buffers so that they fill the entire height of the frame. However, the buffer is displayed in another window if (1) the buffer’s mode derives from magit-process-mode, or (2) the buffer’s mode derives from magit-diff-mode, provided that the mode of the current buffer derives from magit-log-mode or magit-cherry-mode.

User Option: magit-pre-display-buffer-hook
This hook is run by magit-display-buffer before displaying the buffer.

Function: magit-save-window-configuration
This function saves the current window configuration. Later when the buffer is buried, it may be restored by magit-restore-window-configuration.

User Option: magit-post-display-buffer-hook
This hook is run by magit-display-buffer after displaying the buffer.

Function: magit-maybe-set-dedicated
This function remembers if a new window had to be created to display the buffer, or whether an existing window was reused. This information is later used by magit-mode-quit-window, to determine whether the window should be deleted when its last Magit buffer is buried.


**** Naming Buffers

User Option: magit-generate-buffer-name-function
The function used to generate the names of Magit buffers.

Such a function should take the options magit-uniquify-buffer-names as well as magit-buffer-name-format into account. If it doesn’t, then should be clearly stated in the doc-string. And if it supports %-sequences beyond those mentioned in the doc-string of the option magit-buffer-name-format, then its own doc-string should describe the additions.

Function: magit-generate-buffer-name-default-function mode
This function returns a buffer name suitable for a buffer whose major-mode is MODE and which shows information about the repository in which default-directory is located.

This function uses magit-buffer-name-format and supporting all of the %-sequences mentioned the documentation of that option. It also respects the option magit-uniquify-buffer-names.

User Option: magit-buffer-name-format
The format string used to name Magit buffers.

At least the following %-sequences are supported:

%m
The name of the major-mode, but with the -mode suffix removed.

%M
Like %m but abbreviate magit-status-mode as magit.

%v
The value the buffer is locked to, in parentheses, or an empty string if the buffer is not locked to a value.

%V
Like %v, but the string is prefixed with a space, unless it is an empty string.

%t
The top-level directory of the working tree of the repository, or if magit-uniquify-buffer-names is non-nil an abbreviation of that.

%x
If magit-uniquify-buffer-names is nil "*", otherwise the empty string. Due to limitations of the uniquify package, buffer names must end with the path.

The value should always contain %m or %M, %v or %V, and %t. If magit-uniquify-buffer-names is non-nil, then the value must end with %t or %t%x. See issue #2841.

User Option: magit-uniquify-buffer-names
This option controls whether the names of Magit buffers are uniquified. If the names are not being uniquified, then they contain the full path of the top-level of the working tree of the corresponding repository. If they are being uniquified, then they end with the basename of the top-level, or if that would conflict with the name used for other buffers, then the names of all these buffers are adjusted until they no longer conflict.

This is done using the uniquify package; customize its options to control how buffer names are uniquified.


**** Quitting Windows

q (magit-mode-bury-buffer)
This command buries or kills the current Magit buffer. The function specified by option magit-bury-buffer-function is used to bury the buffer when called without a prefix argument or to kill it when called with a single prefix argument.

When called with two or more prefix arguments then it always kills all Magit buffers, associated with the current project, including the current buffer.

User Option: magit-bury-buffer-function
The function used to actually bury or kill the current buffer.

magit-mode-bury-buffer calls this function with one argument. If the argument is non-nil, then the function has to kill the current buffer. Otherwise it has to bury it alive. The default value currently is magit-mode-quit-window.

Function: magit-restore-window-configuration kill-buffer
Bury or kill the current buffer using quit-window, which is called with KILL-BUFFER as first and the selected window as second argument.

Then restore the window configuration that existed right before the current buffer was displayed in the selected frame. Unfortunately that also means that point gets adjusted in all the buffers, which are being displayed in the selected frame.

Function: magit-mode-quit-window kill-buffer
Bury or kill the current buffer using quit-window, which is called with KILL-BUFFER as first and the selected window as second argument.

Then, if the window was originally created to display a Magit buffer and the buried buffer was the last remaining Magit buffer that was ever displayed in the window, then that is deleted.


**** Automatic Refreshing of Magit Buffers

After running a command which may change the state of the current repository, the current Magit buffer and the corresponding status buffer are refreshed. The status buffer can be automatically refreshed whenever a buffer is saved to a file inside the respective repository by adding a hook, like so:

(with-eval-after-load 'magit-mode
  (add-hook 'after-save-hook 'magit-after-save-refresh-status t))
Automatically refreshing Magit buffers ensures that the displayed information is up-to-date most of the time but can lead to a noticeable delay in big repositories. Other Magit buffers are not refreshed to keep the delay to a minimum and also because doing so can sometimes be undesirable.

Buffers can also be refreshed explicitly, which is useful in buffers that weren’t current during the last refresh and after changes were made to the repository outside of Magit.

g (magit-refresh)
This command refreshes the current buffer if its major mode derives from magit-mode as well as the corresponding status buffer.

If the option magit-revert-buffers calls for it, then it also reverts all unmodified buffers that visit files being tracked in the current repository.

G (magit-refresh-all)
This command refreshes all Magit buffers belonging to the current repository and also reverts all unmodified buffers that visit files being tracked in the current repository.

The file-visiting buffers are always reverted, even if magit-revert-buffers is nil.

User Option: magit-refresh-buffer-hook
This hook is run in each Magit buffer that was refreshed during the current refresh - normally the current buffer and the status buffer.

User Option: magit-refresh-status-buffer
When this option is non-nil, then the status buffer is automatically refreshed after running git for side-effects, in addition to the current Magit buffer, which is always refreshed automatically.

Only set this to nil after exhausting all other options to improve performance.

Function: magit-after-save-refresh-status
This function is intended to be added to after-save-hook. After doing that the corresponding status buffer is refreshed whenever a buffer is saved to a file inside a repository.

Note that refreshing a Magit buffer is done by re-creating its contents from scratch, which can be slow in large repositories. If you are not satisfied with Magit’s performance, then you should obviously not add this function to that hook.


**** Automatic Saving of File-Visiting Buffers

File-visiting buffers are by default saved at certain points in time. This doesn’t guarantee that Magit buffers are always up-to-date, but, provided one only edits files by editing them in Emacs and uses only Magit to interact with Git, one can be fairly confident. When in doubt or after outside changes, type g (magit-refresh) to save and refresh explicitly.

User Option: magit-save-repository-buffers
This option controls whether file-visiting buffers are saved before certain events.

If this is non-nil then all modified file-visiting buffers belonging to the current repository may be saved before running commands, before creating new Magit buffers, and before explicitly refreshing such buffers. If this is dontask then this is done without user intervention. If it is t then the user has to confirm each save.


**** Automatic Reverting of File-Visiting Buffers

By default Magit automatically reverts buffers that are visiting files that are being tracked in a Git repository, after they have changed on disk. When using Magit one often changes files on disk by running Git, i.e., "outside Emacs", making this a rather important feature.

For example, if you discard a change in the status buffer, then that is done by running git apply --reverse ..., and Emacs considers the file to have "changed on disk". If Magit did not automatically revert the buffer, then you would have to type M-x revert-buffer RET RET in the visiting buffer before you could continue making changes.

User Option: magit-auto-revert-mode
When this mode is enabled, then buffers that visit tracked files are automatically reverted after the visited files change on disk.

User Option: global-auto-revert-mode
When this mode is enabled, then any file-visiting buffer is automatically reverted after the visited file changes on disk.

If you like buffers that visit tracked files to be automatically reverted, then you might also like any buffer to be reverted, not just those visiting tracked files. If that is the case, then enable this mode instead of magit-auto-revert-mode.

User Option: magit-auto-revert-immediately
This option controls whether Magit reverts buffers immediately.

If this is non-nil and either global-auto-revert-mode or magit-auto-revert-mode is enabled, then Magit immediately reverts buffers by explicitly calling auto-revert-buffers after running Git for side-effects.

If auto-revert-use-notify is non-nil (and file notifications are actually supported), then magit-auto-revert-immediately does not have to be non-nil, because the reverts happen immediately anyway.

If magit-auto-revert-immediately and auto-revert-use-notify are both nil, then reverts happen after auto-revert-interval seconds of user inactivity. That is not desirable.

User Option: auto-revert-use-notify
This option controls whether file notification functions should be used. Note that this variable unfortunately defaults to t even on systems on which file notifications cannot be used.

User Option: magit-auto-revert-tracked-only
This option controls whether magit-auto-revert-mode only reverts tracked files or all files that are located inside Git repositories, including untracked files and files located inside Git’s control directory.

User Option: auto-revert-mode
The global mode magit-auto-revert-mode works by turning on this local mode in the appropriate buffers (but global-auto-revert-mode is implemented differently). You can also turn it on or off manually, which might be necessary if Magit does not notice that a previously untracked file now is being tracked or vice-versa.

User Option: auto-revert-stop-on-user-input
This option controls whether the arrival of user input suspends the automatic reverts for auto-revert-interval seconds.

User Option: auto-revert-interval
This option controls how many seconds Emacs waits for before resuming suspended reverts.

User Option: auto-revert-buffer-list-filter
This option specifies an additional filter used by auto-revert-buffers to determine whether a buffer should be reverted or not.

This option is provided by Magit, which also advises auto-revert-buffers to respect it. Magit users who do not turn on the local mode auto-revert-mode themselves, are best served by setting the value to magit-auto-revert-repository-buffer-p.

However the default is nil, so as not to disturb users who do use the local mode directly. If you experience delays when running Magit commands, then you should consider using one of the predicates provided by Magit - especially if you also use Tramp.

Users who do turn on auto-revert-mode in buffers in which Magit doesn’t do that for them, should likely not use any filter. Users who turn on global-auto-revert-mode, do not have to worry about this option, because it is disregarded if the global mode is enabled.

User Option: auto-revert-verbose
This option controls whether Emacs reports when a buffer has been reverted.

The options with the auto-revert- prefix are located in the Custom group named auto-revert. The other, Magit-specific, options are located in the magit group.

***** Risk of Reverting Automatically

For the vast majority of users, automatically reverting file-visiting buffers after they have changed on disk is harmless.

If a buffer is modified (i.e., it contains changes that haven’t been saved yet), then Emacs will refuse to automatically revert it. If you save a previously modified buffer, then that results in what is seen by Git as an uncommitted change. Git will then refuse to carry out any commands that would cause these changes to be lost. In other words, if there is anything that could be lost, then either Git or Emacs will refuse to discard the changes.

However, if you use file-visiting buffers as a sort of ad hoc "staging area", then the automatic reverts could potentially cause data loss. So far I have heard from only one user who uses such a workflow.

An example: You visit some file in a buffer, edit it, and save the changes. Then, outside of Emacs (or at least not using Magit or by saving the buffer) you change the file on disk again. At this point the buffer is the only place where the intermediate version still exists. You have saved the changes to disk, but that has since been overwritten. Meanwhile Emacs considers the buffer to be unmodified (because you have not made any changes to it since you last saved it to the visited file) and therefore would not object to it being automatically reverted. At this point an Auto-Revert mode would kick in. It would check whether the buffer is modified and since that is not the case it would revert it. The intermediate version would be lost. (Actually you could still get it back using the undo command.)

If your workflow depends on Emacs preserving the intermediate version in the buffer, then you have to disable all Auto-Revert modes. But please consider that such a workflow would be dangerous even without using an Auto-Revert mode, and should therefore be avoided. If Emacs crashes or if you quit Emacs by mistake, then you would also lose the buffer content. There would be no autosave file still containing the intermediate version (because that was deleted when you saved the buffer) and you would not be asked whether you want to save the buffer (because it isn’t modified).


*** Sections

Magit buffers are organized into nested sections, which can be collapsed and expanded, similar to how sections are handled in Org mode. Each section also has a type, and some sections also have a value. For each section type there can also be a local keymap, shared by all sections of that type.

Taking advantage of the section value and type, many commands operate on the current section, or when the region is active and selects sections of the same type, all of the selected sections. Commands that only make sense for a particular section type (as opposed to just behaving differently depending on the type) are usually bound in section type keymaps.

**** Section Movement

To move within a section use the usual keys (C-p, C-n, C-b, C-f etc), whose global bindings are not shadowed. To move to another section use the following commands.

p (magit-section-backward)
When not at the beginning of a section, then move to the beginning of the current section. At the beginning of a section, instead move to the beginning of the previous visible section.

n (magit-section-forward)
Move to the beginning of the next visible section.

M-p (magit-section-backward-siblings)
Move to the beginning of the previous sibling section. If there is no previous sibling section, then move to the parent section instead.

M-n (magit-section-forward-siblings)
Move to the beginning of the next sibling section. If there is no next sibling section, then move to the parent section instead.

^ (magit-section-up)
Move to the beginning of the parent of the current section.

The above commands all call the hook magit-section-movement-hook. Any of the functions listed below can be used as members of this hook.

You might want to remove some of the functions that Magit adds using add-hook. In doing so you have to make sure you do not attempt to remove function that haven’t even been added yet, for example:

(with-eval-after-load 'magit-diff
  (remove-hook 'magit-section-movement-hook
               'magit-hunk-set-window-start))
Variable: magit-section-movement-hook
This hook is run by all of the above movement commands, after arriving at the destination.

Function: magit-hunk-set-window-start
This hook function ensures that the beginning of the current section is visible, provided it is a hunk section. Otherwise, it does nothing.

Loading magit-diff adds this function to the hook.

Function: magit-section-set-window-start
This hook function ensures that the beginning of the current section is visible, regardless of the section’s type. If you add this to magit-section-movement-hook, then you must remove the hunk-only variant in turn.

Function: magit-log-maybe-show-more-commits
This hook function only has an effect in log buffers, and point is on the "show more" section. If that is the case, then it doubles the number of commits that are being shown.

Loading magit-log adds this function to the hook.

Function: magit-log-maybe-update-revision-buffer
When moving inside a log buffer, then this function updates the revision buffer, provided it is already being displayed in another window of the same frame.

Loading magit-log adds this function to the hook.

Function: magit-log-maybe-update-blob-buffer
When moving inside a log buffer and another window of the same frame displays a blob buffer, then this function instead displays the blob buffer for the commit at point in that window.

Function: magit-status-maybe-update-revision-buffer
When moving inside a status buffer, then this function updates the revision buffer, provided it is already being displayed in another window of the same frame.

Function: magit-status-maybe-update-stash-buffer
When moving inside a status buffer, then this function updates the stash buffer, provided it is already being displayed in another window of the same frame.

Function: magit-status-maybe-update-blob-buffer
When moving inside a status buffer and another window of the same frame displays a blob buffer, then this function instead displays the blob buffer for the commit at point in that window.

Function: magit-stashes-maybe-update-stash-buffer
When moving inside a buffer listing stashes, then this function updates the stash buffer, provided it is already being displayed in another window of the same frame.

User Option: magit-update-other-window-delay
Delay before automatically updating the other window.

When moving around in certain buffers, then certain other buffers, which are being displayed in another window, may optionally be updated to display information about the section at point.

When holding down a key to move by more than just one section, then that would update that buffer for each section on the way. To prevent that, updating the revision buffer is delayed, and this option controls for how long. For optimal experience you might have to adjust this delay and/or the keyboard repeat rate and delay of your graphical environment or operating system.


**** Section Visibility

Magit provides many commands for changing the visibility of sections, but all you need to get started are the next two.

TAB (magit-section-toggle)
Toggle the visibility of the body of the current section.

C-c TAB (magit-section-cycle)
C-<tab> (magit-section-cycle)
Cycle the visibility of current section and its children.

If this command is invoked using C-<tab> and that is globally bound to tab-next, then this command pivots to behave like that command, and you must instead use C-c TAB to cycle section visibility.

If you would like to keep using C-<tab> to cycle section visibility but also want to use tab-bar-mode, then you have to prevent that mode from using this key and instead bind another key to tab-next. Because tab-bar-mode does not use a mode map but instead manipulates the global map, this involves advising tab-bar--define-keys.

M-<tab> (magit-section-cycle-diffs)
Cycle the visibility of diff-related sections in the current buffer.

S-<tab> (magit-section-cycle-global)
Cycle the visibility of all sections in the current buffer.

1 (magit-section-show-level-1)
2 (magit-section-show-level-2)
3 (magit-section-show-level-3)
4 (magit-section-show-level-4)
Show sections surrounding the current section up to level N.

M-1 (magit-section-show-level-1-all)
M-2 (magit-section-show-level-2-all)
M-3 (magit-section-show-level-3-all)
M-4 (magit-section-show-level-4-all)
Show all sections up to level N.

Some functions, which are used to implement the above commands, are also exposed as commands themselves. By default no keys are bound to these commands, as they are generally perceived to be much less useful. But your mileage may vary.

Command: magit-section-show
Show the body of the current section.

Command: magit-section-hide
Hide the body of the current section.

Command: magit-section-show-headings
Recursively show headings of children of the current section. Only show the headings. Previously shown text-only bodies are hidden.

Command: magit-section-show-children
Recursively show the bodies of children of the current section. With a prefix argument show children down to the level of the current section, and hide deeper children.

Command: magit-section-hide-children
Recursively hide the bodies of children of the current section.

Command: magit-section-toggle-children
Toggle visibility of bodies of children of the current section.

When a buffer is first created then some sections are shown expanded while others are not. This is hard coded. When a buffer is refreshed then the previous visibility is preserved. The initial visibility of certain sections can also be overwritten using the hook magit-section-set-visibility-hook.

User Option: magit-section-initial-visibility-alist
This options can be used to override the initial visibility of sections. In the future it will also be used to define the defaults, but currently a section’s default is still hardcoded.

The value is an alist. Each element maps a section type or lineage to the initial visibility state for such sections. The state has to be one of show or hide, or a function that returns one of these symbols. A function is called with the section as the only argument.

Use the command magit-describe-section-briefly to determine a section’s lineage or type. The vector in the output is the section lineage and the type is the first element of that vector. Wildcards can be used, see magit-section-match.

User Option: magit-section-cache-visibility
This option controls for which sections the previous visibility state should be restored if a section disappears and later appears again. The value is a boolean or a list of section types. If t, then the visibility of all sections is cached. Otherwise this is only done for sections whose type matches one of the listed types.

This requires that the function magit-section-cached-visibility is a member of magit-section-set-visibility-hook.

Variable: magit-section-set-visibility-hook
This hook is run when first creating a buffer and also when refreshing an existing buffer, and is used to determine the visibility of the section currently being inserted.

Each function is called with one argument, the section being inserted. It should return hide or show, or to leave the visibility undefined nil. If no function decides on the visibility and the buffer is being refreshed, then the visibility is preserved; or if the buffer is being created, then the hard coded default is used.

Usually this should only be used to set the initial visibility but not during refreshes. If magit-insert-section--oldroot is non-nil, then the buffer is being refreshed and these functions should immediately return nil.

User Option: magit-section-visibility-indicator
This option controls whether and how to indicate that a section can be expanded/collapsed.

If nil, then no visibility indicators are shown. Otherwise the value has to have one of these two forms:

(EXPANDABLE-BITMAP . COLLAPSIBLE-BITMAP)
Both values have to be variables whose values are fringe bitmaps. In this case every section that can be expanded or collapsed gets an indicator in the left fringe.

To provide extra padding around the indicator, set left-fringe-width in magit-mode-hook, e.g.:

(add-hook 'magit-mode-hook (lambda ()
                             (setq left-fringe-width 20)))
(STRING . BOOLEAN)
In this case STRING (usually an ellipsis) is shown at the end of the heading of every collapsed section. Expanded sections get no indicator. The cdr controls whether the appearance of these ellipsis take section highlighting into account. Doing so might potentially have an impact on performance, while not doing so is kinda ugly.


**** Section Hooks

Which sections are inserted into certain buffers is controlled with hooks. This includes the status and the refs buffers. For other buffers, e.g., log and diff buffers, this is not possible. The command magit-describe-section can be used to see which hook (if any) was responsible for inserting the section at point.

For buffers whose sections can be customized by the user, a hook variable called magit-TYPE-sections-hook exists. This hook should be changed using magit-add-section-hook. Avoid using add-hooks or the Custom interface.

The various available section hook variables are described later in this manual along with the appropriate "section inserter functions".

Function: magit-add-section-hook hook function &optional at append local
Add the function FUNCTION to the value of section hook HOOK.

Add FUNCTION at the beginning of the hook list unless optional APPEND is non-nil, in which case FUNCTION is added at the end. If FUNCTION already is a member then move it to the new location.

If optional AT is non-nil and a member of the hook list, then add FUNCTION next to that instead. Add before or after AT, or replace AT with FUNCTION depending on APPEND. If APPEND is the symbol replace, then replace AT with FUNCTION. For any other non-nil value place FUNCTION right after AT. If nil, then place FUNCTION right before AT. If FUNCTION already is a member of the list but AT is not, then leave FUNCTION where ever it already is.

If optional LOCAL is non-nil, then modify the hook’s buffer-local value rather than its global value. This makes the hook local by copying the default value. That copy is then modified.

HOOK should be a symbol. If HOOK is void, it is first set to nil. HOOK’s value must not be a single hook function. FUNCTION should be a function that takes no arguments and inserts one or multiple sections at point, moving point forward. FUNCTION may choose not to insert its section(s), when doing so would not make sense. It should not be abused for other side-effects.

To remove a function from a section hook, use remove-hook.


**** Section Types and Values

Each section has a type, for example hunk, file, and commit. Instances of certain section types also have a value. The value of a section of type file, for example, is a file name.

Users usually do not have to worry about a section’s type and value, but knowing them can be handy at times.

H (magit-describe-section)
This command shows information about the section at point in a separate buffer.

Command: magit-describe-section-briefly
This command shows information about the section at point in the echo area, as #<magit-section VALUE [TYPE PARENT-TYPE...] BEGINNING-END>.

Many commands behave differently depending on the type of the section at point and/or somehow consume the value of that section. But that is only one of the reasons why the same key may do something different, depending on what section is current.

Additionally for each section type a keymap might be defined, named magit-TYPE-section-map. That keymap is used as text property keymap of all text belonging to any section of the respective type. If such a map does not exist for a certain type, then you can define it yourself, and it will automatically be used.


**** Section Options

This section describes options that have an effect on more than just a certain type of sections. As you can see there are not many of those.

User Option: magit-section-show-child-count
Whether to append the number of children to section headings. This only affects sections that could benefit from this information.


*** Transient Commands

Many Magit commands are implemented as transient commands. First the user invokes a prefix command, which causes its infix arguments and suffix commands to be displayed in the echo area. The user then optionally sets some infix arguments and finally invokes one of the suffix commands.

This is implemented in the library transient. Earlier Magit releases used the package magit-popup and even earlier versions library magit-key-mode.

Transient is documented in (transient)Top.

C-x M-g (magit-dispatch)
C-c g (magit-dispatch)
This transient prefix command binds most of Magit’s other prefix commands as suffix commands and displays them in a temporary buffer until one of them is invoked. Invoking such a sub-prefix causes the suffixes of that command to be bound and displayed instead of those of magit-dispatch.

This command is also, or especially, useful outside Magit buffers, so Magit by default binds it to C-c M-g in the global keymap. C-c g would be a better binding, but we cannot use that by default, because that key sequence is reserved for the user. See Global Bindings to learn more default and recommended key bindings.


*** Transient Arguments and Buffer Variables

The infix arguments of many of Magit’s transient prefix commands cease to have an effect once the git command that is called with those arguments has returned. Commands that create a commit are a good example for this. If the user changes the arguments, then that only affects the next invocation of a suffix command. If the same transient prefix command is later invoked again, then the arguments are initially reset to the default value. This default value can be set for the current Emacs session or saved permanently, see (transient)Saving Values. It is also possible to cycle through previously used sets of arguments using C-M-p and C-M-n, see (transient)Using History.

However the infix arguments of many other transient commands continue to have an effect even after the git command that was called with those arguments has returned. The most important commands like this are those that display a diff or log in a dedicated buffer. Their arguments obviously continue to have an effect for as long as the respective diff or log is being displayed. Furthermore the used arguments are stored in buffer-local variables for future reference.

For commands in the second group it isn’t always desirable to reset their arguments to the global value when the transient prefix command is invoked again.

As mentioned above, it is possible to cycle through previously used sets of arguments while a transient popup is visible. That means that we could always reset the infix arguments to the default because the set of arguments that is active in the existing buffer is only a few C-M-p away. Magit can be configured to behave like that, but because I expect that most users would not find that very convenient, it is not the default.

Also note that it is possible to change the diff and log arguments used in the current buffer (including the status buffer, which contains both diff and log sections) using the respective "refresh" transient prefix commands on D and L. (d and l on the other hand are intended to change what diff or log is being displayed. It is possible to also change how the diff or log is being displayed at the same time, but if you only want to do the latter, then you should use the refresh variants.) Because these secondary diff and log transient prefixes are about changing the arguments used in the current buffer, they always start out with the set of arguments that are currently in effect in that buffer.

Some commands are usually invoked directly even though they can also be invoked as the suffix of a transient prefix command. Most prominently magit-show-commit is usually invoked by typing RET while point is on a commit in a log, but it can also be invoked from the magit-diff transient prefix.

When such a command is invoked directly, then it is important to reuse the arguments as specified by the respective buffer-local values, instead of using the default arguments. Imagine you press RET in a log to display the commit at point in a different buffer and then use D to change how the diff is displayed in that buffer. And then you press RET on another commit to show that instead and the diff arguments are reset to the default. Not cool; so Magit does not do that by default.

User Option: magit-prefix-use-buffer-arguments
This option controls whether the infix arguments initially shown in certain transient prefix commands are based on the arguments that are currently in effect in the buffer that their suffixes update.

The magit-diff and magit-log transient prefix commands are affected by this option.

User Option: magit-direct-use-buffer-arguments
This option controls whether certain commands, when invoked directly (i.e., not as the suffix of a transient prefix command), use the arguments that are currently active in the buffer that they are about to update. The alternative is to use the default value for these arguments, which might change the arguments that are used in the buffer.

Valid values for both of the above options are:

always: Always use the set of arguments that is currently active in the respective buffer, provided that buffer exists of course.
selected or t: Use the set of arguments from the respective buffer, but only if it is displayed in a window of the current frame. This is the default for both variables.
current: Use the set of arguments from the respective buffer, but only if it is the current buffer.
never: Never use the set of arguments from the respective buffer.
I am afraid it gets more complicated still:

The global diff and log arguments are set for each supported mode individually. The diff arguments for example have different values in magit-diff-mode, magit-revision-mode, magit-merge-preview-mode and magit-status-mode buffers. Setting or saving the value for one mode does not change the value for other modes. The history however is shared.
When magit-show-commit is invoked directly from a log buffer, then the file filter is picked up from that buffer, not from the revision buffer or the mode’s global diff arguments.
Even though they are suffixes of the diff prefix magit-show-commit and magit-stash-show do not use the diff buffer used by the diff commands, instead they use the dedicated revision and stash buffers.
At the time you invoke the diff prefix it is unknown to Magit which of the suffix commands you are going to invoke. While not certain, more often than not users invoke one of the commands that use the diff buffer, so the initial infix arguments are those used in that buffer. However if you invoke one of these commands directly, then Magit knows that it should use the arguments from the revision resp. stash buffer.

The log prefix also features reflog commands, but these commands do not use the log arguments.
If magit-show-refs is invoked from a magit-refs-mode buffer, then it acts as a refresh prefix and therefore unconditionally uses the buffer’s arguments as initial arguments. If it is invoked elsewhere with a prefix argument, then it acts as regular prefix and therefore respects magit-prefix-use-buffer-arguments. If it is invoked elsewhere without a prefix argument, then it acts as a direct command and therefore respects magit-direct-use-buffer-arguments.


*** Completion, Confirmation and the Selection

**** Action Confirmation

By default many actions that could potentially lead to data loss have to be confirmed. This includes many very common actions, so this can quickly become annoying. Many of these actions can be undone and if you have thought about how to undo certain mistakes, then it should be safe to disable confirmation for the respective actions.

The option magit-no-confirm can be used to tell Magit to perform certain actions without the user having to confirm them. Note that while this option can only be used to disable confirmation for a specific set of actions, the next section explains another way of telling Magit to ask fewer questions.

User Option: magit-no-confirm
The value of this option is a list of symbols, representing actions that do not have to be confirmed by the user before being carried out.

By default many potentially dangerous commands ask the user for confirmation. Each of the below symbols stands for an action which, when invoked unintentionally or without being fully aware of the consequences, could lead to tears. In many cases there are several commands that perform variations of a certain action, so we don’t use the command names but more generic symbols.

Applying changes:
discard Discarding one or more changes (i.e., hunks or the complete diff for a file) loses that change, obviously.
reverse Reverting one or more changes can usually be undone by reverting the reversion.
stage-all-changes, unstage-all-changes When there are both staged and unstaged changes, then un-/staging everything would destroy that distinction. Of course that also applies when un-/staging a single change, but then less is lost and one does that so often that having to confirm every time would be unacceptable.
Files:
delete When a file that isn’t yet tracked by Git is deleted, then it is completely lost, not just the last changes. Very dangerous.
trash Instead of deleting a file it can also be move to the system trash. Obviously much less dangerous than deleting it.
Also see option magit-delete-by-moving-to-trash.

resurrect A deleted file can easily be resurrected by "deleting" the deletion, which is done using the same command that was used to delete the same file in the first place.
untrack Untracking a file can be undone by tracking it again.
rename Renaming a file can easily be undone.
Sequences:
reset-bisect Aborting (known to Git as "resetting") a bisect operation loses all information collected so far.
abort-cherry-pick Aborting a cherry-pick throws away all conflict resolutions which have already been carried out by the user.
abort-revert Aborting a revert throws away all conflict resolutions which have already been carried out by the user.
abort-rebase Aborting a rebase throws away all already modified commits, but it’s possible to restore those from the reflog.
abort-merge Aborting a merge throws away all conflict resolutions which have already been carried out by the user.
merge-dirty Merging with a dirty worktree can make it hard to go back to the state before the merge was initiated.
References:
delete-unmerged-branch Once a branch has been deleted, it can only be restored using low-level recovery tools provided by Git. And even then the reflog is gone. The user always has to confirm the deletion of a branch by accepting the default choice (or selecting another branch), but when a branch has not been merged yet, also make sure the user is aware of that.
delete-pr-remote When deleting a branch that was created from a pull-request and if no other branches still exist on that remote, then magit-branch-delete offers to delete the remote as well. This should be safe because it only happens if no other refs exist in the remotes namespace, and you can recreate the remote if necessary.
drop-stashes Dropping a stash is dangerous because Git stores stashes in the reflog. Once a stash is removed, there is no going back without using low-level recovery tools provided by Git. When a single stash is dropped, then the user always has to confirm by accepting the default (or selecting another). This action only concerns the deletion of multiple stashes at once.
Publishing:
set-and-push When pushing to the upstream or the push-remote and that isn’t actually configured yet, then the user can first set the target. If s/he confirms the default too quickly, then s/he might end up pushing to the wrong branch and if the remote repository is configured to disallow fixing such mistakes, then that can be quite embarrassing and annoying.
Edit published history:
Without adding these symbols here, you will be warned before editing commits that have already been pushed to one of the branches listed in magit-published-branches.

amend-published Affects most commands that amend to "HEAD".
rebase-published Affects commands that perform interactive rebases. This includes commands from the commit transient that modify a commit other than "HEAD", namely the various fixup and squash variants.
edit-published Affects the commands magit-edit-line-commit and magit-diff-edit-hunk-commit. These two commands make it quite easy to accidentally edit a published commit, so you should think twice before configuring them not to ask for confirmation.
To disable confirmation completely, add all three symbols here or set magit-published-branches to nil.

Various:
stash-apply-3way When a stash cannot be applied using git stash apply, then Magit uses git apply instead, possibly using the --3way argument, which isn’t always perfectly safe. See also magit-stash-apply.
kill-process There seldom is a reason to kill a process.
Global settings:
Instead of adding all of the above symbols to the value of this option, you can also set it to the atom ‘t’, which has the same effect as adding all of the above symbols. Doing that most certainly is a bad idea, especially because other symbols might be added in the future. So even if you don’t want to be asked for confirmation for any of these actions, you are still better of adding all of the respective symbols individually.

When magit-wip-before-change-mode is enabled, then the following actions can be undone fairly easily: discard, reverse, stage-all-changes, and unstage-all-changes. If and only if this mode is enabled, then safe-with-wip has the same effect as adding all of these symbols individually.


**** Completion and Confirmation

Many Magit commands ask the user to select from a list of possible things to act on, while offering the most likely choice as the default. For many of these commands the default is the thing at point, provided that it actually is a valid thing to act on. For many commands that act on a branch, the current branch serves as the default if there is no branch at point.

These commands combine asking for confirmation and asking for a target to act on into a single action. The user can confirm the default target using RET or abort using C-g. This is similar to a y-or-n-p prompt, but the keys to confirm or abort differ.

At the same time the user is also given the opportunity to select another target, which is useful because for some commands and/or in some situations you might want to select the action before selecting the target by moving to it.

However you might find that for some commands you always want to use the default target, if any, or even that you want the command to act on the default without requiring any confirmation at all. The option magit-dwim-selection can be used to configure certain commands to that effect.

Note that when the region is active then many commands act on the things that are selected using a mechanism based on the region, in many cases after asking for confirmation. This region-based mechanism is called the "selection" and is described in detail in the next section. When a selection exists that is valid for the invoked command, then that command never offers to act on something else, and whether it asks for confirmation is not controlled by this option.

Also note that Magit asks for confirmation of certain actions that are not coupled with completion (or the selection). Such dialogs are also not affected by this option and are described in the previous section.

User Option: magit-dwim-selection
This option can be used to tell certain commands to use the thing at point instead of asking the user to select a candidate to act on, with or without confirmation.

The value has the form ((COMMAND nil|PROMPT DEFAULT)...).

COMMAND is the command that should not prompt for a choice. To have an effect, the command has to use the function magit-completing-read or a utility function which in turn uses that function.
If the command uses magit-completing-read multiple times, then PROMPT can be used to only affect one of these uses. PROMPT, if non-nil, is a regular expression that is used to match against the PROMPT argument passed to magit-completing-read.
DEFAULT specifies how to use the default. If it is t, then the DEFAULT argument passed to magit-completing-read is used without confirmation. If it is ask, then the user is given a chance to abort. DEFAULT can also be nil, in which case the entry has no effect.


**** The Selection

If the region is active, then many Magit commands act on the things that are selected using a mechanism based on the region instead of one single thing. When the region is not active, then these commands act on the thing at point or read a single thing to act on. This is described in the previous section — this section only covers how multiple things are selected, how that is visualized, and how certain commands behave when that is the case.

Magit’s mechanism for selecting multiple things, or rather sections that represent these things, is based on the Emacs region, but the area that Magit considers to be selected is typically larger than the region and additional restrictions apply.

Magit makes a distinction between a region that qualifies as forming a valid Magit selection and a region that does not. If the region does not qualify, then it is displayed as it is in other Emacs buffers. If the region does qualify as a Magit selection, then the selection is always visualized, while the region itself is only visualized if it begins and ends on the same line.

For a region to qualify as a Magit selection, it must begin in the heading of one section and end in the heading of a sibling section. Note that if the end of the region is at the very beginning of section heading (i.e., at the very beginning of a line) then that section is considered to be inside the selection.

This is not consistent with how the region is normally treated in Emacs — if the region ends at the beginning of a line, then that line is outside the region. Due to how Magit visualizes the selection, it should be obvious that this difference exists.

Not every command acts on every valid selection. Some commands do not even consider the location of point, others may act on the section at point but not support acting on the selection, and even commands that do support the selection of course only do so if it selects things that they can act on.

This is the main reason why the selection must include the section at point. Even if a selection exists, the invoked command may disregard it, in which case it may act on the current section only. It is much safer to only act on the current section but not the other selected sections than it is to act on the current section instead of the selected sections. The latter would be much more surprising and if the current section always is part of the selection, then that cannot happen.

Variable: magit-keep-region-overlay
This variable controls whether the region is visualized as usual even when a valid Magit selection or a hunk-internal region exists. See the doc-string for more information.


**** The hunk-internal region

Somewhat related to the Magit selection described in the previous section is the hunk-internal region.

Like the selection, the hunk-internal region is based on the Emacs region but causes that region to not be visualized as it would in other Emacs buffers, and includes the line on which the region ends even if it ends at the very beginning of that line.

Unlike the selection, which is based on a region that must begin in the heading of one section and ends in the section of a sibling section, the hunk-internal region must begin inside the body of a hunk section and end in the body of the same section.

The hunk-internal region is honored by "apply" commands, which can, among other targets, act on a hunk. If the hunk-internal region is active, then such commands act only on the marked part of the hunk instead of on the complete hunk.


**** Support for Completion Frameworks

The built-in option completing-read-function specifies the low-level function used by completing-read to ask a user to select from a list of choices. Its default value is completing-read-default. Alternative completion frameworks typically activate themselves by substituting their own implementation.

Mostly for historic reasons Magit provides a similar option named magit-completing-read-function, which only controls the low-level function used by magit-completing-read. This option also makes it possible to use a different completing mechanism for Magit than for the rest of Emacs, but doing that is not recommend.

You most likely don’t have to customize the magit-specific option to use an alternative completion framework. For example, if you enable ivy-mode, then Magit will respect that, and if you enable helm-mode, then you are done too.

However if you want to use Ido, then ido-mode won’t do the trick. You will also have to install the ido-completing-read+ package and use magit-ido-completing-read as magit-completing-read-function.

User Option: magit-completing-read-function
The value of this variable is the low-level function used to perform completion by code that uses magit-completing-read (as opposed to the built-in completing-read).

The default value, magit-builtin-completing-read, is suitable for the standard completion mechanism, ivy-mode, and helm-mode at least.

The built-in completing-read and completing-read-default are not suitable to be used here. magit-builtin-completing-read performs some additional work, and any function used in its place has to do the same.

Function: magit-builtin-completing-read prompt choices &optional predicate require-match initial-input hist def
This function performs completion using the built-in completing-read and does some additional magit-specific work.

Function: magit-ido-completing-read prompt choices &optional predicate require-match initial-input hist def
This function performs completion using ido-completing-read+ from the package by the same name (which you have to explicitly install) and does some additional magit-specific work.

We have to use ido-completing-read+ instead of the ido-completing-read that comes with Ido itself, because the latter, while intended as a drop-in replacement, cannot serve that purpose because it violates too many of the implicit conventions.

Function: magit-completing-read prompt choices &optional predicate require-match initial-input hist def fallback
This is the function that Magit commands use when they need the user to select a single thing to act on. The arguments have the same meaning as for completing-read, except for FALLBACK, which is unique to this function and is described below.

Instead of asking the user to choose from a list of possible candidates, this function may just return the default specified by DEF, with or without requiring user confirmation. Whether that is the case depends on PROMPT, this-command and magit-dwim-selection. See the documentation of the latter for more information.

If it does read a value in the minibuffer, then this function acts similar to completing-read, except for the following:

COLLECTION must be a list of choices. A function is not supported.
If REQUIRE-MATCH is nil and the user exits without a choice, then nil is returned instead of an empty string.
If REQUIRE-MATCH is non-nil and the users exits without a choice, an user-error is raised.
FALLBACK specifies a secondary default that is only used if the primary default DEF is nil. The secondary default is not subject to magit-dwim-selection — if DEF is nil but FALLBACK is not, then this function always asks the user to choose a candidate, just as if both defaults were nil.
format-prompt is called on PROMPT and DEF (or FALLBACK if DEF is nil). This appends ": " to the prompt and may also add the default to the prompt, using the format specified by minibuffer-default-prompt-format and depending on magit-completing-read-default-prompt-predicate.


**** Additional Completion Options

User Option: magit-list-refs-sortby
For many commands that read a ref or refs from the user, the value of this option can be used to control the order of the refs. Valid values include any key accepted by the --sort flag of git for-each-ref. By default, refs are sorted alphabetically by their full name (e.g., "refs/heads/master").


*** Mouse Support

Double clicking on a section heading toggles the visibility of its body, if any. Likewise clicking in the left fringe toggles the visibility of the appropriate section.

A context menu is provided but has to be enabled explicitly. In Emacs 28 and greater, enable the global mode context-menu-mode. If you use an older Emacs release, set magit-section-show-context-menu-for-emacs<28.


*** Running Git

**** Viewing Git Output

Magit runs Git either for side-effects (e.g., when pushing) or to get some value (e.g., the name of the current branch).

When Git is run for side-effects, the process output is logged in a per-repository log buffer, which can be consulted using the magit-process command when things don’t go as expected.

The output/errors for up to ‘magit-process-log-max’ Git commands are retained.

$ (magit-process)
This commands displays the process buffer for the current repository.

Inside that buffer, the usual key bindings for navigating and showing sections are available. There is one additional command.

k (magit-process-kill)
This command kills the process represented by the section at point.

Variable: magit-git-debug
This option controls whether additional reporting of git errors is enabled.

Magit basically calls git for one of these two reasons: for side-effects or to do something with its standard output.

When git is run for side-effects then its output, including error messages, go into the process buffer which is shown when using $.

When git’s output is consumed in some way, then it would be too expensive to also insert it into this buffer, but when this option is non-nil and git returns with a non-zero exit status, then at least its standard error is inserted into this buffer.

This is only intended for debugging purposes. Do not enable this permanently, that would negatively affect performance.

This is only intended for debugging purposes. Do not enable this permanently, that would negatively affect performance. Also note that just because git exits with a non-zero exit status and prints an error message that usually doesn’t mean that it is an error as far as Magit is concerned, which is another reason we usually hide these error messages. Whether some error message is relevant in the context of some unexpected behavior has to be judged on a case by case basis.

The command magit-toggle-git-debug changes the value of this variable.

Variable: magit-process-extreme-logging
This option controls whether magit-process-file logs to the *Messages* buffer.

Only intended for temporary use when you try to figure out how Magit uses Git behind the scene. Output that normally goes to the magit-process buffer continues to go there. Not all output goes to either of these two buffers.


**** Git Process Status

When a Git process is running for side-effects, Magit displays an indicator in the mode line, using the magit-mode-line-process face.

If the Git process exits successfully, the process indicator is removed from the mode line immediately.

In the case of a Git error, the process indicator is not removed, but is instead highlighted with the magit-mode-line-process-error face, and the error details from the process buffer are provided as a tooltip for mouse users. This error indicator persists in the mode line until the next magit buffer refresh.

If you do not wish process errors to be indicated in the mode line, customize the magit-process-display-mode-line-error user option.

Process errors are additionally indicated at the top of the status buffer.


**** Running Git Manually

While Magit provides many Emacs commands to interact with Git, it does not cover everything. In those cases your existing Git knowledge will come in handy. Magit provides some commands for running arbitrary Git commands by typing them into the minibuffer, instead of having to switch to a shell.

! (magit-run)
This transient prefix command binds the following suffix commands and displays them in a temporary buffer until a suffix is invoked.

! ! (magit-git-command-topdir)
This command reads a command from the user and executes it in the top-level directory of the current working tree.

The string "git " is used as initial input when prompting the user for the command. It can be removed to run another command.

: (magit-git-command)
! p
This command reads a command from the user and executes it in default-directory. With a prefix argument the command is executed in the top-level directory of the current working tree instead.

The string "git " is used as initial input when prompting the user for the command. It can be removed to run another command.

! s (magit-shell-command-topdir)
This command reads a command from the user and executes it in the top-level directory of the current working tree.

! S (magit-shell-command)
This command reads a command from the user and executes it in default-directory. With a prefix argument the command is executed in the top-level directory of the current working tree instead.

User Option: magit-shell-command-verbose-prompt
Whether the prompt, used by the above commands when reading a shell command, shows the directory in which it will be run.

These suffix commands start external gui tools.

! k (magit-run-gitk)
This command runs gitk in the current repository.

! a (magit-run-gitk-all)
This command runs gitk --all in the current repository.

! b (magit-run-gitk-branches)
This command runs gitk --branches in the current repository.

! g (magit-run-git-gui)
This command runs git gui in the current repository.

! m (magit-git-mergetool)
This command runs ‘git mergetool --gui’ in the current repository.

With a prefix argument this acts as a transient prefix command, allowing the user to select the mergetool and change some settings.


**** Git Executable

When Magit calls Git, then it may do so using the absolute path to the git executable, or using just its name.

When running git locally and the system-type is windows-nt (any Windows version) or darwin (macOS) then magit-git-executable is set to an absolute path when Magit is loaded.

On Windows it is necessary to use an absolute path because Git comes with several wrapper scripts for the actual git binary, which are also placed on $PATH, and using one of these wrappers instead of the binary would degrade performance horribly. For some macOS users using just the name of the executable also performs horribly, so we avoid doing that on that platform as well. On other platforms, using just the name seems to work just fine.

Using an absolute path when running git on a remote machine over Tramp, would be problematic to use an absolute path that is suitable on the local machine, so a separate option is used to control the name or path that is used on remote machines.

User Option: magit-git-executable
The git executable used by Magit on the local host. This should be either the absolute path to the executable, or the string "git" to let Emacs find the executable itself, using the standard mechanism for doing such things.

User Option: magit-remote-git-executable
The git executable used by Magit on remote machines over Tramp. Normally this should be just the string "git". Consider customizing tramp-remote-path instead of this option.

If Emacs is unable to find the correct executable, then you can work around that by explicitly setting the value of one of these two options. Doing that should be considered a kludge; it is better to make sure that the order in exec-path or tramp-remote-path is correct.

Note that exec-path is set based on the value of the PATH environment variable that is in effect when Emacs is started. If you set PATH in your shell’s init files, then that only has an effect on Emacs if you start it from that shell (because the environment of a process is only passed to its child processes, not to arbitrary other processes). If that is not how you start Emacs, then the exec-path-from-shell package can help; though honestly I consider that a kludge too.

The command magit-debug-git-executable can be useful to find out where Emacs is searching for git.

M-x magit-debug-git-executable
This command displays a buffer with information about magit-git-executable and magit-remote-git-executable.

M-x magit-version
This command shows the currently used versions of Magit, Git, and Emacs in the echo area. Non-interactively this just returns the Magit version.


**** Global Git Arguments

User Option: magit-git-global-arguments
The arguments set here are used every time the git executable is run as a subprocess. They are placed right after the executable itself and before the git command - as in git HERE... COMMAND REST. For valid arguments see the git(1) manpage.

Be careful what you add here, especially if you are using Tramp to connect to servers with ancient Git versions. Never remove anything that is part of the default value, unless you really know what you are doing. And think very hard before adding something; it will be used every time Magit runs Git for any purpose.


** Inspecting

The functionality provided by Magit can be roughly divided into three groups: inspecting existing data, manipulating existing data or adding new data, and transferring data. Of course that is a rather crude distinction that often falls short, but it’s more useful than no distinction at all. This section is concerned with inspecting data, the next two with manipulating and transferring it. Then follows a section about miscellaneous functionality, which cannot easily be fit into this distinction.

Of course other distinctions make sense too, e.g., Git’s distinction between porcelain and plumbing commands, which for the most part is equivalent to Emacs’ distinction between interactive commands and non-interactive functions. All of the sections mentioned before are mainly concerned with the porcelain – Magit’s plumbing layer is described later.

*** Status Buffer

While other Magit buffers contain, e.g., one particular diff or one particular log, the status buffer contains the diffs for staged and unstaged changes, logs for unpushed and unpulled commits, lists of stashes and untracked files, and information related to the current branch.

During certain incomplete operations – for example when a merge resulted in a conflict – additional information is displayed that helps proceeding with or aborting the operation.

The command magit-status displays the status buffer belonging to the current repository in another window. This command is used so often that it should be bound globally. We recommend using C-x g:

(global-set-key (kbd "C-x g") 'magit-status)
C-x g (magit-status)
When invoked from within an existing Git repository, then this command shows the status of that repository in a buffer.

If the current directory isn’t located within a Git repository, then this command prompts for an existing repository or an arbitrary directory, depending on the option magit-repository-directories, and the status for the selected repository is shown instead.

If that option specifies any existing repositories, then the user is asked to select one of them.
Otherwise the user is asked to select an arbitrary directory using regular file-name completion. If the selected directory is the top-level directory of an existing working tree, then the status buffer for that is shown.
Otherwise the user is offered to initialize the selected directory as a new repository. After creating the repository its status buffer is shown.
These fallback behaviors can also be forced using one or more prefix arguments:

With two prefix arguments (or more precisely a numeric prefix value of 16 or greater) an arbitrary directory is read, which is then acted on as described above. The same could be accomplished using the command magit-init.
With a single prefix argument an existing repository is read from the user, or if no repository can be found based on the value of magit-repository-directories, then the behavior is the same as with two prefix arguments.
User Option: magit-repository-directories
List of directories that are Git repositories or contain Git repositories.

Each element has the form (DIRECTORY . DEPTH). DIRECTORY has to be a directory or a directory file-name, a string. DEPTH, an integer, specifies the maximum depth to look for Git repositories. If it is 0, then only add DIRECTORY itself.

This option controls which repositories are being listed by magit-list-repositories. It also affects magit-status (which see) in potentially surprising ways (see above).

Command: magit-status-quick
This command is an alternative to magit-status that usually avoids refreshing the status buffer.

If the status buffer of the current Git repository exists but isn’t being displayed in the selected frame, then it is displayed without being refreshed.

If the status buffer is being displayed in the selected frame, then this command refreshes it.

Prefix arguments have the same meaning as for magit-status, and additionally cause the buffer to be refresh.

To use this command add this to your init file:

(global-set-key (kbd "C-x g") 'magit-status-quick).
If you do that and then for once want to redisplay the buffer and also immediately refresh it, then type C-x g followed by g.

A possible alternative command is magit-display-repository-buffer. It supports displaying any existing Magit buffer that belongs to the current repository; not just the status buffer.

Command: ido-enter-magit-status
From an Ido prompt used to open a file, instead drop into magit-status. This is similar to ido-magic-delete-char, which, despite its name, usually causes a Dired buffer to be created.

To make this command available, use something like:

(add-hook 'ido-setup-hook
          (lambda ()
            (define-key ido-completion-map
              (kbd \"C-x g\") 'ido-enter-magit-status)))
Starting with Emacs 25.1 the Ido keymaps are defined just once instead of every time Ido is invoked, so now you can modify it like pretty much every other keymap:

(define-key ido-common-completion-map
  (kbd \"C-x g\") 'ido-enter-magit-status)


**** Status Sections

The contents of status buffers is controlled using the hook magit-status-sections-hook. See Section Hooks to learn about such hooks and how to customize them.

User Option: magit-status-sections-hook
Hook run to insert sections into a status buffer.

The first function on that hook by default is magit-insert-status-headers; it is described in the next section. By default the following functions are also members of that hook:

Function: magit-insert-merge-log
Insert section for the on-going merge. Display the heads that are being merged. If no merge is in progress, do nothing.

Function: magit-insert-rebase-sequence
Insert section for the on-going rebase sequence. If no such sequence is in progress, do nothing.

Function: magit-insert-am-sequence
Insert section for the on-going patch applying sequence. If no such sequence is in progress, do nothing.

Function: magit-insert-sequencer-sequence
Insert section for the on-going cherry-pick or revert sequence. If no such sequence is in progress, do nothing.

Function: magit-insert-bisect-output
While bisecting, insert section with output from git bisect.

Function: magit-insert-bisect-rest
While bisecting, insert section visualizing the bisect state.

Function: magit-insert-bisect-log
While bisecting, insert section logging bisect progress.

Function: magit-insert-untracked-files
Maybe insert a list or tree of untracked files.

Do so depending on the value of status.showUntrackedFiles. Note that even if the value is all, Magit still initially only shows directories. But the directory sections can then be expanded using TAB.

Function: magit-insert-unstaged-changes
Insert section showing unstaged changes.

Function: magit-insert-staged-changes
Insert section showing staged changes.

Function: magit-insert-stashes &optional ref heading
Insert the stashes section showing reflog for "refs/stash". If optional REF is non-nil show reflog for that instead. If optional HEADING is non-nil use that as section heading instead of "Stashes:".

Function: magit-insert-unpulled-from-upstream
Insert section showing commits that haven’t been pulled from the upstream branch yet.

Function: magit-insert-unpulled-from-pushremote
Insert section showing commits that haven’t been pulled from the push-remote branch yet.

Function: magit-insert-unpushed-to-upstream
Insert section showing commits that haven’t been pushed to the upstream yet.

Function: magit-insert-unpushed-to-pushremote
Insert section showing commits that haven’t been pushed to the push-remote yet.

The following functions can also be added to the above hook:

Function: magit-insert-tracked-files
Insert a tree of tracked files.

Function: magit-insert-ignored-files
Insert a tree of ignored files. Its possible to limit the logs in the current buffer to a certain directory using D = f <DIRECTORY> RET g. If you do that, then that that also affects this command.

The log filter can be used to limit to multiple files. In that case this function only respects the first of the files and only if it is a directory.

Function: magit-insert-skip-worktree-files
Insert a tree of skip-worktree files. If the first element of magit-buffer-diff-files is a directory, then limit the list to files below that. The value of that variable can be set using D -- DIRECTORY RET g.

Function: magit-insert-assumed-unchanged-files
Insert a tree of files that are assumed to be unchanged. If the first element of magit-buffer-diff-files is a directory, then limit the list to files below that. The value of that variable can be set using D -- DIRECTORY RET g.

Function: magit-insert-unpulled-or-recent-commits
Insert section showing unpulled or recent commits. If an upstream is configured for the current branch and it is ahead of the current branch, then show the missing commits. Otherwise, show the last magit-log-section-commit-count commits.

Function: magit-insert-recent-commits
Insert section showing the last magit-log-section-commit-count commits.

User Option: magit-log-section-commit-count
How many recent commits magit-insert-recent-commits and magit-insert-unpulled-or-recent-commits (provided there are no unpulled commits) show.

Function: magit-insert-unpulled-cherries
Insert section showing unpulled commits. Like magit-insert-unpulled-commits but prefix each commit that has not been applied yet (i.e., a commit with a patch-id not shared with any local commit) with "+", and all others with "-".

Function: magit-insert-unpushed-cherries
Insert section showing unpushed commits. Like magit-insert-unpushed-commits but prefix each commit which has not been applied to upstream yet (i.e., a commit with a patch-id not shared with any upstream commit) with "+" and all others with "-".

See References Buffer for some more section inserters, which could be used here.


**** Status Header Sections

The contents of status buffers is controlled using the hook magit-status-sections-hook (see Status Sections).

By default magit-insert-status-headers is the first member of that hook variable.

Function: magit-insert-status-headers
Insert headers sections appropriate for magit-status-mode buffers. The sections are inserted by running the functions on the hook magit-status-headers-hook.

User Option: magit-status-headers-hook
Hook run to insert headers sections into the status buffer.

This hook is run by magit-insert-status-headers, which in turn has to be a member of magit-status-sections-hook to be used at all.

By default the following functions are members of the above hook:

Function: magit-insert-error-header
Insert a header line showing the message about the Git error that just occurred.

This function is only aware of the last error that occur when Git was run for side-effects. If, for example, an error occurs while generating a diff, then that error won’t be inserted. Refreshing the status buffer causes this section to disappear again.

Function: magit-insert-diff-filter-header
Insert a header line showing the effective diff filters.

Function: magit-insert-head-branch-header
Insert a header line about the current branch or detached HEAD.

Function: magit-insert-upstream-branch-header
Insert a header line about the branch that is usually pulled into the current branch.

Function: magit-insert-push-branch-header
Insert a header line about the branch that the current branch is usually pushed to.

Function: magit-insert-tags-header
Insert a header line about the current and/or next tag, along with the number of commits between the tag and HEAD.

The following functions can also be added to the above hook:

Function: magit-insert-repo-header
Insert a header line showing the path to the repository top-level.

Function: magit-insert-remote-header
Insert a header line about the remote of the current branch.

If no remote is configured for the current branch, then fall back showing the "origin" remote, or if that does not exist the first remote in alphabetic order.

Function: magit-insert-user-header
Insert a header line about the current user.


**** Status Module Sections

The contents of status buffers is controlled using the hook magit-status-sections-hook (see Status Sections).

By default magit-insert-modules is not a member of that hook variable.

Function: magit-insert-modules
Insert submodule sections.

Hook magit-module-sections-hook controls which module sections are inserted, and option magit-module-sections-nested controls whether they are wrapped in an additional section.

User Option: magit-module-sections-hook
Hook run by magit-insert-modules.

User Option: magit-module-sections-nested
This option controls whether magit-insert-modules wraps inserted sections in an additional section.

If this is non-nil, then only a single top-level section is inserted. If it is nil, then all sections listed in magit-module-sections-hook become top-level sections.

Function: magit-insert-modules-overview
Insert sections for all submodules. For each section insert the path, the branch, and the output of git describe --tags, or, failing that, the abbreviated HEAD commit hash.

Press RET on such a submodule section to show its own status buffer. Press RET on the "Modules" section to display a list of submodules in a separate buffer. This shows additional information not displayed in the super-repository’s status buffer.

Function: magit-insert-modules-unpulled-from-upstream
Insert sections for modules that haven’t been pulled from the upstream yet. These sections can be expanded to show the respective commits.

Function: magit-insert-modules-unpulled-from-pushremote
Insert sections for modules that haven’t been pulled from the push-remote yet. These sections can be expanded to show the respective commits.

Function: magit-insert-modules-unpushed-to-upstream
Insert sections for modules that haven’t been pushed to the upstream yet. These sections can be expanded to show the respective commits.

Function: magit-insert-modules-unpushed-to-pushremote
Insert sections for modules that haven’t been pushed to the push-remote yet. These sections can be expanded to show the respective commits.


**** Status Options

User Option: magit-status-margin
This option specifies whether the margin is initially shown in Magit-Status mode buffers and how it is formatted.

The value has the form (INIT STYLE WIDTH AUTHOR AUTHOR-WIDTH).

If INIT is non-nil, then the margin is shown initially.
STYLE controls how to format the author or committer date. It can be one of age (to show the age of the commit), age-abbreviated (to abbreviate the time unit to a character), or a string (suitable for format-time-string) to show the actual date. Option magit-log-margin-show-committer-date controls which date is being displayed.
WIDTH controls the width of the margin. This exists for forward compatibility and currently the value should not be changed.
AUTHOR controls whether the name of the author is also shown by default.
AUTHOR-WIDTH has to be an integer. When the name of the author is shown, then this specifies how much space is used to do so.
Also see the proceeding section for more options concerning status buffers.


*** Repository List

Command: magit-list-repositories
This command displays a list of repositories in a separate buffer.

The option magit-repository-directories controls which repositories are displayed.

User Option: magit-repolist-columns
This option controls what columns are displayed by the command magit-list-repositories and how they are displayed.

Each element has the form (HEADER WIDTH FORMAT PROPS).

HEADER is the string displayed in the header. WIDTH is the width of the column. FORMAT is a function that is called with one argument, the repository identification (usually its basename), and with default-directory bound to the toplevel of its working tree. It has to return a string to be inserted or nil. PROPS is an alist that supports the keys :right-align, :pad-right and :sort.

The :sort function has a weird interface described in the docstring of tabulated-list--get-sort. Alternatively < and magit-repolist-version< can be used as those functions are automatically replaced with functions that satisfy the interface. Set :sort to nil to inhibit sorting; if unspecified, then the column is sortable using the default sorter.

You may wish to display a range of numeric columns using just one character per column and without any padding between columns, in which case you should use an appropriate HEADER, set WIDTH to 1, and set :pad-right to 9. + is substituted for numbers higher than 9.

The following functions can be added to the above option:

Function: magit-repolist-column-ident
This function inserts the identification of the repository. Usually this is just its basename.

Function: magit-repolist-column-path
This function inserts the absolute path of the repository.

Function: magit-repolist-column-version
This function inserts a description of the repository’s HEAD revision.

Function: magit-repolist-column-branch
This function inserts the name of the current branch.

Function: magit-repolist-column-upstream
This function inserts the name of the upstream branch of the current branch.

Function: magit-repolist-column-branches
This function inserts the number of branches.

Function: magit-repolist-column-stashes
This function inserts the number of stashes.

Function: magit-repolist-column-flag
This function inserts a flag as specified by magit-repolist-column-flag-alist.

By default this indicates whether there are uncommitted changes.

N if there is at least one untracked file.
U if there is at least one unstaged file.
S if there is at least one staged file.
Only the first one of these that applies is shown.

Function: magit-repolist-column-flags
This functions insert all flags as specified by magit-repolist-column-flag-alist.

This is an alternative to function magit-repolist-column-flag, which only lists the first one found.

Function: magit-repolist-column-unpulled-from-upstream
This function inserts the number of upstream commits not in the current branch.

Function: magit-repolist-column-unpulled-from-pushremote
This function inserts the number of commits in the push branch but not the current branch.

Function: magit-repolist-column-unpushed-to-upstream
This function inserts the number of commits in the current branch but not its upstream.

Function: magit-repolist-column-unpushed-to-pushremote
This function inserts the number of commits in the current branch but not its push branch.

The following commands are available in repolist buffers:

RET (magit-repolist-status)
This command shows the status for the repository at point.

m (magit-repolist-mark)
This command marks the repository at point.

u (magit-repolist-unmark)
This command unmarks the repository at point.

f (magit-repolist-fetch)
This command fetches all marked repositories. If no repositories are marked, then it offers to fetch all displayed repositories.

5 (magit-repolist-find-file-other-frame)
This command reads a relative file-name (without completion) and opens the respective file in each marked repository in a new frame. If no repositories are marked, then it offers to do this for all displayed repositories.


*** Logging

The status buffer contains logs for the unpushed and unpulled commits, but that obviously isn’t enough. The transient prefix command magit-log, on l, features several suffix commands, which show a specific log in a separate log buffer.

Like other transient prefix commands, magit-log also features several infix arguments that can be changed before invoking one of the suffix commands. However, in the case of the log transient, these arguments may be taken from those currently in use in the current repository’s log buffer, depending on the value of magit-prefix-use-buffer-arguments (see Transient Arguments and Buffer Variables).

For information about the various arguments, see the git-log(1) manpage.

The switch ++order=VALUE is converted to one of --author-date-order, --date-order, or --topo-order before being passed to git log.

The log transient also features several reflog commands. See Reflog.

l (magit-log)
This transient prefix command binds the following suffix commands along with the appropriate infix arguments and displays them in a temporary buffer until a suffix is invoked.

l l (magit-log-current)
Show log for the current branch. When HEAD is detached or with a prefix argument, show log for one or more revs read from the minibuffer.

l h (magit-log-head)
Show log for HEAD.

l u (magit-log-related)
Show log for the current branch, its upstream and its push target. When the upstream is a local branch, then also show its own upstream. When HEAD is detached, then show log for that, the previously checked out branch and its upstream and push-target.

l o (magit-log-other)
Show log for one or more revs read from the minibuffer. The user can input any revision or revisions separated by a space, or even ranges, but only branches, tags, and a representation of the commit at point are available as completion candidates.

l L (magit-log-branches)
Show log for all local branches and HEAD.

l b (magit-log-all-branches)
Show log for all local and remote branches and HEAD.

l a (magit-log-all)
Show log for all references and HEAD.

Two additional commands that show the log for the file or blob that is being visited in the current buffer exists, see Commands for Buffers Visiting Files. The command magit-cherry also shows a log, see Cherries.

**** Refreshing Logs

The transient prefix command magit-log-refresh, on L, can be used to change the log arguments used in the current buffer, without changing which log is shown. This works in dedicated log buffers, but also in the status buffer.

L (magit-log-refresh)
This transient prefix command binds the following suffix commands along with the appropriate infix arguments and displays them in a temporary buffer until a suffix is invoked.

L g (magit-log-refresh)
This suffix command sets the local log arguments for the current buffer.

L s (magit-log-set-default-arguments)
This suffix command sets the default log arguments for buffers of the same type as that of the current buffer. Other existing buffers of the same type are not affected because their local values have already been initialized.

L w (magit-log-save-default-arguments)
This suffix command sets the default log arguments for buffers of the same type as that of the current buffer, and saves the value for future sessions. Other existing buffers of the same type are not affected because their local values have already been initialized.

L L (magit-toggle-margin)
Show or hide the margin.


**** Log Buffer

L (magit-log-refresh)
This transient prefix command binds the following suffix commands along with the appropriate infix arguments and displays them in a temporary buffer until a suffix is invoked.

See Refreshing Logs.

q (magit-log-bury-buffer)
Bury the current buffer or the revision buffer in the same frame. Like magit-mode-bury-buffer (which see) but with a negative prefix argument instead bury the revision buffer, provided it is displayed in the current frame.

C-c C-b (magit-go-backward)
Move backward in current buffer’s history.

C-c C-f (magit-go-forward)
Move forward in current buffer’s history.

C-c C-n (magit-log-move-to-parent)
Move to a parent of the current commit. By default, this is the first parent, but a numeric prefix can be used to specify another parent.

j (magit-log-move-to-revision)
Read a revision and move to it in current log buffer.

If the chosen reference or revision isn’t being displayed in the current log buffer, then inform the user about that and do nothing else.

If invoked outside any log buffer, then display the log buffer of the current repository first; creating it if necessary.

SPC (magit-diff-show-or-scroll-up)
Update the commit or diff buffer for the thing at point.

Either show the commit or stash at point in the appropriate buffer, or if that buffer is already being displayed in the current frame and contains information about that commit or stash, then instead scroll the buffer up. If there is no commit or stash at point, then prompt for a commit.

DEL (magit-diff-show-or-scroll-down)
Update the commit or diff buffer for the thing at point.

Either show the commit or stash at point in the appropriate buffer, or if that buffer is already being displayed in the current frame and contains information about that commit or stash, then instead scroll the buffer down. If there is no commit or stash at point, then prompt for a commit.

= (magit-log-toggle-commit-limit)
Toggle the number of commits the current log buffer is limited to. If the number of commits is currently limited, then remove that limit. Otherwise set it to 256.

+ (magit-log-double-commit-limit)
Double the number of commits the current log buffer is limited to.

- (magit-log-half-commit-limit)
Half the number of commits the current log buffer is limited to.

User Option: magit-log-auto-more
Insert more log entries automatically when moving past the last entry. Only considered when moving past the last entry with magit-goto-*-section commands.

User Option: magit-log-show-refname-after-summary
Whether to show the refnames after the commit summaries. This is useful if you use really long branch names.

User Option: magit-log-show-color-graph-limit
When showing more commits than specified by this option, then the --color argument, if specified, is silently dropped. This is necessary because the ansi-color library, which is used to turn control sequences into faces, is just too slow.

User Option: magit-log-show-signatures-limit
When showing more commits than specified by this option, then the --show-signature argument, if specified, is silently dropped. This is necessary because checking the signature of a large number of commits is just too slow.

Magit displays references in logs a bit differently from how Git does it.

Local branches are blue and remote branches are green. Of course that depends on the used theme, as do the colors used for other types of references. The current branch has a box around it, as do remote branches that are their respective remote’s HEAD branch.

If a local branch and its push-target point at the same commit, then their names are combined to preserve space and to make that relationship visible. For example:

origin/feature
[green][blue-]

instead of

feature origin/feature
[blue-] [green-------]
Also note that while the transient features the --show-signature argument, that won’t actually be used when enabled, because Magit defaults to use just one line per commit. Instead the commit colorized to indicate the validity of the signed commit object, using the faces named magit-signature-* (which see).

For a description of magit-log-margin see Log Margin.


**** Log Margin

In buffers which show one or more logs, it is possible to show additional information about each commit in the margin. The options used to configure the margin are named magit-INFIX-margin, where INFIX is the same as in the respective major-mode magit-INFIX-mode. In regular log buffers that would be magit-log-margin.

User Option: magit-log-margin
This option specifies whether the margin is initially shown in Magit-Log mode buffers and how it is formatted.

The value has the form (INIT STYLE WIDTH AUTHOR AUTHOR-WIDTH).

If INIT is non-nil, then the margin is shown initially.
STYLE controls how to format the author or committer date. It can be one of age (to show the age of the commit), age-abbreviated (to abbreviate the time unit to a character), or a string (suitable for format-time-string) to show the actual date. Option magit-log-margin-show-committer-date controls which date is being displayed.
WIDTH controls the width of the margin. This exists for forward compatibility and currently the value should not be changed.
AUTHOR controls whether the name of the author is also shown by default.
AUTHOR-WIDTH has to be an integer. When the name of the author is shown, then this specifies how much space is used to do so.
You can change the STYLE and AUTHOR-WIDTH of all magit-INFIX-margin options to the same values by customizing magit-log-margin before magit is loaded. If you do that, then the respective values for the other options will default to what you have set for that variable. Likewise if you set INIT in magit-log-margin to nil, then that is used in the default of all other options. But setting it to t, i.e. re-enforcing the default for that option, does not carry to other options.

User Option: magit-log-margin-show-committer-date
This option specifies whether to show the committer date in the margin. This option only controls whether the committer date is displayed instead of the author date. Whether some date is displayed in the margin and whether the margin is displayed at all is controlled by other options.

L (magit-margin-settings)
This transient prefix command binds the following suffix commands, each of which changes the appearance of the margin in some way.

In some buffers that support the margin, L is instead bound to magit-log-refresh, but that transient features the same commands, and then some other unrelated commands.

L L (magit-toggle-margin)
This command shows or hides the margin.

L l (magit-cycle-margin-style)
This command cycles the style used for the margin.

L d (magit-toggle-margin-details)
This command shows or hides details in the margin.


**** Select from Log

When the user has to select a recent commit that is reachable from HEAD, using regular completion would be inconvenient (because most humans cannot remember hashes or "HEAD~5", at least not without double checking). Instead a log buffer is used to select the commit, which has the advantage that commits are presented in order and with the commit message.

Such selection logs are used when selecting the beginning of a rebase and when selecting the commit to be squashed into.

In addition to the key bindings available in all log buffers, the following additional key bindings are available in selection log buffers:

C-c C-c (magit-log-select-pick)
Select the commit at point and act on it. Call magit-log-select-pick-function with the selected commit as argument.

C-c C-k (magit-log-select-quit)
Abort selecting a commit, don’t act on any commit.

User Option: magit-log-select-margin
This option specifies whether the margin is initially shown in Magit-Log-Select mode buffers and how it is formatted.

The value has the form (INIT STYLE WIDTH AUTHOR AUTHOR-WIDTH).

If INIT is non-nil, then the margin is shown initially.
STYLE controls how to format the author or committer date. It can be one of age (to show the age of the commit), age-abbreviated (to abbreviate the time unit to a character), or a string (suitable for format-time-string) to show the actual date. Option magit-log-margin-show-committer-date controls which date is being displayed.
WIDTH controls the width of the margin. This exists for forward compatibility and currently the value should not be changed.
AUTHOR controls whether the name of the author is also shown by default.
AUTHOR-WIDTH has to be an integer. When the name of the author is shown, then this specifies how much space is used to do so.


**** Reflog

Also see the git-reflog(1) manpage.

These reflog commands are available from the log transient. See Logging.

l r (magit-reflog-current)
Display the reflog of the current branch.

l O (magit-reflog-other)
Display the reflog of a branch or another ref.

l H (magit-reflog-head)
Display the HEAD reflog.

User Option: magit-reflog-margin
This option specifies whether the margin is initially shown in Magit-Reflog mode buffers and how it is formatted.

The value has the form (INIT STYLE WIDTH AUTHOR AUTHOR-WIDTH).

If INIT is non-nil, then the margin is shown initially.
STYLE controls how to format the author or committer date. It can be one of age (to show the age of the commit), age-abbreviated (to abbreviate the time unit to a character), or a string (suitable for format-time-string) to show the actual date. Option magit-log-margin-show-committer-date controls which date is being displayed.
WIDTH controls the width of the margin. This exists for forward compatibility and currently the value should not be changed.
AUTHOR controls whether the name of the author is also shown by default.
AUTHOR-WIDTH has to be an integer. When the name of the author is shown, then this specifies how much space is used to do so.


**** Cherries

Cherries are commits that haven’t been applied upstream (yet), and are usually visualized using a log. Each commit is prefixed with - if it has an equivalent in the upstream and + if it does not, i.e., if it is a cherry.

The command magit-cherry shows cherries for a single branch, but the references buffer (see References Buffer) can show cherries for multiple "upstreams" at once.

Also see the git-reflog(1) manpage.

Y (magit-cherry)
Show commits that are in a certain branch but that have not been merged in the upstream branch.

User Option: magit-cherry-margin
This option specifies whether the margin is initially shown in Magit-Cherry mode buffers and how it is formatted.

The value has the form (INIT STYLE WIDTH AUTHOR AUTHOR-WIDTH).

If INIT is non-nil, then the margin is shown initially.
STYLE controls how to format the author or committer date. It can be one of age (to show the age of the commit), age-abbreviated (to abbreviate the time unit to a character), or a string (suitable for format-time-string) to show the actual date. Option magit-log-margin-show-committer-date controls which date is being displayed.
WIDTH controls the width of the margin. This exists for forward compatibility and currently the value should not be changed.
AUTHOR controls whether the name of the author is also shown by default.
AUTHOR-WIDTH has to be an integer. When the name of the author is shown, then this specifies how much space is used to do so.


*** Diffing

The status buffer contains diffs for the staged and unstaged commits, but that obviously isn’t enough. The transient prefix command magit-diff, on d, features several suffix commands, which show a specific diff in a separate diff buffer.

Like other transient prefix commands, magit-diff also features several infix arguments that can be changed before invoking one of the suffix commands. However, in the case of the diff transient, these arguments may be taken from those currently in use in the current repository’s diff buffer, depending on the value of magit-prefix-use-buffer-arguments (see Transient Arguments and Buffer Variables).

Also see the git-diff(1) manpage.

d (magit-diff)
This transient prefix command binds the following suffix commands along with the appropriate infix arguments and displays them in a temporary buffer until a suffix is invoked.

d d (magit-diff-dwim)
Show changes for the thing at point.

d r (magit-diff-range)
Show differences between two commits.

RANGE should be a range (A..B or A…B) but can also be a single commit. If one side of the range is omitted, then it defaults to HEAD. If just a commit is given, then changes in the working tree relative to that commit are shown.

If the region is active, use the revisions on the first and last line of the region. With a prefix argument, instead of diffing the revisions, choose a revision to view changes along, starting at the common ancestor of both revisions (i.e., use a "…" range).

d w (magit-diff-working-tree)
Show changes between the current working tree and the HEAD commit. With a prefix argument show changes between the working tree and a commit read from the minibuffer.

d s (magit-diff-staged)
Show changes between the index and the HEAD commit. With a prefix argument show changes between the index and a commit read from the minibuffer.

d u (magit-diff-unstaged)
Show changes between the working tree and the index.

d p (magit-diff-paths)
Show changes between any two files on disk.

All of the above suffix commands update the repository’s diff buffer. The diff transient also features two commands which show differences in another buffer:

d c (magit-show-commit)
Show the commit at point. If there is no commit at point or with a prefix argument, prompt for a commit.

d t (magit-stash-show)
Show all diffs of a stash in a buffer.

Two additional commands that show the diff for the file or blob that is being visited in the current buffer exists, see Commands for Buffers Visiting Files.

**** Refreshing Diffs

The transient prefix command magit-diff-refresh, on D, can be used to change the diff arguments used in the current buffer, without changing which diff is shown. This works in dedicated diff buffers, but also in the status buffer.

(There is one exception; diff arguments cannot be changed in buffers created by magit-merge-preview because the underlying Git command does not support these arguments.)

D (magit-diff-refresh)
This transient prefix command binds the following suffix commands along with the appropriate infix arguments and displays them in a temporary buffer until a suffix is invoked.

D g (magit-diff-refresh)
This suffix command sets the local diff arguments for the current buffer.

D s (magit-diff-set-default-arguments)
This suffix command sets the default diff arguments for buffers of the same type as that of the current buffer. Other existing buffers of the same type are not affected because their local values have already been initialized.

D w (magit-diff-save-default-arguments)
This suffix command sets the default diff arguments for buffers of the same type as that of the current buffer, and saves the value for future sessions. Other existing buffers of the same type are not affected because their local values have already been initialized.

D t (magit-diff-toggle-refine-hunk)
This command toggles hunk refinement on or off.

D r (magit-diff-switch-range-type)
This command converts the diff range type from "revA..revB" to "revB…revA", or vice versa.

D f (magit-diff-flip-revs)
This command swaps revisions in the diff range from "revA..revB" to "revB..revA", or vice versa.

D F (magit-diff-toggle-file-filter)
This command toggles the file restriction of the diffs in the current buffer, allowing you to quickly switch between viewing all the changes in the commit and the restricted subset. As a special case, when this command is called from a log buffer, it toggles the file restriction in the repository’s revision buffer, which is useful when you display a revision from a log buffer that is restricted to a file or files.

In addition to the above transient, which allows changing any of the supported arguments, there also exist some commands that change only a particular argument.

- (magit-diff-less-context)
This command decreases the context for diff hunks by COUNT lines.

+ (magit-diff-more-context)
This command increases the context for diff hunks by COUNT lines.

0 (magit-diff-default-context)
This command resets the context for diff hunks to the default height.

The following commands quickly change what diff is being displayed without having to using one of the diff transient.

C-c C-d (magit-diff-while-committing)
While committing, this command shows the changes that are about to be committed. While amending, invoking the command again toggles between showing just the new changes or all the changes that will be committed.

This binding is available in the diff buffer as well as the commit message buffer.

C-c C-b (magit-go-backward)
This command moves backward in current buffer’s history.

C-c C-f (magit-go-forward)
This command moves forward in current buffer’s history.


**** Commands Available in Diffs

Some commands are only available if point is inside a diff.

magit-diff-visit-file and related commands visit the appropriate version of the file that the diff at point is about. Likewise magit-diff-visit-worktree-file and related commands visit the worktree version of the file that the diff at point is about. See Visiting Files and Blobs from a Diff for more information and the key bindings.

C-c C-t (magit-diff-trace-definition)
This command shows a log for the definition at point.

User Option: magit-log-trace-definition-function
The function specified by this option is used by magit-log-trace-definition to determine the function at point. For major-modes that have special needs, you could set the local value using the mode’s hook.

C-c C-e (magit-diff-edit-hunk-commit)
From a hunk, this command edits the respective commit and visits the file.

First it visits the file being modified by the hunk at the correct location using magit-diff-visit-file. This actually visits a blob. When point is on a diff header, not within an individual hunk, then this visits the blob the first hunk is about.

Then it invokes magit-edit-line-commit, which uses an interactive rebase to make the commit editable, or if that is not possible because the commit is not reachable from HEAD by checking out that commit directly. This also causes the actual worktree file to be visited.

Neither the blob nor the file buffer are killed when finishing the rebase. If that is undesirable, then it might be better to use magit-rebase-edit-commit instead of this command.

j (magit-jump-to-diffstat-or-diff)
This command jumps to the diffstat or diff. When point is on a file inside the diffstat section, then jump to the respective diff section. Otherwise, jump to the diffstat section or a child thereof.

The next two commands are not specific to Magit-Diff mode (or and Magit buffer for that matter), but it might be worth pointing out that they are available here too.

SPC (scroll-up)
This command scrolls text upward.

DEL (scroll-down)
This command scrolls text downward.


**** Diff Options

User Option: magit-diff-refine-hunk
Whether to show word-granularity differences within diff hunks.

nil Never show fine differences.
t Show fine differences for the current diff hunk only.
all Show fine differences for all displayed diff hunks.
User Option: magit-diff-refine-ignore-whitespace
Whether to ignore whitespace changes in word-granularity differences.

User Option: magit-diff-adjust-tab-width
Whether to adjust the width of tabs in diffs.

Determining the correct width can be expensive if it requires opening large and/or many files, so the widths are cached in the variable magit-diff--tab-width-cache. Set that to nil to invalidate the cache.

nil Never adjust tab width. Use ‘tab-width’s value from the Magit buffer itself instead.
t If the corresponding file-visiting buffer exits, then use tab-width’s value from that buffer. Doing this is cheap, so this value is used even if a corresponding cache entry exists.
always If there is no such buffer, then temporarily visit the file to determine the value.
NUMBER Like always, but don’t visit files larger than NUMBER bytes.
User Option: magit-diff-paint-whitespace
Specify where to highlight whitespace errors.

See magit-diff-highlight-trailing, magit-diff-highlight-indentation. The symbol t means in all diffs, status means only in the status buffer, and nil means nowhere.

nil Never highlight whitespace errors.
t Highlight whitespace errors everywhere.
uncommitted Only highlight whitespace errors in diffs showing uncommitted changes. For backward compatibility status is treated as a synonym.
User Option: magit-diff-paint-whitespace-lines
Specify in what kind of lines to highlight whitespace errors.

t Highlight only in added lines.
both Highlight in added and removed lines.
all Highlight in added, removed and context lines.
User Option: magit-diff-highlight-trailing
Whether to highlight whitespace at the end of a line in diffs. Used only when magit-diff-paint-whitespace is non-nil.

User Option: magit-diff-highlight-indentation
This option controls whether to highlight the indentation in case it used the "wrong" indentation style. Indentation is only highlighted if magit-diff-paint-whitespace is also non-nil.

The value is an alist of the form ((REGEXP . INDENT)...). The path to the current repository is matched against each element in reverse order. Therefore if a REGEXP matches, then earlier elements are not tried.

If the used INDENT is tabs, highlight indentation with tabs. If INDENT is an integer, highlight indentation with at least that many spaces. Otherwise, highlight neither.

User Option: magit-diff-hide-trailing-cr-characters
Whether to hide ^M characters at the end of a line in diffs.

User Option: magit-diff-highlight-hunk-region-functions
This option specifies the functions used to highlight the hunk-internal region.

magit-diff-highlight-hunk-region-dim-outside overlays the outside of the hunk internal selection with a face that causes the added and removed lines to have the same background color as context lines. This function should not be removed from the value of this option.

magit-diff-highlight-hunk-region-using-overlays and magit-diff-highlight-hunk-region-using-underline emphasize the region by placing delimiting horizontal lines before and after it. Both of these functions have glitches which cannot be fixed due to limitations of Emacs’ display engine. For more information see https://github.com/magit/magit/issues/2758 ff.

Instead of, or in addition to, using delimiting horizontal lines, to emphasize the boundaries, you may wish to emphasize the text itself, using magit-diff-highlight-hunk-region-using-face.

In terminal frames it’s not possible to draw lines as the overlay and underline variants normally do, so there they fall back to calling the face function instead.

User Option: magit-diff-unmarked-lines-keep-foreground
This option controls whether added and removed lines outside the hunk-internal region only lose their distinct background color or also the foreground color. Whether the outside of the region is dimmed at all depends on magit-diff-highlight-hunk-region-functions.

User Option: magit-diff-extra-stat-arguments
This option specifies additional arguments to be used alongside --stat.

The value is a list of zero or more arguments or a function that takes no argument and returns such a list. These arguments are allowed here: --stat-width, --stat-name-width, --stat-graph-width and --compact-summary. Also see the git-diff(1) manpage.


**** Revision Buffer

User Option: magit-revision-insert-related-refs
Whether to show related branches in revision buffers.

nil Don’t show any related branches.
t Show related local branches.
all Show related local and remote branches.
mixed Show all containing branches and local merged branches.
User Option: magit-revision-show-gravatars
Whether to show gravatar images in revision buffers.

If nil, then don’t insert any gravatar images. If t, then insert both images. If author or committer, then insert only the respective image.

If you have customized the option magit-revision-headers-format and want to insert the images then you might also have to specify where to do so. In that case the value has to be a cons-cell of two regular expressions. The car specifies where to insert the author’s image. The top half of the image is inserted right after the matched text, the bottom half on the next line in the same column. The cdr specifies where to insert the committer’s image, accordingly. Either the car or the cdr may be nil."

User Option: magit-revision-use-hash-sections
Whether to turn hashes inside the commit message into sections.

If non-nil, then hashes inside the commit message are turned into commit sections. There is a trade off to be made between performance and reliability:

slow calls git for every word to be absolutely sure.
quick skips words less than seven characters long.
quicker additionally skips words that don’t contain a number.
quickest uses all words that are at least seven characters long and which contain at least one number as well as at least one letter.
If nil, then no hashes are turned into sections, but you can still visit the commit at point using "RET".

The diffs shown in the revision buffer may be automatically restricted to a subset of the changed files. If the revision buffer is displayed from a log buffer, the revision buffer will share the same file restriction as that log buffer (also see the command magit-diff-toggle-file-filter).

User Option: magit-revision-filter-files-on-follow
Whether showing a commit from a log buffer honors the log’s file filter when the log arguments include --follow.

When this option is nil, displaying a commit from a log ignores the log’s file filter if the log arguments include --follow. Doing so avoids showing an empty diff in revision buffers for commits before a rename event. In such cases, the --patch argument of the log transient can be used to show the file-restricted diffs inline.

Set this option to non-nil to keep the log’s file restriction even if --follow is present in the log arguments.

If the revision buffer is not displayed from a log buffer, the file restriction is determined as usual (see Transient Arguments and Buffer Variables).


*** Ediffing

This section describes how to enter Ediff from Magit buffers. For information on how to use Ediff itself, see (ediff)Top.

e (magit-ediff-dwim)
Compare, stage, or resolve using Ediff.

This command tries to guess what file, and what commit or range the user wants to compare, stage, or resolve using Ediff. It might only be able to guess either the file, or range/commit, in which case the user is asked about the other. It might not always guess right, in which case the appropriate magit-ediff-* command has to be used explicitly. If it cannot read the user’s mind at all, then it asks the user for a command to run.

E (magit-ediff)
This transient prefix command binds the following suffix commands and displays them in a temporary buffer until a suffix is invoked.

E r (magit-ediff-compare)
Compare two revisions of a file using Ediff.

If the region is active, use the revisions on the first and last line of the region. With a prefix argument, instead of diffing the revisions, choose a revision to view changes along, starting at the common ancestor of both revisions (i.e., use a "…" range).

E m (magit-ediff-resolve-rest)
This command allows you to resolve outstanding conflicts in the file at point using Ediff. If there is no file at point or if it doesn’t have any unmerged changes, then this command prompts for a file.

Provided that the value of merge.conflictstyle is diff3, you can view the file’s merge-base revision using / in the Ediff control buffer.

The A, B and Ancestor buffers are constructed from the conflict markers in the worktree file. Because you and/or Git may have already resolved some conflicts, that means that these buffers may not contain the actual versions from the respective blobs.

E M (magit-ediff-resolve-all)
This command allows you to resolve all conflicts in the file at point using Ediff. If there is no file at point or if it doesn’t have any unmerged changes, then this command prompts for a file.

Provided that the value of merge.conflictstyle is diff3, you can view the file’s merge-base revision using / in the Ediff control buffer.

First the file in the worktree is moved aside, appending the suffix ‘.ORIG’, so that you could later go back to that version. Then it is reconstructed from the two sides of the conflict and the merge-base, if available.

It would be nice if the worktree file were just used as-is, but Ediff does not support that. This means that all conflicts, that Git has already resolved, are restored. On the other hand Ediff also tries to resolve conflicts, and in many cases Ediff and Git should produce similar results.

However if you have already resolved some conflicts manually, then those changes are discarded (though you can recover them from the backup file). In such cases magit-ediff-resolve-rest might be more suitable.

The advantage that this command has over magit-ediff-resolve-rest is that the A, B and Ancestor buffers correspond to blobs from the respective commits, allowing you to inspect a side in context and to use Magit commands in these buffers to do so. Blame and log commands are particularly useful here.

E t (magit-git-mergetool)
This command does not actually use Ediff. While it serves the same purpose as ‘magit-ediff-resolve-rest’, it uses ‘git mergetool --gui’ to resolve conflicts.

With a prefix argument this acts as a transient prefix command, allowing the user to select the mergetool and change some settings.

E s (magit-ediff-stage)
Stage and unstage changes to a file using Ediff, defaulting to the file at point.

E u (magit-ediff-show-unstaged)
Show unstaged changes to a file using Ediff.

E i (magit-ediff-show-staged)
Show staged changes to a file using Ediff.

E w (magit-ediff-show-working-tree)
Show changes in a file between HEAD and working tree using Ediff.

E c (magit-ediff-show-commit)
Show changes to a file introduced by a commit using Ediff.

E z (magit-ediff-show-stash)
Show changes to a file introduced by a stash using Ediff.

User Option: magit-ediff-dwim-resolve-function
This option controls which function magit-ediff-dwim uses to resolve conflicts. One of magit-ediff-resolve-rest, magit-ediff-resolve-all or magit-git-mergetool; which are all discussed above.

User Option: magit-ediff-dwim-show-on-hunks
This option controls what command magit-ediff-dwim calls when point is on uncommitted hunks. When nil, always run magit-ediff-stage. Otherwise, use magit-ediff-show-staged and magit-ediff-show-unstaged to show staged and unstaged changes, respectively.

User Option: magit-ediff-show-stash-with-index
This option controls whether magit-ediff-show-stash includes a buffer containing the file’s state in the index at the time the stash was created. This makes it possible to tell which changes in the stash were staged.

User Option: magit-ediff-quit-hook
This hook is run after quitting an Ediff session that was created using a Magit command. The hook functions are run inside the Ediff control buffer, and should not change the current buffer.

This is similar to ediff-quit-hook but takes the needs of Magit into account. The regular ediff-quit-hook is ignored by Ediff sessions that were created using a Magit command.


*** References Buffer

y (magit-show-refs)
This command lists branches and tags in a dedicated buffer.

However if this command is invoked again from this buffer or if it is invoked with a prefix argument, then it acts as a transient prefix command, which binds the following suffix commands and some infix arguments.

All of the following suffix commands list exactly the same branches and tags. The only difference the optional feature that can be enabled by changing the value of magit-refs-show-commit-count (see below). These commands specify a different branch or commit against which all the other references are compared.

y y (magit-show-refs-head)
This command lists branches and tags in a dedicated buffer. Each reference is being compared with HEAD.

y c (magit-show-refs-current)
This command lists branches and tags in a dedicated buffer. Each reference is being compared with the current branch or HEAD if it is detached.

y o (magit-show-refs-other)
This command lists branches and tags in a dedicated buffer. Each reference is being compared with a branch read from the user.

y r (magit-refs-set-show-commit-count)
This command changes for which refs the commit count is shown.

User Option: magit-refs-show-commit-count
Whether to show commit counts in Magit-Refs mode buffers.

all Show counts for branches and tags.
branch Show counts for branches only.
nil Never show counts.
The default is nil because anything else can be very expensive.

User Option: magit-refs-pad-commit-counts
Whether to pad all commit counts on all sides in Magit-Refs mode buffers.

If this is nil, then some commit counts are displayed right next to one of the branches that appear next to the count, without any space in between. This might look bad if the branch name faces look too similar to magit-dimmed.

If this is non-nil, then spaces are placed on both sides of all commit counts.

User Option: magit-refs-show-remote-prefix
Whether to show the remote prefix in lists of remote branches.

Showing the prefix is redundant because the name of the remote is already shown in the heading preceding the list of its branches.

User Option: magit-refs-primary-column-width
Width of the primary column in ‘magit-refs-mode’ buffers. The primary column is the column that contains the name of the branch that the current row is about.

If this is an integer, then the column is that many columns wide. Otherwise it has to be a cons-cell of two integers. The first specifies the minimal width, the second the maximal width. In that case the actual width is determined using the length of the names of the shown local branches. (Remote branches and tags are not taken into account when calculating to optimal width.)

User Option: magit-refs-focus-column-width
Width of the focus column in ‘magit-refs-mode’ buffers.

The focus column is the first column, which marks one branch (usually the current branch) as the focused branch using * or @. For each other reference, this column optionally shows how many commits it is ahead of the focused branch and <, or if it isn’t ahead then the commits it is behind and >, or if it isn’t behind either, then a =.

This column may also display only * or @ for the focused branch, in which case this option is ignored. Use L v to change the verbosity of this column.

User Option: magit-refs-margin
This option specifies whether the margin is initially shown in Magit-Refs mode buffers and how it is formatted.

The value has the form (INIT STYLE WIDTH AUTHOR AUTHOR-WIDTH).

If INIT is non-nil, then the margin is shown initially.
STYLE controls how to format the author or committer date. It can be one of age (to show the age of the commit), age-abbreviated (to abbreviate the time unit to a character), or a string (suitable for format-time-string) to show the actual date. Option magit-log-margin-show-committer-date controls which date is being displayed.
WIDTH controls the width of the margin. This exists for forward compatibility and currently the value should not be changed.
AUTHOR controls whether the name of the author is also shown by default.
AUTHOR-WIDTH has to be an integer. When the name of the author is shown, then this specifies how much space is used to do so.
User Option: magit-refs-margin-for-tags
This option specifies whether to show information about tags in the margin. This is disabled by default because it is slow if there are many tags.

The following variables control how individual refs are displayed. If you change one of these variables (especially the "%c" part), then you should also change the others to keep things aligned. The following %-sequences are supported:

%a Number of commits this ref has over the one we compare to.
%b Number of commits the ref we compare to has over this one.
%c Number of commits this ref has over the one we compare to. For the ref which all other refs are compared this is instead "@", if it is the current branch, or "#" otherwise.
%C For the ref which all other refs are compared this is "@", if it is the current branch, or "#" otherwise. For all other refs " ".
%h Hash of this ref’s tip.
%m Commit summary of the tip of this ref.
%n Name of this ref.
%u Upstream of this local branch.
%U Upstream of this local branch and additional local vs. upstream information.
User Option: magit-refs-filter-alist
The purpose of this option is to forgo displaying certain refs based on their name. If you want to not display any refs of a certain type, then you should remove the appropriate function from magit-refs-sections-hook instead.

This alist controls which tags and branches are omitted from being displayed in magit-refs-mode buffers. If it is nil, then all refs are displayed (subject to magit-refs-sections-hook).

All keys are tried in order until one matches. Then its value is used and subsequent elements are ignored. If the value is non-nil, then the reference is displayed, otherwise it is not. If no element matches, then the reference is displayed.

A key can either be a regular expression that the refname has to match, or a function that takes the refname as only argument and returns a boolean. A remote branch such as "origin/master" is displayed as just "master", however for this comparison the former is used.

RET (magit-visit-ref)
This command visits the reference or revision at point in another buffer. If there is no revision at point or with a prefix argument then it prompts for a revision.

This command behaves just like magit-show-commit as described above, except if point is on a reference in a magit-refs-mode buffer, in which case the behavior may be different, but only if you have customized the option magit-visit-ref-behavior.

User Option: magit-visit-ref-behavior
This option controls how magit-visit-ref behaves in magit-refs-mode buffers.

By default magit-visit-ref behaves like magit-show-commit, in all buffers, including magit-refs-mode buffers. When the type of the section at point is commit then "RET" is bound to magit-show-commit, and when the type is either branch or tag then it is bound to magit-visit-ref.

"RET" is one of Magit’s most essential keys and at least by default it should behave consistently across all of Magit, especially because users quickly learn that it does something very harmless; it shows more information about the thing at point in another buffer.

However "RET" used to behave differently in magit-refs-mode buffers, doing surprising things, some of which cannot really be described as "visit this thing". If you’ve grown accustomed this behavior, you can restore it by adding one or more of the below symbols to the value of this option. But keep in mind that by doing so you don’t only introduce inconsistencies, you also lose some functionality and might have to resort to M-x magit-show-commit to get it back.

magit-visit-ref looks for these symbols in the order in which they are described here. If the presence of a symbol applies to the current situation, then the symbols that follow do not affect the outcome.

focus-on-ref
With a prefix argument update the buffer to show commit counts and lists of cherry commits relative to the reference at point instead of relative to the current buffer or HEAD.

Instead of adding this symbol, consider pressing "C-u y o RET".

create-branch
If point is on a remote branch, then create a new local branch with the same name, use the remote branch as its upstream, and then check out the local branch.

Instead of adding this symbol, consider pressing "b c RET RET", like you would do in other buffers.

checkout-any
Check out the reference at point. If that reference is a tag or a remote branch, then this results in a detached HEAD.

Instead of adding this symbol, consider pressing "b b RET", like you would do in other buffers.

checkout-branch
Check out the local branch at point.

Instead of adding this symbol, consider pressing "b b RET", like you would do in other buffers.

***** References Sections

The contents of references buffers is controlled using the hook magit-refs-sections-hook. See Section Hooks to learn about such hooks and how to customize them. All of the below functions are members of the default value. Note that it makes much less sense to customize this hook than it does for the respective hook used for the status buffer.

User Option: magit-refs-sections-hook
Hook run to insert sections into a references buffer.

Function: magit-insert-local-branches
Insert sections showing all local branches.

Function: magit-insert-remote-branches
Insert sections showing all remote-tracking branches.

Function: magit-insert-tags
Insert sections showing all tags.


*** Bisecting

Also see the git-bisect(1) manpage.

B (magit-bisect)
This transient prefix command binds the following suffix commands and displays them in a temporary buffer until a suffix is invoked.

When bisecting is not in progress, then the transient features the following suffix commands.

B B (magit-bisect-start)
Start a bisect session.

Bisecting a bug means to find the commit that introduced it. This command starts such a bisect session by asking for a known good commit and a known bad commit. If you’re bisecting a change that isn’t a regression, you can select alternate terms that are conceptually more fitting than "bad" and "good", but the infix arguments to do so are disabled by default.

B s (magit-bisect-run)
Bisect automatically by running commands after each step.

When bisecting in progress, then the transient instead features the following suffix commands.

B b (magit-bisect-bad)
Mark the current commit as bad. Use this after you have asserted that the commit does contain the bug in question.

B g (magit-bisect-good)
Mark the current commit as good. Use this after you have asserted that the commit does not contain the bug in question.

B m (magit-bisect-mark)
Mark the current commit with one of the bisect terms. This command provides an alternative to magit-bisect-bad and magit-bisect-good and is useful when using terms other than "bad" and "good". This suffix is disabled by default.

B k (magit-bisect-skip)
Skip the current commit. Use this if for some reason the current commit is not a good one to test. This command lets Git choose a different one.

B r (magit-bisect-reset)
After bisecting, cleanup bisection state and return to original HEAD.

By default the status buffer shows information about the ongoing bisect session.

User Option: magit-bisect-show-graph
This option controls whether a graph is displayed for the log of commits that still have to be bisected.


*** Visiting Files and Blobs

Magit provides several commands that visit a file or blob (the version of a file that is stored in a certain commit). Actually it provides several groups of such commands and the several variants within each group.

Also see Commands for Buffers Visiting Files.

**** General-Purpose Visit Commands

These commands can be used anywhere to open any blob. Currently no keys are bound to these commands by default, but that is likely to change.

Command: magit-find-file
This command reads a filename and revision from the user and visits the respective blob in a buffer. The buffer is displayed in the selected window.

Command: magit-find-file-other-window
This command reads a filename and revision from the user and visits the respective blob in a buffer. The buffer is displayed in another window.

Command: magit-find-file-other-frame
This command reads a filename and revision from the user and visits the respective blob in a buffer. The buffer is displayed in another frame.


**** Visiting Files and Blobs from a Diff

These commands can only be used when point is inside a diff.

RET (magit-diff-visit-file)
This command visits the appropriate version of the file that the diff at point is about.

This commands visits the worktree version of the appropriate file. The location of point inside the diff determines which file is being visited. The visited version depends on what changes the diff is about.

If the diff shows uncommitted changes (i.e., staged or unstaged changes), then visit the file in the working tree (i.e., the same "real" file that find-file would visit. In all other cases visit a "blob" (i.e., the version of a file as stored in some commit).
If point is on a removed line, then visit the blob for the first parent of the commit that removed that line, i.e., the last commit where that line still exists.
If point is on an added or context line, then visit the blob that adds that line, or if the diff shows from more than a single commit, then visit the blob from the last of these commits.
In the file-visiting buffer this command goes to the line that corresponds to the line that point is on in the diff.

The buffer is displayed in the selected window. With a prefix argument the buffer is displayed in another window instead.

User Option: magit-diff-visit-previous-blob
This option controls whether magit-diff-visit-file may visit the previous blob. When this is t (the default) and point is on a removed line in a diff for a committed change, then magit-diff-visit-file visits the blob from the last revision which still had that line.

Currently this is only supported for committed changes, for staged and unstaged changes magit-diff-visit-file always visits the file in the working tree.

C-<return> (magit-diff-visit-file-worktree)
This command visits the worktree version of the appropriate file. The location of point inside the diff determines which file is being visited. Unlike magit-diff-visit-file it always visits the "real" file in the working tree, i.e the "current version" of the file.

In the file-visiting buffer this command goes to the line that corresponds to the line that point is on in the diff. Lines that were added or removed in the working tree, the index and other commits in between are automatically accounted for.

The buffer is displayed in the selected window. With a prefix argument the buffer is displayed in another window instead.

Variants of the above two commands exist that instead visit the file in another window or in another frame. If you prefer such behavior, then you may want to change the above key bindings, but note that the above commands also use another window when invoked with a prefix argument.

Command: magit-diff-visit-file-other-window
Command: magit-diff-visit-file-other-frame
Command: magit-diff-visit-worktree-file-other-window
Command: magit-diff-visit-worktree-file-other-frame


*** Blaming

Also see the git-blame(1) manpage.

To start blaming, invoke the magit-file-dispatch transient prefix command. When using the default key bindings, that can be done by pressing C-c M-g. When using the recommended bindings, this command is instead bound to C-c f. Also see Global Bindings.

The blaming suffix commands can be invoked directly from the file dispatch transient. However if you want to set an infix argument, then you have to enter the blaming sub-prefix first.

C-c f B (magit-blame)
C-c f b (magit-blame-addition)
C-c f B b
C-c f r (magit-blame-removal)
C-c f B r
C-c f f (magit-blame-reverse)
C-c f B f
C-c f e (magit-blame-echo)
C-c f B e
C-c f q (magit-blame-quit)
C-c f B q
Each of these commands is documented individually right below, alongside their default key bindings. The bindings shown above are the recommended bindings, which you can enable by following the instructions in Global Bindings.

C-c M-g B (magit-blame)
This transient prefix command binds the following suffix commands along with the appropriate infix arguments and displays them in a temporary buffer until a suffix is invoked.

Note that not all of the following suffixes are available at all times. For example if magit-blame-mode is not enabled, then the command whose purpose is to turn off that mode would not be of any use and therefore isn’t available.

C-c M-g b (magit-blame-addition)
C-c M-g B b
This command augments each line or chunk of lines in the current file-visiting or blob-visiting buffer with information about what commits last touched these lines.

If the buffer visits a revision of that file, then history up to that revision is considered. Otherwise, the file’s full history is considered, including uncommitted changes.

If Magit-Blame mode is already turned on in the current buffer then blaming is done recursively, by visiting REVISION:FILE (using magit-find-file), where REVISION is a parent of the revision that added the current line or chunk of lines.

C-c M-g r (magit-blame-removal)
C-c M-g B r
This command augments each line or chunk of lines in the current blob-visiting buffer with information about the revision that removes it. It cannot be used in file-visiting buffers.

Like magit-blame-addition, this command can be used recursively.

C-c M-g f (magit-blame-reverse)
C-c M-g B f
This command augments each line or chunk of lines in the current file-visiting or blob-visiting buffer with information about the last revision in which a line still existed.

Like magit-blame-addition, this command can be used recursively.

C-c M-g e (magit-blame-echo)
C-c M-g B e
This command is like magit-blame-addition except that it doesn’t turn on read-only-mode and that it initially uses the visualization style specified by option magit-blame-echo-style.

The following key bindings are available when Magit-Blame mode is enabled and Read-Only mode is not enabled. These commands are also available in other buffers; here only the behavior is described that is relevant in file-visiting buffers that are being blamed.

C-c M-g q (magit-blame-quit)
C-c M-g B q
This command turns off Magit-Blame mode. If the buffer was created during a recursive blame, then it also kills the buffer.

RET (magit-show-commit)
This command shows the commit that last touched the line at point.

SPC (magit-diff-show-or-scroll-up)
This command updates the commit buffer.

This either shows the commit that last touched the line at point in the appropriate buffer, or if that buffer is already being displayed in the current frame and if that buffer contains information about that commit, then the buffer is scrolled up instead.

DEL (magit-diff-show-or-scroll-down)
This command updates the commit buffer.

This either shows the commit that last touched the line at point in the appropriate buffer, or if that buffer is already being displayed in the current frame and if that buffer contains information about that commit, then the buffer is scrolled down instead.

The following key bindings are available when both Magit-Blame mode and Read-Only mode are enabled.

b (magit-blame)
See above.

n (magit-blame-next-chunk)
This command moves to the next chunk.

N (magit-blame-next-chunk-same-commit)
This command moves to the next chunk from the same commit.

p (magit-blame-previous-chunk)
This command moves to the previous chunk.

P (magit-blame-previous-chunk-same-commit)
This command moves to the previous chunk from the same commit.

q (magit-blame-quit)
This command turns off Magit-Blame mode. If the buffer was created during a recursive blame, then it also kills the buffer.

M-w (magit-blame-copy-hash)
This command saves the hash of the current chunk’s commit to the kill ring.

When the region is active, the command saves the region’s content instead of the hash, like kill-ring-save would.

c (magit-blame-cycle-style)
This command changes how blame information is visualized in the current buffer by cycling through the styles specified using the option magit-blame-styles.

Blaming is also controlled using the following options.

User Option: magit-blame-styles
This option defines a list of styles used to visualize blame information. For now see its doc-string to learn more.

User Option: magit-blame-echo-style
This option specifies the blame visualization style used by the command magit-blame-echo. This must be a symbol that is used as the identifier for one of the styles defined in magit-blame-styles.

User Option: magit-blame-time-format
This option specifies the format string used to display times when showing blame information.

User Option: magit-blame-read-only
This option controls whether blaming a buffer also makes temporarily read-only.

User Option: magit-blame-disable-modes
This option lists incompatible minor-modes that should be disabled temporarily when a buffer contains blame information. They are enabled again when the buffer no longer shows blame information.

User Option: magit-blame-goto-chunk-hook
This hook is run when moving between chunks.



** Manipulating

*** Creating Repository

I (magit-init)
This command initializes a repository and then shows the status buffer for the new repository.

If the directory is below an existing repository, then the user has to confirm that a new one should be created inside. If the directory is the root of the existing repository, then the user has to confirm that it should be reinitialized.


*** Cloning Repository

To clone a remote or local repository use C, which is bound to the command magit-clone. This command either act as a transient prefix command, which binds several infix arguments and suffix commands, or it can invoke git clone directly, depending on whether a prefix argument is used and on the value of magit-clone-always-transient.

User Option: magit-clone-always-transient
This option controls whether the command magit-clone always acts as a transient prefix command, regardless of whether a prefix argument is used or not. If t, then that command always acts as a transient prefix. If nil, then a prefix argument has to be used for it to act as a transient.

C (magit-clone)
This command either acts as a transient prefix command as described above or does the same thing as transient-clone-regular as described below.

If it acts as a transient prefix, then it binds the following suffix commands and several infix arguments.

C C (magit-clone-regular)
This command creates a regular clone of an existing repository. The repository and the target directory are read from the user.

C s (magit-clone-shallow)
This command creates a shallow clone of an existing repository. The repository and the target directory are read from the user. By default the depth of the cloned history is a single commit, but with a prefix argument the depth is read from the user.

C > (magit-clone-sparse)
This command creates a clone of an existing repository and initializes a sparse checkout, avoiding a checkout of the full working tree. To add more directories, use the magit-sparse-checkout transient (see Sparse checkouts).

C b (magit-clone-bare)
This command creates a bare clone of an existing repository. The repository and the target directory are read from the user.

C m (magit-clone-mirror)
This command creates a mirror of an existing repository. The repository and the target directory are read from the user.

The following suffixes are disabled by default. See (transient)Enabling and Disabling Suffixes for how to enable them.

C d (magit-clone-shallow-since)
This command creates a shallow clone of an existing repository. Only commits that were committed after a date are cloned, which is read from the user. The repository and the target directory are also read from the user.

C e (magit-clone-shallow-exclude)
This command creates a shallow clone of an existing repository. This reads a branch or tag from the user. Commits that are reachable from that are not cloned. The repository and the target directory are also read from the user.

User Option: magit-clone-set-remote-head
This option controls whether cloning causes the reference refs/remotes/<remote>/HEAD to be created in the clone. The default is to delete the reference after running git clone, which insists on creating it. This is because the reference has not been found to be particularly useful as it is not automatically updated when the HEAD of the remote changes. Setting this option to t preserves Git’s default behavior of creating the reference.

User Option: magit-clone-set-remote.pushDefault
This option controls whether the value of the Git variable remote.pushDefault is set after cloning.

If t, then it is always set without asking.
If ask, then the users are asked every time they clone a repository.
If nil, then it is never set.
User Option: magit-clone-default-directory
This option control the default directory name used when reading the destination for a cloning operation.

If nil (the default), then the value of default-directory is used.
If a directory, then that is used.
If a function, then that is called with the remote url as the only argument and the returned value is used.
User Option: magit-clone-name-alist
This option maps regular expressions, which match repository names, to repository urls, making it possible for users to enter short names instead of urls when cloning repositories.

Each element has the form (REGEXP HOSTNAME USER). When the user enters a name when a cloning command asks for a name or url, then that is looked up in this list. The first element whose REGEXP matches is used.

The format specified by option magit-clone-url-format is used to turn the name into an url, using HOSTNAME and the repository name. If the provided name contains a slash, then that is used. Otherwise if the name omits the owner of the repository, then the default user specified in the matched entry is used.

If USER contains a dot, then it is treated as a Git variable and the value of that is used as the username. Otherwise it is used as the username itself.

User Option: magit-clone-url-format
The format specified by this option is used when turning repository names into urls. %h is the hostname and %n is the repository name, including the name of the owner. The value can be a string (representing a single static format) or an alist with elements (HOSTNAME . FORMAT) mapping hostnames to formats. When an alist is used, the t key represents the default format.

Example of a single format string:

(setq magit-clone-url-format
      "git@%h:%n.git")
Example of by-hostname format strings:

(setq magit-clone-url-format
      '(("git.example.com" . "git@%h:~%n")
        (nil . "git@%h:%n.git")))
User Option: magit-post-clone-hook
Hook run after the Git process has successfully finished cloning the repository. When the hook is called, default-directory is let-bound to the directory where the repository has been cloned.


*** Staging and Unstaging

Like Git, Magit can of course stage and unstage complete files. Unlike Git, it also allows users to gracefully un-/stage individual hunks and even just part of a hunk. To stage individual hunks and parts of hunks using Git directly, one has to use the very modal and rather clumsy interface of a git add --interactive session.

With Magit, on the other hand, one can un-/stage individual hunks by just moving point into the respective section inside a diff displayed in the status buffer or a separate diff buffer and typing s or u. To operate on just parts of a hunk, mark the changes that should be un-/staged using the region and then press the same key that would be used to un-/stage. To stage multiple files or hunks at once use a region that starts inside the heading of such a section and ends inside the heading of a sibling section of the same type.

Besides staging and unstaging, Magit also provides several other "apply variants" that can also operate on a file, multiple files at once, a hunk, multiple hunks at once, and on parts of a hunk. These apply variants are described in the next section.

You can also use Ediff to stage and unstage. See Ediffing.

s (magit-stage)
Add the change at point to the staging area.

With a prefix argument and an untracked file (or files) at point, stage the file but not its content. This makes it possible to stage only a subset of the new file’s changes.

S (magit-stage-modified)
Stage all changes to files modified in the worktree. Stage all new content of tracked files and remove tracked files that no longer exist in the working tree from the index also. With a prefix argument also stage previously untracked (but not ignored) files.

u (magit-unstage)
Remove the change at point from the staging area.

Only staged changes can be unstaged. But by default this command performs an action that is somewhat similar to unstaging, when it is called on a committed change: it reverses the change in the index but not in the working tree.

U (magit-unstage-all)
Remove all changes from the staging area.

User Option: magit-unstage-committed
This option controls whether magit-unstage "unstages" committed changes by reversing them in the index but not the working tree. The alternative is to raise an error.

M-x magit-reverse-in-index
This command reverses the committed change at point in the index but not the working tree. By default no key is bound directly to this command, but it is indirectly called when u (magit-unstage) is pressed on a committed change.

This allows extracting a change from HEAD, while leaving it in the working tree, so that it can later be committed using a separate commit. A typical workflow would be:

Optionally make sure that there are no uncommitted changes.
Visit the HEAD commit and navigate to the change that should not have been included in that commit.
Type u (magit-unstage) to reverse it in the index. This assumes that magit-unstage-committed is non-nil.
Type c e to extend HEAD with the staged changes, including those that were already staged before.
Optionally stage the remaining changes using s or S and then type c c to create a new commit.
M-x magit-reset-index
Reset the index to some commit. The commit is read from the user and defaults to the commit at point. If there is no commit at point, then it defaults to HEAD.

**** Staging from File-Visiting Buffers

Fine-grained un-/staging has to be done from the status or a diff buffer, but it’s also possible to un-/stage all changes made to the file visited in the current buffer right from inside that buffer.

M-x magit-stage-file
When invoked inside a file-visiting buffer, then stage all changes to that file. In a Magit buffer, stage the file at point if any. Otherwise prompt for a file to be staged. With a prefix argument always prompt the user for a file, even in a file-visiting buffer or when there is a file section at point.

M-x magit-unstage-file
When invoked inside a file-visiting buffer, then unstage all changes to that file. In a Magit buffer, unstage the file at point if any. Otherwise prompt for a file to be unstaged. With a prefix argument always prompt the user for a file, even in a file-visiting buffer or when there is a file section at point.


*** Applying

Magit provides several "apply variants": stage, unstage, discard, reverse, and "regular apply". At least when operating on a hunk they are all implemented using git apply, which is why they are called "apply variants".

Stage. Apply a change from the working tree to the index. The change also remains in the working tree.
Unstage. Remove a change from the index. The change remains in the working tree.
Discard. On a staged change, remove it from the working tree and the index. On an unstaged change, remove it from the working tree only.
Reverse. Reverse a change in the working tree. Both committed and staged changes can be reversed. Unstaged changes cannot be reversed. Discard them instead.
Apply. Apply a change to the working tree. Both committed and staged changes can be applied. Unstaged changes cannot be applied - as they already have been applied.
The previous section described the staging and unstaging commands. What follows are the commands which implement the remaining apply variants.

a (magit-apply)
Apply the change at point to the working tree.

With a prefix argument fallback to a 3-way merge. Doing so causes the change to be applied to the index as well.

k (magit-discard)
Remove the change at point from the working tree.

On a hunk or file with unresolved conflicts prompt which side to keep (while discarding the other). If point is within the text of a side, then keep that side without prompting.

v (magit-reverse)
Reverse the change at point in the working tree.

With a prefix argument fallback to a 3-way merge. Doing so causes the change to be applied to the index as well.

With a prefix argument all apply variants attempt a 3-way merge when appropriate (i.e., when git apply is used internally).


*** Committing

When the user initiates a commit, Magit calls git commit without any arguments, so Git has to get it from the user. It creates the file .git/COMMIT_EDITMSG and then opens that file in an editor. Magit arranges for that editor to be the Emacsclient. Once the user finishes the editing session, the Emacsclient exits and Git creates the commit using the file’s content as message.

**** Initiating a Commit

Also see the git-commit(1) manpage.

c (magit-commit)
This transient prefix command binds the following suffix commands along with the appropriate infix arguments and displays them in a temporary buffer until a suffix is invoked.

c c (magit-commit-create)
Create a new commit on HEAD. With a prefix argument amend to the commit at HEAD instead.

c a (magit-commit-amend)
Amend the last commit.

c e (magit-commit-extend)
Amend the last commit, without editing the message. With a prefix argument keep the committer date, otherwise change it. The option magit-commit-extend-override-date can be used to inverse the meaning of the prefix argument.

Non-interactively respect the optional OVERRIDE-DATE argument and ignore the option.

c w (magit-commit-reword)
Reword the last commit, ignoring staged changes. With a prefix argument keep the committer date, otherwise change it. The option magit-commit-reword-override-date can be used to inverse the meaning of the prefix argument.

Non-interactively respect the optional OVERRIDE-DATE argument and ignore the option.

c f (magit-commit-fixup)
Create a fixup commit.

With a prefix argument the target commit has to be confirmed. Otherwise the commit at point may be used without confirmation depending on the value of option magit-commit-squash-confirm.

c F (magit-commit-instant-fixup)
Create a fixup commit and instantly rebase.

c s (magit-commit-squash)
Create a squash commit, without editing the squash message.

With a prefix argument the target commit has to be confirmed. Otherwise the commit at point may be used without confirmation depending on the value of option magit-commit-squash-confirm.

c S (magit-commit-instant-squash)
Create a squash commit and instantly rebase.

c A (magit-commit-augment)
Create a squash commit, editing the squash message.

With a prefix argument the target commit has to be confirmed. Otherwise the commit at point may be used without confirmation depending on the value of option magit-commit-squash-confirm.

User Option: magit-commit-ask-to-stage
Whether to ask to stage all unstaged changes when committing and nothing is staged.

User Option: magit-commit-show-diff
Whether the relevant diff is automatically shown when committing.

User Option: magit-commit-extend-override-date
Whether using magit-commit-extend changes the committer date.

User Option: magit-commit-reword-override-date
Whether using magit-commit-reword changes the committer date.

User Option: magit-commit-squash-confirm
Whether the commit targeted by squash and fixup has to be confirmed. When non-nil then the commit at point (if any) is used as default choice. Otherwise it has to be confirmed. This option only affects magit-commit-squash and magit-commit-fixup. The "instant" variants always require confirmation because making an error while using those is harder to recover from.

User Option: magit-post-commit-hook
Hook run after creating a commit without the user editing a message.

This hook is run by magit-refresh if this-command is a member of magit-post-commit-hook-commands. This only includes commands named magit-commit-* that do not require that the user edits the commit message in a buffer.

Also see git-commit-post-finish-hook.

User Option: magit-commit-diff-inhibit-same-window
Whether to inhibit use of same window when showing diff while committing.

When writing a commit, then a diff of the changes to be committed is automatically shown. The idea is that the diff is shown in a different window of the same frame and for most users that just works. In other words most users can completely ignore this option because its value doesn’t make a difference for them.

However for users who configured Emacs to never create a new window even when the package explicitly tries to do so, then displaying two new buffers necessarily means that the first is immediately replaced by the second. In our case the message buffer is immediately replaced by the diff buffer, which is of course highly undesirable.

A workaround is to suppress this user configuration in this particular case. Users have to explicitly opt-in by toggling this option. We cannot enable the workaround unconditionally because that again causes issues for other users: if the frame is too tiny or the relevant settings too aggressive, then the diff buffer would end up being displayed in a new frame.

Also see https://github.com/magit/magit/issues/4132.


**** Editing Commit Messages

After initiating a commit as described in the previous section, two new buffers appear. One shows the changes that are about to be committed, while the other is used to write the message.

Commit messages are edited in an edit session - in the background git is waiting for the editor, in our case emacsclient, to save the commit message in a file (in most cases .git/COMMIT_EDITMSG) and then return. If the editor returns with a non-zero exit status then git does not create the commit. So the most important commands are those for finishing and aborting the commit.

C-c C-c (with-editor-finish)
Finish the current editing session by returning with exit code 0. Git then creates the commit using the message it finds in the file.

C-c C-k (with-editor-cancel)
Cancel the current editing session by returning with exit code 1. Git then cancels the commit, but leaves the file untouched.

In addition to being used by git commit, messages may also be stored in a ring that persists until Emacs is closed. By default the message is stored at the beginning and the end of an edit session (regardless of whether the session is finished successfully or was canceled). It is sometimes useful to bring back messages from that ring.

C-c M-s (git-commit-save-message)
Save the current buffer content to the commit message ring.

M-p (git-commit-prev-message)
Cycle backward through the commit message ring, after saving the current message to the ring. With a numeric prefix ARG, go back ARG comments.

M-n (git-commit-next-message)
Cycle forward through the commit message ring, after saving the current message to the ring. With a numeric prefix ARG, go back ARG comments.

By default the diff for the changes that are about to be committed are automatically shown when invoking the commit. To prevent that, remove magit-commit-diff from server-switch-hook.

When amending to an existing commit it may be useful to show either the changes that are about to be added to that commit or to show those changes alongside those that have already been committed.

C-c C-d (magit-diff-while-committing)
While committing, show the changes that are about to be committed. While amending, invoking the command again toggles between showing just the new changes or all the changes that will be committed.

***** Using the Revision Stack

C-c C-w (magit-pop-revision-stack)
This command inserts a representation of a revision into the current buffer. It can be used inside buffers used to write commit messages but also in other buffers such as buffers used to edit emails or ChangeLog files.

By default this command pops the revision which was last added to the magit-revision-stack and inserts it into the current buffer according to magit-pop-revision-stack-format. Revisions can be put on the stack using magit-copy-section-value and magit-copy-buffer-revision.

If the stack is empty or with a prefix argument it instead reads a revision in the minibuffer. By using the minibuffer history this allows selecting an item which was popped earlier or to insert an arbitrary reference or revision without first pushing it onto the stack.

When reading the revision from the minibuffer, then it might not be possible to guess the correct repository. When this command is called inside a repository (e.g., while composing a commit message), then that repository is used. Otherwise (e.g., while composing an email) then the repository recorded for the top element of the stack is used (even though we insert another revision). If not called inside a repository and with an empty stack, or with two prefix arguments, then read the repository in the minibuffer too.

User Option: magit-pop-revision-stack-format
This option controls how the command magit-pop-revision-stack inserts a revision into the current buffer.

The entries on the stack have the format (HASH TOPLEVEL) and this option has the format (POINT-FORMAT EOB-FORMAT INDEX-REGEXP), all of which may be nil or a string (though either one of EOB-FORMAT or POINT-FORMAT should be a string, and if INDEX-REGEXP is non-nil, then the two formats should be too).

First INDEX-REGEXP is used to find the previously inserted entry, by searching backward from point. The first submatch must match the index number. That number is incremented by one, and becomes the index number of the entry to be inserted. If you don’t want to number the inserted revisions, then use nil for INDEX-REGEXP.

If INDEX-REGEXP is non-nil then both POINT-FORMAT and EOB-FORMAT should contain \"%N\", which is replaced with the number that was determined in the previous step.

Both formats, if non-nil and after removing %N, are then expanded using git show --format=FORMAT ... inside TOPLEVEL.

The expansion of POINT-FORMAT is inserted at point, and the expansion of EOB-FORMAT is inserted at the end of the buffer (if the buffer ends with a comment, then it is inserted right before that).


***** Commit Pseudo Headers

Some projects use pseudo headers in commit messages. Magit colorizes such headers and provides some commands to insert such headers.

User Option: git-commit-known-pseudo-headers
A list of Git pseudo headers to be highlighted.

C-c C-i (git-commit-insert-pseudo-header)
Insert a commit message pseudo header.

C-c C-a (git-commit-ack)
Insert a header acknowledging that you have looked at the commit.

C-c C-r (git-commit-review)
Insert a header acknowledging that you have reviewed the commit.

C-c C-s (git-commit-signoff)
Insert a header to sign off the commit.

C-c C-t (git-commit-test)
Insert a header acknowledging that you have tested the commit.

C-c C-o (git-commit-cc)
Insert a header mentioning someone who might be interested.

C-c C-p (git-commit-reported)
Insert a header mentioning the person who reported the issue being fixed by the commit.

C-c M-i (git-commit-suggested)
Insert a header mentioning the person who suggested the change.


***** Commit Mode and Hooks

git-commit-mode is a minor mode that is only used to establish certain key bindings. This makes it possible to use an arbitrary major mode in buffers used to edit commit messages. It is even possible to use different major modes in different repositories, which is useful when different projects impose different commit message conventions.

User Option: git-commit-major-mode
The value of this option is the major mode used to edit Git commit messages.

Because git-commit-mode is a minor mode, we don’t use its mode hook to setup the buffer, except for the key bindings. All other setup happens in the function git-commit-setup, which among other things runs the hook git-commit-setup-hook.

User Option: git-commit-setup-hook
Hook run at the end of git-commit-setup.

The following functions are suitable for this hook:

Function: git-commit-save-message
Save the current buffer content to the commit message ring.

Function: git-commit-setup-changelog-support
After this function is called, ChangeLog entries are treated as paragraphs.

Function: git-commit-turn-on-auto-fill
Turn on auto-fill-mode.

Function: git-commit-turn-on-flyspell
Turn on Flyspell mode. Also prevent comments from being checked and finally check current non-comment text.

Function: git-commit-propertize-diff
Propertize the diff shown inside the commit message buffer. Git inserts such diffs into the commit message template when the --verbose argument is used. magit-commit by default does not offer that argument because the diff that is shown in a separate buffer is more useful. But some users disagree, which is why this function exists.

Function: bug-reference-mode
Hyperlink bug references in the buffer.

Function: with-editor-usage-message
Show usage information in the echo area.

User Option: git-commit-post-finish-hook
Hook run after the user finished writing a commit message.

This hook is only run after pressing C-c C-c in a buffer used to edit a commit message. If a commit is created without the user typing a message into a buffer, then this hook is not run.

This hook is not run until the new commit has been created. If doing so takes Git longer than one second, then this hook isn’t run at all. For certain commands such as magit-rebase-continue this hook is never run because doing so would lead to a race condition.

This hook is only run if magit is available.

Also see magit-post-commit-hook.


***** Commit Message Conventions

Git-Commit highlights certain violations of commonly accepted commit message conventions. Certain violations even cause Git-Commit to ask you to confirm that you really want to do that. This nagging can of course be turned off, but the result of doing that usually is that instead of some code it’s now the human who is reviewing your commits who has to waste some time telling you to fix your commits.

User Option: git-commit-summary-max-length
The intended maximal length of the summary line of commit messages. Characters beyond this column are colorized to indicate that this preference has been violated.

User Option: git-commit-finish-query-functions
List of functions called to query before performing commit.

The commit message buffer is current while the functions are called. If any of them returns nil, then the commit is not performed and the buffer is not killed. The user should then fix the issue and try again.

The functions are called with one argument. If it is non-nil then that indicates that the user used a prefix argument to force finishing the session despite issues. Functions should usually honor this wish and return non-nil.

By default the only member is git-commit-check-style-conventions.

Function: git-commit-check-style-conventions
This function checks for violations of certain basic style conventions. For each violation it asks users if they want to proceed anyway.

User Option: git-commit-style-convention-checks
This option controls what conventions the function by the same name tries to enforce. The value is a list of self-explanatory symbols identifying certain conventions; non-empty-second-line and overlong-summary-line.


*** Branching

**** The Two Remotes

The upstream branch of some local branch is the branch into which the commits on that local branch should eventually be merged, usually something like origin/master. For the master branch itself the upstream branch and the branch it is being pushed to, are usually the same remote branch. But for a feature branch the upstream branch and the branch it is being pushed to should differ.

The commits on feature branches too should eventually end up in a remote branch such as origin/master or origin/maint. Such a branch should therefore be used as the upstream. But feature branches shouldn’t be pushed directly to such branches. Instead a feature branch my-feature is usually pushed to my-fork/my-feature or if you are a contributor origin/my-feature. After the new feature has been reviewed, the maintainer merges the feature into master. And finally master (not my-feature itself) is pushed to origin/master.

But new features seldom are perfect on the first try, and so feature branches usually have to be reviewed, improved, and re-pushed several times. Pushing should therefore be easy to do, and for that reason many Git users have concluded that it is best to use the remote branch to which the local feature branch is being pushed as its upstream.

But luckily Git has long ago gained support for a push-remote which can be configured separately from the upstream branch, using the variables branch.<name>.pushRemote and remote.pushDefault. So we no longer have to choose which of the two remotes should be used as "the remote".

Each of the fetching, pulling, and pushing transient commands features three suffix commands that act on the current branch and some other branch. Of these, p is bound to a command which acts on the push-remote, u is bound to a command which acts on the upstream, and e is bound to a command which acts on any other branch. The status buffer shows unpushed and unpulled commits for both the push-remote and the upstream.

It’s fairly simple to configure these two remotes. The values of all the variables that are related to fetching, pulling, and pushing (as well as some other branch-related variables) can be inspected and changed using the command magit-branch-configure, which is available from many transient prefix commands that deal with branches. It is also possible to set the push-remote or upstream while pushing (see Pushing).


**** Branch Commands

The transient prefix command magit-branch is used to create and checkout branches, and to make changes to existing branches. It is not used to fetch, pull, merge, rebase, or push branches, i.e., this command deals with branches themselves, not with the commits reachable from them. Those features are available from separate transient command.

b (magit-branch)
This transient prefix command binds the following suffix commands and displays them in a temporary buffer until a suffix is invoked.

By default it also binds and displays the values of some branch-related Git variables and allows changing their values.

User Option: magit-branch-direct-configure
This option controls whether the transient command magit-branch can be used to directly change the values of Git variables. This defaults to t (to avoid changing key bindings). When set to nil, then no variables are displayed by that transient command, and its suffix command magit-branch-configure has to be used instead to view and change branch related variables.

b C (magit-branch-configure)
f C
F C
P C
This transient prefix command binds commands that set the value of branch-related variables and displays them in a temporary buffer until the transient is exited.

With a prefix argument, this command always prompts for a branch.

Without a prefix argument this depends on whether it was invoked as a suffix of magit-branch and on the magit-branch-direct-configure option. If magit-branch already displays the variables for the current branch, then it isn’t useful to invoke another transient that displays them for the same branch. In that case this command prompts for a branch.

The variables are described in Branch Git Variables.

b b (magit-checkout)
Checkout a revision read in the minibuffer and defaulting to the branch or arbitrary revision at point. If the revision is a local branch then that becomes the current branch. If it is something else then HEAD becomes detached. Checkout fails if the working tree or the staging area contain changes.

b n (magit-branch-create)
Create a new branch. The user is asked for a branch or arbitrary revision to use as the starting point of the new branch. When a branch name is provided, then that becomes the upstream branch of the new branch. The name of the new branch is also read in the minibuffer.

Also see option magit-branch-prefer-remote-upstream.

b c (magit-branch-and-checkout)
This command creates a new branch like magit-branch-create, but then also checks it out.

Also see option magit-branch-prefer-remote-upstream.

b l (magit-branch-checkout)
This command checks out an existing or new local branch. It reads a branch name from the user offering all local branches and a subset of remote branches as candidates. Remote branches for which a local branch by the same name exists are omitted from the list of candidates. The user can also enter a completely new branch name.

If the user selects an existing local branch, then that is checked out.
If the user selects a remote branch, then it creates and checks out a new local branch with the same name, and configures the selected remote branch as the push target.
If the user enters a new branch name, then it creates and checks that out, after also reading the starting-point from the user.
In the latter two cases the upstream is also set. Whether it is set to the chosen starting point or something else depends on the value of magit-branch-adjust-remote-upstream-alist.

b s (magit-branch-spinoff)
This command creates and checks out a new branch starting at and tracking the current branch. That branch in turn is reset to the last commit it shares with its upstream. If the current branch has no upstream or no unpushed commits, then the new branch is created anyway and the previously current branch is not touched.

This is useful to create a feature branch after work has already begun on the old branch (likely but not necessarily "master").

If the current branch is a member of the value of option magit-branch-prefer-remote-upstream (which see), then the current branch will be used as the starting point as usual, but the upstream of the starting-point may be used as the upstream of the new branch, instead of the starting-point itself.

If optional FROM is non-nil, then the source branch is reset to FROM~, instead of to the last commit it shares with its upstream. Interactively, FROM is only ever non-nil, if the region selects some commits, and among those commits, FROM is the commit that is the fewest commits ahead of the source branch.

The commit at the other end of the selection actually does not matter, all commits between FROM and HEAD are moved to the new branch. If FROM is not reachable from HEAD or is reachable from the source branch’s upstream, then an error is raised.

b S (magit-branch-spinout)
This command behaves like magit-branch-spinoff, except that it does not change the current branch. If there are any uncommitted changes, then it behaves exactly like magit-branch-spinoff.

b x (magit-branch-reset)
This command resets a branch, defaulting to the branch at point, to the tip of another branch or any other commit.

When the branch being reset is the current branch, then a hard reset is performed. If there are any uncommitted changes, then the user has to confirm the reset because those changes would be lost.

This is useful when you have started work on a feature branch but realize it’s all crap and want to start over.

When resetting to another branch and a prefix argument is used, then the target branch is set as the upstream of the branch that is being reset.

b k (magit-branch-delete)
Delete one or multiple branches. If the region marks multiple branches, then offer to delete those. Otherwise, prompt for a single branch to be deleted, defaulting to the branch at point.

Require confirmation when deleting branches is dangerous in some way. Option magit-no-confirm can be customized to not require confirmation in certain cases. See its docstring to learn why confirmation is required by default in certain cases or if a prompt is confusing.

b m (magit-branch-rename)
Rename a branch. The branch and the new name are read in the minibuffer. With prefix argument the branch is renamed even if that name conflicts with an existing branch.

User Option: magit-branch-read-upstream-first
When creating a branch, whether to read the upstream branch before the name of the branch that is to be created. The default is t, and I recommend you leave it at that.

User Option: magit-branch-prefer-remote-upstream
This option specifies whether remote upstreams are favored over local upstreams when creating new branches.

When a new branch is created, then the branch, commit, or stash at point is suggested as the starting point of the new branch, or if there is no such revision at point the current branch. In either case the user may choose another starting point.

If the chosen starting point is a branch, then it may also be set as the upstream of the new branch, depending on the value of the Git variable ‘branch.autoSetupMerge’. By default this is done for remote branches, but not for local branches.

You might prefer to always use some remote branch as upstream. If the chosen starting point is (1) a local branch, (2) whose name matches a member of the value of this option, (3) the upstream of that local branch is a remote branch with the same name, and (4) that remote branch can be fast-forwarded to the local branch, then the chosen branch is used as starting point, but its own upstream is used as the upstream of the new branch.

Members of this option’s value are treated as branch names that have to match exactly unless they contain a character that makes them invalid as a branch name. Recommended characters to use to trigger interpretation as a regexp are "*" and "^". Some other characters which you might expect to be invalid, actually are not, e.g., ".+$" are all perfectly valid. More precisely, if git check-ref-format --branch STRING exits with a non-zero status, then treat STRING as a regexp.

Assuming the chosen branch matches these conditions you would end up with with e.g.:

feature --upstream--> origin/master
instead of

feature --upstream--> master --upstream--> origin/master
Which you prefer is a matter of personal preference. If you do prefer the former, then you should add branches such as master, next, and maint to the value of this options.

User Option: magit-branch-adjust-remote-upstream-alist
The value of this option is an alist of branches to be used as the upstream when branching a remote branch.

When creating a local branch from an ephemeral branch located on a remote, e.g., a feature or hotfix branch, then that remote branch should usually not be used as the upstream branch, since the push-remote already allows accessing it and having both the upstream and the push-remote reference the same related branch would be wasteful. Instead a branch like "maint" or "master" should be used as the upstream.

This option allows specifying the branch that should be used as the upstream when branching certain remote branches. The value is an alist of the form ((UPSTREAM . RULE)...). The first matching element is used, the following elements are ignored.

UPSTREAM is the branch to be used as the upstream for branches specified by RULE. It can be a local or a remote branch.

RULE can either be a regular expression, matching branches whose upstream should be the one specified by UPSTREAM. Or it can be a list of the only branches that should not use UPSTREAM; all other branches will. Matching is done after stripping the remote part of the name of the branch that is being branched from.

If you use a finite set of non-ephemeral branches across all your repositories, then you might use something like:

(("origin/master" . ("master" "next" "maint")))
Or if the names of all your ephemeral branches contain a slash, at least in some repositories, then a good value could be:

(("origin/master" . "/"))
Of course you can also fine-tune:

(("origin/maint" . "\\`hotfix/")
 ("origin/master" . "\\`feature/"))
UPSTREAM can be a local branch:

(("master" . ("master" "next" "maint")))
Because the main branch is no longer almost always named "master" you should also account for other common names:

(("main"  . ("main" "master" "next" "maint"))
 ("master" . ("main" "master" "next" "maint")))
Command: magit-branch-orphan
This command creates and checks out a new orphan branch with contents from a given revision.

Command: magit-branch-or-checkout
This command is a hybrid between magit-checkout and magit-branch-and-checkout and is intended as a replacement for the former in magit-branch.

It first asks the user for an existing branch or revision. If the user input actually can be resolved as a branch or revision, then it checks that out, just like magit-checkout would.

Otherwise it creates and checks out a new branch using the input as its name. Before doing so it reads the starting-point for the new branch. This is similar to what magit-branch-and-checkout does.

To use this command instead of magit-checkout add this to your init file:

(transient-replace-suffix 'magit-branch 'magit-checkout
  '("b" "dwim" magit-branch-or-checkout))

**** Branch Git Variables

These variables can be set from the transient prefix command magit-branch-configure. By default they can also be set from magit-branch. See Branch Commands.

Variable: branch.NAME.merge
Together with branch.NAME.remote this variable defines the upstream branch of the local branch named NAME. The value of this variable is the full reference of the upstream branch.

Variable: branch.NAME.remote
Together with branch.NAME.merge this variable defines the upstream branch of the local branch named NAME. The value of this variable is the name of the upstream remote.

Variable: branch.NAME.rebase
This variable controls whether pulling into the branch named NAME is done by rebasing or by merging the fetched branch.

When true then pulling is done by rebasing.
When false then pulling is done by merging.
When undefined then the value of pull.rebase is used. The default of that variable is false.
Variable: branch.NAME.pushRemote
This variable specifies the remote that the branch named NAME is usually pushed to. The value has to be the name of an existing remote.

It is not possible to specify the name of branch to push the local branch to. The name of the remote branch is always the same as the name of the local branch.

If this variable is undefined but remote.pushDefault is defined, then the value of the latter is used. By default remote.pushDefault is undefined.

Variable: branch.NAME.description
This variable can be used to describe the branch named NAME. That description is used, e.g., when turning the branch into a series of patches.

The following variables specify defaults which are used if the above branch-specific variables are not set.

Variable: pull.rebase
This variable specifies whether pulling is done by rebasing or by merging. It can be overwritten using branch.NAME.rebase.

When true then pulling is done by rebasing.
When false (the default) then pulling is done by merging.
Since it is never a good idea to merge the upstream branch into a feature or hotfix branch and most branches are such branches, you should consider setting this to true, and branch.master.rebase to false.

Variable: remote.pushDefault
This variable specifies what remote the local branches are usually pushed to. This can be overwritten per branch using branch.NAME.pushRemote.

The following variables are used during the creation of a branch and control whether the various branch-specific variables are automatically set at this time.

Variable: branch.autoSetupMerge
This variable specifies under what circumstances creating a branch NAME should result in the variables branch.NAME.merge and branch.NAME.remote being set according to the starting point used to create the branch. If the starting point isn’t a branch, then these variables are never set.

When always then the variables are set regardless of whether the starting point is a local or a remote branch.
When true (the default) then the variables are set when the starting point is a remote branch, but not when it is a local branch.
When false then the variables are never set.
Variable: branch.autoSetupRebase
This variable specifies whether creating a branch NAME should result in the variable branch.NAME.rebase being set to true.

When always then the variable is set regardless of whether the starting point is a local or a remote branch.
When local then the variable are set when the starting point is a local branch, but not when it is a remote branch.
When remote then the variable are set when the starting point is a remote branch, but not when it is a local branch.
When never (the default) then the variable is never set.
Note that the respective commands always change the repository-local values. If you want to change the global value, which is used when the local value is undefined, then you have to do so on the command line, e.g.:

git config --global remote.autoSetupMerge always
For more information about these variables you should also see

the git-config(1) manpage.
Also see the git-branch(1) manpage. , the git-checkout(1) manpage. and Pushing.

User Option: magit-prefer-remote-upstream
This option controls whether commands that read a branch from the user and then set it as the upstream branch, offer a local or a remote branch as default completion candidate, when they have the choice.

This affects all commands that use magit-read-upstream-branch or magit-read-starting-point, which includes all commands that change the upstream and many which create new branches.


**** Auxiliary Branch Commands

These commands are not available from the transient magit-branch by default.

Command: magit-branch-shelve
This command shelves a branch. This is done by deleting the branch, and creating a new reference "refs/shelved/BRANCH-NAME" pointing at the same commit as the branch pointed at. If the deleted branch had a reflog, then that is preserved as the reflog of the new reference.

This is useful if you want to move a branch out of sight, but are not ready to completely discard it yet.

Command: magit-branch-unshelve
This command unshelves a branch that was previously shelved using magit-branch-shelve. This is done by deleting the reference "refs/shelved/BRANCH-NAME" and creating a branch "BRANCH-NAME" pointing at the same commit as the deleted reference pointed at. If the deleted reference had a reflog, then that is restored as the reflog of the branch.


*** Merging

Also see the git-merge(1) manpage. For information on how to resolve merge conflicts see the next section.

m (magit-merge)
This transient prefix command binds the following suffix commands along with the appropriate infix arguments and displays them in a temporary buffer until a suffix is invoked.

When no merge is in progress, then the transient features the following suffix commands.

m m (magit-merge-plain)
This command merges another branch or an arbitrary revision into the current branch. The branch or revision to be merged is read in the minibuffer and defaults to the branch at point.

Unless there are conflicts or a prefix argument is used, then the resulting merge commit uses a generic commit message, and the user does not get a chance to inspect or change it before the commit is created. With a prefix argument this does not actually create the merge commit, which makes it possible to inspect how conflicts were resolved and to adjust the commit message.

m e (magit-merge-editmsg)
This command merges another branch or an arbitrary revision into the current branch and opens a commit message buffer, so that the user can make adjustments. The commit is not actually created until the user finishes with C-c C-c.

m n (magit-merge-nocommit)
This command merges another branch or an arbitrary revision into the current branch, but does not actually create the merge commit. The user can then further adjust the merge, even when automatic conflict resolution succeeded and/or adjust the commit message.

m a (magit-merge-absorb)
This command merges another local branch into the current branch and then removes the former.

Before the source branch is merged, it is first force pushed to its push-remote, provided the respective remote branch already exists. This ensures that the respective pull-request (if any) won’t get stuck on some obsolete version of the commits that are being merged. Finally, if magit-branch-pull-request was used to create the merged branch, then the respective remote branch is also removed.

m i (magit-merge-into)
This command merges the current branch into another local branch and then removes the former. The latter becomes the new current branch.

Before the source branch is merged, it is first force pushed to its push-remote, provided the respective remote branch already exists. This ensures that the respective pull-request (if any) won’t get stuck on some obsolete version of the commits that are being merged. Finally, if magit-branch-pull-request was used to create the merged branch, then the respective remote branch is also removed.

m s (magit-merge-squash)
This command squashes the changes introduced by another branch or an arbitrary revision into the current branch. This only applies the changes made by the squashed commits. No information is preserved that would allow creating an actual merge commit. Instead of this command you should probably use a command from the apply transient.

m p (magit-merge-preview)
This command shows a preview of merging another branch or an arbitrary revision into the current branch.

Note that commands, that normally change how a diff is displayed, do not work in buffers created by this command, because the underlying Git command does not support diff arguments.

When a merge is in progress, then the transient instead features the following suffix commands.

m m (magit-merge)
After the user resolved conflicts, this command proceeds with the merge. If some conflicts weren’t resolved, then this command fails.

m a (magit-merge-abort)
This command aborts the current merge operation.


*** Resolving Conflicts

When merging branches (or otherwise combining or changing history) conflicts can occur. If you edited two completely different parts of the same file in two branches and then merge one of these branches into the other, then Git can resolve that on its own, but if you edit the same area of a file, then a human is required to decide how the two versions, or "sides of the conflict", are to be combined into one.

Here we can only provide a brief introduction to the subject and point you toward some tools that can help. If you are new to this, then please also consult Git’s own documentation as well as other resources.

If a file has conflicts and Git cannot resolve them by itself, then it puts both versions into the affected file along with special markers whose purpose is to denote the boundaries of the unresolved part of the file and between the different versions. These boundary lines begin with the strings consisting of seven times the same character, one of <, |, = and >, and are followed by information about the source of the respective versions, e.g.:

<<<<<<< HEAD
Take the blue pill.
=======
Take the red pill.
>>>>>>> feature
In this case you have chosen to take the red pill on one branch and on another you picked the blue pill. Now that you are merging these two diverging branches, Git cannot possibly know which pill you want to take.

To resolve that conflict you have to create a version of the affected area of the file by keeping only one of the sides, possibly by editing it in order to bring in the changes from the other side, remove the other versions as well as the markers, and then stage the result. A possible resolution might be:

Take both pills.
Often it is useful to see not only the two sides of the conflict but also the "original" version from before the same area of the file was modified twice on different branches. Instruct Git to insert that version as well by running this command once:

git config --global merge.conflictStyle diff3
The above conflict might then have looked like this:

<<<<<<< HEAD
Take the blue pill.
||||||| merged common ancestors
Take either the blue or the red pill, but not both.
=======
Take the red pill.
>>>>>>> feature
If that were the case, then the above conflict resolution would not have been correct, which demonstrates why seeing the original version alongside the conflicting versions can be useful.

You can perform the conflict resolution completely by hand, but Emacs also provides some packages that help in the process: Smerge, Ediff ((ediff)Top), and Emerge ((emacs)Emerge). Magit does not provide its own tools for conflict resolution, but it does make using Smerge and Ediff more convenient. (Ediff supersedes Emerge, so you probably don’t want to use the latter anyway.)

In the Magit status buffer, files with unresolved conflicts are listed in the "Unstaged changes" and/or "Staged changes" sections. They are prefixed with the word "unmerged", which in this context essentially is a synonym for "unresolved".

Pressing RET while point is on such a file section shows a buffer visiting that file, turns on smerge-mode in that buffer, and places point inside the first area with conflicts. You should then resolve that conflict using regular edit commands and/or Smerge commands.

Unfortunately Smerge does not have a manual, but you can get a list of commands and binding C-c ^ C-h and press RET while point is on a command name to read its documentation.

Normally you would edit one version and then tell Smerge to keep only that version. Use C-c ^ m (smerge-keep-mine) to keep the HEAD version or C-c ^ o (smerge-keep-other) to keep the version that follows "|||||||". Then use C-c ^ n to move to the next conflicting area in the same file. Once you are done resolving conflicts, return to the Magit status buffer. The file should now be shown as "modified", no longer as "unmerged", because Smerge automatically stages the file when you save the buffer after resolving the last conflict.

Magit now wraps the mentioned Smerge commands, allowing you to use these key bindings without having to go to the file-visiting buffer. Additionally k (magit-discard) on a hunk with unresolved conflicts asks which side to keep or, if point is on a side, then it keeps it without prompting. Similarly k on a unresolved file ask which side to keep.

Alternatively you could use Ediff, which uses separate buffers for the different versions of the file. To resolve conflicts in a file using Ediff press e while point is on such a file in the status buffer.

Ediff can be used for other purposes as well. For more information on how to enter Ediff from Magit, see Ediffing. Explaining how to use Ediff is beyond the scope of this manual, instead see (ediff)Top.

If you are unsure whether you should Smerge or Ediff, then use the former. It is much easier to understand and use, and except for truly complex conflicts, the latter is usually overkill.


*** Rebasing

Also see the git-rebase(1) manpage. For information on how to resolve conflicts that occur during rebases see the preceding section.

r (magit-rebase)
This transient prefix command binds the following suffix commands along with the appropriate infix arguments and displays them in a temporary buffer until a suffix is invoked.

When no rebase is in progress, then the transient features the following suffix commands.

Using one of these commands starts a rebase sequence. Git might then stop somewhere along the way, either because you told it to do so, or because applying a commit failed due to a conflict. When that happens, then the status buffer shows information about the rebase sequence which is in progress in a section similar to a log section. See Information About In-Progress Rebase.

For information about the upstream and the push-remote, see The Two Remotes.

r p (magit-rebase-onto-pushremote)
This command rebases the current branch onto its push-remote.

With a prefix argument or when the push-remote is either not configured or unusable, then let the user first configure the push-remote.

r u (magit-rebase-onto-upstream)
This command rebases the current branch onto its upstream branch.

With a prefix argument or when the upstream is either not configured or unusable, then let the user first configure the upstream.

r e (magit-rebase-branch)
This command rebases the current branch onto a branch read in the minibuffer. All commits that are reachable from head but not from the selected branch TARGET are being rebased.

r s (magit-rebase-subset)
This command starts a non-interactive rebase sequence to transfer commits from START to HEAD onto NEWBASE. START has to be selected from a list of recent commits.

By default Magit uses the --autostash argument, which causes uncommitted changes to be stored in a stash before the rebase begins. These changes are restored after the rebase completes and if possible the stash is removed. If the stash does not apply cleanly, then the stash is not removed. In case something goes wrong when resolving the conflicts, this allows you to start over.

Even though one of the actions is dedicated to interactive rebases, the transient also features the infix argument --interactive. This can be used to turn one of the other, non-interactive rebase variants into an interactive rebase.

For example if you want to clean up a feature branch and at the same time rebase it onto master, then you could use r-iu. But we recommend that you instead do that in two steps. First use ri to cleanup the feature branch, and then in a second step ru to rebase it onto master. That way if things turn out to be more complicated than you thought and/or you make a mistake and have to start over, then you only have to redo half the work.

Explicitly enabling --interactive won’t have an effect on the following commands as they always use that argument anyway, even if it is not enabled in the transient.

r i (magit-rebase-interactive)
This command starts an interactive rebase sequence.

r f (magit-rebase-autosquash)
This command combines squash and fixup commits with their intended targets.

r m (magit-rebase-edit-commit)
This command starts an interactive rebase sequence that lets the user edit a single older commit.

r w (magit-rebase-reword-commit)
This command starts an interactive rebase sequence that lets the user reword a single older commit.

r k (magit-rebase-remove-commit)
This command removes a single older commit using rebase.

When a rebase is in progress, then the transient instead features the following suffix commands.

r r (magit-rebase-continue)
This command restart the current rebasing operation.

In some cases this pops up a commit message buffer for you do edit. With a prefix argument the old message is reused as-is.

r s (magit-rebase-skip)
This command skips the current commit and restarts the current rebase operation.

r e (magit-rebase-edit)
This command lets the user edit the todo list of the current rebase operation.

r a (magit-rebase-abort)
This command aborts the current rebase operation, restoring the original branch.

**** Editing Rebase Sequences

C-c C-c (with-editor-finish)
Finish the current editing session by returning with exit code 0. Git then uses the rebase instructions it finds in the file.

C-c C-k (with-editor-cancel)
Cancel the current editing session by returning with exit code 1. Git then forgoes starting the rebase sequence.

RET (git-rebase-show-commit)
Show the commit on the current line in another buffer and select that buffer.

SPC (git-rebase-show-or-scroll-up)
Show the commit on the current line in another buffer without selecting that buffer. If the revision buffer is already visible in another window of the current frame, then instead scroll that window up.

DEL (git-rebase-show-or-scroll-down)
Show the commit on the current line in another buffer without selecting that buffer. If the revision buffer is already visible in another window of the current frame, then instead scroll that window down.

p (git-rebase-backward-line)
Move to previous line.

n (forward-line)
Move to next line.

M-p (git-rebase-move-line-up)
Move the current commit (or command) up.

M-n (git-rebase-move-line-down)
Move the current commit (or command) down.

r (git-rebase-reword)
Edit message of commit on current line.

e (git-rebase-edit)
Stop at the commit on the current line.

s (git-rebase-squash)
Meld commit on current line into previous commit, and edit message.

f (git-rebase-fixup)
Meld commit on current line into previous commit, discarding the current commit’s message.

k (git-rebase-kill-line)
Kill the current action line.

c (git-rebase-pick)
Use commit on current line.

x (git-rebase-exec)
Insert a shell command to be run after the proceeding commit.

If there already is such a command on the current line, then edit that instead. With a prefix argument insert a new command even when there already is one on the current line. With empty input remove the command on the current line, if any.

b (git-rebase-break)
Insert a break action before the current line, instructing Git to return control to the user.

y (git-rebase-insert)
Read an arbitrary commit and insert it below current line.

C-x u (git-rebase-undo)
Undo some previous changes. Like undo but works in read-only buffers.

User Option: git-rebase-auto-advance
Whether to move to next line after changing a line.

User Option: git-rebase-show-instructions
Whether to show usage instructions inside the rebase buffer.

User Option: git-rebase-confirm-cancel
Whether confirmation is required to cancel.

When a rebase is performed with the --rebase-merges option, the sequence will include a few other types of actions and the following commands become relevant.

l (git-rebase-label)
This commands inserts a label action or edits the one at point.

t (git-rebase-reset)
This command inserts a reset action or edits the one at point. The prompt will offer the labels that are currently present in the buffer.

MM (git-rebase-merge)
The command inserts a merge action or edits the one at point. The prompt will offer the labels that are currently present in the buffer. Specifying a message to reuse via -c or -C is not supported; an editor will always be invoked for the merge.

Mt (git-rebase-merge-toggle-editmsg)
This command toggles between the -C and -c options of the merge action at point. These options both specify a commit whose message should be reused. The lower-case variant instructs Git to invoke the editor when creating the merge, allowing the user to edit the message.


**** Information About In-Progress Rebase

While a rebase sequence is in progress, the status buffer features a section that lists the commits that have already been applied as well as the commits that still have to be applied.

The commits are split in two halves. When rebase stops at a commit, either because the user has to deal with a conflict or because s/he explicitly requested that rebase stops at that commit, then point is placed on the commit that separates the two groups, i.e., on HEAD. The commits above it have not been applied yet, while the HEAD and the commits below it have already been applied. In between these two groups of applied and yet-to-be applied commits, there sometimes is a commit which has been dropped.

Each commit is prefixed with a word and these words are additionally shown in different colors to indicate the status of the commits.

The following colors are used:

Commits that use the same foreground color as the default face have not been applied yet.
Yellow commits have some special relationship to the commit rebase stopped at. This is used for the words "join", "goal", "same" and "work" (see below).
Gray commits have already been applied.
The blue commit is the HEAD commit.
The green commit is the commit the rebase sequence stopped at. If this is the same commit as HEAD (e.g., because you haven’t done anything yet after rebase stopped at the commit, then this commit is shown in blue, not green). There can only be a green and a blue commit at the same time, if you create one or more new commits after rebase stops at a commit.
Red commits have been dropped. They are shown for reference only, e.g., to make it easier to diff.
Of course these colors are subject to the color-theme in use.

The following words are used:

Commits prefixed with pick, reword, edit, squash, and fixup have not been applied yet. These words have the same meaning here as they do in the buffer used to edit the rebase sequence. See Editing Rebase Sequences. When the --rebase-merges option was specified, reset, label, and merge lines may also be present.
Commits prefixed with done and onto have already been applied. It is possible for such a commit to be the HEAD, in which case it is blue. Otherwise it is grey.
The commit prefixed with onto is the commit on top of which all the other commits are being re-applied. This commit itself did not have to be re-applied, it is the commit rebase did rewind to before starting to re-apply other commits.
Commits prefixed with done have already been re-applied. This includes commits that have been re-applied but also new commits that you have created during the rebase.
All other commits, those not prefixed with any of the above words, are in some way related to the commit at which rebase stopped.
To determine whether a commit is related to the stopped-at commit their hashes, trees and patch-ids 1 are being compared. The commit message is not used for this purpose.

Generally speaking commits that are related to the stopped-at commit can have any of the used colors, though not all color/word combinations are possible.

Words used for stopped-at commits are:

When a commit is prefixed with void, then that indicates that Magit knows for sure that all the changes in that commit have been applied using several new commits. This commit is no longer reachable from HEAD, and it also isn’t one of the commits that will be applied when resuming the session.
When a commit is prefixed with join, then that indicates that the rebase sequence stopped at that commit due to a conflict - you now have to join (merge) the changes with what has already been applied. In a sense this is the commit rebase stopped at, but while its effect is already in the index and in the worktree (with conflict markers), the commit itself has not actually been applied yet (it isn’t the HEAD). So it is shown in yellow, like the other commits that still have to be applied.
When a commit is prefixed with stop or a blue or green same, then that indicates that rebase stopped at this commit, that it is still applied or has been applied again, and that at least its patch-id is unchanged.
When a commit is prefixed with stop, then that indicates that rebase stopped at that commit because you requested that earlier, and its patch-id is unchanged. It might even still be the exact same commit.
When a commit is prefixed with a blue or green same, then that indicates that while its tree or hash changed, its patch-id did not. If it is blue, then it is the HEAD commit (as always for blue). When it is green, then it no longer is HEAD because other commit have been created since (but before continuing the rebase).
When a commit is prefixed with goal, a yellow same, or work, then that indicates that rebase applied that commit but that you then reset HEAD to an earlier commit (likely to split it up into multiple commits), and that there are some uncommitted changes remaining which likely (but not necessarily) originate from that commit.
When a commit is prefixed with goal, then that indicates that it is still possible to create a new commit with the exact same tree (the "goal") without manually editing any files, by committing the index, or by staging all changes and then committing that. This is the case when the original tree still exists in the index or worktree in untainted form.
When a commit is prefixed with a yellow same, then that indicates that it is no longer possible to create a commit with the exact same tree, but that it is still possible to create a commit with the same patch-id. This would be the case if you created a new commit with other changes, but the changes from the original commit still exist in the index or working tree in untainted form.
When a commit is prefixed with work, then that indicates that you reset HEAD to an earlier commit, and that there are some staged and/or unstaged changes (likely, but not necessarily) originating from that commit. However it is no longer possible to create a new commit with the same tree or at least the same patch-id because you have already made other changes.
When a commit is prefixed with poof or gone, then that indicates that rebase applied that commit but that you then reset HEAD to an earlier commit (likely to split it up into multiple commits), and that there are no uncommitted changes.
When a commit is prefixed with poof, then that indicates that it is no longer reachable from HEAD, but that it has been replaced with one or more commits, which together have the exact same effect.
When a commit is prefixed with gone, then that indicates that it is no longer reachable from HEAD and that we also cannot determine whether its changes are still in effect in one or more new commits. They might be, but if so, then there must also be other changes which makes it impossible to know for sure.
Do not worry if you do not fully understand the above. That’s okay, you will acquire a good enough understanding through practice.

For other sequence operations such as cherry-picking, a similar section is displayed, but they lack some of the features described above, due to limitations in the git commands used to implement them. Most importantly these sequences only support "picking" a commit but not other actions such as "rewording", and they do not keep track of the commits which have already been applied.

Footnotes
(1)
The patch-id is a hash of the changes introduced by a commit. It differs from the hash of the commit itself, which is a hash of the result of applying that change (i.e., the resulting trees and blobs) as well as author and committer information, the commit message, and the hashes of the parents of the commit. The patch-id hash on the other hand is created only from the added and removed lines, even line numbers and whitespace changes are ignored when calculating this hash. The patch-ids of two commits can be used to answer the question "Do these commits make the same change?".


*** Cherry Picking

Also see the git-cherry-pick(1) manpage.

A (magit-cherry-pick)
This transient prefix command binds the following suffix commands along with the appropriate infix arguments and displays them in a temporary buffer until a suffix is invoked.

When no cherry-pick or revert is in progress, then the transient features the following suffix commands.

A A (magit-cherry-copy)
This command copies COMMITS from another branch onto the current branch. If the region selects multiple commits, then those are copied, without prompting. Otherwise the user is prompted for a commit or range, defaulting to the commit at point.

A a (magit-cherry-apply)
This command applies the changes in COMMITS from another branch onto the current branch. If the region selects multiple commits, then those are used, without prompting. Otherwise the user is prompted for a commit or range, defaulting to the commit at point.

This command also has a top-level binding, which can be invoked without using the transient by typing a at the top-level.

The following commands not only apply some commits to some branch, but also remove them from some other branch. The removal is performed using either git-update-ref or if necessary git-rebase. Both applying commits as well as removing them using git-rebase can lead to conflicts. If that happens, then these commands abort and you not only have to resolve the conflicts but also finish the process the same way you would have to if these commands didn’t exist at all.

A h (magit-cherry-harvest)
This command moves the selected COMMITS that must be located on another BRANCH onto the current branch instead, removing them from the former. When this command succeeds, then the same branch is current as before.

Applying the commits on the current branch or removing them from the other branch can lead to conflicts. When that happens, then this command stops and you have to resolve the conflicts and then finish the process manually.

A d (magit-cherry-donate)
This command moves the selected COMMITS from the current branch onto another existing BRANCH, removing them from the former. When this command succeeds, then the same branch is current as before. HEAD is allowed to be detached initially.

Applying the commits on the other branch or removing them from the current branch can lead to conflicts. When that happens, then this command stops and you have to resolve the conflicts and then finish the process manually.

A n (magit-cherry-spinout)
This command moves the selected COMMITS from the current branch onto a new branch BRANCH, removing them from the former. When this command succeeds, then the same branch is current as before.

Applying the commits on the other branch or removing them from the current branch can lead to conflicts. When that happens, then this command stops and you have to resolve the conflicts and then finish the process manually.

A s (magit-cherry-spinoff)
This command moves the selected COMMITS from the current branch onto a new branch BRANCH, removing them from the former. When this command succeeds, then the new branch is checked out.

Applying the commits on the other branch or removing them from the current branch can lead to conflicts. When that happens, then this command stops and you have to resolve the conflicts and then finish the process manually.

When a cherry-pick or revert is in progress, then the transient instead features the following suffix commands.

A A (magit-sequence-continue)
Resume the current cherry-pick or revert sequence.

A s (magit-sequence-skip)
Skip the stopped at commit during a cherry-pick or revert sequence.

A a (magit-sequence-abort)
Abort the current cherry-pick or revert sequence. This discards all changes made since the sequence started.

**** Reverting

V (magit-revert)
This transient prefix command binds the following suffix commands along with the appropriate infix arguments and displays them in a temporary buffer until a suffix is invoked.

When no cherry-pick or revert is in progress, then the transient features the following suffix commands.

V V (magit-revert-and-commit)
Revert a commit by creating a new commit. Prompt for a commit, defaulting to the commit at point. If the region selects multiple commits, then revert all of them, without prompting.

V v (magit-revert-no-commit)
Revert a commit by applying it in reverse to the working tree. Prompt for a commit, defaulting to the commit at point. If the region selects multiple commits, then revert all of them, without prompting.

When a cherry-pick or revert is in progress, then the transient instead features the following suffix commands.

V V (magit-sequence-continue)
Resume the current cherry-pick or revert sequence.

V s (magit-sequence-skip)
Skip the stopped at commit during a cherry-pick or revert sequence.

V a (magit-sequence-abort)
Abort the current cherry-pick or revert sequence. This discards all changes made since the sequence started.


*** Resetting

Also see the git-reset(1) manpage.

x (magit-reset-quickly)
Reset the HEAD and index to some commit read from the user and defaulting to the commit at point, and possibly also reset the working tree. With a prefix argument reset the working tree otherwise don’t.

X m (magit-reset-mixed)
Reset the HEAD and index to some commit read from the user and defaulting to the commit at point. The working tree is kept as-is.

X s (magit-reset-soft)
Reset the HEAD to some commit read from the user and defaulting to the commit at point. The index and the working tree are kept as-is.

X h (magit-reset-hard)
Reset the HEAD, index, and working tree to some commit read from the user and defaulting to the commit at point.

X k (magit-reset-keep)
Reset the HEAD, index, and working tree to some commit read from the user and defaulting to the commit at point. Uncommitted changes are kept as-is.

X i (magit-reset-index)
Reset the index to some commit read from the user and defaulting to the commit at point. Keep the HEAD and working tree as-is, so if the commit refers to the HEAD, then this effectively unstages all changes.

X w (magit-reset-worktree)
Reset the working tree to some commit read from the user and defaulting to the commit at point. Keep the HEAD and index as-is.

X f (magit-file-checkout)
Update file in the working tree and index to the contents from a revision. Both the revision and file are read from the user.


*** Stashing

Also see the git-stash(1) manpage.

z (magit-stash)
This transient prefix command binds the following suffix commands along with the appropriate infix arguments and displays them in a temporary buffer until a suffix is invoked.

z z (magit-stash-both)
Create a stash of the index and working tree. Untracked files are included according to infix arguments. One prefix argument is equivalent to --include-untracked while two prefix arguments are equivalent to --all.

z i (magit-stash-index)
Create a stash of the index only. Unstaged and untracked changes are not stashed.

z w (magit-stash-worktree)
Create a stash of unstaged changes in the working tree. Untracked files are included according to infix arguments. One prefix argument is equivalent to --include-untracked while two prefix arguments are equivalent to --all.

z x (magit-stash-keep-index)
Create a stash of the index and working tree, keeping index intact. Untracked files are included according to infix arguments. One prefix argument is equivalent to --include-untracked while two prefix arguments are equivalent to --all.

z Z (magit-snapshot-both)
Create a snapshot of the index and working tree. Untracked files are included according to infix arguments. One prefix argument is equivalent to --include-untracked while two prefix arguments are equivalent to --all.

z I (magit-snapshot-index)
Create a snapshot of the index only. Unstaged and untracked changes are not stashed.

z W (magit-snapshot-worktree)
Create a snapshot of unstaged changes in the working tree. Untracked files are included according to infix arguments. One prefix argument is equivalent to --include-untracked while two prefix arguments are equivalent to --all-.

z a (magit-stash-apply)
Apply a stash to the working tree.

First try git stash apply --index, which tries to preserve the index stored in the stash, if any. This may fail because applying the stash could result in conflicts and those have to be stored in the index, making it impossible to also store the stash’s index there as well.

If the above failed, then try git stash apply. This fails (with or without --index) if there are any uncommitted changes to files that are also modified in the stash.

If both of the above failed, then apply using git apply. If there are no conflicting files, use --3way. If there are conflicting files, then using --3way requires that those files are staged first, which may be undesirable, so prompt the user whether to use --3way or --reject.

Customize magit-no-confirm if you want to always use --3way, without being prompted.

z p (magit-stash-pop)
Apply a stash to the working tree. On complete success (if the stash can be applied without any conflicts, and while preserving the stash’s index) then remove the stash from stash list.

First try git stash pop --index, which tries to preserve the index stored in the stash, if any. This may fail because applying the stash could result in conflicts and those have to be stored in the index, making it impossible to also store the stash’s index there as well.

If the above failed, then try git stash apply. This fails (with or without --index) if there are any uncommitted changes to files that are also modified in the stash.

If both of the above failed, then apply using git apply. If there are no conflicting files, use --3way. If there are conflicting files, then using --3way requires that those files are staged first, which may be undesirable, so prompt the user whether to use --3way or --reject.

Customize magit-no-confirm if you want to always use --3way, without being prompted.

z k (magit-stash-drop)
Remove a stash from the stash list. When the region is active, offer to drop all contained stashes.

z v (magit-stash-show)
Show all diffs of a stash in a buffer.

z b (magit-stash-branch)
Create and checkout a new branch from an existing stash. The new branch starts at the commit that was current when the stash was created.

z B (magit-stash-branch-here)
Create and checkout a new branch from an existing stash. Use the current branch or HEAD as the starting-point of the new branch. Then apply the stash, dropping it if it applies cleanly.

z f (magit-stash-format-patch)
Create a patch from STASH.

k (magit-stash-clear)
Remove all stashes saved in REF’s reflog by deleting REF.

z l (magit-stash-list)
List all stashes in a buffer.

User Option: magit-stashes-margin
This option specifies whether the margin is initially shown in stashes buffers and how it is formatted.

The value has the form (INIT STYLE WIDTH AUTHOR AUTHOR-WIDTH).

If INIT is non-nil, then the margin is shown initially.
STYLE controls how to format the author or committer date. It can be one of age (to show the age of the commit), age-abbreviated (to abbreviate the time unit to a character), or a string (suitable for format-time-string) to show the actual date. Option magit-log-margin-show-committer-date controls which date is being displayed.
WIDTH controls the width of the margin. This exists for forward compatibility and currently the value should not be changed.
AUTHOR controls whether the name of the author is also shown by default.
AUTHOR-WIDTH has to be an integer. When the name of the author is shown, then this specifies how much space is used to do so.


** Transferring

*** Remotes

**** Remote Commands

The transient prefix command magit-remote is used to add remotes and to make changes to existing remotes. This command only deals with remotes themselves, not with branches or the transfer of commits. Those features are available from separate transient commands.

Also see the git-remote(1) manpage.

M (magit-remote)
This transient prefix command binds the following suffix commands and displays them in a temporary buffer until a suffix is invoked.

By default it also binds and displays the values of some remote-related Git variables and allows changing their values.

User Option: magit-remote-direct-configure
This option controls whether remote-related Git variables are accessible directly from the transient magit-remote.

If t (the default) and a local branch is checked out, then magit-remote features the variables for the upstream remote of that branch, or if HEAD is detached, for origin, provided that exists.

If nil, then magit-remote-configure has to be used to do so.

M C (magit-remote-configure)
This transient prefix command binds commands that set the value of remote-related variables and displays them in a temporary buffer until the transient is exited.

With a prefix argument, this command always prompts for a remote.

Without a prefix argument this depends on whether it was invoked as a suffix of magit-remote and on the magit-remote-direct-configure option. If magit-remote already displays the variables for the upstream, then it does not make sense to invoke another transient that displays them for the same remote. In that case this command prompts for a remote.

The variables are described in Remote Git Variables.

M a (magit-remote-add)
This command add a remote and fetches it. The remote name and url are read in the minibuffer.

M r (magit-remote-rename)
This command renames a remote. Both the old and the new names are read in the minibuffer.

M u (magit-remote-set-url)
This command changes the url of a remote. Both the remote and the new url are read in the minibuffer.

M k (magit-remote-remove)
This command deletes a remote, read in the minibuffer.

M p (magit-remote-prune)
This command removes stale remote-tracking branches for a remote read in the minibuffer.

M P (magit-remote-prune-refspecs)
This command removes stale refspecs for a remote read in the minibuffer.

A refspec is stale if there no longer exists at least one branch on the remote that would be fetched due to that refspec. A stale refspec is problematic because its existence causes Git to refuse to fetch according to the remaining non-stale refspecs.

If only stale refspecs remain, then this command offers to either delete the remote or to replace the stale refspecs with the default refspec ("+refs/heads/*:refs/remotes/REMOTE/*").

This command also removes the remote-tracking branches that were created due to the now stale refspecs. Other stale branches are not removed.

User Option: magit-remote-add-set-remote.pushDefault
This option controls whether the user is asked whether they want to set remote.pushDefault after adding a remote.

If ask, then users is always ask. If ask-if-unset, then the user is only if the variable isn’t set already. If nil, then the user isn’t asked and the variable isn’t set. If the value is a string, then the variable is set without the user being asked, provided that the name of the added remote is equal to that string and the variable isn’t already set.


**** Remote Git Variables

These variables can be set from the transient prefix command magit-remote-configure. By default they can also be set from magit-remote. See Remote Commands.

Variable: remote.NAME.url
This variable specifies the url of the remote named NAME. It can have multiple values.

Variable: remote.NAME.fetch
The refspec used when fetching from the remote named NAME. It can have multiple values.

Variable: remote.NAME.pushurl
This variable specifies the url used for pushing to the remote named NAME. If it is not specified, then remote.NAME.url is used instead. It can have multiple values.

Variable: remote.NAME.push
The refspec used when pushing to the remote named NAME. It can have multiple values.

Variable: remote.NAME.tagOpts
This variable specifies what tags are fetched by default. If the value is --no-tags then no tags are fetched. If the value is --tags, then all tags are fetched. If this variable has no value, then only tags are fetched that are reachable from fetched branches.


*** Fetching

Also see the git-fetch(1) manpage. For information about the upstream and the push-remote, see The Two Remotes.

f (magit-fetch)
This transient prefix command binds the following suffix commands along with the appropriate infix arguments and displays them in a temporary buffer until a suffix is invoked.

f p (magit-fetch-from-pushremote)
This command fetches from the current push-remote.

With a prefix argument or when the push-remote is either not configured or unusable, then let the user first configure the push-remote.

f u (magit-fetch-from-upstream)
This command fetch from the upstream of the current branch.

If the upstream is configured for the current branch and names an existing remote, then use that. Otherwise try to use another remote: If only a single remote is configured, then use that. Otherwise if a remote named "origin" exists, then use that.

If no remote can be determined, then this command is not available from the magit-fetch transient prefix and invoking it directly results in an error.

f e (magit-fetch-other)
This command fetch from a repository read from the minibuffer.

f o (magit-fetch-branch)
This command fetches a branch from a remote, both of which are read from the minibuffer.

f r (magit-fetch-refspec)
This command fetches from a remote using an explicit refspec, both of which are read from the minibuffer.

f a (magit-fetch-all)
This command fetches from all remotes.

f m (magit-fetch-modules)
This command fetches all submodules. With a prefix argument, it acts as a transient prefix command, allowing the caller to set options.

User Option: magit-pull-or-fetch
By default fetch and pull commands are available from separate transient prefix command. Setting this to t adds some (but not all) of the above suffix commands to the magit-pull transient.

If you do that, then you might also want to change the key binding for these prefix commands, e.g.:

(setq magit-pull-or-fetch t)
(define-key magit-mode-map "f" 'magit-pull) ; was magit-fetch
(define-key magit-mode-map "F" nil)         ; was magit-pull


*** Pulling

Also see the git-pull(1) manpage. For information about the upstream and the push-remote, see The Two Remotes.

F (magit-pull)
This transient prefix command binds the following suffix commands and displays them in a temporary buffer until a suffix is invoked.

F p (magit-pull-from-pushremote)
This command pulls from the push-remote of the current branch.

With a prefix argument or when the push-remote is either not configured or unusable, then let the user first configure the push-remote.

F u (magit-pull-from-upstream)
This command pulls from the upstream of the current branch.

With a prefix argument or when the upstream is either not configured or unusable, then let the user first configure the upstream.

F e (magit-pull-branch)
This command pulls from a branch read in the minibuffer.


*** Pushing

Also see the git-push(1) manpage. For information about the upstream and the push-remote, see The Two Remotes.

P (magit-push)
This transient prefix command binds the following suffix commands along with the appropriate infix arguments and displays them in a temporary buffer until a suffix is invoked.

P p (magit-push-current-to-pushremote)
This command pushes the current branch to its push-remote.

With a prefix argument or when the push-remote is either not configured or unusable, then let the user first configure the push-remote.

P u (magit-push-current-to-upstream)
This command pushes the current branch to its upstream branch.

With a prefix argument or when the upstream is either not configured or unusable, then let the user first configure the upstream.

P e (magit-push-current)
This command pushes the current branch to a branch read in the minibuffer.

P o (magit-push-other)
This command pushes an arbitrary branch or commit somewhere. Both the source and the target are read in the minibuffer.

P r (magit-push-refspecs)
This command pushes one or multiple refspecs to a remote, both of which are read in the minibuffer.

To use multiple refspecs, separate them with commas. Completion is only available for the part before the colon, or when no colon is used.

P m (magit-push-matching)
This command pushes all matching branches to another repository.

If only one remote exists, then push to that. Otherwise prompt for a remote, offering the remote configured for the current branch as default.

P t (magit-push-tags)
This command pushes all tags to another repository.

If only one remote exists, then push to that. Otherwise prompt for a remote, offering the remote configured for the current branch as default.

P T (magit-push-tag)
This command pushes a tag to another repository.

One of the infix arguments, --force-with-lease, deserves a word of caution. It is passed without a value, which means "permit a force push as long as the remote-tracking branches match their counterparts on the remote end". If you’ve set up a tool to do automatic fetches (Magit itself does not provide such functionality), using --force-with-lease can be dangerous because you don’t actually control or know the state of the remote-tracking refs. In that case, you should consider setting push.useForceIfIncludes to true (available since Git 2.30).

Two more push commands exist, which by default are not available from the push transient. See their doc-strings for instructions on how to add them to the transient.

Command: magit-push-implicitly args
This command pushes somewhere without using an explicit refspec.

This command simply runs git push -v [ARGS]. ARGS are the infix arguments. No explicit refspec arguments are used. Instead the behavior depends on at least these Git variables: push.default, remote.pushDefault, branch.<branch>.pushRemote, branch.<branch>.remote, branch.<branch>.merge, and remote.<remote>.push.

If you add this suffix to a transient prefix without explicitly specifying the description, then an attempt is made to predict what this command will do. For example:

(transient-insert-suffix 'magit-push \"p\"
  '(\"i\" magit-push-implicitly))"
Command: magit-push-to-remote remote args
This command pushes to the remote REMOTE without using an explicit refspec. The remote is read in the minibuffer.

This command simply runs git push -v [ARGS] REMOTE. ARGS are the infix arguments. No refspec arguments are used. Instead the behavior depends on at least these Git variables: push.default, remote.pushDefault, branch.<branch>.pushRemote, branch.<branch>.remote, branch.<branch>.merge, and remote.<remote>.push.


*** Plain Patches

W (magit-patch)
This transient prefix command binds the following suffix commands along with the appropriate infix arguments and displays them in a temporary buffer until a suffix is invoked.

W c (magit-patch-create)
This command creates patches for a set commits. If the region marks several commits, then it creates patches for all of them. Otherwise it functions as a transient prefix command, which features several infix arguments and binds itself as a suffix command. When this command is invoked as a suffix of itself, then it creates a patch using the specified infix arguments.

w a (magit-patch-apply)
This command applies a patch. This is a transient prefix command, which features several infix arguments and binds itself as a suffix command. When this command is invoked as a suffix of itself, then it applies a patch using the specified infix arguments.

W s (magit-patch-save)
This command creates a patch from the current diff.

Inside magit-diff-mode or magit-revision-mode buffers, C-x C-w is also bound to this command.

It is also possible to save a plain patch file by using C-x C-w inside a magit-diff-mode or magit-revision-mode buffer.


*** Maildir Patches

Also see the git-am(1) manpage. and the git-apply(1) manpage.

w (magit-am)
This transient prefix command binds the following suffix commands along with the appropriate infix arguments and displays them in a temporary buffer until a suffix is invoked.

w w (magit-am-apply-patches)
This command applies one or more patches. If the region marks files, then those are applied as patches. Otherwise this command reads a file-name in the minibuffer, defaulting to the file at point.

w m (magit-am-apply-maildir)
This command applies patches from a maildir.

w a (magit-patch-apply)
This command applies a plain patch. For a longer description see Plain Patches. This command is only available from the magit-am transient for historic reasons.

When an "am" operation is in progress, then the transient instead features the following suffix commands.

w w (magit-am-continue)
This command resumes the current patch applying sequence.

w s (magit-am-skip)
This command skips the stopped at patch during a patch applying sequence.

w a (magit-am-abort)
This command aborts the current patch applying sequence. This discards all changes made since the sequence started.


** Miscellaneous

*** Tagging

Also see the git-tag(1) manpage.

t (magit-tag)
This transient prefix command binds the following suffix commands along with the appropriate infix arguments and displays them in a temporary buffer until a suffix is invoked.

t t (magit-tag-create)
This command creates a new tag with the given NAME at REV. With a prefix argument it creates an annotated tag.

t r (magit-tag-release)
This commands creates a release tag. It assumes that release tags match magit-release-tag-regexp.

First it prompts for the name of the new tag using the highest existing tag as initial input and leaving it to the user to increment the desired part of the version string. If you use unconventional release tags or version numbers (e.g., v1.2.3-custom.1), you can set the magit-release-tag-regexp and magit-tag-version-regexp-alist variables.

If --annotate is enabled then it prompts for the message of the new tag. The proposed tag message is based on the message of the highest tag, provided that that contains the corresponding version string and substituting the new version string for that. Otherwise it proposes something like "Foo-Bar 1.2.3", given, for example, a TAG "v1.2.3" and a repository located at something like "/path/to/foo-bar".

t k (magit-tag-delete)
This command deletes one or more tags. If the region marks multiple tags (and nothing else), then it offers to delete those. Otherwise, it prompts for a single tag to be deleted, defaulting to the tag at point.

t p (magit-tag-prune)
This command offers to delete tags missing locally from REMOTE, and vice versa.


*** Notes

Also see the git-notes(1) manpage.

T (magit-notes)
This transient prefix command binds the following suffix commands along with the appropriate infix arguments and displays them in a temporary buffer until a suffix is invoked.

T T (magit-notes-edit)
Edit the note attached to a commit, defaulting to the commit at point.

By default use the value of Git variable core.notesRef or "refs/notes/commits" if that is undefined.

T r (magit-notes-remove)
Remove the note attached to a commit, defaulting to the commit at point.

By default use the value of Git variable core.notesRef or "refs/notes/commits" if that is undefined.

T p (magit-notes-prune)
Remove notes about unreachable commits.

It is possible to merge one note ref into another. That may result in conflicts which have to resolved in the temporary worktree ".git/NOTES_MERGE_WORKTREE".

T m (magit-notes-merge)
Merge the notes of a ref read from the user into the current notes ref. The current notes ref is the value of Git variable core.notesRef or "refs/notes/commits" if that is undefined.

When a notes merge is in progress then the transient features the following suffix commands, instead of those listed above.

T c (magit-notes-merge-commit)
Commit the current notes ref merge, after manually resolving conflicts.

T a (magit-notes-merge-abort)
Abort the current notes ref merge.

The following variables control what notes reference magit-notes-*, git notes and git show act on and display. Both the local and global values are displayed and can be modified.

Variable: core.notesRef
This variable specifies the notes ref that is displayed by default and which commands act on by default.

Variable: notes.displayRef
This variable specifies additional notes ref to be displayed in addition to the ref specified by core.notesRef. It can have multiple values and may end with * to display all refs in the refs/notes/ namespace (or ** if some names contain slashes).


*** Submodules

Also see the git-submodule(1) manpage

**** Listing Submodules

The command magit-list-submodules displays a list of the current repository’s submodules in a separate buffer. It’s also possible to display information about submodules directly in the status buffer of the super-repository by adding magit-insert-modules to the hook magit-status-sections-hook as described in Status Module Sections.

Command: magit-list-submodules
This command displays a list of the current repository’s populated submodules in a separate buffer.

It can be invoked by pressing RET on the section titled "Modules".

User Option: magit-submodule-list-columns
This option controls what columns are displayed by the command magit-list-submodules and how they are displayed.

Each element has the form (HEADER WIDTH FORMAT PROPS).

HEADER is the string displayed in the header. WIDTH is the width of the column. FORMAT is a function that is called with one argument, the repository identification (usually its basename), and with default-directory bound to the toplevel of its working tree. It has to return a string to be inserted or nil. PROPS is an alist that supports the keys :right-align, :pad-right and :sort.

The :sort function has a weird interface described in the docstring of tabulated-list--get-sort. Alternatively < and magit-repolist-version< can be used as those functions are automatically replaced with functions that satisfy the interface. Set :sort to nil to inhibit sorting; if unspecified, then the column is sortable using the default sorter.

You may wish to display a range of numeric columns using just one character per column and without any padding between columns, in which case you should use an appropriate HEADER, set WIDTH to 1, and set :pad-right to 9. + is substituted for numbers higher than 9.


**** Submodule Transient

o (magit-submodule)
This transient prefix command binds the following suffix commands along with the appropriate infix arguments and displays them in a temporary buffer until a suffix is invoked.

Some of the below commands default to act on the modules that are selected using the region. For brevity their description talk about "the selected modules", but if no modules are selected, then they act on the current module instead, or if point isn’t on a module, then the read a single module to act on. With a prefix argument these commands ignore the selection and the current module and instead act on all suitable modules.

o a (magit-submodule-add)
This commands adds the repository at URL as a module. Optional PATH is the path to the module relative to the root of the super-project. If it is nil then the path is determined based on URL.

o r (magit-submodule-register)
This command registers the selected modules by copying their urls from ".gitmodules" to "$GIT_DIR/config". These values can then be edited before running magit-submodule-populate. If you don’t need to edit any urls, then use the latter directly.

o p (magit-submodule-populate)
This command creates the working directory or directories of the selected modules, checking out the recorded commits.

o u (magit-submodule-update)
This command updates the selected modules checking out the recorded commits.

o s (magit-submodule-synchronize)
This command synchronizes the urls of the selected modules, copying the values from ".gitmodules" to the ".git/config" of the super-project as well those of the modules.

o d (magit-submodule-unpopulate)
This command removes the working directory of the selected modules.

o l (magit-list-submodules)
This command displays a list of the current repository’s modules.

o f (magit-fetch-modules)
This command fetches all populated modules. With a prefix argument, it acts as a transient prefix command, allowing the caller to set options.

Also fetch the super-repository, because git fetch does not support not doing that.


*** Subtree

Also see the git-subtree(1) manpage.

O (magit-subtree)
This transient prefix command binds the two sub-transients; one for importing a subtree and one for exporting a subtree.

O i (magit-subtree-import)
This transient prefix command binds the following suffix commands along with the appropriate infix arguments and displays them in a temporary buffer until a suffix is invoked.

The suffixes of this command import subtrees.

If the --prefix argument is set, then the suffix commands use that prefix without prompting the user. If it is unset, then they read the prefix in the minibuffer.

O i a (magit-subtree-add)
This command adds COMMIT from REPOSITORY as a new subtree at PREFIX.

O i c (magit-subtree-add-commit)
This command add COMMIT as a new subtree at PREFIX.

O i m (magit-subtree-merge)
This command merges COMMIT into the PREFIX subtree.

O i f (magit-subtree-pull)
This command pulls COMMIT from REPOSITORY into the PREFIX subtree.

O e (magit-subtree-export)
This transient prefix command binds the following suffix commands along with the appropriate infix arguments and displays them in a temporary buffer until a suffix is invoked.

The suffixes of this command export subtrees.

If the --prefix argument is set, then the suffix commands use that prefix without prompting the user. If it is unset, then they read the prefix in the minibuffer.

O e p (magit-subtree-push)
This command extract the history of the subtree PREFIX and pushes it to REF on REPOSITORY.

O e s (magit-subtree-split)
This command extracts the history of the subtree PREFIX.


*** Worktree

Also see the git-worktree(1) manpage.

Z (magit-worktree)
This transient prefix command binds the following suffix commands and displays them in a temporary buffer until a suffix is invoked.

Z b (magit-worktree-checkout)
Checkout BRANCH in a new worktree at PATH.

Z c (magit-worktree-branch)
Create a new BRANCH and check it out in a new worktree at PATH.

Z m (magit-worktree-move)
Move an existing worktree to a new PATH.

Z k (magit-worktree-delete)
Delete a worktree, defaulting to the worktree at point. The primary worktree cannot be deleted.

Z g (magit-worktree-status)
Show the status for the worktree at point.

If there is no worktree at point, then read one in the minibuffer. If the worktree at point is the one whose status is already being displayed in the current buffer, then show it in Dired instead.


*** Sparse checkouts

Sparse checkouts provide a way to restrict the working tree to a subset of directories. See the git-sparse-checkout(1) manpage.

Warning: Git introduced the git sparse-checkout command in version 2.25 and still advertises it as experimental and subject to change. Magit’s interface should be considered the same. In particular, if Git introduces a backward incompatible change, Magit’s sparse checkout functionality may be updated in a way that requires a more recent Git version.

> (magit-sparse-checkout)
This transient prefix command binds the following suffix commands and displays them in a temporary buffer until a suffix is invoked.

> e (magit-sparse-checkout-enable)
This command initializes a sparse checkout that includes only the files in the top-level directory.

Note that magit-sparse-checkout-set and magit-sparse-checkout-add automatically initialize a sparse checkout if necessary. However, you may want to call magit-sparse-checkout-enable explicitly to re-initialize a sparse checkout after calling magit-sparse-checkout-disable, to pass additional arguments to git sparse-checkout init, or to execute the initialization asynchronously.

> s (magit-sparse-checkout-set)
This command takes a list of directories and configures the sparse checkout to include only files in those subdirectories. Any previously included directories are excluded unless they are in the provided list of directories.

> a (magit-sparse-checkout-add)
This command is like magit-sparse-checkout-set, but instead adds the specified list of directories to the set of directories that is already included in the sparse checkout.

> r (magit-sparse-checkout-reapply)
This command applies the currently configured sparse checkout patterns to the working tree. This is useful to call if excluded files have been checked out after operations such as merging or rebasing.

> d (magit-sparse-checkout-disable)
This command restores the full checkout. To return to the previous sparse checkout, call magit-sparse-checkout-enable.

A sparse checkout can also be initiated when cloning a repository by using the magit-clone-sparse command in the magit-clone transient (see Cloning Repository).

If you want the status buffer to indicate when a sparse checkout is enabled, add the function magit-sparse-checkout-insert-header to magit-status-headers-hook.


*** Bundle

Also see the git-bundle(1) manpage.

Command: magit-bundle
This transient prefix command binds several suffix commands for running git bundle subcommands and displays them in a temporary buffer until a suffix is invoked.


*** Common Commands

Command: magit-switch-to-repository-buffer
Command: magit-switch-to-repository-buffer-other-window
Command: magit-switch-to-repository-buffer-other-frame
Command: magit-display-repository-buffer
These commands read any existing Magit buffer that belongs to the current repository from the user and then switch to the selected buffer (without refreshing it).

The last variant uses magit-display-buffer to do so and thus respects magit-display-buffer-function.

These are some of the commands that can be used in all buffers whose major-modes derive from magit-mode. There are other common commands beside the ones below, but these didn’t fit well anywhere else.

C-w (magit-copy-section-value)
This command saves the value of the current section to the kill-ring, and, provided that the current section is a commit, branch, or tag section, it also pushes the (referenced) revision to the magit-revision-stack.

When the current section is a branch or a tag, and a prefix argument is used, then it saves the revision at its tip to the kill-ring instead of the reference name.

When the region is active, this command saves that to the kill-ring, like kill-ring-save would, instead of behaving as described above. If a prefix argument is used and the region is within a hunk, then it strips the diff marker column and keeps only either the added or removed lines, depending on the sign of the prefix argument.

M-w (magit-copy-buffer-revision)
This command saves the revision being displayed in the current buffer to the kill-ring and also pushes it to the magit-revision-stack. It is mainly intended for use in magit-revision-mode buffers, the only buffers where it is always unambiguous exactly which revision should be saved.

Most other Magit buffers usually show more than one revision, in some way or another, so this command has to select one of them, and that choice might not always be the one you think would have been the best pick.

Outside of Magit M-w and C-w are usually bound to kill-ring-save and kill-region, and these commands would also be useful in Magit buffers. Therefore when the region is active, then both of these commands behave like kill-ring-save instead of as described above.


*** Wip Modes

Git keeps committed changes around long enough for users to recover changes they have accidentally deleted. It does so by not garbage collecting any committed but no longer referenced objects for a certain period of time, by default 30 days.

But Git does not keep track of uncommitted changes in the working tree and not even the index (the staging area). Because Magit makes it so convenient to modify uncommitted changes, it also makes it easy to shoot yourself in the foot in the process.

For that reason Magit provides a global mode that saves tracked files to work-in-progress references after or before certain actions. (At present untracked files are never saved and for technical reasons nothing is saved before the first commit has been created).

Two separate work-in-progress references are used to track the state of the index and of the working tree: refs/wip/index/<branchref> and refs/wip/wtree/<branchref>, where <branchref> is the full ref of the current branch, e.g., refs/heads/master. When the HEAD is detached then HEAD is used in place of <branchref>.

Checking out another branch (or detaching HEAD) causes the use of different wip refs for subsequent changes.

User Option: magit-wip-mode
When this mode is enabled, then uncommitted changes are committed to dedicated work-in-progress refs whenever appropriate (i.e., when dataloss would be a possibility otherwise).

Setting this variable directly does not take effect; either use the Custom interface to do so or call the respective mode function.

For historic reasons this mode is implemented on top of four other magit-wip-* modes, which can also be used individually, if you want finer control over when the wip refs are updated; but that is discouraged. See Legacy Wip Modes.

To view the log for a branch and its wip refs use the commands magit-wip-log and magit-wip-log-current. You should use --graph when using these commands.

Command: magit-wip-log
This command shows the log for a branch and its wip refs. With a negative prefix argument only the worktree wip ref is shown.

The absolute numeric value of the prefix argument controls how many "branches" of each wip ref are shown. This is only relevant if the value of magit-wip-merge-branch is nil.

Command: magit-wip-log-current
This command shows the log for the current branch and its wip refs. With a negative prefix argument only the worktree wip ref is shown.

The absolute numeric value of the prefix argument controls how many "branches" of each wip ref are shown. This is only relevant if the value of magit-wip-merge-branch is nil.

X w (magit-reset-worktree)
This command resets the working tree to some commit read from the user and defaulting to the commit at point, while keeping the HEAD and index as-is.

This can be used to restore files to the state committed to a wip ref. Note that this will discard any unstaged changes that might have existed before invoking this command (but of course only after committing that to the working tree wip ref).

Note that even if you enable magit-wip-mode this won’t give you perfect protection. The most likely scenario for losing changes despite the use of magit-wip-mode is making a change outside Emacs and then destroying it also outside Emacs. In some such a scenario, Magit, being an Emacs package, didn’t get the opportunity to keep you from shooting yourself in the foot.

When you are unsure whether Magit did commit a change to the wip refs, then you can explicitly request that all changes to all tracked files are being committed.

M-x magit-wip-commit
This command commits all changes to all tracked files to the index and working tree work-in-progress refs. Like the modes described above, it does not commit untracked files, but it does check all tracked files for changes. Use this command when you suspect that the modes might have overlooked a change made outside Emacs/Magit.

User Option: magit-wip-namespace
The namespace used for work-in-progress refs. It has to end with a slash. The wip refs are named <namespace>index/<branchref> and <namespace>wtree/<branchref>. When snapshots are created while the HEAD is detached then HEAD is used in place of <branchref>.

User Option: magit-wip-mode-lighter
Mode-line lighter for magit-wip--mode.

**** Wip Graph

User Option: magit-wip-merge-branch
This option controls whether the current branch is merged into the wip refs after a new commit was created on the branch.

If non-nil and the current branch has new commits, then it is merged into the wip ref before creating a new wip commit. This makes it easier to inspect wip history and the wip commits are never garbage collected.

If nil and the current branch has new commits, then the wip ref is reset to the tip of the branch before creating a new wip commit. With this setting wip commits are eventually garbage collected.

When magit-wip-merge-branch is t, then the history looks like this:

  *--*--*--*--*--*       refs/wip/index/refs/heads/master
 /     /     /
A-----B-----C            refs/heads/master
When magit-wip-merge-branch is nil, then creating a commit on the real branch and then making a change causes the wip refs to be recreated to fork from the new commit. But the old commits on the wip refs are not lost. They are still available from the reflog. To make it easier to see when the fork point of a wip ref was changed, an additional commit with the message "restart autosaving" is created on it (xxO commits below are such boundary commits).

Starting with

      BI0---BI1    refs/wip/index/refs/heads/master
     /
A---B              refs/heads/master
     \
      BW0---BW1    refs/wip/wtree/refs/heads/master
and committing the staged changes and editing and saving a file would result in

      BI0---BI1        refs/wip/index/refs/heads/master
     /
A---B---C              refs/heads/master
     \   \
      \   CW0---CW1    refs/wip/wtree/refs/heads/master
       \
        BW0---BW1      refs/wip/wtree/refs/heads/master@{2}
The fork-point of the index wip ref is not changed until some change is being staged. Likewise just checking out a branch or creating a commit does not change the fork-point of the working tree wip ref. The fork-points are not adjusted until there actually is a change that should be committed to the respective wip ref.


**** Legacy Wip Modes

It is recommended that you use the mode magit-wip-mode (which see) and ignore the existence of the following modes, which are preserved for historic reasons.

Setting the following variables directly does not take effect; either use the Custom interface to do so or call the respective mode functions.

User Option: magit-wip-after-save-mode
When this mode is enabled, then saving a buffer that visits a file tracked in a Git repository causes its current state to be committed to the working tree wip ref for the current branch.

User Option: magit-wip-after-apply-mode
When this mode is enabled, then applying (i.e., staging, unstaging, discarding, reversing, and regularly applying) a change to a file tracked in a Git repository causes its current state to be committed to the index and/or working tree wip refs for the current branch.

If you only ever edit files using Emacs and only ever interact with Git using Magit, then the above two modes should be enough to protect each and every change from accidental loss. In practice nobody does that. Two additional modes exists that do commit to the wip refs before making changes that could cause the loss of earlier changes.

User Option: magit-wip-before-change-mode
When this mode is enabled, then certain commands commit the existing changes to the files they are about to make changes to.

User Option: magit-wip-initial-backup-mode
When this mode is enabled, then the current version of a file is committed to the worktree wip ref before the buffer visiting that file is saved for the first time since the buffer was created.

This backs up the same version of the file that backup-buffer would save. While backup-buffer uses a backup file, this mode uses the same worktree wip ref as used by the other Magit Wip modes. Like backup-buffer, it only does this once; unless you kill the buffer and visit the file again only one backup will be created per Emacs session.

This mode ignores the variables that affect backup-buffer and can be used along-side that function, which is recommended because it only backs up files that are tracked in a Git repository.

User Option: magit-wip-after-save-local-mode-lighter
Mode-line lighter for magit-wip-after-save-local-mode.

User Option: magit-wip-after-apply-mode-lighter
Mode-line lighter for magit-wip-after-apply-mode.

User Option: magit-wip-before-change-mode-lighter
Mode-line lighter for magit-wip-before-change-mode.

User Option: magit-wip-initial-backup-mode-lighter
Mode-line lighter for magit-wip-initial-backup-mode.


*** Commands for Buffers Visiting Files

By default Magit defines a few global key bindings. These bindings are a compromise between providing no bindings at all and providing the better bindings I would have liked to use instead. Magit cannot provide the set of recommended bindings by default because those key sequences are strictly reserved for bindings added by the user. Also see Global Bindings and (elisp)Key Binding Conventions.

To use the recommended bindings, add this to your init file and restart Emacs.

(setq magit-define-global-key-bindings 'recommended)
If you don’t want Magit to add any bindings to the global keymap at all, add this to your init file and restart Emacs.

(setq magit-define-global-key-bindings nil)
C-c f (magit-file-dispatch)
C-c f s (magit-stage-file)
C-c f s (magit-stage-buffer-file)
C-c f u (magit-unstage-file)
C-c f u (magit-unstage-buffer-file)
C-c f , x (magit-file-untrack)
C-c f , r (magit-file-rename)
C-c f , k (magit-file-delete)
C-c f , c (magit-file-checkout)
C-c f D (magit-diff)
C-c f d (magit-diff-buffer-file)
C-c f L (magit-log)
C-c f l (magit-log-buffer-file)
C-c f t (magit-log-trace-definition)
C-c f M (magit-log-merged)
C-c f B (magit-blame)
C-c f b (magit-blame-additions)
C-c f r (magit-blame-removal)
C-c f f (magit-blame-reverse)
C-c f m (magit-blame-echo)
C-c f q (magit-blame-quit)
C-c f p (magit-blob-previous)
C-c f n (magit-blob-next)
C-c f v (magit-find-file)
C-c f V (magit-blob-visit-file)
C-c f g (magit-status-here)
C-c f G (magit-display-repository-buffer)
C-c f c (magit-commit)
C-c f e (magit-edit-line-commit)
Each of these commands is documented individually right below, alongside their default key bindings. The bindings shown above are the recommended bindings, which you can enable by following the instructions further up.

C-c M-g (magit-file-dispatch)
This transient prefix command binds the following suffix commands and displays them in a temporary buffer until a suffix is invoked.

C-c M-g s (magit-stage-file)
C-c M-g s (magit-stage-buffer-file)
Stage all changes to the file being visited in the current buffer. When not visiting a file, then the first command is used, which prompts for a file.

C-c M-g u (magit-unstage-file)
C-c M-g u (magit-unstage-buffer-file)
Unstage all changes to the file being visited in the current buffer. When not visiting a file, then the first command is used, which prompts for a file.

C-c M-g , x (magit-file-untrack)
This command untracks a file read from the user, defaulting to the visited file.

C-c M-g , r (magit-file-rename)
This command renames a file read from the user, defaulting to the visited file.

C-c M-g , k (magit-file-delete)
This command deletes a file read from the user, defaulting to the visited file.

C-c M-g , c (magit-file-checkout)
This command updates a file in the working tree and index to the contents from a revision. Both the revision and file are read from the user.

C-c M-g D (magit-diff)
This transient prefix command binds several diff suffix commands and infix arguments and displays them in a temporary buffer until a suffix is invoked. See Diffing.

This is the same command that d is bound to in Magit buffers. If this command is invoked from a file-visiting buffer, then the initial value of the option (--) that limits the diff to certain file(s) is set to the visited file.

C-c M-g d (magit-diff-buffer-file)
This command shows the diff for the file of blob that the current buffer visits.

User Option: magit-diff-buffer-file-locked
This option controls whether magit-diff-buffer-file uses a dedicated buffer. See Modes and Buffers.

C-c M-g L (magit-log)
This transient prefix command binds several log suffix commands and infix arguments and displays them in a temporary buffer until a suffix is invoked. See Logging.

This is the same command that l is bound to in Magit buffers. If this command is invoked from a file-visiting buffer, then the initial value of the option (--) that limits the log to certain file(s) is set to the visited file.

C-c M-g l (magit-log-buffer-file)
This command shows the log for the file of blob that the current buffer visits. Renames are followed when a prefix argument is used or when --follow is an active log argument. When the region is active, the log is restricted to the selected line range.

User Option: magit-log-buffer-file-locked
This option controls whether magit-log-buffer-file uses a dedicated buffer. See Modes and Buffers.

C-c M-g t (magit-log-trace-definition)
This command shows the log for the definition at point.

C-c M-g M (magit-log-merged)
This command reads a commit and a branch in shows a log concerning the merge of the former into the latter. This shows multiple commits even in case of a fast-forward merge.

C-c M-g B (magit-blame)
This transient prefix command binds all blaming suffix commands along with the appropriate infix arguments and displays them in a temporary buffer until a suffix is invoked.

For more information about this and the following commands also see Blaming.

In addition to the magit-blame sub-transient, the dispatch transient also binds several blaming suffix commands directly. See Blaming for information about those commands and bindings.

C-c M-g p (magit-blob-previous)
This command visits the previous blob which modified the current file.

C-c M-g n (magit-blob-next)
This command visits the next blob which modified the current file.

C-c M-g v (magit-find-file)
This command reads a revision and file and visits the respective blob.

C-c M-g V (magit-blob-visit-file)
This command visits the file from the working tree, corresponding to the current blob. When visiting a blob or the version from the index, then it goes to the same location in the respective file in the working tree.

C-c M-g g (magit-status-here)
This command displays the status of the current repository in a buffer, like magit-status does. Additionally it tries to go to the position in that buffer, which corresponds to the position in the current file-visiting buffer (if any).

C-c M-g G (magit-display-repository-buffer)
This command reads and displays a Magit buffer belonging to the current repository, without refreshing it.

C-c M-g c (magit-commit)
This transient prefix command binds the following suffix commands along with the appropriate infix arguments and displays them in a temporary buffer until a suffix is invoked. See Initiating a Commit.

C-c M-g e (magit-edit-line-commit)
This command makes the commit editable that added the current line.

With a prefix argument it makes the commit editable that removes the line, if any. The commit is determined using git blame and made editable using git rebase --interactive if it is reachable from HEAD, or by checking out the commit (or a branch that points at it) otherwise.


*** Minor Mode for Buffers Visiting Blobs

The magit-blob-mode enables certain Magit features in blob-visiting buffers. Such buffers can be created using magit-find-file and some of the commands mentioned below, which also take care of turning on this minor mode. Currently this mode only establishes a few key bindings, but this might be extended.

p (magit-blob-previous)
Visit the previous blob which modified the current file.

n (magit-blob-next)
Visit the next blob which modified the current file.

q (magit-kill-this-buffer)
Kill the current buffer.


** Customizing

Both Git and Emacs are highly customizable. Magit is both a Git porcelain as well as an Emacs package, so it makes sense to customize it using both Git variables as well as Emacs options. However this flexibility doesn’t come without problems, including but not limited to the following.

Some Git variables automatically have an effect in Magit without requiring any explicit support. Sometimes that is desirable - in other cases, it breaks Magit.
When a certain Git setting breaks Magit but you want to keep using that setting on the command line, then that can be accomplished by overriding the value for Magit only by appending something like ("-c" "some.variable=compatible-value") to magit-git-global-arguments.

Certain settings like fetch.prune=true are respected by Magit commands (because they simply call the respective Git command) but their value is not reflected in the respective transient buffers. In this case the --prune argument in magit-fetch might be active or inactive, but that doesn’t keep the Git variable from being honored by the suffix commands anyway. So pruning might happen despite the --prune arguments being displayed in a way that seems to indicate that no pruning will happen.
I intend to address these and similar issues in a future release.

**** Per-Repository Configuration

Magit can be configured on a per-repository level using both Git variables as well as Emacs options.

To set a Git variable for one repository only, simply set it in /path/to/repo/.git/config instead of $HOME/.gitconfig or /etc/gitconfig. See the git-config(1) manpage.

Similarly, Emacs options can be set for one repository only by editing /path/to/repo/.dir-locals.el. See (emacs)Directory Variables. For example to disable automatic refreshes of file-visiting buffers in just one huge repository use this:

/path/to/huge/repo/.dir-locals.el
((nil . ((magit-refresh-buffers . nil))))
It might only be costly to insert certain information into Magit buffers for repositories that are exceptionally large, in which case you can disable the respective section inserters just for that repository:

/path/to/tag/invested/repo/.dir-locals.el
((magit-status-mode
  . ((eval . (magit-disable-section-inserter 'magit-insert-tags-header)))))
Function: magit-disable-section-inserter fn
This function disables the section inserter FN in the current repository. It is only intended for use in .dir-locals.el and .dir-locals-2.el.

If you want to apply the same settings to several, but not all, repositories then keeping the repository-local config files in sync would quickly become annoying. To avoid that you can create config files for certain classes of repositories (e.g., "huge repositories") and then include those files in the per-repository config files. For example:

/path/to/huge/repo/.git/config
[include]
        path = /path/to/huge-gitconfig
/path/to/huge-gitconfig
[status]
        showUntrackedFiles = no
$HOME/.emacs.d/init.el
(dir-locals-set-class-variables 'huge-git-repository
   '((nil . ((magit-refresh-buffers . nil)))))

(dir-locals-set-directory-class
   "/path/to/huge/repo/" 'huge-git-repository)


**** Essential Settings

The next three sections list and discuss several variables that many users might want to customize, for safety and/or performance reasons.

***** Safety

This section discusses various variables that you might want to change (or not change) for safety reasons.

Git keeps committed changes around long enough for users to recover changes they have accidentally been deleted. It does not do the same for uncommitted changes in the working tree and not even the index (the staging area). Because Magit makes it so easy to modify uncommitted changes, it also makes it easy to shoot yourself in the foot in the process. For that reason Magit provides three global modes that save tracked files to work-in-progress references after or before certain actions. See Wip Modes.

These modes are not enabled by default because of performance concerns. Instead a lot of potentially destructive commands require confirmation every time they are used. In many cases this can be disabled by adding a symbol to magit-no-confirm (see Completion and Confirmation). If you enable the various wip modes then you should add safe-with-wip to this list.

Similarly it isn’t necessary to require confirmation before moving a file to the system trash - if you trashed a file by mistake then you can recover it from there. Option magit-delete-by-moving-to-trash controls whether the system trash is used, which is the case by default. Nevertheless, trash isn’t a member of magit-no-confirm - you might want to change that.

By default buffers visiting files are automatically reverted when the visited file changes on disk. This isn’t as risky as it might seem, but to make an informed decision you should see Risk of Reverting Automatically.


***** Performance

After Magit has run git for side-effects, it also refreshes the current Magit buffer and the respective status buffer. This is necessary because otherwise outdated information might be displayed without the user noticing. Magit buffers are updated by recreating their content from scratch, which makes updating simpler and less error-prone, but also more costly. Keeping it simple and just re-creating everything from scratch is an old design decision and departing from that will require major refactoring.

Meanwhile you can tell Magit to only automatically refresh the current Magit buffer, but not the status buffer. If you do that, then the status buffer is only refreshed automatically if it is the current buffer.

(setq magit-refresh-status-buffer nil)
You should also check whether any third-party packages have added anything to magit-refresh-buffer-hook, magit-pre-refresh-hook, and magit-post-refresh-hook. If so, then check whether those additions impact performance significantly.

Magit can be told to refresh buffers verbosely using M-x magit-toggle-verbose-refresh. Enabling this helps figuring out which sections are bottlenecks. Each line printed to the *Messages* buffer contains a section name, the number of seconds it took to show this section, and from 0 to 2 exclamation marks: the more exclamation marks the slower the section is.

Magit also reverts buffers for visited files located inside the current repository when the visited file changes on disk. That is implemented on top of auto-revert-mode from the built-in library autorevert. To figure out whether that impacts performance, check whether performance is significantly worse, when many buffers exist and/or when some buffers visit files using TRAMP. If so, then this should help.

(setq auto-revert-buffer-list-filter
      'magit-auto-revert-repository-buffer-p)
For alternative approaches see Automatic Reverting of File-Visiting Buffers.

If you have enabled any features that are disabled by default, then you should check whether they impact performance significantly. It’s likely that they were not enabled by default because it is known that they reduce performance at least in large repositories.

If performance is only slow inside certain unusually large repositories, then you might want to disable certain features on a per-repository or per-repository-class basis only. See Per-Repository Configuration. For example it takes a long time to determine the next and current tag in repository with exceptional numbers of tags. It would therefore be a good idea to disable magit-insert-tags-headers, as explained at the mentioned node.

Log Performance
When showing logs, Magit limits the number of commits initially shown in the hope that this avoids unnecessary work. When --graph is used, then this unfortunately does not have the desired effect for large histories. Junio, Git’s maintainer, said on the Git mailing list (https://www.spinics.net/lists/git/msg232230.html): "--graph wants to compute the whole history and the max-count only affects the output phase after --graph does its computation".

In other words, it’s not that Git is slow at outputting the differences, or that Magit is slow at parsing the output - the problem is that Git first goes outside and has a smoke.

We actually work around this issue by limiting the number of commits not only by using -<N> but by also using a range. But unfortunately that’s not always possible.

When more than a few thousand commits are shown, then the use of --graph can slow things down.

Using --color --graph is even slower. Magit uses code that is part of Emacs to turn control characters into faces. That code is pretty slow and this is quite noticeable when showing a log with many branches and merges. For that reason --color is not enabled by default anymore. Consider leaving it at that.

Diff Performance
If diffs are slow, then consider turning off some optional diff features by setting all or some of the following variables to nil: magit-diff-highlight-indentation, magit-diff-highlight-trailing, magit-diff-paint-whitespace, magit-diff-highlight-hunk-body, and magit-diff-refine-hunk.

When showing a commit instead of some arbitrary diff, then some additional information is displayed. Calculating this information can be quite expensive given certain circumstances. If looking at a commit using magit-revision-mode takes considerably more time than looking at the same commit in magit-diff-mode, then consider setting magit-revision-insert-related-refs to nil.

When you are often confronted with diffs that contain deleted files, then you might want to enable the --irreversible-delete argument. If you do that then diffs still show that a file was deleted but without also showing the complete deleted content of the file. This argument is not available by default, see (transient)Enabling and Disabling Suffixes. Once you have done that you should enable it and save that setting, see (transient)Saving Values. You should do this in both the diff (d) and the diff refresh (D) transient popups.

Refs Buffer Performance
When refreshing the "references buffer" is slow, then that’s usually because several hundred refs are being displayed. The best way to address that is to display fewer refs, obviously.

If you are not, or only mildly, interested in seeing the list of tags, then start by not displaying them:

(remove-hook 'magit-refs-sections-hook 'magit-insert-tags)
Then you should also make sure that the listed remote branches actually all exist. You can do so by pruning branches which no longer exist using f-pa.

Committing Performance
When you initiate a commit, then Magit by default automatically shows a diff of the changes you are about to commit. For large commits this can take a long time, which is especially distracting when you are committing large amounts of generated data which you don’t actually intend to inspect before committing. This behavior can be turned off using:

(remove-hook 'server-switch-hook 'magit-commit-diff)
(remove-hook 'with-editor-filter-visit-hook 'magit-commit-diff)
Then you can type C-c C-d to show the diff when you actually want to see it, but only then. Alternatively you can leave the hook alone and just type C-g in those cases when it takes too long to generate the diff. If you do that, then you will end up with a broken diff buffer, but doing it this way has the advantage that you usually get to see the diff, which is useful because it increases the odds that you spot potential issues.


****** Microsoft Windows Performance

In order to update the status buffer, git has to be run a few dozen times. That is problematic on Microsoft Windows, because that operating system is exceptionally slow at starting processes. Sadly this is an issue that can only be fixed by Microsoft itself, and they don’t appear to be particularly interested in doing so.

Beside the subprocess issue, there are also other Windows-specific performance issues. Some of these have workarounds. The maintainers of "Git for Windows" try to improve performance on Windows. Always use the latest release in order to benefit from the latest performance tweaks. Magit too tries to work around some Windows-specific issues.

According to some sources, setting the following Git variables can also help.

git config --global core.preloadindex true   # default since v2.1
git config --global core.fscache true        # default since v2.8
git config --global gc.auto 256
You should also check whether an anti-virus program is affecting performance.


****** MacOS Performance

Before Emacs 26.1 child processes were created using fork on macOS. That needlessly copied GUI resources, which is expensive. The result was that forking took about 30 times as long on Darwin than on Linux, and because Magit starts many git processes that made quite a difference.

So make sure that you are using at least Emacs 26.1, in which case the faster vfork will be used. (The creation of child processes still takes about twice as long on Darwin compared to Linux.) See 2 for more information.

Additionally, git installed from a package manager like brew or nix seems to be slower than the native executable. Profile the git executable you’re running against the one at /usr/bin/git, and if you notice a notable difference try using the latter as magit-git-executable.

Footnotes
(2)
https://lists.gnu.org/archive/html/bug-gnu-emacs/2017-04/msg00201.html


**** Global Bindings

User Option: magit-define-global-key-bindings
This option controls which set of Magit key bindings, if any, may be added to the global keymap, even before Magit is first used in the current Emacs session.

If the value is nil, no bindings are added.
If default, maybe add:
C-x g	magit-status
C-x M-g	magit-dispatch
C-c M-g	magit-file-dispatch
If recommended, maybe add:
C-x g	magit-status
C-c g	magit-dispatch
C-c f	magit-file-dispatch
These bindings are strongly recommended, but we cannot use them by default, because the C-c <LETTER> namespace is strictly reserved for bindings added by the user (see (elisp)Key Binding Conventions).

The bindings in the chosen set may be added when after-init-hook is run. Each binding is added if, and only if, at that time no other key is bound to the same command, and no other command is bound to the same key. In other words we try to avoid adding bindings that are unnecessary, as well as bindings that conflict with other bindings.

Adding these bindings is delayed until after-init-hook is run to allow users to set the variable anywhere in their init file (without having to make sure to do so before magit is loaded or autoloaded) and to increase the likelihood that all the potentially conflicting user bindings have already been added.

To set this variable use either setq or the Custom interface. Do not use the function customize-set-variable because doing that would cause Magit to be loaded immediately, when that form is evaluated (this differs from custom-set-variables, which doesn’t load the libraries that define the customized variables).

Setting this variable has no effect if after-init-hook has already been run.


** Plumbing

The following sections describe how to use several of Magit’s core abstractions to extend Magit itself or implement a separate extension.

A few of the low-level features used by Magit have been factored out into separate libraries/packages, so that they can be used by other packages, without having to depend on Magit. See (with-editor)Top for information about with-editor. transient doesn’t have a manual yet.

If you are trying to find an unused key that you can bind to a command provided by your own Magit extension, then checkout https://github.com/magit/magit/wiki/Plugin-Dispatch-Key-Registry.

*** Calling Git

Magit provides many specialized functions for calling Git. All of these functions are defined in either magit-git.el or magit-process.el and have one of the prefixes magit-run-, magit-call-, magit-start-, or magit-git- (which is also used for other things).

All of these functions accept an indefinite number of arguments, which are strings that specify command line arguments for Git (or in some cases an arbitrary executable). These arguments are flattened before being passed on to the executable; so instead of strings they can also be lists of strings and arguments that are nil are silently dropped. Some of these functions also require a single mandatory argument before these command line arguments.

Roughly speaking, these functions run Git either to get some value or for side-effects. The functions that return a value are useful to collect the information necessary to populate a Magit buffer, while the others are used to implement Magit commands.

The functions in the value-only group always run synchronously, and they never trigger a refresh. The function in the side-effect group can be further divided into subgroups depending on whether they run Git synchronously or asynchronously, and depending on whether they trigger a refresh when the executable has finished.

**** Getting a Value from Git

These functions run Git in order to get a value, an exit status, or output. Of course you could also use them to run Git commands that have side-effects, but that should be avoided.

Function: magit-git-exit-code &rest args
Executes git with ARGS and returns its exit code.

Function: magit-git-success &rest args
Executes git with ARGS and returns t if the exit code is 0, nil otherwise.

Function: magit-git-failure &rest args
Executes git with ARGS and returns t if the exit code is 1, nil otherwise.

Function: magit-git-true &rest args
Executes git with ARGS and returns t if the first line printed by git is the string "true", nil otherwise.

Function: magit-git-false &rest args
Executes git with ARGS and returns t if the first line printed by git is the string "false", nil otherwise.

Function: magit-git-insert &rest args
Executes git with ARGS and inserts its output at point.

Function: magit-git-string &rest args
Executes git with ARGS and returns the first line of its output. If there is no output or if it begins with a newline character, then this returns nil.

Function: magit-git-lines &rest args
Executes git with ARGS and returns its output as a list of lines. Empty lines anywhere in the output are omitted.

Function: magit-git-items &rest args
Executes git with ARGS and returns its null-separated output as a list. Empty items anywhere in the output are omitted.

If the value of option magit-git-debug is non-nil and git exits with a non-zero exit status, then warn about that in the echo area and add a section containing git’s standard error in the current repository’s process buffer.

Function: magit-process-git destination &rest args
Calls Git synchronously in a separate process, returning its exit code. DESTINATION specifies how to handle the output, like for call-process, except that file handlers are supported. Enables Cygwin’s "noglob" option during the call and ensures unix eol conversion.

Function: magit-process-file process &optional infile buffer display &rest args
Processes files synchronously in a separate process. Identical to process-file but temporarily enables Cygwin’s "noglob" option during the call and ensures unix eol conversion.

If an error occurs when using one of the above functions, then that is usually due to a bug, i.e., using an argument which is not actually supported. Such errors are usually not reported, but when they occur we need to be able to debug them.

User Option: magit-git-debug
Whether to report errors that occur when using magit-git-insert, magit-git-string, magit-git-lines, or magit-git-items. This does not actually raise an error. Instead a message is shown in the echo area, and git’s standard error is insert into a new section in the current repository’s process buffer.

Function: magit-git-str &rest args
This is a variant of magit-git-string that ignores the option magit-git-debug. It is mainly intended to be used while handling errors in functions that do respect that option. Using such a function while handing an error could cause yet another error and therefore lead to an infinite recursion. You probably won’t ever need to use this function.


**** Calling Git for Effect

These functions are used to run git to produce some effect. Most Magit commands that actually run git do so by using such a function.

Because we do not need to consume git’s output when using these functions, their output is instead logged into a per-repository buffer, which can be shown using $ from a Magit buffer or M-x magit-process elsewhere.

These functions can have an effect in two distinct ways. Firstly, running git may change something, i.e., create or push a new commit. Secondly, that change may require that Magit buffers are refreshed to reflect the changed state of the repository. But refreshing isn’t always desirable, so only some of these functions do perform such a refresh after git has returned.

Sometimes it is useful to run git asynchronously. For example, when the user has just initiated a push, then there is no reason to make her wait until that has completed. In other cases it makes sense to wait for git to complete before letting the user do something else. For example after staging a change it is useful to wait until after the refresh because that also automatically moves to the next change.

Function: magit-call-git &rest args
Calls git synchronously with ARGS.

Function: magit-call-process program &rest args
Calls PROGRAM synchronously with ARGS.

Function: magit-run-git &rest args
Calls git synchronously with ARGS and then refreshes.

Function: magit-run-git-with-input &rest args
Calls git synchronously with ARGS and sends it the content of the current buffer on standard input.

If the current buffer’s default-directory is on a remote filesystem, this function actually runs git asynchronously. But then it waits for the process to return, so the function itself is synchronous.

Function: magit-git &rest args
Calls git synchronously with ARGS for side-effects only. This function does not refresh the buffer.

Function: magit-git-wash washer &rest args
Execute Git with ARGS, inserting washed output at point. Actually first insert the raw output at point. If there is no output call magit-cancel-section. Otherwise temporarily narrow the buffer to the inserted text, move to its beginning, and then call function WASHER with ARGS as its sole argument.

And now for the asynchronous variants.

Function: magit-run-git-async &rest args
Start Git, prepare for refresh, and return the process object. ARGS is flattened and then used as arguments to Git.

Display the command line arguments in the echo area.

After Git returns some buffers are refreshed: the buffer that was current when this function was called (if it is a Magit buffer and still alive), as well as the respective Magit status buffer. Unmodified buffers visiting files that are tracked in the current repository are reverted if magit-revert-buffers is non-nil.

Function: magit-run-git-with-editor &rest args
Export GIT_EDITOR and start Git. Also prepare for refresh and return the process object. ARGS is flattened and then used as arguments to Git.

Display the command line arguments in the echo area.

After Git returns some buffers are refreshed: the buffer that was current when this function was called (if it is a Magit buffer and still alive), as well as the respective Magit status buffer.

Function: magit-start-git input &rest args
Start Git, prepare for refresh, and return the process object.

If INPUT is non-nil, it has to be a buffer or the name of an existing buffer. The buffer content becomes the processes standard input.

Option magit-git-executable specifies the Git executable and option magit-git-global-arguments specifies constant arguments. The remaining arguments ARGS specify arguments to Git. They are flattened before use.

After Git returns, some buffers are refreshed: the buffer that was current when this function was called (if it is a Magit buffer and still alive), as well as the respective Magit status buffer. Unmodified buffers visiting files that are tracked in the current repository are reverted if magit-revert-buffers is non-nil.

Function: magit-start-process &rest args
Start PROGRAM, prepare for refresh, and return the process object.

If optional argument INPUT is non-nil, it has to be a buffer or the name of an existing buffer. The buffer content becomes the processes standard input.

The process is started using start-file-process and then setup to use the sentinel magit-process-sentinel and the filter magit-process-filter. Information required by these functions is stored in the process object. When this function returns the process has not started to run yet so it is possible to override the sentinel and filter.

After the process returns, magit-process-sentinel refreshes the buffer that was current when magit-start-process was called (if it is a Magit buffer and still alive), as well as the respective Magit status buffer. Unmodified buffers visiting files that are tracked in the current repository are reverted if magit-revert-buffers is non-nil.

Variable: magit-this-process
The child process which is about to start. This can be used to change the filter and sentinel.

Variable: magit-process-raise-error
When this is non-nil, then magit-process-sentinel raises an error if git exits with a non-zero exit status. For debugging purposes.


*** Section Plumbing

**** Creating Sections

Macro: magit-insert-section &rest args
Insert a section at point.

TYPE is the section type, a symbol. Many commands that act on the current section behave differently depending on that type. Also if a variable magit-TYPE-section-map exists, then use that as the text-property keymap of all text belonging to the section (but this may be overwritten in subsections). TYPE can also have the form (eval FORM) in which case FORM is evaluated at runtime.

Optional VALUE is the value of the section, usually a string that is required when acting on the section.

When optional HIDE is non-nil collapse the section body by default, i.e., when first creating the section, but not when refreshing the buffer. Otherwise, expand it by default. This can be overwritten using magit-section-set-visibility-hook. When a section is recreated during a refresh, then the visibility of predecessor is inherited and HIDE is ignored (but the hook is still honored).

BODY is any number of forms that actually insert the section’s heading and body. Optional NAME, if specified, has to be a symbol, which is then bound to the struct of the section being inserted.

Before BODY is evaluated the start of the section object is set to the value of point and after BODY was evaluated its end is set to the new value of point; BODY is responsible for moving point forward.

If it turns out inside BODY that the section is empty, then magit-cancel-section can be used to abort and remove all traces of the partially inserted section. This can happen when creating a section by washing Git’s output and Git didn’t actually output anything this time around.

Function: magit-insert-heading &rest args
Insert the heading for the section currently being inserted.

This function should only be used inside magit-insert-section.

When called without any arguments, then just set the content slot of the object representing the section being inserted to a marker at point. The section should only contain a single line when this function is used like this.

When called with arguments ARGS, which have to be strings, then insert those strings at point. The section should not contain any text before this happens and afterwards it should again only contain a single line. If the face property is set anywhere inside any of these strings, then insert all of them unchanged. Otherwise use the magit-section-heading face for all inserted text.

The content property of the section struct is the end of the heading (which lasts from start to content) and the beginning of the body (which lasts from content to end). If the value of content is nil, then the section has no heading and its body cannot be collapsed. If a section does have a heading then its height must be exactly one line, including a trailing newline character. This isn’t enforced; you are responsible for getting it right. The only exception is that this function does insert a newline character if necessary.

Function: magit-cancel-section
Cancel the section currently being inserted. This exits the innermost call to magit-insert-section and removes all traces of what has already happened inside that call.

Function: magit-define-section-jumper sym title &optional value
Define an interactive function to go to section SYM. TITLE is the displayed title of the section.


**** Section Selection

Function: magit-current-section
Return the section at point.

Function: magit-region-sections &optional condition multiple
Return a list of the selected sections.

When the region is active and constitutes a valid section selection, then return a list of all selected sections. This is the case when the region begins in the heading of a section and ends in the heading of the same section or in that of a sibling section. If optional MULTIPLE is non-nil, then the region cannot begin and end in the same section.

When the selection is not valid, then return nil. In this case, most commands that can act on the selected sections will instead act on the section at point.

When the region looks like it would in any other buffer then the selection is invalid. When the selection is valid then the region uses the magit-section-highlight face. This does not apply to diffs where things get a bit more complicated, but even here if the region looks like it usually does, then that’s not a valid selection as far as this function is concerned.

If optional CONDITION is non-nil, then the selection not only has to be valid; all selected sections additionally have to match CONDITION, or nil is returned. See magit-section-match for the forms CONDITION can take.

Function: magit-region-values &optional condition multiple
Return a list of the values of the selected sections.

Return the values that themselves would be returned by magit-region-sections (which see).


**** Matching Sections

M-x magit-describe-section-briefly
Show information about the section at point. This command is intended for debugging purposes.

Function: magit-section-ident section
Return an unique identifier for SECTION. The return value has the form ((TYPE . VALUE)...).

Function: magit-get-section ident &optional root
Return the section identified by IDENT. IDENT has to be a list as returned by magit-section-ident.

Function: magit-section-match condition &optional section
Return t if SECTION matches CONDITION. SECTION defaults to the section at point. If SECTION is not specified and there also is no section at point, then return nil.

CONDITION can take the following forms:

(CONDITION...)
matches if any of the CONDITIONs matches.

[CLASS...]
matches if the section’s class is the same as the first CLASS or a subclass of that; the section’s parent class matches the second CLASS; and so on.

[* CLASS...]
matches sections that match [CLASS...] and also recursively all their child sections.

CLASS
matches if the section’s class is the same as CLASS or a subclass of that; regardless of the classes of the parent sections.

Each CLASS should be a class symbol, identifying a class that derives from magit-section. For backward compatibility CLASS can also be a "type symbol". A section matches such a symbol if the value of its type slot is eq. If a type symbol has an entry in magit--section-type-alist, then a section also matches that type if its class is a subclass of the class that corresponds to the type as per that alist.

Note that it is not necessary to specify the complete section lineage as printed by magit-describe-section-briefly, unless of course you want to be that precise.

Function: magit-section-value-if condition &optional section
If the section at point matches CONDITION, then return its value.

If optional SECTION is non-nil then test whether that matches instead. If there is no section at point and SECTION is nil, then return nil. If the section does not match, then return nil.

See magit-section-match for the forms CONDITION can take.

Function: magit-section-case &rest clauses
Choose among clauses on the type of the section at point.

Each clause looks like (CONDITION BODY…). The type of the section is compared against each CONDITION; the BODY forms of the first match are evaluated sequentially and the value of the last form is returned. Inside BODY the symbol it is bound to the section at point. If no clause succeeds or if there is no section at point return nil.

See magit-section-match for the forms CONDITION can take. Additionally a CONDITION of t is allowed in the final clause and matches if no other CONDITION match, even if there is no section at point.

Variable: magit-root-section
The root section in the current buffer. All other sections are descendants of this section. The value of this variable is set by magit-insert-section and you should never modify it.

For diff related sections a few additional tools exist.

Function: magit-diff-type &optional section
Return the diff type of SECTION.

The returned type is one of the symbols staged, unstaged, committed, or undefined. This type serves a similar purpose as the general type common to all sections (which is stored in the type slot of the corresponding magit-section struct) but takes additional information into account. When the SECTION isn’t related to diffs and the buffer containing it also isn’t a diff-only buffer, then return nil.

Currently the type can also be one of tracked and untracked, but these values are not handled explicitly in every place they should be. A possible fix could be to just return nil here.

The section has to be a diff or hunk section, or a section whose children are of type diff. If optional SECTION is nil, return the diff type for the current section. In buffers whose major mode is magit-diff-mode SECTION is ignored and the type is determined using other means. In magit-revision-mode buffers the type is always committed.

Function: magit-diff-scope &optional section strict
Return the diff scope of SECTION or the selected section(s).

A diff’s "scope" describes what part of a diff is selected, it is a symbol, one of region, hunk, hunks, file, files, or list. Do not confuse this with the diff "type", as returned by magit-diff-type.

If optional SECTION is non-nil, then return the scope of that, ignoring the sections selected by the region. Otherwise return the scope of the current section, or if the region is active and selects a valid group of diff related sections, the type of these sections, i.e., hunks or files. If SECTION (or if the current section that is nil) is a hunk section and the region starts and ends inside the body of a that section, then the type is region.

If optional STRICT is non-nil then return nil if the diff type of the section at point is untracked or the section at point is not actually a diff but a diffstat section.


*** Refreshing Buffers

All commands that create a new Magit buffer or change what is being displayed in an existing buffer do so by calling magit-mode-setup. Among other things, that function sets the buffer local values of default-directory (to the top-level of the repository), magit-refresh-function, and magit-refresh-args.

Buffers are refreshed by calling the function that is the local value of magit-refresh-function (a function named magit-*-refresh-buffer, where * may be something like diff) with the value of magit-refresh-args as arguments.

Macro: magit-mode-setup buffer switch-func mode refresh-func &optional refresh-args
This function displays and selects BUFFER, turns on MODE, and refreshes a first time.

This function displays and optionally selects BUFFER by calling magit-mode-display-buffer with BUFFER, MODE and SWITCH-FUNC as arguments. Then it sets the local value of magit-refresh-function to REFRESH-FUNC and that of magit-refresh-args to REFRESH-ARGS. Finally it creates the buffer content by calling REFRESH-FUNC with REFRESH-ARGS as arguments.

All arguments are evaluated before switching to BUFFER.

Function: magit-mode-display-buffer buffer mode &optional switch-function
This function display BUFFER in some window and select it. BUFFER may be a buffer or a string, the name of a buffer. The buffer is returned.

Unless BUFFER is already displayed in the selected frame, store the previous window configuration as a buffer local value, so that it can later be restored by magit-mode-bury-buffer.

The buffer is displayed and selected using SWITCH-FUNCTION. If that is nil then pop-to-buffer is used if the current buffer’s major mode derives from magit-mode. Otherwise switch-to-buffer is used.

Variable: magit-refresh-function
The value of this buffer-local variable is the function used to refresh the current buffer. It is called with magit-refresh-args as arguments.

Variable: magit-refresh-args
The list of arguments used by magit-refresh-function to refresh the current buffer. magit-refresh-function is called with these arguments.

The value is usually set using magit-mode-setup, but in some cases it’s also useful to provide commands that can change the value. For example, the magit-diff-refresh transient can be used to change any of the arguments used to display the diff, without having to specify again which differences should be shown, but magit-diff-more-context, magit-diff-less-context and magit-diff-default-context change just the -U<N> argument. In both case this is done by changing the value of this variable and then calling this magit-refresh-function.


*** Conventions

Also see Completion and Confirmation.

**** Theming Faces

The default theme uses blue for local branches, green for remote branches, and goldenrod (brownish yellow) for tags. When creating a new theme, you should probably follow that example. If your theme already uses other colors, then stick to that.

In older releases these reference faces used to have a background color and a box around them. The basic default faces no longer do so, to make Magit buffers much less noisy, and you should follow that example at least with regards to boxes. (Boxes were used in the past to work around a conflict between the highlighting overlay and text property backgrounds. That’s no longer necessary because highlighting no longer causes other background colors to disappear.) Alternatively you can keep the background color and/or box, but then have to take special care to adjust magit-branch-current accordingly. By default it looks mostly like magit-branch-local, but with a box (by default the former is the only face that uses a box, exactly so that it sticks out). If the former also uses a box, then you have to make sure that it differs in some other way from the latter.

The most difficult faces to theme are those related to diffs, headings, highlighting, and the region. There are faces that fall into all four groups - expect to spend some time getting this right.

The region face in the default theme, in both the light and dark variants, as well as in many other themes, distributed with Emacs or by third-parties, is very ugly. It is common to use a background color that really sticks out, which is ugly but if that were the only problem then it would be acceptable. Unfortunately many themes also set the foreground color, which ensures that all text within the region is readable. Without doing that there might be cases where some foreground color is too close to the region background color to still be readable. But it also means that text within the region loses all syntax highlighting.

I consider the work that went into getting the region face right to be a good indicator for the general quality of a theme. My recommendation for the region face is this: use a background color slightly different from the background color of the default face, and do not set the foreground color at all. So for a light theme you might use a light (possibly tinted) gray as the background color of default and a somewhat darker gray for the background of region. That should usually be enough to not collide with the foreground color of any other face. But if some other faces also set a light gray as background color, then you should also make sure it doesn’t collide with those (in some cases it might be acceptable though).

Magit only uses the region face when the region is "invalid" by its own definition. In a Magit buffer the region is used to either select multiple sibling sections, so that commands which support it act on all of these sections instead of just the current section, or to select lines within a single hunk section. In all other cases, the section is considered invalid and Magit won’t act on it. But such invalid sections happen, either because the user has not moved point enough yet to make it valid or because she wants to use a non-magit command to act on the region, e.g., kill-region.

So using the regular region face for invalid sections is a feature. It tells the user that Magit won’t be able to act on it. It’s acceptable if that face looks a bit odd and even (but less so) if it collides with the background colors of section headings and other things that have a background color.

Magit highlights the current section. If a section has subsections, then all of them are highlighted. This is done using faces that have "highlight" in their names. For most sections, magit-section-highlight is used for both the body and the heading. Like the region face, it should only set the background color to something similar to that of default. The highlight background color must be different from both the region background color and the default background color.

For diff related sections Magit uses various faces to highlight different parts of the selected section(s). Note that hunk headings, unlike all other section headings, by default have a background color, because it is useful to have very visible separators between hunks. That face magit-diff-hunk-heading, should be different from both magit-diff-hunk-heading-highlight and magit-section-highlight, as well as from magit-diff-context and magit-diff-context-highlight. By default we do that by changing the foreground color. Changing the background color would lead to complications, and there are already enough we cannot get around. (Also note that it is generally a good idea for section headings to always be bold, but only for sections that have subsections).

When there is a valid region selecting diff-related sibling sections, i.e., multiple files or hunks, then the bodies of all these sections use the respective highlight faces, but additionally the headings instead use one of the faces magit-diff-file-heading-selection or magit-diff-hunk-heading-selection. These faces have to be different from the regular highlight variants to provide explicit visual indication that the region is active.

When theming diff related faces, start by setting the option magit-diff-refine-hunk to all. You might personally prefer to only refine the current hunk or not use hunk refinement at all, but some of the users of your theme want all hunks to be refined, so you have to cater to that.

(Also turn on magit-diff-highlight-indentation, magit-diff-highlight-trailing, and magit-diff-paint-whitespace; and insert some whitespace errors into the code you use for testing.)

For added lines you have to adjust three faces: magit-diff-added, magit-diff-added-highlight, and diff-refined-added. Make sure that the latter works well with both of the former, as well as smerge-other and diff-added. Then do the same for the removed lines, context lines, lines added by us, and lines added by them. Also make sure the respective added, removed, and context faces use approximately the same saturation for both the highlighted and unhighlighted variants. Also make sure the file and diff headings work nicely with context lines (e.g., make them look different). Line faces should set both the foreground and the background color. For example, for added lines use two different greens.

It’s best if the foreground color of both the highlighted and the unhighlighted variants are the same, so you will need to have to find a color that works well on the highlight and unhighlighted background, the refine background, and the highlight context background. When there is an hunk internal region, then the added- and removed-lines background color is used only within that region. Outside the region the highlighted context background color is used. This makes it easier to see what is being staged. With an hunk internal region the hunk heading is shown using magit-diff-hunk-heading-selection, and so are the thin lines that are added around the lines that fall within the region. The background color of that has to be distinct enough from the various other involved background colors.

Nobody said this would be easy. If your theme restricts itself to a certain set of colors, then you should make an exception here. Otherwise it would be impossible to make the diffs look good in each and every variation. Actually you might want to just stick to the default definitions for these faces. You have been warned. Also please note that if you do not get this right, this will in some cases look to users like bugs in Magit - so please do it right or not at all.


** How to show git’s output?

To show the output of recently run git commands, press $ (or, if that isn’t available, M-x magit-process-buffer). This will show a buffer containing a section per git invocation; as always press TAB to expand or collapse them.

By default, git’s output is only inserted into the process buffer if it is run for side-effects. When the output is consumed in some way, also inserting it into the process buffer would be too expensive. For debugging purposes, it’s possible to do so anyway by setting magit-git-debug to t.


** Debugging Tools

Magit and its dependencies provide a few debugging tools, and we appreciate it very much if you use those tools before reporting an issue. Please include all relevant output when reporting an issue.

M-x magit-version
This command shows the currently used versions of Magit, Git, and Emacs in the echo area. Non-interactively this just returns the Magit version.

M-x magit-emacs-Q-command
This command shows a debugging shell command in the echo area and adds it to the kill ring. Paste that command into a shell and run it.

This shell command starts emacs with only magit and its dependencies loaded. Neither your configuration nor other installed packages are loaded. This makes it easier to determine whether some issue lays with Magit or something else.

If you run Magit from its Git repository, then you should be able to use make emacs-Q instead of the output of this command.

M-x magit-toggle-git-debug
This command toggles whether additional git errors are reported.

Magit basically calls git for one of these two reasons: for side-effects or to do something with its standard output.

When git is run for side-effects then its output, including error messages, go into the process buffer which is shown when using $.

When git’s output is consumed in some way, then it would be too expensive to also insert it into this buffer, but when this option is non-nil and git returns with a non-zero exit status, then at least its standard error is inserted into this buffer.

This is only intended for debugging purposes. Do not enable this permanently, that would negatively affect performance. Also note that just because git exits with a non-zero exit status and prints an error message that usually doesn’t mean that it is an error as far as Magit is concerned, which is another reason we usually hide these error messages. Whether some error message is relevant in the context of some unexpected behavior has to be judged on a case by case basis.

M-x magit-toggle-verbose-refresh
This command toggles whether Magit refreshes buffers verbosely. Enabling this helps figuring out which sections are bottlenecks. The additional output can be found in the *Messages* buffer.

M-x magit-debug-git-executable
This command displays a buffer containing information about the available and used git executable(s), and can be useful when investigating exec-path issues.

Also see Git Executable.

M-x with-editor-debug
This command displays a buffer containing information about the available and used emacsclient executable(s), and can be useful when investigating why Magit (or rather with-editor) cannot find an appropriate emacsclient executable.

Also see (with-editor)Debugging.

Please also see FAQ.





* Emacs Calculator

Calc is an advanced desk calculator and mathematical tool written by Dave Gillespie that runs as part of the GNU Emacs environment.

** Getting Started

This chapter provides a general overview of Calc, the GNU Emacs Calculator: What it is, how to start it and how to exit from it, and what are the various ways that it can be used.

*** What is Calc?

Calc is an advanced calculator and mathematical tool that runs as part of the GNU Emacs environment. Very roughly based on the HP-28/48 series of calculators, its many features include:

Choice of algebraic or Reverse Polish notation (RPN), i.e. stack-based, entry of calculations.
Arbitrary precision integers and floating-point numbers.
Arithmetic on rational numbers, complex numbers (rectangular and polar), error forms with standard deviations, open and closed intervals, vectors and matrices, dates and times, infinities, sets, quantities with units, and algebraic formulas.
Mathematical operations such as logarithms and trigonometric functions.
Programmer’s features (bitwise operations, non-decimal numbers).
Financial functions such as future value and internal rate of return.
Number theoretical features such as prime factorization and arithmetic modulo m for any m.
Algebraic manipulation features, including symbolic calculus.
Moving data to and from regular editing buffers.
Embedded mode for manipulating Calc formulas and data directly inside any editing buffer.
Graphics using GNUPLOT, a versatile (and free) plotting program.
Easy programming using keyboard macros, algebraic formulas, algebraic rewrite rules, or extended Emacs Lisp.
Calc tries to include a little something for everyone; as a result it is large and might be intimidating to the first-time user. If you plan to use Calc only as a traditional desk calculator, all you really need to read is the “Getting Started” chapter of this manual and possibly the first few sections of the tutorial. As you become more comfortable with the program you can learn its additional features. Calc does not have the scope and depth of a fully-functional symbolic math package, but Calc has the advantages of convenience, portability, and freedom.


*** About This Manual

This document serves as a complete description of the GNU Emacs Calculator. It works both as an introduction for novices and as a reference for experienced users. While it helps to have some experience with GNU Emacs in order to get the most out of Calc, this manual ought to be readable even if you don’t know or use Emacs regularly.

This manual is divided into three major parts: the “Getting Started” chapter you are reading now, the Calc tutorial, and the Calc reference manual.

If you are in a hurry to use Calc, there is a brief “demonstration” below which illustrates the major features of Calc in just a couple of pages. If you don’t have time to go through the full tutorial, this will show you everything you need to know to begin. See A Demonstration of Calc.

The tutorial chapter walks you through the various parts of Calc with lots of hands-on examples and explanations. If you are new to Calc and you have some time, try going through at least the beginning of the tutorial. The tutorial includes about 70 exercises with answers. These exercises give you some guided practice with Calc, as well as pointing out some interesting and unusual ways to use its features.

The reference section discusses Calc in complete depth. You can read the reference from start to finish if you want to learn every aspect of Calc. Or, you can look in the table of contents or the Concept Index to find the parts of the manual that discuss the things you need to know.

Every Calc keyboard command is listed in the Calc Summary, and also in the Key Index. Algebraic functions, M-x commands, and variables also have their own indices.

You can access this manual on-line at any time within Calc by pressing the h i key sequence. Outside of the Calc window, you can press C-x * i to read the manual on-line. From within Calc the command h t will jump directly to the Tutorial; from outside of Calc the command C-x * t will jump to the Tutorial and start Calc if necessary. Pressing h s or C-x * s will take you directly to the Calc Summary. Within Calc, you can also go to the part of the manual describing any Calc key, function, or variable using h k, h f, or h v, respectively. See Help Commands.

The Calc manual can be printed, but because the manual is so large, you should only make a printed copy if you really need it. To print the manual, you will need the TeX typesetting program (this is a free program by Donald Knuth at Stanford University) as well as the texindex program and texinfo.tex file, both of which can be obtained from the FSF as part of the texinfo package. To print the Calc manual in one huge tome, you will need the Emacs source, which contains the source code to this manual, calc.texi. Change to the doc/misc subdirectory of the Emacs source distribution, which contains source code for this manual, and type make calc.pdf. (Don’t worry if you get some “overfull box” warnings while TeX runs.) The result will be this entire manual as a pdf file.


*** Notations Used in This Manual

This section describes the various notations that are used throughout the Calc manual.

In keystroke sequences, uppercase letters mean you must hold down the shift key while typing the letter. Keys pressed with Control held down are shown as C-x. Keys pressed with Meta held down are shown as M-x. Other notations are RET for the Return key, SPC for the space bar, TAB for the Tab key, DEL for the Delete key, and LFD for the Line-Feed key. The DEL key is called Backspace on some keyboards, it is whatever key you would use to correct a simple typing error when regularly using Emacs.

(If you don’t have the LFD or TAB keys on your keyboard, the C-j and C-i keys are equivalent to them, respectively. If you don’t have a Meta key, look for Alt or Extend Char. You can also press ESC or C-[ first to get the same effect, so that M-x, ESC x, and C-[ x are all equivalent.)

Sometimes the RET key is not shown when it is “obvious” that you must press RET to proceed. For example, the RET is usually omitted in key sequences like M-x calc-keypad RET.

Commands are generally shown like this: p (calc-precision) or C-x * k (calc-keypad). This means that the command is normally used by pressing the p key or C-x * k key sequence, but it also has the full-name equivalent shown, e.g., M-x calc-precision.

Commands that correspond to functions in algebraic notation are written: C (calc-cos) [cos]. This means the C key is equivalent to M-x calc-cos, and that the corresponding function in an algebraic-style formula would be ‘cos(x)’.

A few commands don’t have key equivalents: calc-sincos [sincos].


*** A Demonstration of Calc

This section will show some typical small problems being solved with Calc. The focus is more on demonstration than explanation, but everything you see here will be covered more thoroughly in the Tutorial.

To begin, start Emacs if necessary (usually the command emacs does this), and type C-x * c to start the Calculator. (You can also use M-x calc if this doesn’t work. See Starting Calc, for various ways of starting the Calculator.)

Be sure to type all the sample input exactly, especially noting the difference between lower-case and upper-case letters. Remember, RET, TAB, DEL, and SPC are the Return, Tab, Delete, and Space keys.

RPN calculation. In Reverse Polish notation (RPN), you type the input number(s) first, then the command to operate on the numbers.

Type 2 RET 3 + Q to compute the square root of 2+3, which is 2.2360679775.

Type P 2 ^ to compute the value of ‘pi’ squared, 9.86960440109.

Type TAB to exchange the order of these two results.

Type - I H S to subtract these results and compute the Inverse Hyperbolic sine of the difference, 2.72996136574.

Type DEL to erase this result.

Algebraic calculation. You can also enter calculations using conventional “algebraic” notation. To enter an algebraic formula, use the apostrophe key.

Type ' sqrt(2+3) RET to compute the square root of 2+3.

Type ' pi^2 RET to enter ‘pi’ squared. To evaluate this symbolic formula as a number, type =.

Type ' arcsinh($ - $$) RET to subtract the second-most-recent result from the most-recent and compute the Inverse Hyperbolic sine.

Keypad mode. If you are using the X window system, press C-x * k to get Keypad mode. (If you don’t use X, skip to the next section.)

Click on the 2, ENTER, 3, +, and SQRT “buttons” using your left mouse button.

Click on PI, 2, and y^x.

Click on INV, then ENTER to swap the two results.

Click on -, INV, HYP, and SIN.

Click on <- to erase the result, then click OFF to turn the Keypad Calculator off.

Grabbing data. Type C-x * x if necessary to exit Calc. Now select the following numbers as an Emacs region: “Mark” the front of the list by typing C-SPC or C-@ there, then move to the other end of the list. (Either get this list from the on-line copy of this manual, accessed by C-x * i, or just type these numbers into a scratch file.) Now type C-x * g to “grab” these numbers into Calc.

1.23  1.97
1.6   2
1.19  1.08
The result ‘[1.23, 1.97, 1.6, 2, 1.19, 1.08]’ is a Calc “vector.” Type V R + to compute the sum of these numbers.

Type U to Undo this command, then type V R * to compute the product of the numbers.

You can also grab data as a rectangular matrix. Place the cursor on the upper-leftmost ‘1’ and set the mark, then move to just after the lower-right ‘8’ and press C-x * r.

Type v t to transpose this 3x2 matrix into a 2x3 matrix. Type v u to unpack the rows into two separate vectors. Now type V R + TAB V R + to compute the sums of the two original columns. (There is also a special grab-and-sum-columns command, C-x * :.)

Units conversion. Units are entered algebraically. Type ' 43 mi/hr RET to enter the quantity 43 miles-per-hour. Type u c km/hr RET. Type u c m/s RET.

Date arithmetic. Type t N to get the current date and time. Type 90 + to find the date 90 days from now. Type ' <25 dec 87> RET to enter a date, then - 7 / to see how many weeks have passed since then.

Algebra. Algebraic entries can also include formulas or equations involving variables. Type ' [x + y = a, x y = 1] RET to enter a pair of equations involving three variables. (Note the leading apostrophe in this example; also, note that the space in ‘x y’ is required.) Type a S x,y RET to solve these equations for the variables ‘x’ and ‘y’.

Type d B to view the solutions in more readable notation. Type d C to view them in C language notation, d T to view them in the notation for the TeX typesetting system, and d L to view them in the notation for the LaTeX typesetting system. Type d N to return to normal notation.

Type 7.5, then s l a RET to let ‘a = 7.5’ in these formulas. (That’s the letter l, not the numeral 1.)

Help functions. You can read about any command in the on-line manual. Type C-x * c to return to Calc after each of these commands: h k t N to read about the t N command, h f sqrt RET to read about the sqrt function, and h s to read the Calc summary.

Press DEL repeatedly to remove any leftover results from the stack. To exit from Calc, press q or C-x * c again.


*** Using Calc

Calc has several user interfaces that are specialized for different kinds of tasks. As well as Calc’s standard interface, there are Quick mode, Keypad mode, and Embedded mode.

**** Starting Calc

On most systems, you can type C-x * to start the Calculator. The key sequence C-x * is bound to the command calc-dispatch, which can be rebound if convenient (see Customizing Calc).

When you press C-x *, Emacs waits for you to press a second key to complete the command. In this case, you will follow C-x * with a letter (upper- or lower-case, it doesn’t matter for C-x *) that says which Calc interface you want to use.

To get Calc’s standard interface, type C-x * c. To get Keypad mode, type C-x * k. Type C-x * ? to get a brief list of the available options, and type a second ? to get a complete list.

To ease typing, C-x * * also works to start Calc. It starts the same interface (either C-x * c or C-x * k) that you last used, selecting the C-x * c interface by default.

If C-x * doesn’t work for you, you can always type explicit commands like M-x calc (for the standard user interface) or M-x calc-keypad (for Keypad mode). First type M-x (that’s Meta with the letter x), then, at the prompt, type the full command (like calc-keypad) and press Return.

The same commands (like C-x * c or C-x * *) that start the Calculator also turn it off if it is already on.


**** The Standard Calc Interface

Calc’s standard interface acts like a traditional RPN calculator, operated by the normal Emacs keyboard. When you type C-x * c to start the Calculator, the Emacs screen splits into two windows with the file you were editing on top and Calc on the bottom.


...
--**-Emacs: myfile             (Fundamental)----All----------------------
--- Emacs Calculator Mode ---                   |Emacs Calculator Trail
2:  17.3                                        |    17.3
1:  -5                                          |    3
    .                                           |    2
                                                |    4
                                                |  * 8
                                                |  ->-5
                                                |
--%*-Calc: 12 Deg       (Calculator)----All----- --%*- *Calc Trail*
In this figure, the mode-line for myfile has moved up and the “Calculator” window has appeared below it. As you can see, Calc actually makes two windows side-by-side. The lefthand one is called the stack window and the righthand one is called the trail window. The stack holds the numbers involved in the calculation you are currently performing. The trail holds a complete record of all calculations you have done. In a desk calculator with a printer, the trail corresponds to the paper tape that records what you do.

In this case, the trail shows that four numbers (17.3, 3, 2, and 4) were first entered into the Calculator, then the 2 and 4 were multiplied to get 8, then the 3 and 8 were subtracted to get -5. (The ‘>’ symbol shows that this was the most recent calculation.) The net result is the two numbers 17.3 and -5 sitting on the stack.

Most Calculator commands deal explicitly with the stack only, but there is a set of commands that allow you to search back through the trail and retrieve any previous result.

Calc commands use the digits, letters, and punctuation keys. Shifted (i.e., upper-case) letters are different from lowercase letters. Some letters are prefix keys that begin two-letter commands. For example, e means “enter exponent” and shifted E means ‘e^x’. With the d (“display modes”) prefix the letter “e” takes on very different meanings: d e means “engineering notation” and d E means “eqn language mode.”

There is nothing stopping you from switching out of the Calc window and back into your editing window, say by using the Emacs C-x o (other-window) command. When the cursor is inside a regular window, Emacs acts just like normal. When the cursor is in the Calc stack or trail windows, keys are interpreted as Calc commands.

When you quit by pressing C-x * c a second time, the Calculator windows go away but the actual Stack and Trail are not gone, just hidden. When you press C-x * c once again you will get the same stack and trail contents you had when you last used the Calculator.

The Calculator does not remember its state between Emacs sessions. Thus if you quit Emacs and start it again, C-x * c will give you a fresh stack and trail. There is a command (m m) that lets you save your favorite mode settings between sessions, though. One of the things it saves is which user interface (standard or Keypad) you last used; otherwise, a freshly started Emacs will always treat C-x * * the same as C-x * c.

The q key is another equivalent way to turn the Calculator off.

If you type C-x * b first and then C-x * c, you get a full-screen version of Calc (full-calc) in which the stack and trail windows are still side-by-side but are now as tall as the whole Emacs screen. When you press q or C-x * c again to quit, the file you were editing before reappears. The C-x * b key switches back and forth between “big” full-screen mode and the normal partial-screen mode.

Finally, C-x * o (calc-other-window) is like C-x * c except that the Calc window is not selected. The buffer you were editing before remains selected instead. If you are in a Calc window, then C-x * o will switch you out of it, being careful not to switch you to the Calc Trail window. So C-x * o is a handy way to switch out of Calc momentarily to edit your file; you can then type C-x * c to switch back into Calc when you are done.


**** Quick Mode (Overview)

Quick mode is a quick way to use Calc when you don’t need the full complexity of the stack and trail. To use it, type C-x * q (quick-calc) in any regular editing buffer.

Quick mode is very simple: It prompts you to type any formula in standard algebraic notation (like ‘4 - 2/3’) and then displays the result at the bottom of the Emacs screen (3.33333333333 in this case). You are then back in the same editing buffer you were in before, ready to continue editing or to type C-x * q again to do another quick calculation. The result of the calculation will also be in the Emacs “kill ring” so that a C-y command at this point will yank the result into your editing buffer.

Calc mode settings affect Quick mode, too, though you will have to go into regular Calc (with C-x * c) to change the mode settings.

See “Quick Calculator” Mode, for further information.


**** Keypad Mode (Overview)
Keypad mode is a mouse-based interface to the Calculator. It is designed for use with terminals that support a mouse. If you don’t have a mouse, you will have to operate Keypad mode with your arrow keys (which is probably more trouble than it’s worth).

Type C-x * k to turn Keypad mode on or off. Once again you get two new windows, this time on the righthand side of the screen instead of at the bottom. The upper window is the familiar Calc Stack; the lower window is a picture of a typical calculator keypad.

|--- Emacs Calculator Mode ---
|2:  17.3
|1:  -5
|    .
|--%*-Calc: 12 Deg       (Calcul
|----+----+--Calc---+----+----1
|FLR |CEIL|RND |TRNC|CLN2|FLT |
|----+----+----+----+----+----|
| LN |EXP |    |ABS |IDIV|MOD |
|----+----+----+----+----+----|
|SIN |COS |TAN |SQRT|y^x |1/x |
|----+----+----+----+----+----|
|  ENTER  |+/- |EEX |UNDO| <- |
|-----+---+-+--+--+-+---++----|
| INV |  7  |  8  |  9  |  /  |
|-----+-----+-----+-----+-----|
| HYP |  4  |  5  |  6  |  *  |
|-----+-----+-----+-----+-----|
|EXEC |  1  |  2  |  3  |  -  |
|-----+-----+-----+-----+-----|
| OFF |  0  |  .  | PI  |  +  |
|-----+-----+-----+-----+-----+
Keypad mode is much easier for beginners to learn, because there is no need to memorize lots of obscure key sequences. But not all commands in regular Calc are available on the Keypad. You can always switch the cursor into the Calc stack window to use standard Calc commands if you need. Serious Calc users, though, often find they prefer the standard interface over Keypad mode.

To operate the Calculator, just click on the “buttons” of the keypad using your left mouse button. To enter the two numbers shown here you would click 1 7 . 3 ENTER 5 +/- ENTER; to add them together you would then click + (to get 12.3 on the stack).

If you click the right mouse button, the top three rows of the keypad change to show other sets of commands, such as advanced math functions, vector operations, and operations on binary numbers.

Because Keypad mode doesn’t use the regular keyboard, Calc leaves the cursor in your original editing buffer. You can type in this buffer in the usual way while also clicking on the Calculator keypad. One advantage of Keypad mode is that you don’t need an explicit command to switch between editing and calculating.

If you press C-x * b first, you get a full-screen Keypad mode (full-calc-keypad) with three windows: The keypad in the lower left, the stack in the lower right, and the trail on top.

See Keypad Mode, for further information.


**** Standalone Operation

If you are not in Emacs at the moment but you wish to use Calc, you must start Emacs first. If all you want is to run Calc, you can give the commands:

emacs -f full-calc
or

emacs -f full-calc-keypad
which run a full-screen Calculator (as if by C-x * b C-x * c) or a full-screen X-based Calculator (as if by C-x * b C-x * k). In standalone operation, quitting the Calculator (by pressing q or clicking on the keypad EXIT button) quits Emacs itself.


**** Embedded Mode (Overview)

Embedded mode is a way to use Calc directly from inside an editing buffer. Suppose you have a formula written as part of a document like this:

The derivative of

                                   ln(ln(x))

is
and you wish to have Calc compute and format the derivative for you and store this derivative in the buffer automatically. To do this with Embedded mode, first copy the formula down to where you want the result to be, leaving a blank line before and after the formula:

The derivative of

                                   ln(ln(x))

is

                                   ln(ln(x))
Now, move the cursor onto this new formula and press C-x * e. Calc will read the formula (using the surrounding blank lines to tell how much text to read), then push this formula (invisibly) onto the Calc stack. The cursor will stay on the formula in the editing buffer, but the line with the formula will now appear as it would on the Calc stack (in this case, it will be left-aligned) and the buffer’s mode line will change to look like the Calc mode line (with mode indicators like ‘12 Deg’ and so on). Even though you are still in your editing buffer, the keyboard now acts like the Calc keyboard, and any new result you get is copied from the stack back into the buffer. To take the derivative, you would type a d x RET.

The derivative of

                                   ln(ln(x))

is

1 / x ln(x)
(Note that by default, Calc gives division lower precedence than multiplication, so that ‘1 / x ln(x)’ is equivalent to ‘1 / (x ln(x))’.)

To make this look nicer, you might want to press d = to center the formula, and even d B to use Big display mode.

The derivative of

                                   ln(ln(x))

is
% [calc-mode: justify: center]
% [calc-mode: language: big]

                                       1
                                    -------
                                    x ln(x)
Calc has added annotations to the file to help it remember the modes that were used for this formula. They are formatted like comments in the TeX typesetting language, just in case you are using TeX or LaTeX. (In this example TeX is not being used, so you might want to move these comments up to the top of the file or otherwise put them out of the way.)

As an extra flourish, we can add an equation number using a righthand label: Type d } (1) RET.

% [calc-mode: justify: center]
% [calc-mode: language: big]
% [calc-mode: right-label: " (1)"]

                                       1
                                    -------                      (1)
                                    ln(x) x
To leave Embedded mode, type C-x * e again. The mode line and keyboard will revert to the way they were before.

The related command C-x * w operates on a single word, which generally means a single number, inside text. It searches for an expression which “looks” like a number containing the point. Here’s an example of its use (before you try this, remove the Calc annotations or use a new buffer so that the extra settings in the annotations don’t take effect):

A slope of one-third corresponds to an angle of 1 degrees.
Place the cursor on the ‘1’, then type C-x * w to enable Embedded mode on that number. Now type 3 / (to get one-third), and I T (the Inverse Tangent converts a slope into an angle), then C-x * w again to exit Embedded mode.

A slope of one-third corresponds to an angle of 18.4349488229 degrees.
See Embedded Mode, for full details.


**** Other C-x * Commands

Two more Calc-related commands are C-x * g and C-x * r, which “grab” data from a selected region of a buffer into the Calculator. The region is defined in the usual Emacs way, by a “mark” placed at one end of the region, and the Emacs cursor or “point” placed at the other.

The C-x * g command reads the region in the usual left-to-right, top-to-bottom order. The result is packaged into a Calc vector of numbers and placed on the stack. Calc (in its standard user interface) is then started. Type v u if you want to unpack this vector into separate numbers on the stack. Also, C-u C-x * g interprets the region as a single number or formula.

The C-x * r command reads a rectangle, with the point and mark defining opposite corners of the rectangle. The result is a matrix of numbers on the Calculator stack.

Complementary to these is C-x * y, which “yanks” the value at the top of the Calc stack back into an editing buffer. If you type C-x * y while in such a buffer, the value is yanked at the current position. If you type C-x * y while in the Calc buffer, Calc makes an educated guess as to which editing buffer you want to use. The Calc window does not have to be visible in order to use this command, as long as there is something on the Calc stack.

Here, for reference, is the complete list of C-x * commands. The shift, control, and meta keys are ignored for the keystroke following C-x *.

Commands for turning Calc on and off:

*
Turn Calc on or off, employing the same user interface as last time.

=, +, -, /, \, &, #
Alternatives for *.

C
Turn Calc on or off using its standard bottom-of-the-screen interface. If Calc is already turned on but the cursor is not in the Calc window, move the cursor into the window.

O
Same as C, but don’t select the new Calc window. If Calc is already turned on and the cursor is in the Calc window, move it out of that window.

B
Control whether C-x * c and C-x * k use the full screen.

Q
Use Quick mode for a single short calculation.

K
Turn Calc Keypad mode on or off.

E
Turn Calc Embedded mode on or off at the current formula.

J
Turn Calc Embedded mode on or off, select the interesting part.

W
Turn Calc Embedded mode on or off at the current word (number).

Z
Turn Calc on in a user-defined way, as defined by a Z I command.

X
Quit Calc; turn off standard, Keypad, or Embedded mode if on. (This is like q or OFF inside of Calc.)

Commands for moving data into and out of the Calculator:

G
Grab the region into the Calculator as a vector.

R
Grab the rectangular region into the Calculator as a matrix.

:
Grab the rectangular region and compute the sums of its columns.

_
Grab the rectangular region and compute the sums of its rows.

Y
Yank a value from the Calculator into the current editing buffer.

Commands for use with Embedded mode:

A
“Activate” the current buffer. Locate all formulas that contain ‘:=’ or ‘=>’ symbols and record their locations so that they can be updated automatically as variables are changed.

D
Duplicate the current formula immediately below and select the duplicate.

F
Insert a new formula at the current point.

N
Move the cursor to the next active formula in the buffer.

P
Move the cursor to the previous active formula in the buffer.

U
Update (i.e., as if by the = key) the formula at the current point.

`
Edit (as if by calc-edit) the formula at the current point.

Miscellaneous commands:

I
Run the Emacs Info system to read the Calc manual. (This is the same as h i inside of Calc.)

T
Run the Emacs Info system to read the Calc Tutorial.

S
Run the Emacs Info system to read the Calc Summary.

L
Load Calc entirely into memory. (Normally the various parts are loaded only as they are needed.)

M
Read a region of written keystroke names (like C-n a b c RET) and record them as the current keyboard macro.

0
(This is the “zero” digit key.) Reset the Calculator to its initial state: Empty stack, and initial mode settings.


** Tutorial

This chapter explains how to use Calc and its many features, in a step-by-step, tutorial way. You are encouraged to run Calc and work along with the examples as you read (see Starting Calc). If you are already familiar with advanced calculators, you may wish to skip on to the rest of this manual.

This tutorial describes the standard user interface of Calc only. The Quick mode and Keypad mode interfaces are fairly self-explanatory. See Embedded Mode, for a description of the Embedded mode interface.

The easiest way to read this tutorial on-line is to have two windows on your Emacs screen, one with Calc and one with the Info system. Press C-x * t to set this up; the on-line tutorial will be opened in the current window and Calc will be started in another window. From the Info window, the command C-x * c can be used to switch to the Calc window and C-x * o can be used to switch back to the Info window. (If you have a printed copy of the manual you can use that instead; in that case you only need to press C-x * c to start Calc.)

This tutorial is designed to be done in sequence. But the rest of this manual does not assume you have gone through the tutorial. The tutorial does not cover everything in the Calculator, but it touches on most general areas.

You may wish to print out a copy of the Calc Summary and keep notes on it as you learn Calc. See About This Manual, to see how to make a printed summary. See Calc Summary.

*** Basic Tutorial

In this section, we learn how RPN and algebraic-style calculations work, how to undo and redo an operation done by mistake, and how to control various modes of the Calculator.

**** RPN Calculations and the Stack

Calc normally uses Reverse Polish notation (RPN). You may be familiar with the RPN system from Hewlett-Packard calculators, FORTH, or PostScript. (Reverse Polish Notation is named after the Polish mathematician Jan Lukasiewicz.)

The central component of an RPN calculator is the stack. A calculator stack is like a stack of dishes. New dishes (numbers) are added at the top of the stack, and numbers are normally only removed from the top of the stack.

In an operation like ‘2+3’, the 2 and 3 are called the operands and the ‘+’ is the operator. In an RPN calculator you always enter the operands first, then the operator. Each time you type a number, Calc adds or pushes it onto the top of the Stack. When you press an operator key like +, Calc pops the appropriate number of operands from the stack and pushes back the result.

Thus we could add the numbers 2 and 3 in an RPN calculator by typing: 2 RET 3 RET +. (The RET key, Return, corresponds to the ENTER key on traditional RPN calculators.) Try this now if you wish; type C-x * c to switch into the Calc window (you can type C-x * c again or C-x * o to switch back to the Tutorial window). The first four keystrokes “push” the numbers 2 and 3 onto the stack. The + key “pops” the top two numbers from the stack, adds them, and pushes the result (5) back onto the stack. Here’s how the stack will look at various points throughout the calculation:

    .          1:  2          2:  2          1:  5              .
                   .          1:  3              .
                                  .

  C-x * c          2 RET          3 RET            +             DEL
The ‘.’ symbol is a marker that represents the top of the stack. Note that the “top” of the stack is really shown at the bottom of the Stack window. This may seem backwards, but it turns out to be less distracting in regular use.

The numbers ‘1:’ and ‘2:’ on the left are stack level numbers. Old RPN calculators always had four stack levels called ‘x’, ‘y’, ‘z’, and ‘t’. Calc’s stack can grow as large as you like, so it uses numbers instead of letters. Some stack-manipulation commands accept a numeric argument that says which stack level to work on. Normal commands like + always work on the top few levels of the stack.

The Stack buffer is just an Emacs buffer, and you can move around in it using the regular Emacs motion commands. But no matter where the cursor is, even if you have scrolled the ‘.’ marker out of view, most Calc commands always move the cursor back down to level 1 before doing anything. It is possible to move the ‘.’ marker upwards through the stack, temporarily “hiding” some numbers from commands like +. This is called stack truncation and we will not cover it in this tutorial; see Truncating the Stack, if you are interested.

You don’t really need the second RET in 2 RET 3 RET +. That’s because if you type any operator name or other non-numeric key when you are entering a number, the Calculator automatically enters that number and then does the requested command. Thus 2 RET 3 + will work just as well.

Examples in this tutorial will often omit RET even when the stack displays shown would only happen if you did press RET:

1:  2          2:  2          1:  5
    .          1:  3              .
                   .

  2 RET            3              +
Here, after pressing 3 the stack would really show ‘1: 2’ with ‘Calc: 3’ in the minibuffer. In these situations, you can press the optional RET to see the stack as the figure shows.

(•) Exercise 1. (This tutorial will include exercises at various points. Try them if you wish. Answers to all the exercises are located at the end of the Tutorial chapter. Each exercise will include a cross-reference to its particular answer. If you are reading with the Emacs Info system, press f and the exercise number to go to the answer, then the letter l to return to where you were.)

Here’s the first exercise: What will the keystrokes 1 RET 2 RET 3 RET 4 + * - compute? (‘*’ is the symbol for multiplication.) Figure it out by hand, then try it with Calc to see if you’re right. See 1. (•)

(•) Exercise 2. Compute ‘2*4 + 7*9.5 + 5/4’ using the stack. See 2. (•)

The DEL key is called Backspace on some keyboards. It is whatever key you would use to correct a simple typing error when regularly using Emacs. The DEL key pops and throws away the top value on the stack. (You can still get that value back from the Trail if you should need it later on.) There are many places in this tutorial where we assume you have used DEL to erase the results of the previous example at the beginning of a new example. In the few places where it is really important to use DEL to clear away old results, the text will remind you to do so.

(It won’t hurt to let things accumulate on the stack, except that whenever you give a display-mode-changing command Calc will have to spend a long time reformatting such a large stack.)

Since the - key is also an operator (it subtracts the top two stack elements), how does one enter a negative number? Calc uses the _ (underscore) key to act like the minus sign in a number. So, typing -5 RET won’t work because the - key will try to do a subtraction, but _5 RET works just fine.

You can also press n, which means “change sign.” It changes the number at the top of the stack (or the number being entered) from positive to negative or vice-versa: 5 n RET.

If you press RET when you’re not entering a number, the effect is to duplicate the top number on the stack. Consider this calculation:

1:  3          2:  3          1:  9          2:  9          1:  81
    .          1:  3              .          1:  9              .
                   .                             .

  3 RET           RET             *             RET             *
(Of course, an easier way to do this would be 3 RET 4 ^, to raise 3 to the fourth power.)

The space-bar key (denoted SPC here) performs the same function as RET; you could replace all three occurrences of RET in the above example with SPC and the effect would be the same.

Another stack manipulation key is TAB. This exchanges the top two stack entries. Suppose you have computed 2 RET 3 + to get 5, and then you realize what you really wanted to compute was ‘20 / (2+3)’.

1:  5          2:  5          2:  20         1:  4
    .          1:  20         1:  5              .
                   .              .

 2 RET 3 +         20            TAB             /
Planning ahead, the calculation would have gone like this:

1:  20         2:  20         3:  20         2:  20         1:  4
    .          1:  2          2:  2          1:  5              .
                   .          1:  3              .
                                  .

  20 RET         2 RET            3              +              /
A related stack command is M-TAB (hold META and type TAB). It rotates the top three elements of the stack upward, bringing the object in level 3 to the top.

1:  10         2:  10         3:  10         3:  20         3:  30
    .          1:  20         2:  20         2:  30         2:  10
                   .          1:  30         1:  10         1:  20
                                  .              .              .

  10 RET         20 RET         30 RET         M-TAB          M-TAB
(•) Exercise 3. Suppose the numbers 10, 20, and 30 are on the stack. Figure out how to add one to the number in level 2 without affecting the rest of the stack. Also figure out how to add one to the number in level 3. See 3. (•)

Operations like +, -, *, /, and ^ pop two arguments from the stack and push a result. Operations like n and Q (square root) pop a single number and push the result. You can think of them as simply operating on the top element of the stack.

1:  3          1:  9          2:  9          1:  25         1:  5
    .              .          1:  16             .              .
                                  .

  3 RET          RET *        4 RET RET *        +              Q
(Note that capital Q means to hold down the Shift key while typing q. Remember, plain unshifted q is the Quit command.)

Here we’ve used the Pythagorean Theorem to determine the hypotenuse of a right triangle. Calc actually has a built-in command for that called f h, but let’s suppose we can’t remember the necessary keystrokes. We can still enter it by its full name using M-x notation:

1:  3          2:  3          1:  5
    .          1:  4              .
                   .

  3 RET          4 RET      M-x calc-hypot
All Calculator commands begin with the word ‘calc-’. Since it gets tiring to type this, Calc provides an x key which is just like the regular Emacs M-x key except that it types the ‘calc-’ prefix for you:

1:  3          2:  3          1:  5
    .          1:  4              .
                   .

  3 RET          4 RET         x hypot
What happens if you take the square root of a negative number?

1:  4          1:  -4         1:  (0, 2)
    .              .              .

  4 RET            n              Q
The notation ‘(a, b)’ represents a complex number. Complex numbers are more traditionally written ‘a + b i’; Calc can display in this format, too, but for now we’ll stick to the ‘(a, b)’ notation.

If you don’t know how complex numbers work, you can safely ignore this feature. Complex numbers only arise from operations that would be errors in a calculator that didn’t have complex numbers. (For example, taking the square root or logarithm of a negative number produces a complex result.)

Complex numbers are entered in the notation shown. The ( and , and ) keys manipulate “incomplete complex numbers.”

1:  ( ...      2:  ( ...      1:  (2, ...    1:  (2, ...    1:  (2, 3)
    .          1:  2              .              3              .
                   .                             .

    (              2              ,              3              )
You can perform calculations while entering parts of incomplete objects. However, an incomplete object cannot actually participate in a calculation:

1:  ( ...      2:  ( ...      3:  ( ...      1:  ( ...      1:  ( ...
    .          1:  2          2:  2              5              5
                   .          1:  3              .              .
                                  .
                                                             (error)
    (             2 RET           3              +              +
Adding 5 to an incomplete object makes no sense, so the last command produces an error message and leaves the stack the same.

Incomplete objects can’t participate in arithmetic, but they can be moved around by the regular stack commands.

2:  2          3:  2          3:  3          1:  ( ...      1:  (2, 3)
1:  3          2:  3          2:  ( ...          2              .
    .          1:  ( ...      1:  2              3
                   .              .              .

2 RET 3 RET        (            M-TAB          M-TAB            )
Note that the , (comma) key did not have to be used here. When you press ) all the stack entries between the incomplete entry and the top are collected, so there’s never really a reason to use the comma. It’s up to you.

(•) Exercise 4. To enter the complex number ‘(2, 3)’, your friend Joe typed ( 2 , SPC 3 ). What happened? (Joe thought of a clever way to correct his mistake in only two keystrokes, but it didn’t quite work. Try it to find out why.) See 4. (•)

Vectors are entered the same way as complex numbers, but with square brackets in place of parentheses. We’ll meet vectors again later in the tutorial.

Any Emacs command can be given a numeric prefix argument by typing a series of META-digits beforehand. If META is awkward for you, you can instead type C-u followed by the necessary digits. Numeric prefix arguments can be negative, as in M-- M-3 M-5 or C-u - 3 5. Calc commands use numeric prefix arguments in a variety of ways. For example, a numeric prefix on the + operator adds any number of stack entries at once:

1:  10         2:  10         3:  10         3:  10         1:  60
    .          1:  20         2:  20         2:  20             .
                   .          1:  30         1:  30
                                  .              .

  10 RET         20 RET         30 RET         C-u 3            +
For stack manipulation commands like RET, a positive numeric prefix argument operates on the top n stack entries at once. A negative argument operates on the entry in level n only. An argument of zero operates on the entire stack. In this example, we copy the second-to-top element of the stack:

1:  10         2:  10         3:  10         3:  10         4:  10
    .          1:  20         2:  20         2:  20         3:  20
                   .          1:  30         1:  30         2:  30
                                  .              .          1:  20
                                                                .

  10 RET         20 RET         30 RET         C-u -2          RET
Another common idiom is M-0 DEL, which clears the stack. (The M-0 numeric prefix tells DEL to operate on the entire stack.)


**** Algebraic-Style Calculations

If you are not used to RPN notation, you may prefer to operate the Calculator in Algebraic mode, which is closer to the way non-RPN calculators work. In Algebraic mode, you enter formulas in traditional ‘2+3’ notation.

Notice: Calc gives ‘/’ lower precedence than ‘*’, so that ‘a/b*c’ is interpreted as ‘a/(b*c)’; this is not standard across all computer languages. See below for details.

You don’t really need any special “mode” to enter algebraic formulas. You can enter a formula at any time by pressing the apostrophe (') key. Answer the prompt with the desired formula, then press RET. The formula is evaluated and the result is pushed onto the RPN stack. If you don’t want to think in RPN at all, you can enter your whole computation as a formula, read the result from the stack, then press DEL to delete it from the stack.

Try pressing the apostrophe key, then 2+3+4, then RET. The result should be the number 9.

Algebraic formulas use the operators ‘+’, ‘-’, ‘*’, ‘/’, and ‘^’. You can use parentheses to make the order of evaluation clear. In the absence of parentheses, ‘^’ is evaluated first, then ‘*’, then ‘/’, then finally ‘+’ and ‘-’. For example, the expression

2 + 3*4*5 / 6*7^8 - 9
is equivalent to

2 + ((3*4*5) / (6*(7^8))) - 9
or, in large mathematical notation,

    3 * 4 * 5
2 + --------- - 9
          8
     6 * 7
The result of this expression will be the number -6.99999826533.

Calc’s order of evaluation is the same as for most computer languages, except that ‘*’ binds more strongly than ‘/’, as the above example shows. As in normal mathematical notation, the ‘*’ symbol can often be omitted: ‘2 a’ is the same as ‘2*a’.

Operators at the same level are evaluated from left to right, except that ‘^’ is evaluated from right to left. Thus, ‘2-3-4’ is equivalent to ‘(2-3)-4’ or -5, whereas ‘2^3^4’ is equivalent to ‘2^(3^4)’ (a very large integer; try it!).

If you tire of typing the apostrophe all the time, there is Algebraic mode, where Calc automatically senses when you are about to type an algebraic expression. To enter this mode, press the two letters m a. (An ‘Alg’ indicator should appear in the Calc window’s mode line.)

Press m a, then 2+3+4 with no apostrophe, then RET.

In Algebraic mode, when you press any key that would normally begin entering a number (such as a digit, a decimal point, or the _ key), or if you press ( or [, Calc automatically begins an algebraic entry.

Functions which do not have operator symbols like ‘+’ and ‘*’ must be entered in formulas using function-call notation. For example, the function name corresponding to the square-root key Q is sqrt. To compute a square root in a formula, you would use the notation ‘sqrt(x)’.

Press the apostrophe, then type sqrt(5*2) - 3. The result should be ‘0.16227766017’.

Note that if the formula begins with a function name, you need to use the apostrophe even if you are in Algebraic mode. If you type arcsin out of the blue, the a r will be taken as an Algebraic Rewrite command, and the csin will be taken as the name of the rewrite rule to use!

Some people prefer to enter complex numbers and vectors in algebraic form because they find RPN entry with incomplete objects to be too distracting, even though they otherwise use Calc as an RPN calculator.

Still in Algebraic mode, type:

1:  (2, 3)     2:  (2, 3)     1:  (8, -1)    2:  (8, -1)    1:  (9, -1)
    .          1:  (1, -2)        .          1:  1              .
                   .                             .

 (2,3) RET      (1,-2) RET        *              1 RET          +
Algebraic mode allows us to enter complex numbers without pressing an apostrophe first, but it also means we need to press RET after every entry, even for a simple number like ‘1’.

(You can type C-u m a to enable a special Incomplete Algebraic mode in which the ( and [ keys use algebraic entry even though regular numeric keys still use RPN numeric entry. There is also Total Algebraic mode, started by typing m t, in which all normal keys begin algebraic entry. You must then use the META key to type Calc commands: M-m t to get back out of Total Algebraic mode, M-q to quit, etc.)

If you’re still in Algebraic mode, press m a again to turn it off.

Actual non-RPN calculators use a mixture of algebraic and RPN styles. In general, operators of two numbers (like + and *) use algebraic form, but operators of one number (like n and Q) use RPN form. Also, a non-RPN calculator allows you to see the intermediate results of a calculation as you go along. You can accomplish this in Calc by performing your calculation as a series of algebraic entries, using the $ sign to tie them together. In an algebraic formula, $ represents the number on the top of the stack. Here, we perform the calculation ‘sqrt(2*4+1)’, which on a traditional calculator would be done by pressing 2 * 4 + 1 = and then the square-root key.

1:  8          1:  9          1:  3
    .              .              .

  ' 2*4 RET        $+1 RET        Q
Notice that we didn’t need to press an apostrophe for the $+1, because the dollar sign always begins an algebraic entry.

(•) Exercise 1. How could you get the same effect as pressing Q but using an algebraic entry instead? How about if the Q key on your keyboard were broken? See 1. (•)

The notations $$, $$$, and so on stand for higher stack entries. For example, ' $$+$ RET is just like typing +.

Algebraic formulas can include variables. To store in a variable, press s s, then type the variable name, then press RET. (There are actually two flavors of store command: s s stores a number in a variable but also leaves the number on the stack, while s t removes a number from the stack and stores it in the variable.) A variable name should consist of one or more letters or digits, beginning with a letter.

1:  17             .          1:  a + a^2    1:  306
    .                             .              .

    17          s t a RET      ' a+a^2 RET       =
The = key evaluates a formula by replacing all its variables by the values that were stored in them.

For RPN calculations, you can recall a variable’s value on the stack either by entering its name as a formula and pressing =, or by using the s r command.

1:  17         2:  17         3:  17         2:  17         1:  306
    .          1:  17         2:  17         1:  289            .
                   .          1:  2              .
                                  .

  s r a RET     ' a RET =         2              ^              +
If you press a single digit for a variable name (as in s t 3, you get one of ten quick variables q0 through q9. They are “quick” simply because you don’t have to type the letter q or the RET after their names. In fact, you can type simply s 3 as a shorthand for s s 3, and likewise for t 3 and r 3.

Any variables in an algebraic formula for which you have not stored values are left alone, even when you evaluate the formula.

1:  2 a + 2 b     1:  2 b + 34
    .                 .

 ' 2a+2b RET          =
Calls to function names which are undefined in Calc are also left alone, as are calls for which the value is undefined.

1:  log10(0) + log10(x) + log10(5, 6) + foo(3) + 2
    .

 ' log10(100) + log10(0) + log10(x) + log10(5,6) + foo(3) RET
In this example, the first call to log10 works, but the other calls are not evaluated. In the second call, the logarithm is undefined for that value of the argument; in the third, the argument is symbolic, and in the fourth, there are too many arguments. In the fifth case, there is no function called foo. You will see a “Wrong number of arguments” message referring to ‘log10(5,6)’. Press the w (“why”) key to see any other messages that may have arisen from the last calculation. In this case you will get “logarithm of zero,” then “number expected: x”. Calc automatically displays the first message only if the message is sufficiently important; for example, Calc considers “wrong number of arguments” and “logarithm of zero” to be important enough to report automatically, while a message like “number expected: x” will only show up if you explicitly press the w key.

(•) Exercise 2. Joe entered the formula ‘2 x y’, stored 5 in x, pressed =, and got the expected result, ‘10 y’. He then tried the same for the formula ‘2 x (1+y)’, expecting ‘10 (1+y)’, but it didn’t work. Why not? See 2. (•)

(•) Exercise 3. What result would you expect 1 RET 0 / to give? What if you then type 0 *? See 3. (•)

One interesting way to work with variables is to use the evaluates-to (‘=>’) operator. It works like this: Enter a formula algebraically in the usual way, but follow the formula with an ‘=>’ symbol. (There is also an s = command which builds an ‘=>’ formula using the stack.) On the stack, you will see two copies of the formula with an ‘=>’ between them. The lefthand formula is exactly like you typed it; the righthand formula has been evaluated as if by typing =.

2:  2 + 3 => 5                     2:  2 + 3 => 5
1:  2 a + 2 b => 34 + 2 b          1:  2 a + 2 b => 20 + 2 b
    .                                  .

' 2+3 => RET  ' 2a+2b RET s =          10 s t a RET
Notice that the instant we stored a new value in a, all ‘=>’ operators already on the stack that referred to ‘a’ were updated to use the new value. With ‘=>’, you can push a set of formulas on the stack, then change the variables experimentally to see the effects on the formulas’ values.

You can also “unstore” a variable when you are through with it:

2:  2 + 3 => 5
1:  2 a + 2 b => 2 a + 2 b
    .

    s u a RET
We will encounter formulas involving variables and functions again when we discuss the algebra and calculus features of the Calculator.


**** Undo and Redo

If you make a mistake, you can usually correct it by pressing shift-U, the “undo” command. First, clear the stack (M-0 DEL) and exit and restart Calc (C-x * * C-x * *) to make sure things start off with a clean slate. Now:

1:  2          2:  2          1:  8          2:  2          1:  6
    .          1:  3              .          1:  3              .
                   .                             .

   2 RET           3              ^              U              *
You can undo any number of times. Calc keeps a complete record of all you have done since you last opened the Calc window. After the above example, you could type:

1:  6          2:  2          1:  2              .              .
    .          1:  3              .
                   .
                                                             (error)
                   U              U              U              U
You can also type D to “redo” a command that you have undone mistakenly.

    .          1:  2          2:  2          1:  6          1:  6
                   .          1:  3              .              .
                                  .
                                                             (error)
                   D              D              D              D
It was not possible to redo past the ‘6’, since that was placed there by something other than an undo command.

You can think of undo and redo as a sort of “time machine.” Press U to go backward in time, D to go forward. If you go backward and do something (like *) then, as any science fiction reader knows, you have changed your future and you cannot go forward again. Thus, the inability to redo past the ‘6’ even though there was an earlier undo command.

You can always recall an earlier result using the Trail. We’ve ignored the trail so far, but it has been faithfully recording everything we did since we loaded the Calculator. If the Trail is not displayed, press t d now to turn it on.

Let’s try grabbing an earlier result. The ‘8’ we computed was undone by a U command, and was lost even to Redo when we pressed *, but it’s still there in the trail. There should be a little ‘>’ arrow (the trail pointer) resting on the last trail entry. If there isn’t, press t ] to reset the trail pointer. Now, press t p to move the arrow onto the line containing ‘8’, and press t y to “yank” that number back onto the stack.

If you press t ] again, you will see that even our Yank command went into the trail.

Let’s go further back in time. Earlier in the tutorial we computed a huge integer using the formula ‘2^3^4’. We don’t remember what it was, but the first digits were “241”. Press t r (which stands for trail-search-reverse), then type 241. The trail cursor will jump back to the next previous occurrence of the string “241” in the trail. This is just a regular Emacs incremental search; you can now press C-s or C-r to continue the search forwards or backwards as you like.

To finish the search, press RET. This halts the incremental search and leaves the trail pointer at the thing we found. Now we can type t y to yank that number onto the stack. If we hadn’t remembered the “241”, we could simply have searched for 2^3^4, then pressed RET t n to halt and then move to the next item.

You may have noticed that all the trail-related commands begin with the letter t. (The store-and-recall commands, on the other hand, all began with s.) Calc has so many commands that there aren’t enough keys for all of them, so various commands are grouped into two-letter sequences where the first letter is called the prefix key. If you type a prefix key by accident, you can press C-g to cancel it. (In fact, you can press C-g to cancel almost anything in Emacs.) To get help on a prefix key, press that key followed by ?. Some prefixes have several lines of help, so you need to press ? repeatedly to see them all. You can also type h h to see all the help at once.

Try pressing t ? now. You will see a line of the form,

trail/time: Display; Fwd, Back; Next, Prev, Here, [, ]; Yank:  [MORE]  t-
The word “trail” indicates that the t prefix key contains trail-related commands. Each entry on the line shows one command, with a single capital letter showing which letter you press to get that command. We have used t n, t p, t ], and t y so far. The ‘[MORE]’ means you can press ? again to see more t-prefix commands. Notice that the commands are roughly divided (by semicolons) into related groups.

When you are in the help display for a prefix key, the prefix is still active. If you press another key, like y for example, it will be interpreted as a t y command. If all you wanted was to look at the help messages, press C-g afterwards to cancel the prefix.

One more way to correct an error is by editing the stack entries. The actual Stack buffer is marked read-only and must not be edited directly, but you can press ` (grave accent) to edit a stack entry.

Try entering ‘3.141439’ now. If this is supposed to represent ‘pi’, it’s got several errors. Press ` to edit this number. Now use the normal Emacs cursor motion and editing keys to change the second 4 to a 5, and to transpose the 3 and the 9. When you press RET, the number on the stack will be replaced by your new number. This works for formulas, vectors, and all other types of values you can put on the stack. The ` key also works during entry of a number or algebraic formula.


**** Mode-Setting Commands

Calc has many types of modes that affect the way it interprets your commands or the way it displays data. We have already seen one mode, namely Algebraic mode. There are many others, too; we’ll try some of the most common ones here.

Perhaps the most fundamental mode in Calc is the current precision. Notice the ‘12’ on the Calc window’s mode line:

--%*-Calc: 12 Deg       (Calculator)----All------
Most of the symbols there are Emacs things you don’t need to worry about, but the ‘12’ and the ‘Deg’ are mode indicators. The ‘12’ means that calculations should always be carried to 12 significant figures. That is why, when we type 1 RET 7 /, we get ‘0.142857142857’ with exactly 12 digits, not counting leading and trailing zeros.

You can set the precision to anything you like by pressing p, then entering a suitable number. Try pressing p 30 RET, then doing 1 RET 7 / again:

1:  0.142857142857
2:  0.142857142857142857142857142857
    .
Although the precision can be set arbitrarily high, Calc always has to have some value for the current precision. After all, the true value ‘1/7’ is an infinitely repeating decimal; Calc has to stop somewhere.

Of course, calculations are slower the more digits you request. Press p 12 now to set the precision back down to the default.

Calculations always use the current precision. For example, even though we have a 30-digit value for ‘1/7’ on the stack, if we use it in a calculation in 12-digit mode it will be rounded down to 12 digits before it is used. Try it; press RET to duplicate the number, then 1 +. Notice that the RET key didn’t round the number, because it doesn’t do any calculation. But the instant we pressed +, the number was rounded down.

1:  0.142857142857
2:  0.142857142857142857142857142857
3:  1.14285714286
    .
In fact, since we added a digit on the left, we had to lose one digit on the right from even the 12-digit value of ‘1/7’.

How did we get more than 12 digits when we computed ‘2^3^4’? The answer is that Calc makes a distinction between integers and floating-point numbers, or floats. An integer is a number that does not contain a decimal point. There is no such thing as an “infinitely repeating fraction integer,” so Calc doesn’t have to limit itself. If you asked for ‘2^10000’ (don’t try this!), you would have to wait a long time but you would eventually get an exact answer. If you ask for ‘2.^10000’, you will quickly get an answer which is correct only to 12 places. The decimal point tells Calc that it should use floating-point arithmetic to get the answer, not exact integer arithmetic.

You can use the F (calc-floor) command to convert a floating-point value to an integer, and c f (calc-float) to convert an integer to floating-point form.

Let’s try entering that last calculation:

1:  2.         2:  2.         1:  1.99506311689e3010
    .          1:  10000          .
                   .

  2.0 RET          10000 RET      ^
Notice the letter ‘e’ in there. It represents “times ten to the power of,” and is used by Calc automatically whenever writing the number out fully would introduce more extra zeros than you probably want to see. You can enter numbers in this notation, too.

1:  2.         2:  2.         1:  1.99506311678e3010
    .          1:  10000.         .
                   .

  2.0 RET          1e4 RET        ^
Hey, the answer is different! Look closely at the middle columns of the two examples. In the first, the stack contained the exact integer ‘10000’, but in the second it contained a floating-point value with a decimal point. When you raise a number to an integer power, Calc uses repeated squaring and multiplication to get the answer. When you use a floating-point power, Calc uses logarithms and exponentials. As you can see, a slight error crept in during one of these methods. Which one should we trust? Let’s raise the precision a bit and find out:

    .          1:  2.         2:  2.         1:  1.995063116880828e3010
                   .          1:  10000.         .
                                  .

 p 16 RET        2. RET           1e4            ^    p 12 RET
Presumably, it doesn’t matter whether we do this higher-precision calculation using an integer or floating-point power, since we have added enough “guard digits” to trust the first 12 digits no matter what. And the verdict is… Integer powers were more accurate; in fact, the result was only off by one unit in the last place.

Calc does many of its internal calculations to a slightly higher precision, but it doesn’t always bump the precision up enough. In each case, Calc added about two digits of precision during its calculation and then rounded back down to 12 digits afterward. In one case, it was enough; in the other, it wasn’t. If you really need x digits of precision, it never hurts to do the calculation with a few extra guard digits.

What if we want guard digits but don’t want to look at them? We can set the float format. Calc supports four major formats for floating-point numbers, called normal, fixed-point, scientific notation, and engineering notation. You get them by pressing d n, d f, d s, and d e, respectively. In each case, you can supply a numeric prefix argument which says how many digits should be displayed. As an example, let’s put a few numbers onto the stack and try some different display modes. First, use M-0 DEL to clear the stack, then enter the four numbers shown here:

4:  12345      4:  12345      4:  12345      4:  12345      4:  12345
3:  12345.     3:  12300.     3:  1.2345e4   3:  1.23e4     3:  12345.000
2:  123.45     2:  123.       2:  1.2345e2   2:  1.23e2     2:  123.450
1:  12.345     1:  12.3       1:  1.2345e1   1:  1.23e1     1:  12.345
    .              .              .              .              .

   d n          M-3 d n          d s          M-3 d s        M-3 d f
Notice that when we typed M-3 d n, the numbers were rounded down to three significant digits, but then when we typed d s all five significant figures reappeared. The float format does not affect how numbers are stored, it only affects how they are displayed. Only the current precision governs the actual rounding of numbers in the Calculator’s memory.

Engineering notation, not shown here, is like scientific notation except the exponent (the power-of-ten part) is always adjusted to be a multiple of three (as in “kilo,” “micro,” etc.). As a result there will be one, two, or three digits before the decimal point.

Whenever you change a display-related mode, Calc redraws everything in the stack. This may be slow if there are many things on the stack, so Calc allows you to type shift-H before any mode command to prevent it from updating the stack. Anything Calc displays after the mode-changing command will appear in the new format.

4:  12345      4:  12345      4:  12345      4:  12345      4:  12345
3:  12345.000  3:  12345.000  3:  12345.000  3:  1.2345e4   3:  12345.
2:  123.450    2:  123.450    2:  1.2345e1   2:  1.2345e1   2:  123.45
1:  12.345     1:  1.2345e1   1:  1.2345e2   1:  1.2345e2   1:  12.345
    .              .              .              .              .

    H d s          DEL U          TAB            d SPC          d n
Here the H d s command changes to scientific notation but without updating the screen. Deleting the top stack entry and undoing it back causes it to show up in the new format; swapping the top two stack entries reformats both entries. The d SPC command refreshes the whole stack. The d n command changes back to the normal float format; since it doesn’t have an H prefix, it also updates all the stack entries to be in d n format.

Notice that the integer ‘12345’ was not affected by any of the float formats. Integers are integers, and are always displayed exactly.

Large integers have their own problems. Let’s look back at the result of 2^3^4.

2417851639229258349412352
Quick—how many digits does this have? Try typing d g:

2,417,851,639,229,258,349,412,352
Now how many digits does this have? It’s much easier to tell! We can actually group digits into clumps of any size. Some people prefer M-5 d g:

24178,51639,22925,83494,12352
Let’s see what happens to floating-point numbers when they are grouped. First, type p 25 RET to make sure we have enough precision to get ourselves into trouble. Now, type 1e13 /:

24,17851,63922.9258349412352
The integer part is grouped but the fractional part isn’t. Now try M-- M-5 d g (that’s meta-minus-sign, meta-five):

24,17851,63922.92583,49412,352
If you find it hard to tell the decimal point from the commas, try changing the grouping character to a space with d , SPC:

24 17851 63922.92583 49412 352
Type d , , to restore the normal grouping character, then d g again to turn grouping off. Also, press p 12 to restore the default precision.

Press U enough times to get the original big integer back. (Notice that U does not undo each mode-setting command; if you want to undo a mode-setting command, you have to do it yourself.) Now, type d r 16 RET:

16#200000000000000000000
The number is now displayed in hexadecimal, or “base-16” form. Suddenly it looks pretty simple; this should be no surprise, since we got this number by computing a power of two, and 16 is a power of 2. In fact, we can use d r 2 RET to see it in actual binary form:

2#1000000000000000000000000000000000000000000000000000000 …
We don’t have enough space here to show all the zeros! They won’t fit on a typical screen, either, so you will have to use horizontal scrolling to see them all. Press < and > to scroll the stack window left and right by half its width. Another way to view something large is to press ` (grave accent) to edit the top of stack in a separate window. (Press C-c C-c when you are done.)

You can enter non-decimal numbers using the # symbol, too. Let’s see what the hexadecimal number ‘5FE’ looks like in binary. Type 16#5FE (the letters can be typed in upper or lower case; they will always appear in upper case). It will also help to turn grouping on with d g:

2#101,1111,1110
Notice that d g groups by fours by default if the display radix is binary or hexadecimal, but by threes if it is decimal, octal, or any other radix.

Now let’s see that number in decimal; type d r 10:

1,534
Numbers are not stored with any particular radix attached. They’re just numbers; they can be entered in any radix, and are always displayed in whatever radix you’ve chosen with d r. The current radix applies to integers, fractions, and floats.

(•) Exercise 1. Your friend Joe tried to enter one-third as ‘3#0.1’ in d r 3 mode with a precision of 12. He got ‘3#0.0222222...’ (with 25 2’s) in the display. When he multiplied that by three, he got ‘3#0.222222...’ instead of the expected ‘3#1’. Next, Joe entered ‘3#0.2’ and, to his great relief, saw ‘3#0.2’ on the screen. But when he typed 2 /, he got ‘3#0.10000001’ (some zeros omitted). What’s going on here? See 1. (•)

(•) Exercise 2. Scientific notation works in non-decimal modes in the natural way (the exponent is a power of the radix instead of a power of ten, although the exponent itself is always written in decimal). Thus ‘8#1.23e3 = 8#1230.0’. Suppose we have the hexadecimal number ‘f.e8f’ times 16 to the 15th power: We write ‘16#f.e8fe15’. What is wrong with this picture? What could we write instead that would work better? See 2. (•)

The m prefix key has another set of modes, relating to the way Calc interprets your inputs and does computations. Whereas d-prefix modes generally affect the way things look, m-prefix modes affect the way they are actually computed.

The most popular m-prefix mode is the angular mode. Notice the ‘Deg’ indicator in the mode line. This means that if you use a command that interprets a number as an angle, it will assume the angle is measured in degrees. For example,

1:  45         1:  0.707106781187   1:  0.500000000001    1:  0.5
    .              .                    .                     .

    45             S                    2 ^                   c 1
The shift-S command computes the sine of an angle. The sine of 45 degrees is ‘sqrt(2)/2’; squaring this yields ‘2/4 = 0.5’. However, there has been a slight roundoff error because the representation of ‘sqrt(2)/2’ wasn’t exact. The c 1 command is a handy way to clean up numbers in this case; it temporarily reduces the precision by one digit while it re-rounds the number on the top of the stack.

(•) Exercise 3. Your friend Joe computed the sine of 45 degrees as shown above, then, hoping to avoid an inexact result, he increased the precision to 16 digits before squaring. What happened? See 3. (•)

To do this calculation in radians, we would type m r first. (The indicator changes to ‘Rad’.) 45 degrees corresponds to ‘pi/4’ radians. To get ‘pi’, press the P key. (Once again, this is a shifted capital P. Remember, unshifted p sets the precision.)

1:  3.14159265359   1:  0.785398163398   1:  0.707106781187
    .                   .                .

    P                   4 /       m r    S
Likewise, inverse trigonometric functions generate results in either radians or degrees, depending on the current angular mode.

1:  0.707106781187   1:  0.785398163398   1:  45.
    .                    .                    .

    .5 Q        m r      I S        m d       U I S
Here we compute the Inverse Sine of ‘sqrt(0.5)’, first in radians, then in degrees.

Use c d and c r to convert a number from radians to degrees and vice-versa.

1:  45         1:  0.785398163397     1:  45.
    .              .                      .

    45             c r                    c d
Another interesting mode is Fraction mode. Normally, dividing two integers produces a floating-point result if the quotient can’t be expressed as an exact integer. Fraction mode causes integer division to produce a fraction, i.e., a rational number, instead.

2:  12         1:  1.33333333333    1:  4:3
1:  9              .                    .
    .

 12 RET 9          /          m f       U /      m f
In the first case, we get an approximate floating-point result. In the second case, we get an exact fractional result (four-thirds).

You can enter a fraction at any time using : notation. (Calc uses : instead of / as the fraction separator because / is already used to divide the top two stack elements.) Calculations involving fractions will always produce exact fractional results; Fraction mode only says what to do when dividing two integers.

(•) Exercise 4. If fractional arithmetic is exact, why would you ever use floating-point numbers instead? See 4. (•)

Typing m f doesn’t change any existing values in the stack. In the above example, we had to Undo the division and do it over again when we changed to Fraction mode. But if you use the evaluates-to operator you can get commands like m f to recompute for you.

1:  12 / 9 => 1.33333333333    1:  12 / 9 => 1.333    1:  12 / 9 => 4:3
    .                              .                      .

   ' 12/9 => RET                   p 4 RET                m f
In this example, the righthand side of the ‘=>’ operator on the stack is recomputed when we change the precision, then again when we change to Fraction mode. All ‘=>’ expressions on the stack are recomputed every time you change any mode that might affect their values.


*** Arithmetic Tutorial

In this section, we explore the arithmetic and scientific functions available in the Calculator.

The standard arithmetic commands are +, -, *, /, and ^. Each normally takes two numbers from the top of the stack and pushes back a result. The n and & keys perform change-sign and reciprocal operations, respectively.

1:  5          1:  0.2        1:  5.         1:  -5.        1:  5.
    .              .              .              .              .

    5              &              &              n              n
You can apply a “binary operator” like + across any number of stack entries by giving it a numeric prefix. You can also apply it pairwise to several stack elements along with the top one if you use a negative prefix.

3:  2          1:  9          3:  2          4:  2          3:  12
2:  3              .          2:  3          3:  3          2:  13
1:  4                         1:  4          2:  4          1:  14
    .                             .          1:  10             .
                                                 .

2 RET 3 RET 4     M-3 +           U              10          M-- M-3 +
You can apply a “unary operator” like & to the top n stack entries with a numeric prefix, too.

3:  2          3:  0.5                3:  0.5
2:  3          2:  0.333333333333     2:  3.
1:  4          1:  0.25               1:  4.
    .              .                      .

2 RET 3 RET 4      M-3 &                  M-2 &
Notice that the results here are left in floating-point form. We can convert them back to integers by pressing F, the “floor” function. This function rounds down to the next lower integer. There is also R, which rounds to the nearest integer.

7:  2.         7:  2          7:  2
6:  2.4        6:  2          6:  2
5:  2.5        5:  2          5:  3
4:  2.6        4:  2          4:  3
3:  -2.        3:  -2         3:  -2
2:  -2.4       2:  -3         2:  -2
1:  -2.6       1:  -3         1:  -3
    .              .              .

                  M-7 F        U M-7 R
Since dividing-and-flooring (i.e., “integer quotient”) is such a common operation, Calc provides a special command for that purpose, the backslash \. Another common arithmetic operator is %, which computes the remainder that would arise from a \ operation, i.e., the “modulo” of two numbers. For example,

2:  1234       1:  12         2:  1234       1:  34
1:  100            .          1:  100            .
    .                             .

1234 RET 100       \              U              %
These commands actually work for any real numbers, not just integers.

2:  3.1415     1:  3          2:  3.1415     1:  0.1415
1:  1              .          1:  1              .
    .                             .

3.1415 RET 1       \              U              %
(•) Exercise 1. The \ command would appear to be a frill, since you could always do the same thing with / F. Think of a situation where this is not true—/ F would be inadequate. Now think of a way you could get around the problem if Calc didn’t provide a \ command. See 1. (•)

We’ve already seen the Q (square root) and S (sine) commands. Other commands along those lines are C (cosine), T (tangent), E (‘e^x’) and L (natural logarithm). These can be modified by the I (inverse) and H (hyperbolic) prefix keys.

Let’s compute the sine and cosine of an angle, and verify the identity ‘sin(x)^2 + cos(x)^2 = 1’. We’ll arbitrarily pick -64 degrees as a good value for ‘x’. With the angular mode set to degrees (type m d), do:

2:  -64        2:  -64        2:  -0.89879   2:  -0.89879   1:  1.
1:  -64        1:  -0.89879   1:  -64        1:  0.43837        .
    .              .              .              .

 64 n RET RET      S              TAB            C              f h
(For brevity, we’re showing only five digits of the results here. You can of course do these calculations to any precision you like.)

Remember, f h is the calc-hypot, or square-root of sum of squares, command.

Another identity is ‘tan(x) = sin(x) / cos(x)’.


2:  -0.89879   1:  -2.0503    1:  -64.
1:  0.43837        .              .
    .

    U              /              I T
A physical interpretation of this calculation is that if you move ‘0.89879’ units downward and ‘0.43837’ units to the right, your direction of motion is -64 degrees from horizontal. Suppose we move in the opposite direction, up and to the left:

2:  -0.89879   2:  0.89879    1:  -2.0503    1:  -64.
1:  0.43837    1:  -0.43837       .              .
    .              .

    U U            M-2 n          /              I T
How can the angle be the same? The answer is that the / operation loses information about the signs of its inputs. Because the quotient is negative, we know exactly one of the inputs was negative, but we can’t tell which one. There is an f T [arctan2] function which computes the inverse tangent of the quotient of a pair of numbers. Since you feed it the two original numbers, it has enough information to give you a full 360-degree answer.

2:  0.89879    1:  116.       3:  116.       2:  116.       1:  180.
1:  -0.43837       .          2:  -0.89879   1:  -64.           .
    .                         1:  0.43837        .
                                  .

    U U            f T         M-RET M-2 n       f T            -
The resulting angles differ by 180 degrees; in other words, they point in opposite directions, just as we would expect.

The META-RET we used in the third step is the “last-arguments” command. It is sort of like Undo, except that it restores the arguments of the last command to the stack without removing the command’s result. It is useful in situations like this one, where we need to do several operations on the same inputs. We could have accomplished the same thing by using M-2 RET to duplicate the top two stack elements right after the U U, then a pair of M-TAB commands to cycle the 116 up around the duplicates.

A similar identity is supposed to hold for hyperbolic sines and cosines, except that it is the difference ‘cosh(x)^2 - sinh(x)^2’ that always equals one. Let’s try to verify this identity.

2:  -64        2:  -64        2:  -64        2:  9.7192e54  2:  9.7192e54
1:  -64        1:  3.1175e27  1:  9.7192e54  1:  -64        1:  9.7192e54
    .              .              .              .              .

 64 n RET RET      H C            2 ^            TAB            H S 2 ^
Something’s obviously wrong, because when we subtract these numbers the answer will clearly be zero! But if you think about it, if these numbers did differ by one, it would be in the 55th decimal place. The difference we seek has been lost entirely to roundoff error.

We could verify this hypothesis by doing the actual calculation with, say, 60 decimal places of precision. This will be slow, but not enormously so. Try it if you wish; sure enough, the answer is 0.99999, reasonably close to 1.

Of course, a more reasonable way to verify the identity is to use a more reasonable value for ‘x’!

Some Calculator commands use the Hyperbolic prefix for other purposes. The logarithm and exponential functions, for example, work to the base ‘e’ normally but use base-10 instead if you use the Hyperbolic prefix.

1:  1000       1:  6.9077     1:  1000       1:  3
    .              .              .              .

    1000           L              U              H L
First, we mistakenly compute a natural logarithm. Then we undo and compute a common logarithm instead.

The B key computes a general base-b logarithm for any value of b.

2:  1000       1:  3          1:  1000.      2:  1000.      1:  6.9077
1:  10             .              .          1:  2.71828        .
    .                                            .

 1000 RET 10       B              H E            H P            B
Here we first use B to compute the base-10 logarithm, then use the “hyperbolic” exponential as a cheap hack to recover the number 1000, then use B again to compute the natural logarithm. Note that P with the hyperbolic prefix pushes the constant ‘e’ onto the stack.

You may have noticed that both times we took the base-10 logarithm of 1000, we got an exact integer result. Calc always tries to give an exact rational result for calculations involving rational numbers where possible. But when we used H E, the result was a floating-point number for no apparent reason. In fact, if we had computed 10 RET 3 ^ we would have gotten an exact integer 1000. But the H E command is rigged to generate a floating-point result all of the time so that 1000 H E will not waste time computing a thousand-digit integer when all you probably wanted was ‘1e1000’.

(•) Exercise 2. Find a pair of integer inputs to the B command for which Calc could find an exact rational result but doesn’t. See 2. (•)

The Calculator also has a set of functions relating to combinatorics and statistics. You may be familiar with the factorial function, which computes the product of all the integers up to a given number.

1:  100        1:  93326215443...    1:  100.       1:  9.3326e157
    .              .                     .              .

    100            !                     U c f          !
Recall, the c f command converts the integer or fraction at the top of the stack to floating-point format. If you take the factorial of a floating-point number, you get a floating-point result accurate to the current precision. But if you give ! an exact integer, you get an exact integer result (158 digits long in this case).

If you take the factorial of a non-integer, Calc uses a generalized factorial function defined in terms of Euler’s Gamma function ‘gamma(n)’ (which is itself available as the f g command).

3:  4.         3:  24.               1:  5.5        1:  52.342777847
2:  4.5        2:  52.3427777847         .              .
1:  5.         1:  120.
    .              .

                   M-3 !              M-0 DEL 5.5       f g
Here we verify the identity ‘n! = gamma(n+1)’.

The binomial coefficient n-choose-m is defined by ‘n! / m! (n-m)!’ for all reals ‘n’ and ‘m’. The intermediate results in this formula can become quite large even if the final result is small; the k c command computes a binomial coefficient in a way that avoids large intermediate values.

The k prefix key defines several common functions out of combinatorics and number theory. Here we compute the binomial coefficient 30-choose-20, then determine its prime factorization.

2:  30         1:  30045015   1:  [3, 3, 5, 7, 11, 13, 23, 29]
1:  20             .              .
    .

 30 RET 20         k c            k f
You can verify these prime factors by using V R * to multiply together the elements of this vector. The result is the original number, 30045015.

Suppose a program you are writing needs a hash table with at least 10000 entries. It’s best to use a prime number as the actual size of a hash table. Calc can compute the next prime number after 10000:

1:  10000      1:  10007      1:  9973
    .              .              .

    10000          k n            I k n
Just for kicks we’ve also computed the next prime less than 10000.

See Financial Functions, for a description of the Calculator commands that deal with business and financial calculations (functions like pv, rate, and sln).

See Binary Number Functions, to read about the commands for operating on binary numbers (like and, xor, and lsh).


*** Vector/Matrix Tutorial

A vector is a list of numbers or other Calc data objects. Calc provides a large set of commands that operate on vectors. Some are familiar operations from vector analysis. Others simply treat a vector as a list of objects.

**** Vector Analysis
If you add two vectors, the result is a vector of the sums of the elements, taken pairwise.

1:  [1, 2, 3]     2:  [1, 2, 3]     1:  [8, 8, 3]
    .             1:  [7, 6, 0]         .
                      .

    [1,2,3]  s 1      [7 6 0]  s 2      +
Note that we can separate the vector elements with either commas or spaces. This is true whether we are using incomplete vectors or algebraic entry. The s 1 and s 2 commands save these vectors so we can easily reuse them later.

If you multiply two vectors, the result is the sum of the products of the elements taken pairwise. This is called the dot product of the vectors.

2:  [1, 2, 3]     1:  19
1:  [7, 6, 0]         .
    .

    r 1 r 2           *
The dot product of two vectors is equal to the product of their lengths times the cosine of the angle between them. (Here the vector is interpreted as a line from the origin ‘(0,0,0)’ to the specified point in three-dimensional space.) The A (absolute value) command can be used to compute the length of a vector.

3:  19            3:  19          1:  0.550782    1:  56.579
2:  [1, 2, 3]     2:  3.741657        .               .
1:  [7, 6, 0]     1:  9.219544
    .                 .

    M-RET             M-2 A          * /             I C
First we recall the arguments to the dot product command, then we compute the absolute values of the top two stack entries to obtain the lengths of the vectors, then we divide the dot product by the product of the lengths to get the cosine of the angle. The inverse cosine finds that the angle between the vectors is about 56 degrees.

The cross product of two vectors is a vector whose length is the product of the lengths of the inputs times the sine of the angle between them, and whose direction is perpendicular to both input vectors. Unlike the dot product, the cross product is defined only for three-dimensional vectors. Let’s double-check our computation of the angle using the cross product.

2:  [1, 2, 3]  3:  [-18, 21, -8]  1:  [-0.52, 0.61, -0.23]  1:  56.579
1:  [7, 6, 0]  2:  [1, 2, 3]          .                         .
    .          1:  [7, 6, 0]
                   .

    r 1 r 2        V C  s 3  M-RET    M-2 A * /                 A I S
First we recall the original vectors and compute their cross product, which we also store for later reference. Now we divide the vector by the product of the lengths of the original vectors. The length of this vector should be the sine of the angle; sure enough, it is!

Vector-related commands generally begin with the v prefix key. Some are uppercase letters and some are lowercase. To make it easier to type these commands, the shift-V prefix key acts the same as the v key. (See General Mode Commands, for a way to make all prefix keys have this property.)

If we take the dot product of two perpendicular vectors we expect to get zero, since the cosine of 90 degrees is zero. Let’s check that the cross product is indeed perpendicular to both inputs:

2:  [1, 2, 3]      1:  0          2:  [7, 6, 0]      1:  0
1:  [-18, 21, -8]      .          1:  [-18, 21, -8]      .
    .                                 .

    r 1 r 3            *          DEL r 2 r 3            *
(•) Exercise 1. Given a vector on the top of the stack, what keystrokes would you use to normalize the vector, i.e., to reduce its length to one without changing its direction? See 1. (•)

(•) Exercise 2. Suppose a certain particle can be at any of several positions along a ruler. You have a list of those positions in the form of a vector, and another list of the probabilities for the particle to be at the corresponding positions. Find the average position of the particle. See 2. (•)


**** Matrices

A matrix is just a vector of vectors, all the same length. This means you can enter a matrix using nested brackets. You can also use the semicolon character to enter a matrix. We’ll show both methods here:

1:  [ [ 1, 2, 3 ]             1:  [ [ 1, 2, 3 ]
      [ 4, 5, 6 ] ]                 [ 4, 5, 6 ] ]
    .                             .

  [[1 2 3] [4 5 6]]             ' [1 2 3; 4 5 6] RET
We’ll be using this matrix again, so type s 4 to save it now.

Note that semicolons work with incomplete vectors, but they work better in algebraic entry. That’s why we use the apostrophe in the second example.

When two matrices are multiplied, the lefthand matrix must have the same number of columns as the righthand matrix has rows. Row ‘i’, column ‘j’ of the result is effectively the dot product of row ‘i’ of the left matrix by column ‘j’ of the right matrix.

If we try to duplicate this matrix and multiply it by itself, the dimensions are wrong and the multiplication cannot take place:

1:  [ [ 1, 2, 3 ]   * [ [ 1, 2, 3 ]
      [ 4, 5, 6 ] ]     [ 4, 5, 6 ] ]
    .

    RET *
Though rather hard to read, this is a formula which shows the product of two matrices. The ‘*’ function, having invalid arguments, has been left in symbolic form.

We can multiply the matrices if we transpose one of them first.

2:  [ [ 1, 2, 3 ]       1:  [ [ 14, 32 ]      1:  [ [ 17, 22, 27 ]
      [ 4, 5, 6 ] ]           [ 32, 77 ] ]          [ 22, 29, 36 ]
1:  [ [ 1, 4 ]              .                       [ 27, 36, 45 ] ]
      [ 2, 5 ]                                    .
      [ 3, 6 ] ]
    .

    U v t                   *                     U TAB *
Matrix multiplication is not commutative; indeed, switching the order of the operands can even change the dimensions of the result matrix, as happened here!

If you multiply a plain vector by a matrix, it is treated as a single row or column depending on which side of the matrix it is on. The result is a plain vector which should also be interpreted as a row or column as appropriate.

2:  [ [ 1, 2, 3 ]      1:  [14, 32]
      [ 4, 5, 6 ] ]        .
1:  [1, 2, 3]
    .

    r 4 r 1                *
Multiplying in the other order wouldn’t work because the number of rows in the matrix is different from the number of elements in the vector.

(•) Exercise 1. Use ‘*’ to sum along the rows of the above 2x3 matrix to get ‘[6, 15]’. Now use ‘*’ to sum along the columns to get ‘[5, 7, 9]’. See 1. (•)

An identity matrix is a square matrix with ones along the diagonal and zeros elsewhere. It has the property that multiplication by an identity matrix, on the left or on the right, always produces the original matrix.

1:  [ [ 1, 2, 3 ]      2:  [ [ 1, 2, 3 ]      1:  [ [ 1, 2, 3 ]
      [ 4, 5, 6 ] ]          [ 4, 5, 6 ] ]          [ 4, 5, 6 ] ]
    .                  1:  [ [ 1, 0, 0 ]          .
                             [ 0, 1, 0 ]
                             [ 0, 0, 1 ] ]
                           .

    r 4                    v i 3 RET              *
If a matrix is square, it is often possible to find its inverse, that is, a matrix which, when multiplied by the original matrix, yields an identity matrix. The & (reciprocal) key also computes the inverse of a matrix.

1:  [ [ 1, 2, 3 ]      1:  [ [   -2.4,     1.2,   -0.2 ]
      [ 4, 5, 6 ]            [    2.8,    -1.4,    0.4 ]
      [ 7, 6, 0 ] ]          [ -0.73333, 0.53333, -0.2 ] ]
    .                      .

    r 4 r 2 |  s 5         &
The vertical bar | concatenates numbers, vectors, and matrices together. Here we have used it to add a new row onto our matrix to make it square.

We can multiply these two matrices in either order to get an identity.

1:  [ [ 1., 0., 0. ]      1:  [ [ 1., 0., 0. ]
      [ 0., 1., 0. ]            [ 0., 1., 0. ]
      [ 0., 0., 1. ] ]          [ 0., 0., 1. ] ]
    .                         .

    M-RET  *                  U TAB *
Matrix inverses are related to systems of linear equations in algebra. Suppose we had the following set of equations:

    a + 2b + 3c = 6
   4a + 5b + 6c = 2
   7a + 6b      = 3
This can be cast into the matrix equation,

   [ [ 1, 2, 3 ]     [ [ a ]     [ [ 6 ]
     [ 4, 5, 6 ]   *   [ b ]   =   [ 2 ]
     [ 7, 6, 0 ] ]     [ c ] ]     [ 3 ] ]
We can solve this system of equations by multiplying both sides by the inverse of the matrix. Calc can do this all in one step:

2:  [6, 2, 3]          1:  [-12.6, 15.2, -3.93333]
1:  [ [ 1, 2, 3 ]          .
      [ 4, 5, 6 ]
      [ 7, 6, 0 ] ]
    .

    [6,2,3] r 5            /
The result is the ‘[a, b, c]’ vector that solves the equations. (Dividing by a square matrix is equivalent to multiplying by its inverse.)

Let’s verify this solution:

2:  [ [ 1, 2, 3 ]                1:  [6., 2., 3.]
      [ 4, 5, 6 ]                    .
      [ 7, 6, 0 ] ]
1:  [-12.6, 15.2, -3.93333]
    .

    r 5  TAB                         *
Note that we had to be careful about the order in which we multiplied the matrix and vector. If we multiplied in the other order, Calc would assume the vector was a row vector in order to make the dimensions come out right, and the answer would be incorrect. If you don’t feel safe letting Calc take either interpretation of your vectors, use explicit Nx1 or 1xN matrices instead. In this case, you would enter the original column vector as ‘[[6], [2], [3]]’ or ‘[6; 2; 3]’.

(•) Exercise 2. Algebraic entry allows you to make vectors and matrices that include variables. Solve the following system of equations to get expressions for ‘x’ and ‘y’ in terms of ‘a’ and ‘b’.

   x + a y = 6
   x + b y = 10
See 2. (•)

(•) Exercise 3. A system of equations is “over-determined” if it has more equations than variables. It is often the case that there are no values for the variables that will satisfy all the equations at once, but it is still useful to find a set of values which “nearly” satisfy all the equations. In terms of matrix equations, you can’t solve ‘A X = B’ directly because the matrix ‘A’ is not square for an over-determined system. Matrix inversion works only for square matrices. One common trick is to multiply both sides on the left by the transpose of ‘A’: ‘trn(A)*A*X = trn(A)*B’. Now ‘trn(A)*A’ is a square matrix so a solution is possible. It turns out that the ‘X’ vector you compute in this way will be a “least-squares” solution, which can be regarded as the “closest” solution to the set of equations. Use Calc to solve the following over-determined system:

    a + 2b + 3c = 6
   4a + 5b + 6c = 2
   7a + 6b      = 3
   2a + 4b + 6c = 11
See 3. (•)


**** Vectors as Lists

Although Calc has a number of features for manipulating vectors and matrices as mathematical objects, you can also treat vectors as simple lists of values. For example, we saw that the k f command returns a vector which is a list of the prime factors of a number.

You can pack and unpack stack entries into vectors:

3:  10         1:  [10, 20, 30]     3:  10
2:  20             .                2:  20
1:  30                              1:  30
    .                                   .

                   M-3 v p              v u
You can also build vectors out of consecutive integers, or out of many copies of a given value:

1:  [1, 2, 3, 4]    2:  [1, 2, 3, 4]    2:  [1, 2, 3, 4]
    .               1:  17              1:  [17, 17, 17, 17]
                        .                   .

    v x 4 RET           17                  v b 4 RET
You can apply an operator to every element of a vector using the map command.

1:  [17, 34, 51, 68]   1:  [289, 1156, 2601, 4624]  1:  [17, 34, 51, 68]
    .                      .                            .

    V M *                  2 V M ^                      V M Q
In the first step, we multiply the vector of integers by the vector of 17’s elementwise. In the second step, we raise each element to the power two. (The general rule is that both operands must be vectors of the same length, or else one must be a vector and the other a plain number.) In the final step, we take the square root of each element.

(•) Exercise 1. Compute a vector of powers of two from ‘2^-4’ to ‘2^4’. See 1. (•)

You can also reduce a binary operator across a vector. For example, reducing ‘*’ computes the product of all the elements in the vector:

1:  123123     1:  [3, 7, 11, 13, 41]      1:  123123
    .              .                           .

    123123         k f                         V R *
In this example, we decompose 123123 into its prime factors, then multiply those factors together again to yield the original number.

We could compute a dot product “by hand” using mapping and reduction:

2:  [1, 2, 3]     1:  [7, 12, 0]     1:  19
1:  [7, 6, 0]         .                  .
    .

    r 1 r 2           V M *              V R +
Recalling two vectors from the previous section, we compute the sum of pairwise products of the elements to get the same answer for the dot product as before.

A slight variant of vector reduction is the accumulate operation, V U. This produces a vector of the intermediate results from a corresponding reduction. Here we compute a table of factorials:

1:  [1, 2, 3, 4, 5, 6]    1:  [1, 2, 6, 24, 120, 720]
    .                         .

    v x 6 RET                 V U *
Calc allows vectors to grow as large as you like, although it gets rather slow if vectors have more than about a hundred elements. Actually, most of the time is spent formatting these large vectors for display, not calculating on them. Try the following experiment (if your computer is very fast you may need to substitute a larger vector size).

1:  [1, 2, 3, 4, ...      1:  [2, 3, 4, 5, ...
    .                         .

    v x 500 RET               1 V M +
Now press v . (the letter v, then a period) and try the experiment again. In v . mode, long vectors are displayed “abbreviated” like this:

1:  [1, 2, 3, ..., 500]   1:  [2, 3, 4, ..., 501]
    .                         .

    v x 500 RET               1 V M +
(where now the ‘...’ is actually part of the Calc display). You will find both operations are now much faster. But notice that even in v . mode, the full vectors are still shown in the Trail. Type t . to cause the trail to abbreviate as well, and try the experiment one more time. Operations on long vectors are now quite fast! (But of course if you use t . you will lose the ability to get old vectors back using the t y command.)

An easy way to view a full vector when v . mode is active is to press ` (grave accent) to edit the vector; editing always works with the full, unabbreviated value.

As a larger example, let’s try to fit a straight line to some data, using the method of least squares. (Calc has a built-in command for least-squares curve fitting, but we’ll do it by hand here just to practice working with vectors.) Suppose we have the following list of values in a file we have loaded into Emacs:

  x        y
 ---      ---
 1.34    0.234
 1.41    0.298
 1.49    0.402
 1.56    0.412
 1.64    0.466
 1.73    0.473
 1.82    0.601
 1.91    0.519
 2.01    0.603
 2.11    0.637
 2.22    0.645
 2.33    0.705
 2.45    0.917
 2.58    1.009
 2.71    0.971
 2.85    1.062
 3.00    1.148
 3.15    1.157
 3.32    1.354
If you are reading this tutorial in printed form, you will find it easiest to press C-x * i to enter the on-line Info version of the manual and find this table there. (Press g, then type List Tutorial, to jump straight to this section.)

Position the cursor at the upper-left corner of this table, just to the left of the ‘1.34’. Press C-@ to set the mark. (On your system this may be C-2, C-SPC, or NUL.) Now position the cursor to the lower-right, just after the ‘1.354’. You have now defined this region as an Emacs “rectangle.” Still in the Info buffer, type C-x * r. This command (calc-grab-rectangle) will pop you back into the Calculator, with the contents of the rectangle you specified in the form of a matrix.

1:  [ [ 1.34, 0.234 ]
      [ 1.41, 0.298 ]
      …
(You may wish to use v . mode to abbreviate the display of this large matrix.)

We want to treat this as a pair of lists. The first step is to transpose this matrix into a pair of rows. Remember, a matrix is just a vector of vectors. So we can unpack the matrix into a pair of row vectors on the stack.

1:  [ [ 1.34,  1.41,  1.49,  ... ]     2:  [1.34, 1.41, 1.49, ... ]
      [ 0.234, 0.298, 0.402, ... ] ]   1:  [0.234, 0.298, 0.402, ... ]
    .                                      .

    v t                                    v u
Let’s store these in quick variables 1 and 2, respectively.

1:  [1.34, 1.41, 1.49, ... ]        .
    .

    t 2                             t 1
(Recall that t 2 is a variant of s 2 that removes the stored value from the stack.)

In a least squares fit, the slope ‘m’ is given by the formula

m = (N sum(x y) - sum(x) sum(y)) / (N sum(x^2) - sum(x)^2)
where ‘sum(x)’ represents the sum of all the values of ‘x’. While there is an actual sum function in Calc, it’s easier to sum a vector using a simple reduction. First, let’s compute the four different sums that this formula uses.

1:  41.63                 1:  98.0003
    .                         .

 r 1 V R +   t 3           r 1 2 V M ^ V R +   t 4

1:  13.613                1:  33.36554
    .                         .

 r 2 V R +   t 5           r 1 r 2 V M * V R +   t 6
These are ‘sum(x)’, ‘sum(x^2)’, ‘sum(y)’, and ‘sum(x y)’, respectively. (We could have used * to compute ‘sum(x^2)’ and ‘sum(x y)’.)

Finally, we also need ‘N’, the number of data points. This is just the length of either of our lists.

1:  19
    .

 r 1 v l   t 7
(That’s v followed by a lower-case l.)

Now we grind through the formula:

1:  633.94526  2:  633.94526  1:  67.23607
    .          1:  566.70919      .
                   .

 r 7 r 6 *      r 3 r 5 *         -

2:  67.23607   3:  67.23607   2:  67.23607   1:  0.52141679
1:  1862.0057  2:  1862.0057  1:  128.9488       .
    .          1:  1733.0569      .
                   .

 r 7 r 4 *      r 3 2 ^           -              /   t 8
That gives us the slope ‘m’. The y-intercept ‘b’ can now be found with the simple formula,

b = (sum(y) - m sum(x)) / N
1:  13.613     2:  13.613     1:  -8.09358   1:  -0.425978
    .          1:  21.70658       .              .
                   .

   r 5            r 8 r 3 *       -              r 7 /   t 9
Let’s “plot” this straight line approximation, ‘m x + b’, and compare it with the original data.

1:  [0.699, 0.735, ... ]    1:  [0.273, 0.309, ... ]
    .                           .

    r 1 r 8 *                   r 9 +    s 0
Notice that multiplying a vector by a constant, and adding a constant to a vector, can be done without mapping commands since these are common operations from vector algebra. As far as Calc is concerned, we’ve just been doing geometry in 19-dimensional space!

We can subtract this vector from our original ‘y’ vector to get a feel for the error of our fit. Let’s find the maximum error:

1:  [0.0387, 0.0112, ... ]   1:  [0.0387, 0.0112, ... ]   1:  0.0897
    .                            .                            .

    r 2 -                        V M A                        V R X
First we compute a vector of differences, then we take the absolute values of these differences, then we reduce the max function across the vector. (The max function is on the two-key sequence f x; because it is so common to use max in a vector operation, the letters X and N are also accepted for max and min in this context. In general, you answer the V M or V R prompt with the actual key sequence that invokes the function you want. You could have typed V R f x or even V R x max RET if you had preferred.)

If your system has the GNUPLOT program, you can see graphs of your data and your straight line to see how well they match. (If you have GNUPLOT 3.0 or higher, the following instructions will work regardless of the kind of display you have. Some GNUPLOT 2.0, non-X-windows systems may require additional steps to view the graphs.)

Let’s start by plotting the original data. Recall the “x” and “y” vectors onto the stack and press g f. This “fast” graphing command does everything you need to do for simple, straightforward plotting of data.

2:  [1.34, 1.41, 1.49, ... ]
1:  [0.234, 0.298, 0.402, ... ]
    .

    r 1 r 2    g f
If all goes well, you will shortly get a new window containing a graph of the data. (If not, contact your GNUPLOT or Calc installer to find out what went wrong.) In the X window system, this will be a separate graphics window. For other kinds of displays, the default is to display the graph in Emacs itself using rough character graphics. Press q when you are done viewing the character graphics.

Next, let’s add the line we got from our least-squares fit.

2:  [1.34, 1.41, 1.49, ... ]
1:  [0.273, 0.309, 0.351, ... ]
    .

    DEL r 0    g a  g p
It’s not very useful to get symbols to mark the data points on this second curve; you can type g S g p to remove them. Type g q when you are done to remove the X graphics window and terminate GNUPLOT.

(•) Exercise 2. An earlier exercise showed how to do least squares fitting to a general system of equations. Our 19 data points are really 19 equations of the form ‘y_i = m x_i + b’ for different pairs of ‘(x_i,y_i)’. Use the matrix-transpose method to solve for ‘m’ and ‘b’, duplicating the above result. See 2. (•)

(•) Exercise 3. If the input data do not form a rectangle, you can use C-x * g (calc-grab-region) to grab the data the way Emacs normally works with regions—it reads left-to-right, top-to-bottom, treating line breaks the same as spaces. Use this command to find the geometric mean of the following numbers. (The geometric mean is the nth root of the product of n numbers.)

2.3  6  22  15.1  7
  15  14  7.5
  2.5
The C-x * g command accepts numbers separated by spaces or commas, with or without surrounding vector brackets. See 3. (•)

As another example, a theorem about binomial coefficients tells us that the alternating sum of binomial coefficients n-choose-0 minus n-choose-1 plus n-choose-2, and so on up to n-choose-n, always comes out to zero. Let’s verify this for ‘n=6’.

1:  [1, 2, 3, 4, 5, 6, 7]     1:  [0, 1, 2, 3, 4, 5, 6]
    .                             .

    v x 7 RET                     1 -

1:  [1, -6, 15, -20, 15, -6, 1]          1:  0
    .                                        .

    V M ' (-1)^$ choose(6,$) RET             V R +
The V M ' command prompts you to enter any algebraic expression to define the function to map over the vector. The symbol ‘$’ inside this expression represents the argument to the function. The Calculator applies this formula to each element of the vector, substituting each element’s value for the ‘$’ sign(s) in turn.

To define a two-argument function, use ‘$$’ for the first argument and ‘$’ for the second: V M ' $$-$ RET is equivalent to V M -. This is analogous to regular algebraic entry, where ‘$$’ would refer to the next-to-top stack entry and ‘$’ would refer to the top stack entry, and ' $$-$ RET would act exactly like -.

Notice that the V M ' command has recorded two things in the trail: The result, as usual, and also a funny-looking thing marked ‘oper’ that represents the operator function you typed in. The function is enclosed in ‘< >’ brackets, and the argument is denoted by a ‘#’ sign. If there were several arguments, they would be shown as ‘#1’, ‘#2’, and so on. (For example, V M ' $$-$ will put the function ‘<#1 - #2>’ on the trail.) This object is a “nameless function”; you can use nameless ‘< >’ notation to answer the V M ' prompt if you like. Nameless function notation has the interesting, occasionally useful property that a nameless function is not actually evaluated until it is used. For example, V M ' $+random(2.0) evaluates ‘random(2.0)’ once and adds that random number to all elements of the vector, but V M ' <#+random(2.0)> evaluates the ‘random(2.0)’ separately for each vector element.

Another group of operators that are often useful with V M are the relational operators: a =, for example, compares two numbers and gives the result 1 if they are equal, or 0 if not. Similarly, a < checks for one number being less than another.

Other useful vector operations include v v, to reverse a vector end-for-end; V S, to sort the elements of a vector into increasing order; and v r and v c, to extract one row or column of a matrix, or (in both cases) to extract one element of a plain vector. With a negative argument, v r and v c instead delete one row, column, or vector element.

(•) Exercise 4. The ‘k’th divisor function is the sum of the ‘k’th powers of all the divisors of an integer ‘n’. Figure out a method for computing the divisor function for reasonably small values of ‘n’. As a test, the 0th and 1st divisor functions of 30 are 8 and 72, respectively. See 4. (•)

(•) Exercise 5. The k f command produces a list of prime factors for a number. Sometimes it is important to know that a number is square-free, i.e., that no prime occurs more than once in its list of prime factors. Find a sequence of keystrokes to tell if a number is square-free; your method should leave 1 on the stack if it is, or 0 if it isn’t. See 5. (•)

(•) Exercise 6. Build a list of lists that looks like the following diagram. (You may wish to use the v / command to enable multi-line display of vectors.)

1:  [ [1],
      [1, 2],
      [1, 2, 3],
      [1, 2, 3, 4],
      [1, 2, 3, 4, 5],
      [1, 2, 3, 4, 5, 6] ]
See 6. (•)

(•) Exercise 7. Build the following list of lists.

1:  [ [0],
      [1, 2],
      [3, 4, 5],
      [6, 7, 8, 9],
      [10, 11, 12, 13, 14],
      [15, 16, 17, 18, 19, 20] ]
See 7. (•)

(•) Exercise 8. Compute a list of values of Bessel’s ‘J1’ function ‘besJ(1,x)’ for ‘x’ from 0 to 5 in steps of 0.25. Find the value of ‘x’ (from among the above set of values) for which ‘besJ(1,x)’ is a maximum. Use an “automatic” method, i.e., just reading along the list by hand to find the largest value is not allowed! (There is an a X command which does this kind of thing automatically; see Numerical Solutions.) See 8. (•)

(•) Exercise 9. You are given an integer in the range ‘0 <= N < 10^m’ for ‘m=12’ (i.e., an integer of less than twelve digits). Convert this integer into a vector of ‘m’ digits, each in the range from 0 to 9. In vector-of-digits notation, add one to this integer to produce a vector of ‘m+1’ digits (since there could be a carry out of the most significant digit). Convert this vector back into a regular integer. A good integer to try is 25129925999. See 9. (•)

(•) Exercise 10. Your friend Joe tried to use V R a = to test if all numbers in a list were equal. What happened? How would you do this test? See 10. (•)

(•) Exercise 11. The area of a circle of radius one is ‘pi’. The area of the 2x2 square that encloses that circle is 4. So if we throw n darts at random points in the square, about ‘pi/4’ of them will land inside the circle. This gives us an entertaining way to estimate the value of ‘pi’. The k r command picks a random number between zero and the value on the stack. We could get a random floating-point number between -1 and 1 by typing 2.0 k r 1 -. Build a vector of 100 random ‘(x,y)’ points in this square, then use vector mapping and reduction to count how many points lie inside the unit circle. Hint: Use the v b command. See 11. (•)

(•) Exercise 12. The matchstick problem provides another way to calculate ‘pi’. Say you have an infinite field of vertical lines with a spacing of one inch. Toss a one-inch matchstick onto the field. The probability that the matchstick will land crossing a line turns out to be ‘2/pi’. Toss 100 matchsticks to estimate ‘pi’. (If you want still more fun, the probability that the GCD (k g) of two large integers is one turns out to be ‘6/pi^2’. That provides yet another way to estimate ‘pi’.) See 12. (•)

(•) Exercise 13. An algebraic entry of a string in double-quote marks, ‘"hello"’, creates a vector of the numerical (ASCII) codes of the characters (here, ‘[104, 101, 108, 108, 111]’). Sometimes it is convenient to compute a hash code of a string, which is just an integer that represents the value of that string. Two equal strings have the same hash code; two different strings probably have different hash codes. (For example, Calc has over 400 function names, but Emacs can quickly find the definition for any given name because it has sorted the functions into “buckets” by their hash codes. Sometimes a few names will hash into the same bucket, but it is easier to search among a few names than among all the names.) One popular hash function is computed as follows: First set ‘h = 0’. Then, for each character from the string in turn, set ‘h = 3h + c_i’ where ‘c_i’ is the character’s ASCII code. If we have 511 buckets, we then take the hash code modulo 511 to get the bucket number. Develop a simple command or commands for converting string vectors into hash codes. The hash code for ‘"Testing, 1, 2, 3"’ is 1960915098, which modulo 511 is 121. See 13. (•)

(•) Exercise 14. The H V R and H V U commands do nested function evaluations. H V U takes a starting value and a number of steps n from the stack; it then applies the function you give to the starting value 0, 1, 2, up to n times and returns a vector of the results. Use this command to create a “random walk” of 50 steps. Start with the two-dimensional point ‘(0,0)’; then take one step a random distance between -1 and 1 in both ‘x’ and ‘y’; then take another step, and so on. Use the g f command to display this random walk. Now modify your random walk to walk a unit distance, but in a random direction, at each step. (Hint: The sincos function returns a vector of the cosine and sine of an angle.) See 14. (•)


*** Types Tutorial

Calc understands a variety of data types as well as simple numbers. In this section, we’ll experiment with each of these types in turn.

The numbers we’ve been using so far have mainly been either integers or floats. We saw that floats are usually a good approximation to the mathematical concept of real numbers, but they are only approximations and are susceptible to roundoff error. Calc also supports fractions, which can exactly represent any rational number.

1:  3628800    2:  3628800    1:  518400:7   1:  518414:7   1:  7:518414
    .          1:  49             .              .              .
                   .

    10 !           49 RET         :              2 +            &
The : command divides two integers to get a fraction; / would normally divide integers to get a floating-point result. Notice we had to type RET between the 49 and the : since the : would otherwise be interpreted as part of a fraction beginning with 49.

You can convert between floating-point and fractional format using c f and c F:

1:  1.35027217629e-5    1:  7:518414
    .                       .

    c f                     c F
The c F command replaces a floating-point number with the “simplest” fraction whose floating-point representation is the same, to within the current precision.

1:  3.14159265359   1:  1146408:364913   1:  3.1416   1:  355:113
    .                   .                    .            .

    P                   c F      DEL       p 5 RET P      c F
(•) Exercise 1. A calculation has produced the result 1.26508260337. You suspect it is the square root of the product of ‘pi’ and some rational number. Is it? (Be sure to allow for roundoff error!) See 1. (•)

Complex numbers can be stored in both rectangular and polar form.

1:  -9     1:  (0, 3)    1:  (3; 90.)   1:  (6; 90.)   1:  (2.4495; 45.)
    .          .             .              .              .

    9 n        Q             c p            2 *            Q
The square root of -9 is by default rendered in rectangular form (‘0 + 3i’), but we can convert it to polar form (3 with a phase angle of 90 degrees). All the usual arithmetic and scientific operations are defined on both types of complex numbers.

Another generalized kind of number is infinity. Infinity isn’t really a number, but it can sometimes be treated like one. Calc uses the symbol inf to represent positive infinity, i.e., a value greater than any real number. Naturally, you can also write ‘-inf’ for minus infinity, a value less than any real number. The word inf can only be input using algebraic entry.

2:  inf        2:  -inf       2:  -inf       2:  -inf       1:  nan
1:  -17        1:  -inf       1:  -inf       1:  inf            .
    .              .              .              .

' inf RET 17 n     *  RET         72 +           A              +
Since infinity is infinitely large, multiplying it by any finite number (like -17) has no effect, except that since -17 is negative, it changes a plus infinity to a minus infinity. (“A huge positive number, multiplied by -17, yields a huge negative number.”) Adding any finite number to infinity also leaves it unchanged. Taking an absolute value gives us plus infinity again. Finally, we add this plus infinity to the minus infinity we had earlier. If you work it out, you might expect the answer to be -72 for this. But the 72 has been completely lost next to the infinities; by the time we compute ‘inf - inf’ the finite difference between them, if any, is undetectable. So we say the result is indeterminate, which Calc writes with the symbol nan (for Not A Number).

Dividing by zero is normally treated as an error, but you can get Calc to write an answer in terms of infinity by pressing m i to turn on Infinite mode.

3:  nan        2:  nan        2:  nan        2:  nan        1:  nan
2:  1          1:  1 / 0      1:  uinf       1:  uinf           .
1:  0              .              .              .
    .

  1 RET 0          /       m i    U /            17 n *         +
Dividing by zero normally is left unevaluated, but after m i it instead gives an infinite result. The answer is actually uinf, “undirected infinity.” If you look at a graph of ‘1 / x’ around ‘x = 0’, you’ll see that it goes toward plus infinity as you approach zero from above, but toward minus infinity as you approach from below. Since we said only ‘1 / 0’, Calc knows that the answer is infinite but not in which direction. That’s what uinf means. Notice that multiplying uinf by a negative number still leaves plain uinf; there’s no point in saying ‘-uinf’ because the sign of uinf is unknown anyway. Finally, we add uinf to our nan, yielding nan again. It’s easy to see that, because nan means “totally unknown” while uinf means “unknown sign but known to be infinite,” the more mysterious nan wins out when it is combined with uinf, or, for that matter, with anything else.

(•) Exercise 2. Predict what Calc will answer for each of these formulas: ‘inf / inf’, ‘exp(inf)’, ‘exp(-inf)’, ‘sqrt(-inf)’, ‘sqrt(uinf)’, ‘abs(uinf)’, ‘ln(0)’. See 2. (•)

(•) Exercise 3. We saw that ‘inf - inf = nan’, which stands for an unknown value. Can nan stand for a complex number? Can it stand for infinity? See 3. (•)

HMS forms represent a value in terms of hours, minutes, and seconds.

1:  2@ 30' 0"     1:  3@ 30' 0"     2:  3@ 30' 0"     1:  2.
    .                 .             1:  1@ 45' 0."        .
                                        .

  2@ 30' RET          1 +               RET 2 /           /
HMS forms can also be used to hold angles in degrees, minutes, and seconds.

1:  0.5        1:  26.56505   1:  26@ 33' 54.18"    1:  0.44721
    .              .              .                     .

    0.5            I T            c h                   S
First we convert the inverse tangent of 0.5 to degrees-minutes-seconds form, then we take the sine of that angle. Note that the trigonometric functions will accept HMS forms directly as input.

(•) Exercise 4. The Beatles’ Abbey Road is 47 minutes and 26 seconds long, and contains 17 songs. What is the average length of a song on Abbey Road? If the Extended Disco Version of Abbey Road added 20 seconds to the length of each song, how long would the album be? See 4. (•)

A date form represents a date, or a date and time. Dates must be entered using algebraic entry. Date forms are surrounded by ‘< >’ symbols; most standard formats for dates are recognized.

2:  <Sun Jan 13, 1991>                    1:  2.25
1:  <6:00pm Thu Jan 10, 1991>                 .
    .

' <13 Jan 1991>, <1/10/91, 6pm> RET           -
In this example, we enter two dates, then subtract to find the number of days between them. It is also possible to add an HMS form or a number (of days) to a date form to get another date form.

1:  <4:45:59pm Mon Jan 14, 1991>     1:  <2:50:59am Thu Jan 17, 1991>
    .                                    .

    t N                                  2 + 10@ 5' +
The t N (“now”) command pushes the current date and time on the stack; then we add two days, ten hours and five minutes to the date and time. Other date-and-time related commands include t J, which does Julian day conversions, t W, which finds the beginning of the week in which a date form lies, and t I, which increments a date by one or several months. See Date Arithmetic, for more.

(•) Exercise 5. How many days until the next Friday the 13th? See 5. (•)

(•) Exercise 6. How many leap years will there be between now and the year 10001 AD? See 6. (•)

An error form represents a mean value with an attached standard deviation, or error estimate. Suppose our measurements indicate that a certain telephone pole is about 30 meters away, with an estimated error of 1 meter, and 8 meters tall, with an estimated error of 0.2 meters. What is the slope of a line from here to the top of the pole, and what is the equivalent angle in degrees?

1:  8 +/- 0.2    2:  8 +/- 0.2   1:  0.266 +/- 0.011   1:  14.93 +/- 0.594
    .            1:  30 +/- 1        .                     .
                     .

    8 p .2 RET       30 p 1          /                     I T
This means that the angle is about 15 degrees, and, assuming our original error estimates were valid standard deviations, there is about a 60% chance that the result is correct within 0.59 degrees.

(•) Exercise 7. The volume of a torus (a donut shape) is ‘2 pi^2 R r^2’ where ‘R’ is the radius of the circle that defines the center of the tube and ‘r’ is the radius of the tube itself. Suppose ‘R’ is 20 cm and ‘r’ is 4 cm, each known to within 5 percent. What is the volume and the relative uncertainty of the volume? See 7. (•)

An interval form represents a range of values. While an error form is best for making statistical estimates, intervals give you exact bounds on an answer. Suppose we additionally know that our telephone pole is definitely between 28 and 31 meters away, and that it is between 7.7 and 8.1 meters tall.

1:  [7.7 .. 8.1]  2:  [7.7 .. 8.1]  1:  [0.24 .. 0.28]  1:  [13.9 .. 16.1]
    .             1:  [28 .. 31]        .                   .
                      .

  [ 7.7 .. 8.1 ]    [ 28 .. 31 ]        /                   I T
If our bounds were correct, then the angle to the top of the pole is sure to lie in the range shown.

The square brackets around these intervals indicate that the endpoints themselves are allowable values. In other words, the distance to the telephone pole is between 28 and 31, inclusive. You can also make an interval that is exclusive of its endpoints by writing parentheses instead of square brackets. You can even make an interval which is inclusive (“closed”) on one end and exclusive (“open”) on the other.

1:  [1 .. 10)    1:  (0.1 .. 1]   2:  (0.1 .. 1]   1:  (0.2 .. 3)
    .                .            1:  [2 .. 3)         .
                                      .

  [ 1 .. 10 )        &              [ 2 .. 3 )         *
The Calculator automatically keeps track of which end values should be open and which should be closed. You can also make infinite or semi-infinite intervals by using ‘-inf’ or ‘inf’ for one or both endpoints.

(•) Exercise 8. What answer would you expect from ‘1 / (0 .. 10)’? What about ‘1 / (-10 .. 0)’? What about ‘1 / [0 .. 10]’ (where the interval actually includes zero)? What about ‘1 / (-10 .. 10)’? See 8. (•)

(•) Exercise 9. Two easy ways of squaring a number are RET * and 2 ^. Normally these produce the same answer. Would you expect this still to hold true for interval forms? If not, which of these will result in a larger interval? See 9. (•)

A modulo form is used for performing arithmetic modulo m. For example, arithmetic involving time is generally done modulo 12 or 24 hours.

1:  17 mod 24    1:  3 mod 24     1:  21 mod 24    1:  9 mod 24
    .                .                .                .

    17 M 24 RET      10 +             n                5 /
In this last step, Calc has divided by 5 modulo 24; i.e., it has found a new number which, when multiplied by 5 modulo 24, produces the original number, 21. If m is prime and the divisor is not a multiple of m, it is always possible to find such a number. For non-prime m like 24, it is only sometimes possible.

1:  10 mod 24    1:  16 mod 24    1:  1000000...   1:  16
    .                .                .                .

    10 M 24 RET      100 ^            10 RET 100 ^     24 %
These two calculations get the same answer, but the first one is much more efficient because it avoids the huge intermediate value that arises in the second one.

(•) Exercise 10. A theorem of Pierre de Fermat says that ‘x^(n-1) mod n = 1’ if ‘n’ is a prime number and ‘x’ is an integer less than ‘n’. If ‘n’ is not a prime number, this will not be true for most values of ‘x’. Thus we can test informally if a number is prime by trying this formula for several values of ‘x’. Use this test to tell whether the following numbers are prime: 811749613, 15485863. See 10. (•)

It is possible to use HMS forms as parts of error forms, intervals, modulo forms, or as the phase part of a polar complex number. For example, the calc-time command pushes the current time of day on the stack as an HMS/modulo form.

1:  17@ 34' 45" mod 24@ 0' 0"     1:  6@ 22' 15" mod 24@ 0' 0"
    .                                 .

    x time RET                        n
This calculation tells me it is six hours and 22 minutes until midnight.

(•) Exercise 11. A rule of thumb is that one year is about ‘pi * 10^7’ seconds. What time will it be that many seconds from right now? See 11. (•)

(•) Exercise 12. You are preparing to order packaging for the CD release of the Extended Disco Version of Abbey Road. You are told that the songs will actually be anywhere from 20 to 60 seconds longer than the originals. One CD can hold about 75 minutes of music. Should you order single or double packages? See 12. (•)

Another kind of data the Calculator can manipulate is numbers with units. This isn’t strictly a new data type; it’s simply an application of algebraic expressions, where we use variables with suggestive names like ‘cm’ and ‘in’ to represent units like centimeters and inches.

1:  2 in        1:  5.08 cm      1:  0.027778 fath   1:  0.0508 m
    .               .                .                   .

    ' 2in RET       u c cm RET       u c fath RET        u b
We enter the quantity “2 inches” (actually an algebraic expression which means two times the variable ‘in’), then we convert it first to centimeters, then to fathoms, then finally to “base” units, which in this case means meters.

1:  9 acre     1:  3 sqrt(acre)   1:  190.84 m   1:  190.84 m + 30 cm
    .              .                  .              .

 ' 9 acre RET      Q                  u s            ' $+30 cm RET

1:  191.14 m     1:  36536.3046 m^2    1:  365363046 cm^2
    .                .                     .

    u s              2 ^                   u c cgs
Since units expressions are really just formulas, taking the square root of ‘acre’ is undefined. After all, acre might be an algebraic variable that you will someday assign a value. We use the “units-simplify” command to simplify the expression with variables being interpreted as unit names.

In the final step, we have converted not to a particular unit, but to a units system. The “cgs” system uses centimeters instead of meters as its standard unit of length.

There is a wide variety of units defined in the Calculator.

1:  55 mph     1:  88.5139 kph   1:   88.5139 km / hr   1:  8.201407e-8 c
    .              .                  .                     .

 ' 55 mph RET      u c kph RET        u c km/hr RET         u c c RET
We express a speed first in miles per hour, then in kilometers per hour, then again using a slightly more explicit notation, then finally in terms of fractions of the speed of light.

Temperature conversions are a bit more tricky. There are two ways to interpret “20 degrees Fahrenheit”—it could mean an actual temperature, or it could mean a change in temperature. For normal units there is no difference, but temperature units have an offset as well as a scale factor and so there must be two explicit commands for them.

1:  20 degF       1:  11.1111 degC     1:  -6.666 degC
    .                 .                    .                 .

  ' 20 degF RET       u c degC RET         U u t degC RET
First we convert a change of 20 degrees Fahrenheit into an equivalent change in degrees Celsius (or Centigrade). Then, we convert the absolute temperature 20 degrees Fahrenheit into Celsius.

For simple unit conversions, you can put a plain number on the stack. Then u c and u t will prompt for both old and new units. When you use this method, you’re responsible for remembering which numbers are in which units:

1:  55         1:  88.5139              1:  8.201407e-8
    .              .                        .

    55             u c mph RET kph RET      u c km/hr RET c RET
To see a complete list of built-in units, type u v. Press C-x * c again to re-enter the Calculator when you’re done looking at the units table.

(•) Exercise 13. How many seconds are there really in a year? See 13. (•)

(•) Exercise 14. Supercomputer designs are limited by the speed of light (and of electricity, which is nearly as fast). Suppose a computer has a 4.1 ns (nanosecond) clock cycle, and its cabinet is one meter across. Is speed of light going to be a significant factor in its design? See 14. (•)

(•) Exercise 15. Sam the Slug normally travels about five yards in an hour. He has obtained a supply of Power Pills; each Power Pill he eats doubles his speed. How many Power Pills can he swallow and still travel legally on most US highways? See 15. (•)


*** Algebra and Calculus Tutorial

This section shows how to use Calc’s algebra facilities to solve equations, do simple calculus problems, and manipulate algebraic formulas.

**** Basic Algebra

If you enter a formula in Algebraic mode that refers to variables, the formula itself is pushed onto the stack. You can manipulate formulas as regular data objects.

1:  2 x^2 - 6       1:  6 - 2 x^2       1:  (3 x^2 + y) (6 - 2 x^2)
    .                   .                   .

    ' 2x^2-6 RET        n                   ' 3x^2+y RET *
(•) Exercise 1. Do ' x RET Q 2 ^ and ' x RET 2 ^ Q both wind up with the same result (‘x’)? Why or why not? See 1. (•)

There are also commands for doing common algebraic operations on formulas. Continuing with the formula from the last example,

1:  18 x^2 - 6 x^4 + 6 y - 2 y x^2    1:  (18 - 2 y) x^2 - 6 x^4 + 6 y
    .                                     .

    a x                                   a c x RET
First we “expand” using the distributive law, then we “collect” terms involving like powers of ‘x’.

Let’s find the value of this expression when ‘x’ is 2 and ‘y’ is one-half.

1:  17 x^2 - 6 x^4 + 3      1:  -25
    .                           .

    1:2 s l y RET               2 s l x RET
The s l command means “let”; it takes a number from the top of the stack and temporarily assigns it as the value of the variable you specify. It then evaluates (as if by the = key) the next expression on the stack. After this command, the variable goes back to its original value, if any.

(An earlier exercise in this tutorial involved storing a value in the variable x; if this value is still there, you will have to unstore it with s u x RET before the above example will work properly.)

Let’s find the maximum value of our original expression when ‘y’ is one-half and ‘x’ ranges over all possible values. We can do this by taking the derivative with respect to ‘x’ and examining values of ‘x’ for which the derivative is zero. If the second derivative of the function at that value of ‘x’ is negative, the function has a local maximum there.

1:  17 x^2 - 6 x^4 + 3      1:  34 x - 24 x^3
    .                           .

    U DEL  s 1                  a d x RET   s 2
Well, the derivative is clearly zero when ‘x’ is zero. To find the other root(s), let’s divide through by ‘x’ and then solve:

1:  (34 x - 24 x^3) / x    1:  34 - 24 x^2
    .                          .

    ' x RET /                  a x

1:  0.70588 x^2 = 1        1:  x = 1.19023
    .                          .

    0 a =  s 3                 a S x RET
Now we compute the second derivative and plug in our values of ‘x’:

1:  1.19023        2:  1.19023         2:  1.19023
    .              1:  34 x - 24 x^3   1:  34 - 72 x^2
                       .                   .

    a .                r 2                 a d x RET s 4
(The a . command extracts just the righthand side of an equation. Another method would have been to use v u to unpack the equation ‘x = 1.19’ to ‘x’ and ‘1.19’, then use M-- M-2 DEL to delete the ‘x’.)

2:  34 - 72 x^2   1:  -68.         2:  34 - 72 x^2     1:  34
1:  1.19023           .            1:  0                   .
    .                                  .

    TAB               s l x RET        U DEL 0             s l x RET
The first of these second derivatives is negative, so we know the function has a maximum value at ‘x = 1.19023’. (The function also has a local minimum at ‘x = 0’.)

When we solved for ‘x’, we got only one value even though ‘0.70588 x^2 = 1’ is a quadratic equation that ought to have two solutions. The reason is that a S normally returns a single “principal” solution. If it needs to come up with an arbitrary sign (as occurs in the quadratic formula) it picks ‘+’. If it needs an arbitrary integer, it picks zero. We can get a full solution by pressing H (the Hyperbolic flag) before a S.

1:  0.70588 x^2 = 1    1:  x = 1.19023 s1      1:  x = -1.19023
    .                      .                       .

    r 3                    H a S x RET  s 5        1 n  s l s1 RET
Calc has invented the variable ‘s1’ to represent an unknown sign; it is supposed to be either +1 or -1. Here we have used the “let” command to evaluate the expression when the sign is negative. If we plugged this into our second derivative we would get the same, negative, answer, so ‘x = -1.19023’ is also a maximum.

To find the actual maximum value, we must plug our two values of ‘x’ into the original formula.

2:  17 x^2 - 6 x^4 + 3    1:  24.08333 s1^2 - 12.04166 s1^4 + 3
1:  x = 1.19023 s1            .
    .

    r 1 r 5                   s l RET
(Here we see another way to use s l; if its input is an equation with a variable on the lefthand side, then s l treats the equation like an assignment to that variable if you don’t give a variable name.)

It’s clear that this will have the same value for either sign of s1, but let’s work it out anyway, just for the exercise:

2:  [-1, 1]              1:  [15.04166, 15.04166]
1:  24.08333 s1^2 ...        .
    .

  [ 1 n , 1 ] TAB            V M $ RET
Here we have used a vector mapping operation to evaluate the function at several values of ‘s1’ at once. V M $ is like V M ' except that it takes the formula from the top of the stack. The formula is interpreted as a function to apply across the vector at the next-to-top stack level. Since a formula on the stack can’t contain ‘$’ signs, Calc assumes the variables in the formula stand for different arguments. It prompts you for an argument list, giving the list of all variables in the formula in alphabetical order as the default list. In this case the default is ‘(s1)’, which is just what we want so we simply press RET at the prompt.

If there had been several different values, we could have used V R X to find the global maximum.

Calc has a built-in a P command that solves an equation using H a S and returns a vector of all the solutions. It simply automates the job we just did by hand. Applied to our original cubic polynomial, it would produce the vector of solutions ‘[1.19023, -1.19023, 0]’. (There is also an a X command which finds a local maximum of a function. It uses a numerical search method rather than examining the derivatives, and thus requires you to provide some kind of initial guess to show it where to look.)

(•) Exercise 2. Given a vector of the roots of a polynomial (such as the output of an a P command), what sequence of commands would you use to reconstruct the original polynomial? (The answer will be unique to within a constant multiple; choose the solution where the leading coefficient is one.) See 2. (•)

The m s command enables Symbolic mode, in which formulas like ‘sqrt(5)’ that can’t be evaluated exactly are left in symbolic form rather than giving a floating-point approximate answer. Fraction mode (m f) is also useful when doing algebra.

2:  34 x - 24 x^3        2:  34 x - 24 x^3
1:  34 x - 24 x^3        1:  [sqrt(51) / 6, sqrt(51) / -6, 0]
    .                        .

    r 2  RET     m s  m f    a P x RET
One more mode that makes reading formulas easier is Big mode.

               3
2:  34 x - 24 x

      ____   ____
     V 51   V 51
1:  [-----, -----, 0]
       6     -6

    .

    d B
Here things like powers, square roots, and quotients and fractions are displayed in a two-dimensional pictorial form. Calc has other language modes as well, such as C mode, FORTRAN mode, TeX mode and LaTeX mode.

2:  34*x - 24*pow(x, 3)               2:  34*x - 24*x**3
1:  {sqrt(51) / 6, sqrt(51) / -6, 0}  1:  /sqrt(51) / 6, sqrt(51) / -6, 0/
    .                                     .

    d C                                   d F

3:  34 x - 24 x^3
2:  [{\sqrt{51} \over 6}, {\sqrt{51} \over -6}, 0]
1:  {2 \over 3} \sqrt{5}
    .

    d T   ' 2 \sqrt{5} \over 3 RET
As you can see, language modes affect both entry and display of formulas. They affect such things as the names used for built-in functions, the set of arithmetic operators and their precedences, and notations for vectors and matrices.

Notice that ‘sqrt(51)’ may cause problems with older implementations of C and FORTRAN, which would require something more like ‘sqrt(51.0)’. It is always wise to check over the formulas produced by the various language modes to make sure they are fully correct.

Type m s, m f, and d N to reset these modes. (You may prefer to remain in Big mode, but all the examples in the tutorial are shown in normal mode.)

What is the area under the portion of this curve from ‘x = 1’ to ‘2’? This is simply the integral of the function:

1:  17 x^2 - 6 x^4 + 3     1:  5.6666 x^3 - 1.2 x^5 + 3 x
    .                          .

    r 1                        a i x
We want to evaluate this at our two values for ‘x’ and subtract. One way to do it is again with vector mapping and reduction:

2:  [2, 1]            1:  [12.93333, 7.46666]    1:  5.46666
1:  5.6666 x^3 ...        .                          .

   [ 2 , 1 ] TAB          V M $ RET                  V R -
(•) Exercise 3. Find the integral from 1 to ‘y’ of ‘x sin(pi x)’ (where the sine is calculated in radians). Find the values of the integral for integers ‘y’ from 1 to 5. See 3. (•)

Calc’s integrator can do many simple integrals symbolically, but many others are beyond its capabilities. Suppose we wish to find the area under the curve ‘sin(x) ln(x)’ over the same range of ‘x’. If you entered this formula and typed a i x RET (don’t bother to try this), Calc would work for a long time but would be unable to find a solution. In fact, there is no closed-form solution to this integral. Now what do we do?

One approach would be to do the integral numerically. It is not hard to do this by hand using vector mapping and reduction. It is rather slow, though, since the sine and logarithm functions take a long time. We can save some time by reducing the working precision.

3:  10                  1:  [1, 1.1, 1.2,  ...  , 1.8, 1.9]
2:  1                       .
1:  0.1
    .

 10 RET 1 RET .1 RET        C-u v x
(Note that we have used the extended version of v x; we could also have used plain v x as follows: v x 10 RET 9 + .1 *.)

2:  [1, 1.1, ... ]              1:  [0., 0.084941, 0.16993, ... ]
1:  ln(x) sin(x)                    .
    .

    ' sin(x) ln(x) RET  s 1    m r  p 5 RET   V M $ RET

1:  3.4195     0.34195
    .          .

    V R +      0.1 *
(If you got wildly different results, did you remember to switch to Radians mode?)

Here we have divided the curve into ten segments of equal width; approximating these segments as rectangular boxes (i.e., assuming the curve is nearly flat at that resolution), we compute the areas of the boxes (height times width), then sum the areas. (It is faster to sum first, then multiply by the width, since the width is the same for every box.)

The true value of this integral turns out to be about 0.374, so we’re not doing too well. Let’s try another approach.

1:  ln(x) sin(x)    1:  0.84147 x + 0.11957 (x - 1)^2 - ...
    .                   .

    r 1                 a t x=1 RET 4 RET
Here we have computed the Taylor series expansion of the function about the point ‘x=1’. We can now integrate this polynomial approximation, since polynomials are easy to integrate.

1:  0.42074 x^2 + ...    1:  [-0.0446, -0.42073]      1:  0.3761
    .                        .                            .

    a i x RET            [ 2 , 1 ] TAB  V M $ RET         V R -
Better! By increasing the precision and/or asking for more terms in the Taylor series, we can get a result as accurate as we like. (Taylor series converge better away from singularities in the function such as the one at ln(0), so it would also help to expand the series about the points ‘x=2’ or ‘x=1.5’ instead of ‘x=1’.)

(•) Exercise 4. Our first method approximated the curve by stairsteps of width 0.1; the total area was then the sum of the areas of the rectangles under these stairsteps. Our second method approximated the function by a polynomial, which turned out to be a better approximation than stairsteps. A third method is Simpson’s rule, which is like the stairstep method except that the steps are not required to be flat. Simpson’s rule boils down to the formula,

(h/3) * (f(a) + 4 f(a+h) + 2 f(a+2h) + 4 f(a+3h) + ...
              + 2 f(a+(n-2)*h) + 4 f(a+(n-1)*h) + f(a+n*h))
where ‘n’ (which must be even) is the number of slices and ‘h’ is the width of each slice. These are 10 and 0.1 in our example. For reference, here is the corresponding formula for the stairstep method:

h * (f(a) + f(a+h) + f(a+2h) + f(a+3h) + ...
          + f(a+(n-2)*h) + f(a+(n-1)*h))
Compute the integral from 1 to 2 of ‘sin(x) ln(x)’ using Simpson’s rule with 10 slices. See 4. (•)

Calc has a built-in a I command for doing numerical integration. It uses Romberg’s method, which is a more sophisticated cousin of Simpson’s rule. In particular, it knows how to keep refining the result until the current precision is satisfied.

Aside from the commands we’ve seen so far, Calc also provides a large set of commands for operating on parts of formulas. You indicate the desired sub-formula by placing the cursor on any part of the formula before giving a selection command. Selections won’t be covered in the tutorial; see Selecting Sub-Formulas, for details and examples.


**** Rewrite Rules

No matter how many built-in commands Calc provided for doing algebra, there would always be something you wanted to do that Calc didn’t have in its repertoire. So Calc also provides a rewrite rule system that you can use to define your own algebraic manipulations.

Suppose we want to simplify this trigonometric formula:

1:  2 sec(x)^2 / tan(x)^2 - 2 / tan(x)^2
    .

    ' 2sec(x)^2/tan(x)^2 - 2/tan(x)^2 RET   s 1
If we were simplifying this by hand, we’d probably combine over the common denominator. The a n algebra command will do this, but we’ll do it with a rewrite rule just for practice.

Rewrite rules are written with the ‘:=’ symbol.

1:  (2 sec(x)^2 - 2) / tan(x)^2
    .

    a r a/x + b/x := (a+b)/x RET
(The “assignment operator” ‘:=’ has several uses in Calc. All by itself the formula ‘a/x + b/x := (a+b)/x’ doesn’t do anything, but when it is given to the a r command, that command interprets it as a rewrite rule.)

The lefthand side, ‘a/x + b/x’, is called the pattern of the rewrite rule. Calc searches the formula on the stack for parts that match the pattern. Variables in a rewrite pattern are called meta-variables, and when matching the pattern each meta-variable can match any sub-formula. Here, the meta-variable ‘a’ matched the expression ‘2 sec(x)^2’, the meta-variable ‘b’ matched the constant ‘-2’ and the meta-variable ‘x’ matched the expression ‘tan(x)^2’.

This rule points out several interesting features of rewrite patterns. First, if a meta-variable appears several times in a pattern, it must match the same thing everywhere. This rule detects common denominators because the same meta-variable ‘x’ is used in both of the denominators.

Second, meta-variable names are independent from variables in the target formula. Notice that the meta-variable ‘x’ here matches the subformula ‘tan(x)^2’; Calc never confuses the two meanings of ‘x’.

And third, rewrite patterns know a little bit about the algebraic properties of formulas. The pattern called for a sum of two quotients; Calc was able to match a difference of two quotients by matching ‘a = 2 sec(x)^2’, ‘b = -2’, and ‘x = tan(x)^2’.

When the pattern part of a rewrite rule matches a part of the formula, that part is replaced by the righthand side with all the meta-variables substituted with the things they matched. So the result is ‘(2 sec(x)^2 - 2) / tan(x)^2’.

We could just as easily have written ‘a/x - b/x := (a-b)/x’ for the rule. It would have worked just the same in all cases. (If we really wanted the rule to apply only to ‘+’ or only to ‘-’, we could have used the plain symbol. See Algebraic Properties of Rewrite Rules, for some examples of this.)

One more rewrite will complete the job. We want to use the identity ‘tan(x)^2 + 1 = sec(x)^2’, but of course we must first rearrange the identity in a way that matches our formula. The obvious rule would be ‘2 sec(x)^2 - 2 := 2 tan(x)^2’, but a little thought shows that the rule ‘sec(x)^2 := 1 + tan(x)^2’ will also work. The latter rule has a more general pattern so it will work in many other situations, too.

1:  2
    .

    a r sec(x)^2 := 1 + tan(x)^2 RET
You may ask, what’s the point of using the most general rule if you have to type it in every time anyway? The answer is that Calc allows you to store a rewrite rule in a variable, then give the variable name in the a r command. In fact, this is the preferred way to use rewrites. For one, if you need a rule once you’ll most likely need it again later. Also, if the rule doesn’t work quite right you can simply Undo, edit the variable, and run the rule again without having to retype it.

' a/x + b/x := (a+b)/x RET          s t merge RET
' sec(x)^2 := 1 + tan(x)^2 RET      s t secsqr RET

1:  2 sec(x)^2 / tan(x)^2 - 2 / tan(x)^2    1:  2
    .                                  .

    r 1                  a r merge RET  a r secsqr RET
To edit a variable, type s e and the variable name, use regular Emacs editing commands as necessary, then type C-c C-c to store the edited value back into the variable. You can also use s e to create a new variable if you wish.

Notice that the first time you use each rule, Calc puts up a “compiling” message briefly. The pattern matcher converts rules into a special optimized pattern-matching language rather than using them directly. This allows a r to apply even rather complicated rules very efficiently. If the rule is stored in a variable, Calc compiles it only once and stores the compiled form along with the variable. That’s another good reason to store your rules in variables rather than entering them on the fly.

(•) Exercise 1. Type m s to get Symbolic mode, then enter the formula ‘(2 + sqrt(2)) / (1 + sqrt(2))’. Using a rewrite rule, simplify this formula by multiplying the top and bottom by the conjugate ‘1 - sqrt(2)’. The result will have to be expanded by the distributive law; do this with another rewrite. See 1. (•)

The a r command can also accept a vector of rewrite rules, or a variable containing a vector of rules.

1:  [merge, secsqr]          1:  [a/x + b/x := (a + b)/x, ... ]
    .                                 .

    ' [merge,secsqr] RET          =

1:  2 sec(x)^2 / tan(x)^2 - 2 / tan(x)^2     1:  2
    .                                 .

    s t trig RET  r 1                  a r trig RET
Calc tries all the rules you give against all parts of the formula, repeating until no further change is possible. (The exact order in which things are tried is rather complex, but for simple rules like the ones we’ve used here the order doesn’t really matter. See Nested Formulas with Rewrite Rules.)

Calc actually repeats only up to 100 times, just in case your rule set has gotten into an infinite loop. You can give a numeric prefix argument to a r to specify any limit. In particular, M-1 a r does only one rewrite at a time.

1:  (2 sec(x)^2 - 2) / tan(x)^2         1:  2
    .                                       .

    r 1  M-1 a r trig RET                   M-1 a r trig RET
You can type M-0 a r if you want no limit at all on the number of rewrites that occur.

Rewrite rules can also be conditional. Simply follow the rule with a ‘::’ symbol and the desired condition. For example,

1:  sin(x + 2 pi) + sin(x + 3 pi) + sin(x + 4 pi)
    .

    ' sin(x+2pi) + sin(x+3pi) + sin(x+4pi) RET

1:  sin(x + 3 pi) + 2 sin(x)
    .

    a r sin(a + k pi) := sin(a) :: k % 2 = 0 RET
(Recall, ‘k % 2’ is the remainder from dividing ‘k’ by 2, which will be zero only when ‘k’ is an even integer.)

An interesting point is that the variable ‘pi’ was matched literally rather than acting as a meta-variable. This is because it is a special-constant variable. The special constants ‘e’, ‘i’, ‘phi’, and so on also match literally. A common error with rewrite rules is to write, say, ‘f(a,b,c,d,e) := g(a+b+c+d+e)’, expecting to match any ‘f’ with five arguments but in fact matching only when the fifth argument is literally ‘e’!

Rewrite rules provide an interesting way to define your own functions. Suppose we want to define ‘fib(n)’ to produce the nth Fibonacci number. The first two Fibonacci numbers are each 1; later numbers are formed by summing the two preceding numbers in the sequence. This is easy to express in a set of three rules:

' [fib(1) := 1, fib(2) := 1, fib(n) := fib(n-1) + fib(n-2)] RET  s t fib

1:  fib(7)               1:  13
    .                        .

    ' fib(7) RET             a r fib RET
One thing that is guaranteed about the order that rewrites are tried is that, for any given subformula, earlier rules in the rule set will be tried for that subformula before later ones. So even though the first and third rules both match ‘fib(1)’, we know the first will be used preferentially.

This rule set has one dangerous bug: Suppose we apply it to the formula ‘fib(x)’? (Don’t actually try this.) The third rule will match ‘fib(x)’ and replace it with ‘fib(x-1) + fib(x-2)’. Each of these will then be replaced to get ‘fib(x-2) + 2 fib(x-3) + fib(x-4)’, and so on, expanding forever. What we really want is to apply the third rule only when ‘n’ is an integer greater than two. Type s e fib RET, then edit the third rule to:

fib(n) := fib(n-1) + fib(n-2) :: integer(n) :: n > 2
Now:

1:  fib(6) + fib(x) + fib(0)      1:  fib(x) + fib(0) + 8
    .                                 .

    ' fib(6)+fib(x)+fib(0) RET        a r fib RET
We’ve created a new function, fib, and a new command, a r fib RET, which means “evaluate all fib calls in this formula.” To make things easier still, we can tell Calc to apply these rules automatically by storing them in the special variable EvalRules.

1:  [fib(1) := ...]    .                1:  [8, 13]
    .                                       .

    s r fib RET        s t EvalRules RET    ' [fib(6), fib(7)] RET
It turns out that this rule set has the problem that it does far more work than it needs to when ‘n’ is large. Consider the first few steps of the computation of ‘fib(6)’:

fib(6) =
fib(5)              +               fib(4) =
fib(4)     +      fib(3)     +      fib(3)     +      fib(2) =
fib(3) + fib(2) + fib(2) + fib(1) + fib(2) + fib(1) + 1 = ...
Note that ‘fib(3)’ appears three times here. Unless Calc’s algebraic simplifier notices the multiple ‘fib(3)’s and combines them (and, as it happens, it doesn’t), this rule set does lots of needless recomputation. To cure the problem, type s e EvalRules to edit the rules (or just s E, a shorthand command for editing EvalRules) and add another condition:

fib(n) := fib(n-1) + fib(n-2) :: integer(n) :: n > 2 :: remember
If a ‘:: remember’ condition appears anywhere in a rule, then if that rule succeeds Calc will add another rule that describes that match to the front of the rule set. (Remembering works in any rule set, but for technical reasons it is most effective in EvalRules.) For example, if the rule rewrites ‘fib(7)’ to something that evaluates to 13, then the rule ‘fib(7) := 13’ will be added to the rule set.

Type ' fib(8) RET to compute the eighth Fibonacci number, then type s E again to see what has happened to the rule set.

With the remember feature, our rule set can now compute ‘fib(n)’ in just n steps. In the process it builds up a table of all Fibonacci numbers up to n. After we have computed the result for a particular n, we can get it back (and the results for all smaller n) later in just one step.

All Calc operations will run somewhat slower whenever EvalRules contains any rules. You should type s u EvalRules RET now to un-store the variable.

(•) Exercise 2. Sometimes it is possible to reformulate a problem to reduce the amount of recursion necessary to solve it. Create a rule that, in about n simple steps and without recourse to the remember option, replaces ‘fib(n, 1, 1)’ with ‘fib(1, x, y)’ where x and y are the nth and n+1st Fibonacci numbers, respectively. This rule is rather clunky to use, so add a couple more rules to make the “user interface” the same as for our first version: enter ‘fib(n)’, get back a plain number. See 2. (•)

There are many more things that rewrites can do. For example, there are ‘&&&’ and ‘|||’ pattern operators that create “and” and “or” combinations of rules. As one really simple example, we could combine our first two Fibonacci rules thusly:

[fib(1 ||| 2) := 1, fib(n) := ... ]
That means “fib of something matching either 1 or 2 rewrites to 1.”

You can also make meta-variables optional by enclosing them in opt. For example, the pattern ‘a + b x’ matches ‘2 + 3 x’ but not ‘2 + x’ or ‘3 x’ or ‘x’. The pattern ‘opt(a) + opt(b) x’ matches all of these forms, filling in a default of zero for ‘a’ and one for ‘b’.

(•) Exercise 3. Your friend Joe had ‘2 + 3 x’ on the stack and tried to use the rule ‘opt(a) + opt(b) x := f(a, b, x)’. What happened? See 3. (•)

(•) Exercise 4. Starting with a positive integer ‘a’, divide ‘a’ by two if it is even, otherwise compute ‘3 a + 1’. Now repeat this step over and over. A famous unproved conjecture is that for any starting ‘a’, the sequence always eventually reaches 1. Given the formula ‘seq(a, 0)’, write a set of rules that convert this into ‘seq(1, n)’ where n is the number of steps it took the sequence to reach the value 1. Now enhance the rules to accept ‘seq(a)’ as a starting configuration, and to stop with just the number n by itself. Now make the result be a vector of values in the sequence, from a to 1. (The formula ‘x|y’ appends the vectors x and y.) For example, rewriting ‘seq(6)’ should yield the vector ‘[6, 3, 10, 5, 16, 8, 4, 2, 1]’. See 4. (•)

(•) Exercise 5. Define, using rewrite rules, a function ‘nterms(x)’ that returns the number of terms in the sum x, or 1 if x is not a sum. (A sum for our purposes is one or more non-sum terms separated by ‘+’ or ‘-’ signs, so that ‘2 - 3 (x + y) + x y’ is a sum of three terms.) See 5. (•)

(•) Exercise 6. A Taylor series for a function is an infinite series that exactly equals the value of that function at values of ‘x’ near zero.

cos(x) = 1 - x^2 / 2! + x^4 / 4! - x^6 / 6! + ...
The a t command produces a truncated Taylor series which is obtained by dropping all the terms higher than, say, ‘x^2’. Calc represents the truncated Taylor series as a polynomial in ‘x’. Mathematicians often write a truncated series using a “big-O” notation that records what was the lowest term that was truncated.

cos(x) = 1 - x^2 / 2! + O(x^3)
The meaning of ‘O(x^3)’ is “a quantity which is negligibly small if ‘x^3’ is considered negligibly small as ‘x’ goes to zero.”

The exercise is to create rewrite rules that simplify sums and products of power series represented as ‘polynomial + O(var^n)’. For example, given ‘1 - x^2 / 2 + O(x^3)’ and ‘x - x^3 / 6 + O(x^4)’ on the stack, we want to be able to type * and get the result ‘x - 2:3 x^3 + O(x^4)’. Don’t worry if the terms of the sum are rearranged. (This one is rather tricky; the solution at the end of this chapter uses 6 rewrite rules. Hint: The ‘constant(x)’ condition tests whether ‘x’ is a number.) See 6. (•)

Just for kicks, try adding the rule 2+3 := 6 to EvalRules. What happens? (Be sure to remove this rule afterward, or you might get a nasty surprise when you use Calc to balance your checkbook!)

See Rewrite Rules, for the whole story on rewrite rules.


*** Programming Tutorial

The Calculator is written entirely in Emacs Lisp, a highly extensible language. If you know Lisp, you can program the Calculator to do anything you like. Rewrite rules also work as a powerful programming system. But Lisp and rewrite rules take a while to master, and often all you want to do is define a new function or repeat a command a few times. Calc has features that allow you to do these things easily.

One very limited form of programming is defining your own functions. Calc’s Z F command allows you to define a function name and key sequence to correspond to any formula. Programming commands use the shift-Z prefix; the user commands they create use the lower case z prefix.

1:  x + x^2 / 2 + x^3 / 6 + 1         1:  x + x^2 / 2 + x^3 / 6 + 1
    .                                     .

    ' 1 + x + x^2/2! + x^3/3! RET         Z F e myexp RET RET RET y
This polynomial is a Taylor series approximation to ‘exp(x)’. The Z F command asks a number of questions. The above answers say that the key sequence for our function should be z e; the M-x equivalent should be calc-myexp; the name of the function in algebraic formulas should also be myexp; the default argument list ‘(x)’ is acceptable; and finally y answers the question “leave it in symbolic form for non-constant arguments?”

1:  1.3495     2:  1.3495     3:  1.3495
    .          1:  1.34986    2:  1.34986
                   .          1:  myexp(a + 1)
                                  .

    .3 z e         .3 E           ' a+1 RET z e
First we call our new exp approximation with 0.3 as an argument, and compare it with the true exp function. Then we note that, as requested, if we try to give z e an argument that isn’t a plain number, it leaves the myexp function call in symbolic form. If we had answered n to the final question, ‘myexp(a + 1)’ would have evaluated by plugging in ‘a + 1’ for ‘x’ in the defining formula.

(•) Exercise 1. The “sine integral” function ‘Si(x)’ is defined as the integral of ‘sin(t)/t’ for ‘t = 0’ to ‘x’ in radians. (It was invented because this integral has no solution in terms of basic functions; if you give it to Calc’s a i command, it will ponder it for a long time and then give up.) We can use the numerical integration command, however, which in algebraic notation is written like ‘ninteg(f(t), t, 0, x)’ with any integrand ‘f(t)’. Define a z s command and Si function that implement this. You will need to edit the default argument list a bit. As a test, ‘Si(1)’ should return 0.946083. (If you don’t get this answer, you might want to check that Calc is in Radians mode. Also, ninteg will run a lot faster if you reduce the precision to, say, six digits beforehand.) See 1. (•)

The simplest way to do real “programming” of Emacs is to define a keyboard macro. A keyboard macro is simply a sequence of keystrokes which Emacs has stored away and can play back on demand. For example, if you find yourself typing H a S x RET often, you may wish to program a keyboard macro to type this for you.

1:  y = sqrt(x)          1:  x = y^2
    .                        .

    ' y=sqrt(x) RET       C-x ( H a S x RET C-x )

1:  y = cos(x)           1:  x = s1 arccos(y) + 2 n1 pi
    .                        .

    ' y=cos(x) RET           X
When you type C-x (, Emacs begins recording. But it is also still ready to execute your keystrokes, so you’re really “training” Emacs by walking it through the procedure once. When you type C-x ), the macro is recorded. You can now type X to re-execute the same keystrokes.

You can give a name to your macro by typing Z K.

1:  .              1:  y = x^4         1:  x = s2 sqrt(s1 sqrt(y))
                       .                   .

  Z K x RET            ' y=x^4 RET         z x
Notice that we use shift-Z to define the command, and lower-case z to call it up.

Keyboard macros can call other macros.

1:  abs(x)        1:  x = s1 y                1:  2 / x    1:  x = 2 / y
    .                 .                           .            .

 ' abs(x) RET   C-x ( ' y RET a = z x C-x )    ' 2/x RET       X
(•) Exercise 2. Define a keyboard macro to negate the item in level 3 of the stack, without disturbing the rest of the stack. See 2. (•)

(•) Exercise 3. Define keyboard macros to compute the following functions:

Compute ‘sin(x) / x’, where ‘x’ is the number on the top of the stack.
Compute the base-‘b’ logarithm, just like the B key except the arguments are taken in the opposite order.
Produce a vector of integers from 1 to the integer on the top of the stack.
See 3. (•)

(•) Exercise 4. Define a keyboard macro to compute the average (mean) value of a list of numbers. See 4. (•)

In many programs, some of the steps must execute several times. Calc has looping commands that allow this. Loops are useful inside keyboard macros, but actually work at any time.

1:  x^6          2:  x^6        1: 360 x^2
    .            1:  4             .
                     .

  ' x^6 RET          4         Z < a d x RET Z >
Here we have computed the fourth derivative of ‘x^6’ by enclosing a derivative command in a “repeat loop” structure. This structure pops a repeat count from the stack, then executes the body of the loop that many times.

If you make a mistake while entering the body of the loop, type Z C-g to cancel the loop command.

Here’s another example:

3:  1               2:  10946
2:  1               1:  17711
1:  20                  .
    .

1 RET RET 20       Z < TAB C-j + Z >
The numbers in levels 2 and 1 should be the 21st and 22nd Fibonacci numbers, respectively. (To see what’s going on, try a few repetitions of the loop body by hand; C-j, also on the Line-Feed or LFD key if you have one, makes a copy of the number in level 2.)

A fascinating property of the Fibonacci numbers is that the ‘n’th Fibonacci number can be found directly by computing ‘phi^n / sqrt(5)’ and then rounding to the nearest integer, where ‘phi’, the “golden ratio,” is ‘(1 + sqrt(5)) / 2’. (For convenience, this constant is available from the phi variable, or the I H P command.)

1:  1.61803         1:  24476.0000409    1:  10945.9999817    1:  10946
    .                   .                    .                    .

    I H P               21 ^                 5 Q /                R
(•) Exercise 5. The continued fraction representation of ‘phi’ is ‘1 + 1/(1 + 1/(1 + 1/( ... )))’. We can compute an approximate value by carrying this however far and then replacing the innermost ‘1/( ... )’ by 1. Approximate ‘phi’ using a twenty-term continued fraction. See 5. (•)

(•) Exercise 6. Linear recurrences like the one for Fibonacci numbers can be expressed in terms of matrices. Given a vector ‘[a, b]’ determine a matrix which, when multiplied by this vector, produces the vector ‘[b, c]’, where ‘a’, ‘b’ and ‘c’ are three successive Fibonacci numbers. Now write a program that, given an integer ‘n’, computes the ‘n’th Fibonacci number using matrix arithmetic. See 6. (•)

A more sophisticated kind of loop is the for loop. Suppose we wish to compute the 20th “harmonic” number, which is equal to the sum of the reciprocals of the integers from 1 to 20.

3:  0               1:  3.597739
2:  1                   .
1:  20
    .

0 RET 1 RET 20         Z ( & + 1 Z )
The “for” loop pops two numbers, the lower and upper limits, then repeats the body of the loop as an internal counter increases from the lower limit to the upper one. Just before executing the loop body, it pushes the current loop counter. When the loop body finishes, it pops the “step,” i.e., the amount by which to increment the loop counter. As you can see, our loop always uses a step of one.

This harmonic number function uses the stack to hold the running total as well as for the various loop housekeeping functions. If you find this disorienting, you can sum in a variable instead:

1:  0         2:  1                  .            1:  3.597739
    .         1:  20                                  .
                  .

    0 t 7       1 RET 20      Z ( & s + 7 1 Z )       r 7
The s + command adds the top-of-stack into the value in a variable (and removes that value from the stack).

It’s worth noting that many jobs that call for a “for” loop can also be done more easily by Calc’s high-level operations. Two other ways to compute harmonic numbers are to use vector mapping and reduction (v x 20, then V M &, then V R +), or to use the summation command a +. Both of these are probably easier than using loops. However, there are some situations where loops really are the way to go:

(•) Exercise 7. Use a “for” loop to find the first harmonic number which is greater than 4.0. See 7. (•)

Of course, if we’re going to be using variables in our programs, we have to worry about the programs clobbering values that the caller was keeping in those same variables. This is easy to fix, though:

    .        1:  0.6667       1:  0.6667     3:  0.6667
                 .                .          2:  3.597739
                                             1:  0.6667
                                                 .

   Z `    p 4 RET 2 RET 3 /   s 7 s s a RET    Z '  r 7 s r a RET
When we type Z ` (that’s a grave accent), Calc saves its mode settings and the contents of the ten “quick variables” for later reference. When we type Z ' (that’s an apostrophe now), Calc restores those saved values. Thus the p 4 and s 7 commands have no effect outside this sequence. Wrapping this around the body of a keyboard macro ensures that it doesn’t interfere with what the user of the macro was doing. Notice that the contents of the stack, and the values of named variables, survive past the Z ' command.

The Bernoulli numbers are a sequence with the interesting property that all of the odd Bernoulli numbers are zero, and the even ones, while difficult to compute, can be roughly approximated by the formula ‘2 n! / (2 pi)^n’. Let’s write a keyboard macro to compute (approximate) Bernoulli numbers. (Calc has a command, k b, to compute exact Bernoulli numbers, but this command is very slow for large ‘n’ since the higher Bernoulli numbers are very large fractions.)

1:  10               1:  0.0756823
    .                    .

    10     C-x ( RET 2 % Z [ DEL 0 Z : ' 2 $! / (2 pi)^$ RET = Z ] C-x )
You can read Z [ as “then,” Z : as “else,” and Z ] as “end-if.” There is no need for an explicit “if” command. For the purposes of Z [, the condition is “true” if the value it pops from the stack is a nonzero number, or “false” if it pops zero or something that is not a number (like a formula). Here we take our integer argument modulo 2; this will be nonzero if we’re asking for an odd Bernoulli number.

The actual tenth Bernoulli number is ‘5/66’.

3:  0.0756823    1:  0          1:  0.25305    1:  0          1:  1.16659
2:  5:66             .              .              .              .
1:  0.0757575
    .

10 k b RET c f   M-0 DEL 11 X   DEL 12 X       DEL 13 X       DEL 14 X
Just to exercise loops a bit more, let’s compute a table of even Bernoulli numbers.

3:  []             1:  [0.10132, 0.03079, 0.02340, 0.033197, ...]
2:  2                  .
1:  30
    .

 [ ] 2 RET 30          Z ( X | 2 Z )
The vertical-bar | is the vector-concatenation command. When we execute it, the list we are building will be in stack level 2 (initially this is an empty list), and the next Bernoulli number will be in level 1. The effect is to append the Bernoulli number onto the end of the list. (To create a table of exact fractional Bernoulli numbers, just replace X with k b in the above sequence of keystrokes.)

With loops and conditionals, you can program essentially anything in Calc. One other command that makes looping easier is Z /, which takes a condition from the stack and breaks out of the enclosing loop if the condition is true (non-zero). You can use this to make “while” and “until” style loops.

If you make a mistake when entering a keyboard macro, you can edit it using Z E. First, you must attach it to a key with Z K. One technique is to enter a throwaway dummy definition for the macro, then enter the real one in the edit command.

1:  3                   1:  3           Calc Macro Edit Mode.
    .                       .           Original keys: 1 <return> 2 +

                                        1                          ;; calc digits
                                        RET                        ;; calc-enter
                                        2                          ;; calc digits
                                        +                          ;; calc-plus

C-x ( 1 RET 2 + C-x )    Z K h RET      Z E h
A keyboard macro is stored as a pure keystroke sequence. The edmacro package (invoked by Z E) scans along the macro and tries to decode it back into human-readable steps. Descriptions of the keystrokes are given as comments, which begin with ‘;;’, and which are ignored when the edited macro is saved. Spaces and line breaks are also ignored when the edited macro is saved. To enter a space into the macro, type SPC. All the special characters RET, LFD, TAB, SPC, DEL, and NUL must be written in all uppercase, as must the prefixes C- and M-.

Let’s edit in a new definition, for computing harmonic numbers. First, erase the four lines of the old definition. Then, type in the new definition (or use Emacs M-w and C-y commands to copy it from this page of the Info file; you can of course skip typing the comments, which begin with ‘;;’).

Z`                      ;; calc-kbd-push     (Save local values)
0                       ;; calc digits       (Push a zero onto the stack)
st                      ;; calc-store-into   (Store it in the following variable)
1                       ;; calc quick variable  (Quick variable q1)
1                       ;; calc digits       (Initial value for the loop)
TAB                     ;; calc-roll-down    (Swap initial and final)
Z(                      ;; calc-kbd-for      (Begin the "for" loop)
&                       ;; calc-inv          (Take the reciprocal)
s+                      ;; calc-store-plus   (Add to the following variable)
1                       ;; calc quick variable  (Quick variable q1)
1                       ;; calc digits       (The loop step is 1)
Z)                      ;; calc-kbd-end-for  (End the "for" loop)
sr                      ;; calc-recall       (Recall the final accumulated value)
1                       ;; calc quick variable (Quick variable q1)
Z'                      ;; calc-kbd-pop      (Restore values)
Press C-c C-c to finish editing and return to the Calculator.

1:  20         1:  3.597739
    .              .

    20             z h
The edmacro package defines a handy read-kbd-macro command which reads the current region of the current buffer as a sequence of keystroke names, and defines that sequence on the X (and C-x e) key. Because this is so useful, Calc puts this command on the C-x * m key. Try reading in this macro in the following form: Press C-@ (or C-SPC) at one end of the text below, then type C-x * m at the other.

Z ` 0 t 1
    1 TAB
    Z (  & s + 1  1 Z )
    r 1
Z '
(•) Exercise 8. A general algorithm for solving equations numerically is Newton’s Method. Given the equation ‘f(x) = 0’ for any function ‘f’, and an initial guess ‘x_0’ which is reasonably close to the desired solution, apply this formula over and over:

new_x = x - f(x)/f'(x)
where ‘f'(x)’ is the derivative of ‘f’. The ‘x’ values will quickly converge to a solution, i.e., eventually ‘new_x’ and ‘x’ will be equal to within the limits of the current precision. Write a program which takes a formula involving the variable ‘x’, and an initial guess ‘x_0’, on the stack, and produces a value of ‘x’ for which the formula is zero. Use it to find a solution of ‘sin(cos(x)) = 0.5’ near ‘x = 4.5’. (Use angles measured in radians.) Note that the built-in a R (calc-find-root) command uses Newton’s method when it is able. See 8. (•)

(•) Exercise 9. The digamma function ‘psi(z)’ is defined as the derivative of ‘ln(gamma(z))’. For large values of ‘z’, it can be approximated by the infinite sum

psi(z) ~= ln(z) - 1/2z - sum(bern(2 n) / 2 n z^(2 n), n, 1, inf)
where ‘sum’ represents the sum over ‘n’ from 1 to infinity (or to some limit high enough to give the desired accuracy), and the bern function produces (exact) Bernoulli numbers. While this sum is not guaranteed to converge, in practice it is safe. An interesting mathematical constant is Euler’s gamma, which is equal to about 0.5772. One way to compute it is by the formula, ‘gamma = -psi(1)’. Unfortunately, 1 isn’t a large enough argument for the above formula to work (5 is a much safer value for ‘z’). Fortunately, we can compute ‘psi(1)’ from ‘psi(5)’ using the recurrence ‘psi(z+1) = psi(z) + 1/z’. Your task: Develop a program to compute ‘psi(z)’; it should “pump up” ‘z’ if necessary to be greater than 5, then use the above summation formula. Use looping commands to compute the sum. Use your function to compute ‘gamma’ to twelve decimal places. (Calc has a built-in command for Euler’s constant, I P, which you can use to check your answer.) See 9. (•)

(•) Exercise 10. Given a polynomial in ‘x’ and a number ‘m’ on the stack, where the polynomial is of degree ‘m’ or less (i.e., does not have any terms higher than ‘x^m’), write a program to convert the polynomial into a list-of-coefficients notation. For example, ‘5 x^4 + (x + 1)^2’ with ‘m = 6’ should produce the list ‘[1, 2, 1, 0, 5, 0, 0]’. Also develop a way to convert from this form back to the standard algebraic form. See 10. (•)

(•) Exercise 11. The Stirling numbers of the first kind are defined by the recurrences,

s(n,n) = 1   for n >= 0,
s(n,0) = 0   for n > 0,
s(n+1,m) = s(n,m-1) - n s(n,m)   for n >= m >= 1.
This can be implemented using a recursive program in Calc; the program must invoke itself in order to calculate the two righthand terms in the general formula. Since it always invokes itself with “simpler” arguments, it’s easy to see that it must eventually finish the computation. Recursion is a little difficult with Emacs keyboard macros since the macro is executed before its definition is complete. So here’s the recommended strategy: Create a “dummy macro” and assign it to a key with, e.g., Z K s. Now enter the true definition, using the z s command to call itself recursively, then assign it to the same key with Z K s. Now the z s command will run the complete recursive program. (Another way is to use Z E or C-x * m (read-kbd-macro) to read the whole macro at once, thus avoiding the “training” phase.) The task: Write a program that computes Stirling numbers of the first kind, given ‘n’ and ‘m’ on the stack. Test it with small inputs like ‘s(4,2)’. (There is a built-in command for Stirling numbers, k s, which you can use to check your answers.) See 11. (•)

The programming commands we’ve seen in this part of the tutorial are low-level, general-purpose operations. Often you will find that a higher-level function, such as vector mapping or rewrite rules, will do the job much more easily than a detailed, step-by-step program can:

(•) Exercise 12. Write another program for computing Stirling numbers of the first kind, this time using rewrite rules. Once again, ‘n’ and ‘m’ should be taken from the stack. See 12. (•)


This ends the tutorial section of the Calc manual. Now you know enough about Calc to use it effectively for many kinds of calculations. But Calc has many features that were not even touched upon in this tutorial. The rest of this manual tells the whole story.


** Introduction

This chapter is the beginning of the Calc reference manual. It covers basic concepts such as the stack, algebraic and numeric entry, undo, numeric prefix arguments, etc.

*** Basic Commands

To start the Calculator in its standard interface, type M-x calc. By default this creates a pair of small windows, *Calculator* and *Calc Trail*. The former displays the contents of the Calculator stack and is manipulated exclusively through Calc commands. It is possible (though not usually necessary) to create several Calc mode buffers each of which has an independent stack, undo list, and mode settings. There is exactly one Calc Trail buffer; it records a list of the results of all calculations that have been done. The Calc Trail buffer uses a variant of Calc mode, so Calculator commands still work when the trail buffer’s window is selected. It is possible to turn the trail window off, but the *Calc Trail* buffer itself still exists and is updated silently. See Trail Commands.

In most installations, the C-x * c key sequence is a more convenient way to start the Calculator. Also, C-x * * is a synonym for C-x * c unless you last used Calc in its Keypad mode.

Most Calc commands use one or two keystrokes. Lower- and upper-case letters are distinct. Commands may also be entered in full M-x form; for some commands this is the only form. As a convenience, the x key (calc-execute-extended-command) is like M-x except that it enters the initial string ‘calc-’ for you. For example, the following key sequences are equivalent: S, M-x calc-sin RET, x sin RET.

Although Calc is designed to be used from the keyboard, some of Calc’s more common commands are available from a menu. In the menu, the arguments to the functions are given by referring to their stack level numbers.

The Calculator exists in many parts. When you type C-x * c, the Emacs “auto-load” mechanism will bring in only the first part, which contains the basic arithmetic functions. The other parts will be auto-loaded the first time you use the more advanced commands like trig functions or matrix operations. This is done to improve the response time of the Calculator in the common case when all you need to do is a little arithmetic. If for some reason the Calculator fails to load an extension module automatically, you can force it to load all the extensions by using the C-x * L (calc-load-everything) command. See Mode Settings.

If you type M-x calc or C-x * c with any numeric prefix argument, the Calculator is loaded if necessary, but it is not actually started. If the argument is positive, the calc-ext extensions are also loaded if necessary. User-written Lisp code that wishes to make use of Calc’s arithmetic routines can use ‘(calc 0)’ or ‘(calc 1)’ to auto-load the Calculator.

If you type C-x * b, then next time you use C-x * c you will get a Calculator that uses the full height of the Emacs screen. When full-screen mode is on, C-x * c runs the full-calc command instead of calc. From the Unix shell you can type ‘emacs -f full-calc’ to start a new Emacs specifically for use as a calculator. When Calc is started from the Emacs command line like this, Calc’s normal “quit” commands actually quit Emacs itself.

The C-x * o command is like C-x * c except that the Calc window is not actually selected. If you are already in the Calc window, C-x * o switches you out of it. (The regular Emacs C-x o command would also work for this, but it has a tendency to drop you into the Calc Trail window instead, which C-x * o takes care not to do.)

For one quick calculation, you can type C-x * q (quick-calc) which prompts you for a formula (like ‘2+3/4’). The result is displayed at the bottom of the Emacs screen without ever creating any special Calculator windows. See “Quick Calculator” Mode.

Finally, if you are using the X window system you may want to try C-x * k (calc-keypad) which runs Calc with a “calculator keypad” picture as well as a stack display. Click on the keys with the mouse to operate the calculator. See Keypad Mode.

The q key (calc-quit) exits Calc mode and closes the Calculator’s window(s). It does not delete the Calculator buffers. If you type M-x calc again, the Calculator will reappear with the contents of the stack intact. Typing C-x * c or C-x * * again from inside the Calculator buffer is equivalent to executing calc-quit; you can think of C-x * * as toggling the Calculator on and off.

The C-x * x command also turns the Calculator off, no matter which user interface (standard, Keypad, or Embedded) is currently active. It also cancels calc-edit mode if used from there.

The d SPC key sequence (calc-refresh) redraws the contents of the Calculator buffer from memory. Use this if the contents of the buffer have been damaged somehow.

The o key (calc-realign) moves the cursor back to its “home” position at the bottom of the Calculator buffer.

The < and > keys are bound to calc-scroll-left and calc-scroll-right. These are just like the normal horizontal scrolling commands except that they scroll one half-screen at a time by default. (Calc formats its output to fit within the bounds of the window whenever it can.)

The { and } keys are bound to calc-scroll-down and calc-scroll-up. They scroll up or down by one-half the height of the Calc window.

The C-x * 0 command (calc-reset; that’s C-x * followed by a zero) resets the Calculator to its initial state. This clears the stack, resets all the modes to their initial values (the values that were saved with m m (calc-save-modes)), clears the caches (see Caches), and so on. (It does not erase the values of any variables.) With an argument of 0, Calc will be reset to its default state; namely, the modes will be given their default values. With a positive prefix argument, C-x * 0 preserves the contents of the stack but resets everything else to its initial state; with a negative prefix argument, C-x * 0 preserves the contents of the stack but resets everything else to its default state.


*** Help Commands

The ? key (calc-help) displays a series of brief help messages. Some keys (such as b and d) are prefix keys, like Emacs’s ESC and C-x prefixes. You can type ? after a prefix to see a list of commands beginning with that prefix. (If the message includes ‘[MORE]’, press ? again to see additional commands for that prefix.)

The h h (calc-full-help) command displays all the ? responses at once. When printed, this makes a nice, compact (three pages) summary of Calc keystrokes.

In general, the h key prefix introduces various commands that provide help within Calc. Many of the h key functions are Calc-specific analogues to the C-h functions for Emacs help.

The h i (calc-info) command runs the Emacs Info system to read this manual on-line. This is basically the same as typing C-h i (the regular way to run the Info system), then, if Info is not already in the Calc manual, selecting the beginning of the manual. The C-x * i command is another way to read the Calc manual; it is different from h i in that it works any time, not just inside Calc. The plain i key is also equivalent to h i, though this key is obsolete and may be replaced with a different command in a future version of Calc.

The h t (calc-tutorial) command runs the Info system on the Tutorial section of the Calc manual. It is like h i, except that it selects the starting node of the tutorial rather than the beginning of the whole manual. (It actually selects the node “Interactive Tutorial” which tells a few things about using the Info system before going on to the actual tutorial.) The C-x * t key is equivalent to h t (but it works at all times).

The h s (calc-info-summary) command runs the Info system on the Summary node of the Calc manual. See Calc Summary. The C-x * s key is equivalent to h s.

The h k (calc-describe-key) command looks up a key sequence in the Calc manual. For example, h k H a S looks up the documentation on the H a S (calc-solve-for) command. This works by looking up the textual description of the key(s) in the Key Index of the manual, then jumping to the node indicated by the index.

Most Calc commands do not have traditional Emacs documentation strings, since the h k command is both more convenient and more instructive. This means the regular Emacs C-h k (describe-key) command will not be useful for Calc keystrokes.

The h c (calc-describe-key-briefly) command reads a key sequence and displays a brief one-line description of it at the bottom of the screen. It looks for the key sequence in the Summary node of the Calc manual; if it doesn’t find the sequence there, it acts just like its regular Emacs counterpart C-h c (describe-key-briefly). For example, h c H a S gives the description:

H a S runs calc-solve-for:  a `H a S' v  => fsolve(a,v)  (?=notes)
which means the command H a S or H M-x calc-solve-for takes a value ‘a’ from the stack, prompts for a value ‘v’, then applies the algebraic function fsolve to these values. The ‘?=notes’ message means you can now type ? to see additional notes from the summary that apply to this command.

The h f (calc-describe-function) command looks up an algebraic function or a command name in the Calc manual. Enter an algebraic function name to look up that function in the Function Index or enter a command name beginning with ‘calc-’ to look it up in the Command Index. This command will also look up operator symbols that can appear in algebraic formulas, like ‘%’ and ‘=>’.

The h v (calc-describe-variable) command looks up a variable in the Calc manual. Enter a variable name like pi or PlotRejects.

The h b (calc-describe-bindings) command is just like C-h b, except that only local (Calc-related) key bindings are listed.

The h n or h C-n (calc-view-news) command displays the “news” or change history of Emacs, and jumps to the most recent portion concerning Calc (if present). For older history, see the file etc/CALC-NEWS in the Emacs distribution.

The h C-c, h C-d, and h C-w keys display copying, distribution, and warranty information about Calc. These work by pulling up the appropriate parts of the “Copying” or “Reporting Bugs” sections of the manual.


*** Stack Basics

Calc uses RPN notation. If you are not familiar with RPN, see RPN Calculations and the Stack.

To add the numbers 1 and 2 in Calc you would type the keys: 1 RET 2 +. (RET corresponds to the ENTER key on most calculators.) The first three keystrokes “push” the numbers 1 and 2 onto the stack. The + key always “pops” the top two numbers from the stack, adds them, and pushes the result (3) back onto the stack. This number is ready for further calculations: 5 - pushes 5 onto the stack, then pops the 3 and 5, subtracts them, and pushes the result (-2).

Note that the “top” of the stack actually appears at the bottom of the buffer. A line containing a single ‘.’ character signifies the end of the buffer; Calculator commands operate on the number(s) directly above this line. The d t (calc-truncate-stack) command allows you to move the ‘.’ marker up and down in the stack; see Truncating the Stack.

Stack elements are numbered consecutively, with number 1 being the top of the stack. These line numbers are ordinarily displayed on the lefthand side of the window. The d l (calc-line-numbering) command controls whether these numbers appear. (Line numbers may be turned off since they slow the Calculator down a bit and also clutter the display.)

The unshifted letter o (calc-realign) command repositions the cursor to its top-of-stack “home” position. It also undoes any horizontal scrolling in the window. If you give it a numeric prefix argument, it instead moves the cursor to the specified stack element.

The RET (or equivalent SPC) key is only required to separate two consecutive numbers. (After all, if you typed 1 2 by themselves the Calculator would enter the number 12.) If you press RET or SPC not right after typing a number, the key duplicates the number on the top of the stack. RET * is thus a handy way to square a number.

The DEL key pops and throws away the top number on the stack. The TAB key swaps the top two objects on the stack. See Stack and Trail Commands, for descriptions of these and other stack-related commands.


*** Numeric Entry

Pressing a digit or other numeric key begins numeric entry using the minibuffer. The number is pushed on the stack when you press the RET or SPC keys. If you press any other non-numeric key, the number is pushed onto the stack and the appropriate operation is performed. If you press a numeric key which is not valid, the key is ignored.

There are three different concepts corresponding to the word “minus,” typified by ‘a-b’ (subtraction), ‘-x’ (change-sign), and ‘-5’ (negative number). Calc uses three different keys for these operations, respectively: -, n, and _ (the underscore). The - key subtracts the two numbers on the top of the stack. The n key changes the sign of the number on the top of the stack or the number currently being entered. The _ key begins entry of a negative number or changes the sign of the number currently being entered. The following sequences all enter the number -5 onto the stack: 0 RET 5 -, 5 n RET, 5 RET n, _ 5 RET, 5 _ RET.

Some other keys are active during numeric entry, such as # for non-decimal numbers, : for fractions, and @ for HMS forms. These notations are described later in this manual with the corresponding data types. See Data Types.

During numeric entry, the only editing key available is DEL.


*** Algebraic Entry

The ' (calc-algebraic-entry) command can be used to enter calculations in algebraic form. This is accomplished by typing the apostrophe key, ’, followed by the expression in standard format:

' 2+3*4 RET.
This will compute ‘2+(3*4) = 14’ and push it on the stack. If you wish you can ignore the RPN aspect of Calc altogether and simply enter algebraic expressions in this way. You may want to use DEL every so often to clear previous results off the stack.

You can press the apostrophe key during normal numeric entry to switch the half-entered number into Algebraic entry mode. One reason to do this would be to fix a typo, as the full Emacs cursor motion and editing keys are available during algebraic entry but not during numeric entry.

In the same vein, during either numeric or algebraic entry you can press ` (grave accent) to switch to calc-edit mode, where you complete your half-finished entry in a separate buffer. See Editing Stack Entries.

If you prefer algebraic entry, you can use the command m a (calc-algebraic-mode) to set Algebraic mode. In this mode, digits and other keys that would normally start numeric entry instead start full algebraic entry; as long as your formula begins with a digit you can omit the apostrophe. Open parentheses and square brackets also begin algebraic entry. You can still do RPN calculations in this mode, but you will have to press RET to terminate every number: 2 RET 3 RET * 4 RET + would accomplish the same thing as 2*3+4 RET.

If you give a numeric prefix argument like C-u to the m a command, it enables Incomplete Algebraic mode; this is like regular Algebraic mode except that it applies to the ( and [ keys only. Numeric keys still begin a numeric entry in this mode.

The m t (calc-total-algebraic-mode) gives you an even stronger algebraic-entry mode, in which all regular letter and punctuation keys begin algebraic entry. Use this if you prefer typing sqrt( ) instead of Q, factor( ) instead of a f, and so on. To type regular Calc commands when you are in Total Algebraic mode, hold down the META key. Thus M-q is the command to quit Calc, M-p sets the precision, and M-m t (or M-m M-t, if you prefer) turns Total Algebraic mode back off again. Meta keys also terminate algebraic entry, so that 2+3 M-S is equivalent to 2+3 RET M-S. The symbol ‘Alg*’ will appear in the mode line whenever you are in this mode.

Pressing ' (the apostrophe) a second time re-enters the previous algebraic formula. You can then use the normal Emacs editing keys to modify this formula to your liking before pressing RET.

Within a formula entered from the keyboard, the symbol $ represents the number on the top of the stack. If an entered formula contains any $ characters, the Calculator replaces the top of stack with that formula rather than simply pushing the formula onto the stack. Thus, ' 1+2 RET pushes 3 on the stack, and $*2 RET replaces it with 6. Note that the $ key always initiates algebraic entry; the ' is unnecessary if $ is the first character in the new formula.

Higher stack elements can be accessed from an entered formula with the symbols $$, $$$, and so on. The number of stack elements removed (to be replaced by the entered values) equals the number of dollar signs in the longest such symbol in the formula. For example, ‘$$+$$$’ adds the second and third stack elements, replacing the top three elements with the answer. (All information about the top stack element is thus lost since no single ‘$’ appears in this formula.)

A slightly different way to refer to stack elements is with a dollar sign followed by a number: ‘$1’, ‘$2’, and so on are much like ‘$’, ‘$$’, etc., except that stack entries referred to numerically are not replaced by the algebraic entry. That is, while ‘$+1’ replaces 5 on the stack with 6, ‘$1+1’ leaves the 5 on the stack and pushes an additional 6.

If a sequence of formulas are entered separated by commas, each formula is pushed onto the stack in turn. For example, ‘1,2,3’ pushes those three numbers onto the stack (leaving the 3 at the top), and ‘$+1,$-1’ replaces a 5 on the stack with 4 followed by 6. Also, ‘$,$$’ exchanges the top two elements of the stack, just like the TAB key.

You can finish an algebraic entry with M-= or M-RET instead of RET. This uses = to evaluate the variables in each formula that goes onto the stack. (Thus ' pi RET pushes the variable ‘pi’, but ' pi M-RET pushes 3.1415.)

If you finish your algebraic entry by pressing LFD (or C-j) instead of RET, Calc disables simplification (as if by m O; see Simplification Modes) while the entry is being pushed on the stack. Thus ' 1+2 RET pushes 3 on the stack, but ' 1+2 LFD pushes the formula ‘1+2’; you might then press = when it is time to evaluate this formula.


*** “Quick Calculator” Mode

There is another way to invoke the Calculator if all you need to do is make one or two quick calculations. Type C-x * q (or M-x quick-calc), then type any formula as an algebraic entry. The Calculator will compute the result and display it in the echo area, without ever actually putting up a Calc window.

You can use the $ character in a Quick Calculator formula to refer to the previous Quick Calculator result. Older results are not retained; the Quick Calculator has no effect on the full Calculator’s stack or trail. If you compute a result and then forget what it was, just run C-x * q again and enter ‘$’ as the formula.

If this is the first time you have used the Calculator in this Emacs session, the C-x * q command will create the *Calculator* buffer and perform all the usual initializations; it simply will refrain from putting that buffer up in a new window. The Quick Calculator refers to the *Calculator* buffer for all mode settings. Thus, for example, to set the precision that the Quick Calculator uses, simply run the full Calculator momentarily and use the regular p command.

If you use C-x * q from inside the Calculator buffer, the effect is the same as pressing the apostrophe key (algebraic entry).

The result of a Quick calculation is placed in the Emacs “kill ring” as well as being displayed. A subsequent C-y command will yank the result into the editing buffer. You can also use this to yank the result into the next C-x * q input line as a more explicit alternative to $ notation, or to yank the result into the Calculator stack after typing C-x * c.

If you give a prefix argument to C-x * q or finish your formula by typing LFD (or C-j) instead of RET, the result is inserted immediately into the current buffer rather than going into the kill ring.

Quick Calculator results are actually evaluated as if by the = key (which replaces variable names by their stored values, if any). If the formula you enter is an assignment to a variable using the ‘:=’ operator, say, ‘foo := 2 + 3’ or ‘foo := foo + 1’, then the result of the evaluation is stored in that Calc variable. See Storing and Recalling.

If the result is an integer and the current display radix is decimal, the number will also be displayed in hex, octal and binary formats. If the integer is in the range from 1 to 126, it will also be displayed as an ASCII character.

For example, the quoted character ‘"x"’ produces the vector result ‘[120]’ (because 120 is the ASCII code of the lower-case “x”; see Strings). Since this is a vector, not an integer, it is displayed only according to the current mode settings. But running Quick Calc again and entering ‘120’ will produce the result ‘120 (16#78, 8#170, x)’ which shows the number in its decimal, hexadecimal, octal, and ASCII forms.

Please note that the Quick Calculator is not any faster at loading or computing the answer than the full Calculator; the name “quick” merely refers to the fact that it’s much less hassle to use for small calculations.


*** Numeric Prefix Arguments

Many Calculator commands use numeric prefix arguments. Some, such as d s (calc-sci-notation), set a parameter to the value of the prefix argument or use a default if you don’t use a prefix. Others (like d f (calc-fix-notation)) require an argument and prompt for a number if you don’t give one as a prefix.

As a rule, stack-manipulation commands accept a numeric prefix argument which is interpreted as an index into the stack. A positive argument operates on the top n stack entries; a negative argument operates on the nth stack entry in isolation; and a zero argument operates on the entire stack.

Most commands that perform computations (such as the arithmetic and scientific functions) accept a numeric prefix argument that allows the operation to be applied across many stack elements. For unary operations (that is, functions of one argument like absolute value or complex conjugate), a positive prefix argument applies that function to the top n stack entries simultaneously, and a negative argument applies it to the nth stack entry only. For binary operations (functions of two arguments like addition, GCD, and vector concatenation), a positive prefix argument “reduces” the function across the top n stack elements (for example, C-u 5 + sums the top 5 stack entries; see Reducing and Mapping Vectors), and a negative argument maps the next-to-top n stack elements with the top stack element as a second argument (for example, 7 c-u -5 + adds 7 to the top 5 stack elements). This feature is not available for operations which use the numeric prefix argument for some other purpose.

Numeric prefixes are specified the same way as always in Emacs: Press a sequence of META-digits, or press ESC followed by digits, or press C-u followed by digits. Some commands treat plain C-u (without any actual digits) specially.

You can type ~ (calc-num-prefix) to pop an integer from the top of the stack and enter it as the numeric prefix for the next command. For example, C-u 16 p sets the precision to 16 digits; an alternate (silly) way to do this would be 2 RET 4 ^ ~ p, i.e., compute 2 to the fourth power and set the precision to that value.

Conversely, if you have typed a numeric prefix argument the ~ key pushes it onto the stack in the form of an integer.


*** Undoing Mistakes

The shift-U key (calc-undo) undoes the most recent operation. If that operation added or dropped objects from the stack, those objects are removed or restored. If it was a “store” operation, you are queried whether or not to restore the variable to its original value. The U key may be pressed any number of times to undo successively farther back in time; with a numeric prefix argument it undoes a specified number of operations. When the Calculator is quit, as with the q (calc-quit) command, the undo history will be truncated to the length of the customizable variable calc-undo-length (see Customizing Calc), which by default is ‘100’. (Recall that C-x * c is synonymous with calc-quit while inside the Calculator; this also truncates the undo history.)

Currently the mode-setting commands (like calc-precision) are not undoable. You can undo past a point where you changed a mode, but you will need to reset the mode yourself.

The shift-D key (calc-redo) redoes an operation that was mistakenly undone. Pressing U with a negative prefix argument is equivalent to executing calc-redo. You can redo any number of times, up to the number of recent consecutive undo commands. Redo information is cleared whenever you give any command that adds new undo information, i.e., if you undo, then enter a number on the stack or make any other change, then it will be too late to redo.

The M-RET key (calc-last-args) is like undo in that it restores the arguments of the most recent command onto the stack; however, it does not remove the result of that command. Given a numeric prefix argument, this command applies to the ‘n’th most recent command which removed items from the stack; it pushes those items back onto the stack.

The K (calc-keep-args) command provides a related function to M-RET. See Stack and Trail Commands.

It is also possible to recall previous results or inputs using the trail. See Trail Commands.

The standard Emacs C-_ undo key is recognized as a synonym for U.


*** Error Messages

Many situations that would produce an error message in other calculators simply create unsimplified formulas in the Emacs Calculator. For example, 1 RET 0 / pushes the formula ‘1 / 0’; 0 L pushes the formula ‘ln(0)’. Floating-point overflow and underflow are also reasons for this to happen.

When a function call must be left in symbolic form, Calc usually produces a message explaining why. Messages that are probably surprising or indicative of user errors are displayed automatically. Other messages are simply kept in Calc’s memory and are displayed only if you type w (calc-why). You can also press w if the same computation results in several messages. (The first message will end with ‘[w=more]’ in this case.)

The d w (calc-auto-why) command controls when error messages are displayed automatically. (Calc effectively presses w for you after your computation finishes.) By default, this occurs only for “important” messages. The other possible modes are to report all messages automatically, or to report none automatically (so that you must always press w yourself to see the messages).


*** Multiple Calculators

It is possible to have any number of Calc mode buffers at once. Usually this is done by executing M-x another-calc, which is similar to C-x * c except that if a *Calculator* buffer already exists, a new, independent one with a name of the form *Calculator*<n> is created. You can also use the command calc-mode to put any buffer into Calculator mode, but this would ordinarily never be done.

The q (calc-quit) command does not destroy a Calculator buffer; it only closes its window. Use M-x kill-buffer to destroy a Calculator buffer.

Each Calculator buffer keeps its own stack, undo list, and mode settings such as precision, angular mode, and display formats. In Emacs terms, variables such as calc-stack are buffer-local variables. The global default values of these variables are used only when a new Calculator buffer is created. The calc-quit command saves the stack and mode settings of the buffer being quit as the new defaults.

There is only one trail buffer, *Calc Trail*, used by all Calculator buffers.


*** Troubleshooting Commands

This section describes commands you can use in case a computation incorrectly fails or gives the wrong answer.

See Reporting Bugs, if you find a problem that appears to be due to a bug or deficiency in Calc.

**** Autoloading Problems

The Calc program is split into many component files; components are loaded automatically as you use various commands that require them. Occasionally Calc may lose track of when a certain component is necessary; typically this means you will type a command and it won’t work because some function you’ve never heard of was undefined.

If this happens, the easiest workaround is to type C-x * L (calc-load-everything) to force all the parts of Calc to be loaded right away. This will cause Emacs to take up a lot more memory than it would otherwise, but it’s guaranteed to fix the problem.


**** Recursion Depth

Calc uses recursion in many of its calculations. Emacs Lisp keeps a variable max-lisp-eval-depth which limits the amount of recursion possible in an attempt to recover from program bugs. If a calculation ever halts incorrectly with the message “Computation got stuck or ran too long,” use the M command (calc-more-recursion-depth) to increase this limit. (Of course, this will not help if the calculation really did get stuck due to some problem inside Calc.)

The limit is always increased (multiplied) by a factor of two. There is also an I M (calc-less-recursion-depth) command which decreases this limit by a factor of two, down to a minimum value of 200. The default value is 1000.


**** Caches

Calc saves certain values after they have been computed once. For example, the P (calc-pi) command initially “knows” the constant ‘pi’ to about 20 decimal places; if the current precision is greater than this, it will recompute ‘pi’ using a series approximation. This value will not need to be recomputed ever again unless you raise the precision still further. Many operations such as logarithms and sines make use of similarly cached values such as ‘pi/4’ and ‘ln(2)’. The visible effect of caching is that high-precision computations may seem to do extra work the first time. Other things cached include powers of two (for the binary arithmetic functions), matrix inverses and determinants, symbolic integrals, and data points computed by the graphing commands.

If you suspect a Calculator cache has become corrupt, you can use the calc-flush-caches command to reset all caches to the empty state. (This should only be necessary in the event of bugs in the Calculator.) The C-x * 0 (with the zero key) command also resets caches along with all other aspects of the Calculator’s state.


**** Debugging Calc

A few commands exist to help in the debugging of Calc commands. See Programming, to see the various ways that you can write your own Calc commands.

The Z T (calc-timing) command turns on and off a mode in which the timing of slow commands is reported in the Trail. Any Calc command that takes two seconds or longer writes a line to the Trail showing how many seconds it took. This value is accurate only to within one second.

All steps of executing a command are included; in particular, time taken to format the result for display in the stack and trail is counted. Some prompts also count time taken waiting for them to be answered, while others do not; this depends on the exact implementation of the command. For best results, if you are timing a sequence that includes prompts or multiple commands, define a keyboard macro to run the whole sequence at once. Calc’s X command (see Programming with Keyboard Macros) will then report the time taken to execute the whole macro.

Another advantage of the X command is that while it is executing, the stack and trail are not updated from step to step. So if you expect the output of your test sequence to leave a result that may take a long time to format and you don’t wish to count this formatting time, end your sequence with a DEL keystroke to clear the result from the stack. When you run the sequence with X, Calc will never bother to format the large result.

Another thing Z T does is to increase the Emacs variable gc-cons-threshold to a much higher value (two million; the usual default in Calc is 250,000) for the duration of each command. This generally prevents garbage collection during the timing of the command, though it may cause your Emacs process to grow abnormally large. (Garbage collection time is a major unpredictable factor in the timing of Emacs operations.)

Another command that is useful when debugging your own Lisp extensions to Calc is M-x calc-pass-errors, which disables the error handler that changes the “max-lisp-eval-depth exceeded” message to the much more friendly “Computation got stuck or ran too long.” This handler interferes with the Emacs Lisp debugger’s debug-on-error mode. Errors are reported in the handler itself rather than at the true location of the error. After you have executed calc-pass-errors, Lisp errors will be reported correctly but the user-friendly message will be lost.


** Data Types

This chapter discusses the various types of objects that can be placed on the Calculator stack, how they are displayed, and how they are entered. (See Data Type Formats, for information on how these data types are represented as underlying Lisp objects.)

Integers, fractions, and floats are various ways of describing real numbers. HMS forms also for many purposes act as real numbers. These types can be combined to form complex numbers, modulo forms, error forms, or interval forms. (But these last four types cannot be combined arbitrarily: error forms may not contain modulo forms, for example.) Finally, all these types of numbers may be combined into vectors, matrices, or algebraic formulas.

*** Integers

The Calculator stores integers to arbitrary precision. Addition, subtraction, and multiplication of integers always yields an exact integer result. (If the result of a division or exponentiation of integers is not an integer, it is expressed in fractional or floating-point form according to the current Fraction mode. See Fraction Mode.)

A decimal integer is represented as an optional sign followed by a sequence of digits. Grouping (see Grouping Digits) can be used to insert a comma at every third digit for display purposes, but you must not type commas during the entry of numbers.

A non-decimal integer is represented as an optional sign, a radix between 2 and 36, a ‘#’ symbol, and one or more digits. For radix 11 and above, the letters A through Z (upper- or lower-case) count as digits and do not terminate numeric entry mode. See Radix Modes, for how to set the default radix for display of integers. Numbers of any radix may be entered at any time. If you press # at the beginning of a number, the current display radix is used.


*** Fractions

A fraction is a ratio of two integers. Fractions are traditionally written “2/3” but Calc uses the notation ‘2:3’. (The / key performs RPN division; the following two sequences push the number ‘2:3’ on the stack: 2 : 3 RET, or 2 RET 3 / assuming Fraction mode has been enabled.) When the Calculator produces a fractional result it always reduces it to simplest form, which may in fact be an integer.

Fractions may also be entered in a three-part form, where ‘2:3:4’ represents two-and-three-quarters. See Fraction Formats, for fraction display formats.

Non-decimal fractions are entered and displayed as ‘radix#num:denom’ (or in the analogous three-part form). The numerator and denominator always use the same radix.


*** Floats

A floating-point number or float is a number stored in scientific notation. The number of significant digits in the fractional part is governed by the current floating precision (see Precision). The range of acceptable values is from ‘10^-3999999’ (inclusive) to ‘10^4000000’ (exclusive), plus the corresponding negative values and zero.

Calculations that would exceed the allowable range of values (such as ‘exp(exp(20))’) are left in symbolic form by Calc. The messages “floating-point overflow” or “floating-point underflow” indicate that during the calculation a number would have been produced that was too large or too close to zero, respectively, to be represented by Calc. This does not necessarily mean the final result would have overflowed, just that an overflow occurred while computing the result. (In fact, it could report an underflow even though the final result would have overflowed!)

If a rational number and a float are mixed in a calculation, the result will in general be expressed as a float. Commands that require an integer value (such as k g [gcd]) will also accept integer-valued floats, i.e., floating-point numbers with nothing after the decimal point.

Floats are identified by the presence of a decimal point and/or an exponent. In general a float consists of an optional sign, digits including an optional decimal point, and an optional exponent consisting of an ‘e’, an optional sign, and up to seven exponent digits. For example, ‘23.5e-2’ is 23.5 times ten to the minus-second power, or 0.235.

Floating-point numbers are normally displayed in decimal notation with all significant figures shown. Exceedingly large or small numbers are displayed in scientific notation. Various other display options are available. See Float Formats.

Floating-point numbers are stored in decimal, not binary. The result of each operation is rounded to the nearest value representable in the number of significant digits specified by the current precision, rounding away from zero in the case of a tie. Thus (in the default display mode) what you see is exactly what you get. Some operations such as square roots and transcendental functions are performed with several digits of extra precision and then rounded down, in an effort to make the final result accurate to the full requested precision. However, accuracy is not rigorously guaranteed. If you suspect the validity of a result, try doing the same calculation in a higher precision. The Calculator’s arithmetic is not intended to be IEEE-conformant in any way.

While floats are always stored in decimal, they can be entered and displayed in any radix just like integers and fractions. Since a float that is entered in a radix other that 10 will be converted to decimal, the number that Calc stores may not be exactly the number that was entered, it will be the closest decimal approximation given the current precision. The notation ‘radix#ddd.ddd’ is a floating-point number whose digits are in the specified radix. Note that the ‘.’ is more aptly referred to as a “radix point” than as a decimal point in this case. The number ‘8#123.4567’ is defined as ‘8#1234567 * 8^-4’. If the radix is 14 or less, you can use ‘e’ notation to write a non-decimal number in scientific notation. The exponent is written in decimal, and is considered to be a power of the radix: ‘8#1234567e-4’. If the radix is 15 or above, the letter ‘e’ is a digit, so scientific notation must be written out, e.g., ‘16#123.4567*16^2’. The first two exercises of the Modes Tutorial explore some of the properties of non-decimal floats.


*** Complex Numbers

There are two supported formats for complex numbers: rectangular and polar. The default format is rectangular, displayed in the form ‘(real,imag)’ where real is the real part and imag is the imaginary part, each of which may be any real number. Rectangular complex numbers can also be displayed in ‘a+bi’ notation; see Complex Formats.

Polar complex numbers are displayed in the form ‘(r;theta)’ where r is the nonnegative magnitude and theta is the argument or phase angle. The range of theta depends on the current angular mode (see Angular Modes); it is generally between -180 and +180 degrees or the equivalent range in radians.

Complex numbers are entered in stages using incomplete objects. See Incomplete Objects.

Operations on rectangular complex numbers yield rectangular complex results, and similarly for polar complex numbers. Where the two types are mixed, or where new complex numbers arise (as for the square root of a negative real), the current Polar mode is used to determine the type. See Polar Mode.

A complex result in which the imaginary part is zero (or the phase angle is 0 or 180 degrees or ‘pi’ radians) is automatically converted to a real number.


*** Infinities

The word inf represents the mathematical concept of infinity. Calc actually has three slightly different infinity-like values: inf, uinf, and nan. These are just regular variable names (see Variables); you should avoid using these names for your own variables because Calc gives them special treatment. Infinities, like all variable names, are normally entered using algebraic entry.

Mathematically speaking, it is not rigorously correct to treat “infinity” as if it were a number, but mathematicians often do so informally. When they say that ‘1 / inf = 0’, what they really mean is that ‘1 / x’, as ‘x’ becomes larger and larger, becomes arbitrarily close to zero. So you can imagine that if ‘x’ got “all the way to infinity,” then ‘1 / x’ would go all the way to zero. Similarly, when they say that ‘exp(inf) = inf’, they mean that ‘exp(x)’ grows without bound as ‘x’ grows. The symbol ‘-inf’ likewise stands for an infinitely negative real value; for example, we say that ‘exp(-inf) = 0’. You can have an infinity pointing in any direction on the complex plane: ‘sqrt(-inf) = i inf’.

The same concept of limits can be used to define ‘1 / 0’. We really want the value that ‘1 / x’ approaches as ‘x’ approaches zero. But if all we have is ‘1 / 0’, we can’t tell which direction ‘x’ was coming from. If ‘x’ was positive and decreasing toward zero, then we should say that ‘1 / 0 = inf’. But if ‘x’ was negative and increasing toward zero, the answer is ‘1 / 0 = -inf’. In fact, ‘x’ could be an imaginary number, giving the answer ‘i inf’ or ‘-i inf’. Calc uses the special symbol ‘uinf’ to mean undirected infinity, i.e., a value which is infinitely large but with an unknown sign (or direction on the complex plane).

Calc actually has three modes that say how infinities are handled. Normally, infinities never arise from calculations that didn’t already have them. Thus, ‘1 / 0’ is treated simply as an error and left unevaluated. The m i (calc-infinite-mode) command (see Infinite Mode) enables a mode in which ‘1 / 0’ evaluates to uinf instead. There is also an alternative type of infinite mode which says to treat zeros as if they were positive, so that ‘1 / 0 = inf’. While this is less mathematically correct, it may be the answer you want in some cases.

Since all infinities are “as large” as all others, Calc simplifies, e.g., ‘5 inf’ to ‘inf’. Another example is ‘5 - inf = -inf’, where the ‘-inf’ is so large that adding a finite number like five to it does not affect it. Note that ‘a - inf’ also results in ‘-inf’; Calc assumes that variables like a always stand for finite quantities. Just to show that infinities really are all the same size, note that ‘sqrt(inf) = inf^2 = exp(inf) = inf’ in Calc’s notation.

It’s not so easy to define certain formulas like ‘0 * inf’ and ‘inf / inf’. Depending on where these zeros and infinities came from, the answer could be literally anything. The latter formula could be the limit of ‘x / x’ (giving a result of one), or ‘2 x / x’ (giving two), or ‘x^2 / x’ (giving inf), or ‘x / x^2’ (giving zero). Calc uses the symbol nan to represent such an indeterminate value. (The name “nan” comes from analogy with the “NAN” concept of IEEE standard arithmetic; it stands for “Not A Number.” This is somewhat of a misnomer, since nan does stand for some number or infinity, it’s just that which number it stands for cannot be determined.) In Calc’s notation, ‘0 * inf = nan’ and ‘inf / inf = nan’. A few other common indeterminate expressions are ‘inf - inf’ and ‘inf ^ 0’. Also, ‘0 / 0 = nan’ if you have turned on Infinite mode (as described above).

Infinities are especially useful as parts of intervals. See Interval Forms.


*** Vectors and Matrices

The vector data type is flexible and general. A vector is simply a list of zero or more data objects. When these objects are numbers, the whole is a vector in the mathematical sense. When these objects are themselves vectors of equal (nonzero) length, the whole is a matrix. A vector which is not a matrix is referred to here as a plain vector.

A vector is displayed as a list of values separated by commas and enclosed in square brackets: ‘[1, 2, 3]’. Thus the following is a 2 row by 3 column matrix: ‘[[1, 2, 3], [4, 5, 6]]’. Vectors, like complex numbers, are entered as incomplete objects. See Incomplete Objects. During algebraic entry, vectors are entered all at once in the usual brackets-and-commas form. Matrices may be entered algebraically as nested vectors, or using the shortcut notation ‘[1, 2, 3; 4, 5, 6]’, with rows separated by semicolons. The commas may usually be omitted when entering vectors: ‘[1 2 3]’. Curly braces may be used in place of brackets: ‘{1, 2, 3}’, but the commas are required in this case.

Traditional vector and matrix arithmetic is also supported; see Basic Arithmetic and see Vector/Matrix Functions. Many other operations are applied to vectors element-wise. For example, the complex conjugate of a vector is a vector of the complex conjugates of its elements.

Algebraic functions for building vectors include ‘vec(a, b, c)’ to build ‘[a, b, c]’, ‘cvec(a, n, m)’ to build an nxm matrix of ‘a’s, and ‘index(n)’ to build a vector of integers from 1 to ‘n’.


*** Strings

Character strings are not a special data type in the Calculator. Rather, a string is represented simply as a vector all of whose elements are integers in the range 0 to 255 (ASCII codes). You can enter a string at any time by pressing the " key. Quotation marks and backslashes are written ‘\"’ and ‘\\’, respectively, inside strings. Other notations introduced by backslashes are:

\a     7          \^@    0
\b     8          \^a-z  1-26
\e     27         \^[    27
\f     12         \^\\   28
\n     10         \^]    29
\r     13         \^^    30
\t     9          \^_    31
                  \^?    127
Finally, a backslash followed by three octal digits produces any character from its ASCII code.

Strings are normally displayed in vector-of-integers form. The d " (calc-display-strings) command toggles a mode in which any vectors of small integers are displayed as quoted strings instead.

The backslash notations shown above are also used for displaying strings. Characters 128 and above are not translated by Calc; unless you have an Emacs modified for 8-bit fonts, these will show up in backslash-octal-digits notation. For characters below 32, and for character 127, Calc uses the backslash-letter combination if there is one, or otherwise uses a ‘\^’ sequence.

The only Calc feature that uses strings is compositions; see Compositions. Strings also provide a convenient way to do conversions between ASCII characters and integers.

There is a string function which provides a different display format for strings. Basically, ‘string(s)’, where s is a vector of integers in the proper range, is displayed as the corresponding string of characters with no surrounding quotation marks or other modifications. Thus ‘string("ABC")’ (or ‘string([65 66 67])’) will look like ‘ABC’ on the stack. This happens regardless of whether d " has been used. The only way to turn it off is to use d U (unformatted language mode) which will display ‘string("ABC")’ instead.

Control characters are displayed somewhat differently by string. Characters below 32, and character 127, are shown using ‘^’ notation (same as shown above, but without the backslash). The quote and backslash characters are left alone, as are characters 128 and above.

The bstring function is just like string except that the resulting string is breakable across multiple lines if it doesn’t fit all on one line. Potential break points occur at every space character in the string.


*** HMS Forms

HMS stands for Hours-Minutes-Seconds; when used as an angular argument, the interpretation is Degrees-Minutes-Seconds. All functions that operate on angles accept HMS forms. These are interpreted as degrees regardless of the current angular mode. It is also possible to use HMS as the angular mode so that calculated angles are expressed in degrees, minutes, and seconds.

The default format for HMS values is ‘hours@ mins' secs"’. During entry, the letters ‘h’ (for “hours”) or ‘o’ (approximating the “degrees” symbol) are accepted as well as ‘@’, ‘m’ is accepted in place of ‘'’, and ‘s’ is accepted in place of ‘"’. The hours value is an integer (or integer-valued float). The mins value is an integer or integer-valued float between 0 and 59. The secs value is a real number between 0 (inclusive) and 60 (exclusive). A positive HMS form is interpreted as hours + mins/60 + secs/3600. A negative HMS form is interpreted as - hours - mins/60 - secs/3600. Display format for HMS forms is quite flexible. See HMS Formats.

HMS forms can be added and subtracted. When they are added to numbers, the numbers are interpreted according to the current angular mode. HMS forms can also be multiplied and divided by real numbers. Dividing two HMS forms produces a real-valued ratio of the two angles.

Just for kicks, M-x calc-time pushes the current time of day on the stack as an HMS form.


*** Date Forms

A date form represents a date and possibly an associated time. Simple date arithmetic is supported: Adding a number to a date produces a new date shifted by that many days; adding an HMS form to a date shifts it by that many hours. Subtracting two date forms computes the number of days between them (represented as a simple number). Many other operations, such as multiplying two date forms, are nonsensical and are not allowed by Calc.

Date forms are entered and displayed enclosed in ‘< >’ brackets. The default format is, e.g., ‘<Wed Jan 9, 1991>’ for dates, or ‘<3:32:20pm Wed Jan 9, 1991>’ for dates with times. Input is flexible; date forms can be entered in any of the usual notations for dates and times. See Date Formats.

Date forms are stored internally as numbers, specifically the number of days since midnight on the morning of December 31 of the year 1 BC. If the internal number is an integer, the form represents a date only; if the internal number is a fraction or float, the form represents a date and time. For example, ‘<6:00am Thu Jan 10, 1991>’ is represented by the number 726842.25. The standard precision of 12 decimal digits is enough to ensure that a (reasonable) date and time can be stored without roundoff error.

If the current precision is greater than 12, date forms will keep additional digits in the seconds position. For example, if the precision is 15, the seconds will keep three digits after the decimal point. Decreasing the precision below 12 may cause the time part of a date form to become inaccurate. This can also happen if astronomically high years are used, though this will not be an issue in everyday (or even everymillennium) use. Note that date forms without times are stored as exact integers, so roundoff is never an issue for them.

You can use the v p (calc-pack) and v u (calc-unpack) commands to get at the numerical representation of a date form. See Packing and Unpacking.

Date forms can go arbitrarily far into the future or past. Negative year numbers represent years BC. There is no “year 0”; the day before ‘<Mon Jan 1, +1>’ is ‘<Sun Dec 31, -1>’. These are days 1 and 0 respectively in Calc’s internal numbering scheme. The Gregorian calendar is used for all dates, including dates before the Gregorian calendar was invented (although that can be configured; see below). Thus Calc’s use of the day number -10000 to represent August 15, 28 BC should be taken with a grain of salt.

Some historical background: The Julian calendar was created by Julius Caesar in the year 46 BC as an attempt to fix the confusion caused by the irregular Roman calendar that was used before that time. The Julian calendar introduced an extra day in all years divisible by four. After some initial confusion, the calendar was adopted around the year we call 8 AD. Some centuries later it became apparent that the Julian year of 365.25 days was itself not quite right. In 1582 Pope Gregory XIII introduced the Gregorian calendar, which added the new rule that years divisible by 100, but not by 400, were not to be considered leap years despite being divisible by four. Many countries delayed adoption of the Gregorian calendar because of religious differences. For example, Great Britain and the British colonies switched to the Gregorian calendar in September 1752, when the Julian calendar was eleven days behind the Gregorian calendar. That year in Britain, the day after September 2 was September 14. To take another example, Russia did not adopt the Gregorian calendar until 1918, and that year in Russia the day after January 31 was February 14. Calc’s reckoning therefore matches English practice starting in 1752 and Russian practice starting in 1918, but disagrees with earlier dates in both countries.

When the Julian calendar was introduced, it had January 1 as the first day of the year. By the Middle Ages, many European countries had changed the beginning of a new year to a different date, often to a religious festival. Almost all countries reverted to using January 1 as the beginning of the year by the time they adopted the Gregorian calendar.

Some calendars attempt to mimic the historical situation by using the Gregorian calendar for recent dates and the Julian calendar for older dates. The cal program in most Unix implementations does this, for example. While January 1 wasn’t always the beginning of a calendar year, these hybrid calendars still use January 1 as the beginning of the year even for older dates. The customizable variable calc-gregorian-switch (see Customizing Calc) can be set to have Calc’s date forms switch from the Julian to Gregorian calendar at any specified date.

Today’s timekeepers introduce an occasional “leap second”. These do not occur regularly and Calc does not take these minor effects into account. (If it did, it would have to report a non-integer number of days between, say, ‘<12:00am Mon Jan 1, 1900>’ and ‘<12:00am Sat Jan 1, 2000>’.)

Another day counting system in common use is, confusingly, also called “Julian.” Julian days go from noon to noon. The Julian day number is the numbers of days since 12:00 noon (GMT) on November 24, 4714 BC in the Gregorian calendar (i.e., January 1, 4713 BC in the Julian calendar). In Calc’s scheme (in GMT) the Julian day origin is -1721424.5, because Calc starts at midnight instead of noon. Thus to convert a Calc date code obtained by unpacking a date form into a Julian day number, simply add 1721424.5 after compensating for the time zone difference. The built-in t J command performs this conversion for you.

The Julian day number is based on the Julian cycle, which was invented in 1583 by Joseph Justus Scaliger. Scaliger named it the Julian cycle since it involves the Julian calendar, but some have suggested that Scaliger named it in honor of his father, Julius Caesar Scaliger. The Julian cycle is based on three other cycles: the indiction cycle, the Metonic cycle, and the solar cycle. The indiction cycle is a 15 year cycle originally used by the Romans for tax purposes but later used to date medieval documents. The Metonic cycle is a 19 year cycle; 19 years is close to being a common multiple of a solar year and a lunar month, and so every 19 years the phases of the moon will occur on the same days of the year. The solar cycle is a 28 year cycle; the Julian calendar repeats itself every 28 years. The smallest time period which contains multiples of all three cycles is the least common multiple of 15 years, 19 years and 28 years, which (since they’re pairwise relatively prime) is 15*19*28 = 7980 years. This is the length of a Julian cycle. Working backwards, the previous year in which all three cycles began was 4713 BC, and so Scaliger chose that year as the beginning of a Julian cycle. Since at the time there were no historical records from before 4713 BC, using this year as a starting point had the advantage of avoiding negative year numbers. In 1849, the astronomer John Herschel (son of William Herschel) suggested using the number of days since the beginning of the Julian cycle as an astronomical dating system; this idea was taken up by other astronomers. (At the time, noon was the start of the astronomical day. Herschel originally suggested counting the days since Jan 1, 4713 BC at noon Alexandria time; this was later amended to noon GMT.) Julian day numbering is largely used in astronomy.

The Unix operating system measures time as an integer number of seconds since midnight, Jan 1, 1970. To convert a Calc date value into a Unix time stamp, first subtract 719163 (the code for ‘<Jan 1, 1970>’), then multiply by 86400 (the number of seconds in a day) and press R to round to the nearest integer. If you have a date form, you can simply subtract the day ‘<Jan 1, 1970>’ instead of unpacking and subtracting 719163. Likewise, divide by 86400 and add ‘<Jan 1, 1970>’ to convert from Unix time to a Calc date form. (Note that Unix normally maintains the time in the GMT time zone; you may need to subtract five hours to get New York time, or eight hours for California time. The same is usually true of Julian day counts.) The built-in t U command performs these conversions.


*** Modulo Forms

A modulo form is a real number which is taken modulo (i.e., within an integer multiple of) some value M. Arithmetic modulo M often arises in number theory. Modulo forms are written ‘a mod M’, where a and M are real numbers or HMS forms, and ‘0 <= a < M’. In many applications ‘a’ and ‘M’ will be integers but this is not required.

To create a modulo form during numeric entry, press the shift-M key to enter the word ‘mod’. As a special convenience, pressing shift-M a second time automatically enters the value of ‘M’ that was most recently used before. During algebraic entry, either type ‘mod’ by hand or press M-m (that’s META-m). Once again, pressing this a second time enters the current modulo.

Modulo forms are not to be confused with the modulo operator ‘%’. The expression ‘27 % 10’ means to compute 27 modulo 10 to produce the result 7. Further computations treat this 7 as just a regular integer. The expression ‘27 mod 10’ produces the result ‘7 mod 10’; further computations with this value are again reduced modulo 10 so that the result always lies in the desired range.

When two modulo forms with identical ‘M’’s are added or multiplied, the Calculator simply adds or multiplies the values, then reduces modulo ‘M’. If one argument is a modulo form and the other a plain number, the plain number is treated like a compatible modulo form. It is also possible to raise modulo forms to powers; the result is the value raised to the power, then reduced modulo ‘M’. (When all values involved are integers, this calculation is done much more efficiently than actually computing the power and then reducing.)

Two modulo forms ‘a mod M’ and ‘b mod M’ can be divided if ‘a’, ‘b’, and ‘M’ are all integers. The result is the modulo form which, when multiplied by ‘b mod M’, produces ‘a mod M’. If there is no solution to this equation (which can happen only when ‘M’ is non-prime), or if any of the arguments are non-integers, the division is left in symbolic form. Other operations, such as square roots, are not yet supported for modulo forms. (Note that, although ‘(a mod M)^.5’ will compute a “modulo square root” in the sense of reducing ‘sqrt(a)’ modulo ‘M’, this is not a useful definition from the number-theoretical point of view.)

It is possible to mix HMS forms and modulo forms. For example, an HMS form modulo 24 could be used to manipulate clock times; an HMS form modulo 360 would be suitable for angles. Making the modulo ‘M’ also be an HMS form eliminates troubles that would arise if the angular mode were inadvertently set to Radians, in which case ‘2@ 0' 0" mod 24’ would be interpreted as two degrees modulo 24 radians!

Modulo forms cannot have variables or formulas for components. If you enter the formula ‘(x + 2) mod 5’, Calc propagates the modulus to each of the coefficients: ‘(1 mod 5) x + (2 mod 5)’.

You can use v p and % to modify modulo forms. See Packing and Unpacking. See Basic Arithmetic.

The algebraic function ‘makemod(a, m)’ builds the modulo form ‘a mod m’.


*** Error Forms

An error form is a number with an associated standard deviation, as in ‘2.3 +/- 0.12’. The notation ‘x +/- sigma’ stands for an uncertain value which follows a normal or Gaussian distribution of mean ‘x’ and standard deviation or “error” ‘sigma’. Both the mean and the error can be either numbers or formulas. Generally these are real numbers but the mean may also be complex. If the error is negative or complex, it is changed to its absolute value. An error form with zero error is converted to a regular number by the Calculator.

All arithmetic and transcendental functions accept error forms as input. Operations on the mean-value part work just like operations on regular numbers. The error part for any function ‘f(x)’ (such as ‘sin(x)’) is defined by the error of ‘x’ times the derivative of ‘f’ evaluated at the mean value of ‘x’. For a two-argument function ‘f(x,y)’ (such as addition) the error is the square root of the sum of the squares of the errors due to ‘x’ and ‘y’. Note that this definition assumes the errors in ‘x’ and ‘y’ are uncorrelated. A side effect of this definition is that ‘(2 +/- 1) * (2 +/- 1)’ is not the same as ‘(2 +/- 1)^2’; the former represents the product of two independent values which happen to have the same probability distributions, and the latter is the product of one random value with itself. The former will produce an answer with less error, since on the average the two independent errors can be expected to cancel out.

Consult a good text on error analysis for a discussion of the proper use of standard deviations. Actual errors often are neither Gaussian-distributed nor uncorrelated, and the above formulas are valid only when errors are small. As an example, the error arising from ‘sin(x +/- sigma)’ is ‘sigma abs(cos(x))’. When ‘x’ is close to zero, ‘cos(x)’ is close to one so the error in the sine is close to ‘sigma’; this makes sense, since ‘sin(x)’ is approximately ‘x’ near zero, so a given error in ‘x’ will produce about the same error in the sine. Likewise, near 90 degrees ‘cos(x)’ is nearly zero and so the computed error is small: The sine curve is nearly flat in that region, so an error in ‘x’ has relatively little effect on the value of ‘sin(x)’. However, consider ‘sin(90 +/- 1000)’. The cosine of 90 is zero, so Calc will report zero error! We get an obviously wrong result because we have violated the small-error approximation underlying the error analysis. If the error in ‘x’ had been small, the error in ‘sin(x)’ would indeed have been negligible.

To enter an error form during regular numeric entry, use the p (“plus-or-minus”) key to type the ‘+/-’ symbol. (If you try actually typing ‘+/-’ the + key will be interpreted as the Calculator’s + command!) Within an algebraic formula, you can press M-+ to type the ‘+/-’ symbol, or type it out by hand.

Error forms and complex numbers can be mixed; the formulas shown above are used for complex numbers, too; note that if the error part evaluates to a complex number its absolute value (or the square root of the sum of the squares of the absolute values of the two error contributions) is used. Mathematically, this corresponds to a radially symmetric Gaussian distribution of numbers on the complex plane. However, note that Calc considers an error form with real components to represent a real number, not a complex distribution around a real mean.

Error forms may also be composed of HMS forms. For best results, both the mean and the error should be HMS forms if either one is.

The algebraic function ‘sdev(a, b)’ builds the error form ‘a +/- b’.


*** Interval Forms

An interval is a subset of consecutive real numbers. For example, the interval ‘[2 .. 4]’ represents all the numbers from 2 to 4, inclusive. If you multiply it by the interval ‘[0.5 .. 2]’ you obtain ‘[1 .. 8]’. This calculation represents the fact that if you multiply some number in the range ‘[2 .. 4]’ by some other number in the range ‘[0.5 .. 2]’, your result will lie in the range from 1 to 8. Interval arithmetic is used to get a worst-case estimate of the possible range of values a computation will produce, given the set of possible values of the input.

Calc supports several varieties of intervals, including closed intervals of the type shown above, open intervals such as ‘(2 .. 4)’, which represents the range of numbers from 2 to 4 exclusive, and semi-open intervals in which one end uses a round parenthesis and the other a square bracket. In mathematical terms, ‘[2 .. 4]’ means ‘2 <= x <= 4’, whereas ‘[2 .. 4)’ represents ‘2 <= x < 4’, ‘(2 .. 4]’ represents ‘2 < x <= 4’, and ‘(2 .. 4)’ represents ‘2 < x < 4’.

The lower and upper limits of an interval must be either real numbers (or HMS or date forms), or symbolic expressions which are assumed to be real-valued, or ‘-inf’ and ‘inf’. In general the lower limit must be less than the upper limit. A closed interval containing only one value, ‘[3 .. 3]’, is converted to a plain number (3) automatically. An interval containing no values at all (such as ‘[3 .. 2]’ or ‘[2 .. 2)’) can be represented but is not guaranteed to behave well when used in arithmetic. Note that the interval ‘[3 .. inf)’ represents all real numbers greater than or equal to 3, and ‘(-inf .. inf)’ represents all real numbers. In fact, ‘[-inf .. inf]’ represents all real numbers including the real infinities.

Intervals are entered in the notation shown here, either as algebraic formulas, or using incomplete forms. (See Incomplete Objects.) In algebraic formulas, multiple periods in a row are collected from left to right, so that ‘1...1e2’ is interpreted as ‘1.0 .. 1e2’ rather than ‘1 .. 0.1e2’. Add spaces or zeros if you want to get the other interpretation. If you omit the lower or upper limit, a default of ‘-inf’ or ‘inf’ (respectively) is furnished.

Infinite mode also affects operations on intervals (see Infinities). Calc will always introduce an open infinity, as in ‘1 / (0 .. 2] = [0.5 .. inf)’. But closed infinities, ‘1 / [0 .. 2] = [0.5 .. inf]’, arise only in Infinite mode; otherwise they are left unevaluated. Note that the “direction” of a zero is not an issue in this case since the zero is always assumed to be continuous with the rest of the interval. For intervals that contain zero inside them Calc is forced to give the result, ‘1 / (-2 .. 2) = [-inf .. inf]’.

While it may seem that intervals and error forms are similar, they are based on entirely different concepts of inexact quantities. An error form ‘x +/- sigma’ means a variable is random, and its value could be anything but is “probably” within one sigma of the mean value ‘x’. An interval ‘[a .. b]’ means a variable’s value is unknown, but guaranteed to lie in the specified range. Error forms are statistical or “average case” approximations; interval arithmetic tends to produce “worst case” bounds on an answer.

Intervals may not contain complex numbers, but they may contain HMS forms or date forms.

See Set Operations using Vectors, for commands that interpret interval forms as subsets of the set of real numbers.

The algebraic function ‘intv(n, a, b)’ builds an interval form from ‘a’ to ‘b’; ‘n’ is an integer code which must be 0 for ‘(..)’, 1 for ‘(..]’, 2 for ‘[..)’, or 3 for ‘[..]’.

Please note that in fully rigorous interval arithmetic, care would be taken to make sure that the computation of the lower bound rounds toward minus infinity, while upper bound computations round toward plus infinity. Calc’s arithmetic always uses a round-to-nearest mode, which means that roundoff errors could creep into an interval calculation to produce intervals slightly smaller than they ought to be. For example, entering ‘[1..2]’ and pressing Q 2 ^ should yield the interval ‘[1..2]’ again, but in fact it yields the (slightly too small) interval ‘[1..1.9999999]’ due to roundoff error.


*** Incomplete Objects

When ( or [ is typed to begin entering a complex number or vector, respectively, the effect is to push an incomplete complex number or vector onto the stack. The , key adds the value(s) at the top of the stack onto the current incomplete object. The ) and ] keys “close” the incomplete object after adding any values on the top of the stack in front of the incomplete object.

As a result, the sequence of keystrokes [ 2 , 3 RET 2 * , 9 ] pushes the vector ‘[2, 6, 9]’ onto the stack. Likewise, ( 1 , 2 Q ) pushes the complex number ‘(1, 1.414)’ (approximately).

If several values lie on the stack in front of the incomplete object, all are collected and appended to the object. Thus the , key is redundant: [ 2 RET 3 RET 2 * 9 ]. Some people prefer the equivalent SPC key to RET.

As a special case, typing , immediately after (, [, or , adds a zero or duplicates the preceding value in the list being formed. Typing DEL during incomplete entry removes the last item from the list.

The ; key is used in the same way as , to create polar complex numbers: ( 1 ; 2 ). When entering a vector, ; is useful for creating a matrix. In particular, [ [ 1 , 2 ; 3 , 4 ; 5 , 6 ] ] is equivalent to [ [ 1 , 2 ] , [ 3 , 4 ] , [ 5 , 6 ] ].

Incomplete entry is also used to enter intervals. For example, [ 2 .. 4 ) enters a semi-open interval. Note that when you type the first period, it will be interpreted as a decimal point, but when you type a second period immediately afterward, it is re-interpreted as part of the interval symbol. Typing .. corresponds to executing the calc-dots command.

If you find incomplete entry distracting, you may wish to enter vectors and complex numbers as algebraic formulas by pressing the apostrophe key.


*** Variables

A variable is somewhere between a storage register on a conventional calculator, and a variable in a programming language. (In fact, a Calc variable is really just an Emacs Lisp variable that contains a Calc number or formula.) A variable’s name is normally composed of letters and digits. Calc also allows apostrophes and # signs in variable names. (The Calc variable foo corresponds to the Emacs Lisp variable var-foo, but unless you access the variable from within Emacs Lisp, you don’t need to worry about it. Variable names in algebraic formulas implicitly have ‘var-’ prefixed to their names. The ‘#’ character in variable names used in algebraic formulas corresponds to a dash ‘-’ in the Lisp variable name. If the name contains any dashes, the prefix ‘var-’ is not automatically added. Thus the two formulas ‘foo + 1’ and ‘var#foo + 1’ both refer to the same variable.)

In a command that takes a variable name, you can either type the full name of a variable, or type a single digit to use one of the special convenience variables q0 through q9. For example, 3 s s 2 stores the number 3 in variable q2, and 3 s s foo RET stores that number in variable foo.

To push a variable itself (as opposed to the variable’s value) on the stack, enter its name as an algebraic expression using the apostrophe (') key.

The = (calc-evaluate) key “evaluates” a formula by replacing all variables in the formula which have been given values by a calc-store or calc-let command by their stored values. Other variables are left alone. Thus a variable that has not been stored acts like an abstract variable in algebra; a variable that has been stored acts more like a register in a traditional calculator. With a positive numeric prefix argument, = evaluates the top n stack entries; with a negative argument, = evaluates the nth stack entry.

A few variables are called special constants. Their names are ‘e’, ‘pi’, ‘i’, ‘phi’, and ‘gamma’. (See Scientific Functions.) When they are evaluated with =, their values are calculated if necessary according to the current precision or complex polar mode. If you wish to use these symbols for other purposes, simply undefine or redefine them using calc-store.

The variables ‘inf’, ‘uinf’, and ‘nan’ stand for infinite or indeterminate values. It’s best not to use them as regular variables, since Calc uses special algebraic rules when it manipulates them. Calc displays a warning message if you store a value into any of these special variables.

See Storing and Recalling, for a discussion of commands dealing with variables.


*** Formulas

When you press the apostrophe key you may enter any expression or formula in algebraic form. (Calc uses the terms “expression” and “formula” interchangeably.) An expression is built up of numbers, variable names, and function calls, combined with various arithmetic operators. Parentheses may be used to indicate grouping. Spaces are ignored within formulas, except that spaces are not permitted within variable names or numbers. Arithmetic operators, in order from highest to lowest precedence, and with their equivalent function names, are:

‘_’ [subscr] (subscripts);

postfix ‘%’ [percent] (as in ‘25% = 0.25’);

prefix ‘!’ [lnot] (logical “not,” as in ‘!x’);

‘+/-’ [sdev] (the standard deviation symbol) and ‘mod’ [makemod] (the symbol for modulo forms);

postfix ‘!’ [fact] (factorial, as in ‘n!’) and postfix ‘!!’ [dfact] (double factorial);

‘^’ [pow] (raised-to-the-power-of);

prefix ‘+’ and ‘-’ [neg] (as in ‘-x’);

‘*’ [mul];

‘/’ [div], ‘%’ [mod] (modulo), and ‘\’ [idiv] (integer division);

infix ‘+’ [add] and ‘-’ [sub] (as in ‘x-y’);

‘|’ [vconcat] (vector concatenation);

relations ‘=’ [eq], ‘!=’ [neq], ‘<’ [lt], ‘>’ [gt], ‘<=’ [leq], and ‘>=’ [geq];

‘&&’ [land] (logical “and”);

‘||’ [lor] (logical “or”);

the C-style “if” operator ‘a?b:c’ [if];

‘!!!’ [pnot] (rewrite pattern “not”);

‘&&&’ [pand] (rewrite pattern “and”);

‘|||’ [por] (rewrite pattern “or”);

‘:=’ [assign] (for assignments and rewrite rules);

‘::’ [condition] (rewrite pattern condition);

‘=>’ [evalto].

Note that, unlike in usual computer notation, multiplication binds more strongly than division: ‘a*b/c*d’ is equivalent to ‘(a*b)/(c*d)’.

The multiplication sign ‘*’ may be omitted in many cases. In particular, if the righthand side is a number, variable name, or parenthesized expression, the ‘*’ may be omitted. Implicit multiplication has the same precedence as the explicit ‘*’ operator. The one exception to the rule is that a variable name followed by a parenthesized expression, as in ‘f(x)’, is interpreted as a function call, not an implicit ‘*’. In many cases you must use a space if you omit the ‘*’: ‘2a’ is the same as ‘2*a’, and ‘a b’ is the same as ‘a*b’, but ‘ab’ is a variable called ab, not the product of ‘a’ and ‘b’! Also note that ‘f (x)’ is still a function call.

The rules are slightly different for vectors written with square brackets. In vectors, the space character is interpreted (like the comma) as a separator of elements of the vector. Thus ‘[ 2a b+c d ]’ is equivalent to ‘[2*a, b+c, d]’, whereas ‘2a b+c d’ is equivalent to ‘2*a*b + c*d’. Note that spaces around the brackets, and around explicit commas, are ignored. To force spaces to be interpreted as multiplication you can enclose a formula in parentheses as in ‘[(a b) 2(c d)]’, which is interpreted as ‘[a*b, 2*c*d]’. An implicit comma is also inserted between ‘][’, as in the matrix ‘[[1 2][3 4]]’.

Vectors that contain commas (not embedded within nested parentheses or brackets) do not treat spaces specially: ‘[a b, 2 c d]’ is a vector of two elements. Also, if it would be an error to treat spaces as separators, but not otherwise, then Calc will ignore spaces: ‘[a - b]’ is a vector of one element, but ‘[a -b]’ is a vector of two elements. Finally, vectors entered with curly braces instead of square brackets do not give spaces any special treatment. When Calc displays a vector that does not contain any commas, it will insert parentheses if necessary to make the meaning clear: ‘[(a b)]’.

The expression ‘5%-2’ is ambiguous; is this five-percent minus two, or five modulo minus-two? Calc always interprets the leftmost symbol as an infix operator preferentially (modulo, in this case), so you would need to write ‘(5%)-2’ to get the former interpretation.

A function call is, e.g., ‘sin(1+x)’. (The Calc algebraic function foo corresponds to the Emacs Lisp function calcFunc-foo, but unless you access the function from within Emacs Lisp, you don’t need to worry about it.) Most mathematical Calculator commands like calc-sin have function equivalents like sin. If no Lisp function is defined for a function called by a formula, the call is left as it is during algebraic manipulation: ‘f(x+y)’ is left alone. Beware that many innocent-looking short names like in and re have predefined meanings which could surprise you; however, single letters or single letters followed by digits are always safe to use for your own function names. See Index of Algebraic Functions.

In the documentation for particular commands, the notation H S (calc-sinh) [sinh] means that the key sequence H S, the command M-x calc-sinh, and the algebraic function sinh(x) all represent the same operation.

Commands that interpret (“parse”) text as algebraic formulas include algebraic entry ('), editing commands like ` which parse the contents of the editing buffer when you finish, the C-x * g and C-x * r commands, the C-y command, the X window system “paste” mouse operation, and Embedded mode. All of these operations use the same rules for parsing formulas; in particular, language modes (see Language Modes) affect them all in the same way.

When you read a large amount of text into the Calculator (say a vector which represents a big set of rewrite rules; see Rewrite Rules), you may wish to include comments in the text. Calc’s formula parser ignores the symbol ‘%%’ and anything following it on a line:

[ a + b,   %% the sum of "a" and "b"
  c + d,
  %% last line is coming up:
  e + f ]
This is parsed exactly the same as ‘[ a + b, c + d, e + f ]’.

See Syntax Tables, for a way to create your own operators and other input notations. See Compositions, for a way to create new display formats.

See Algebra, for commands for manipulating formulas symbolically.


** Stack and Trail Commands

This chapter describes the Calc commands for manipulating objects on the stack and in the trail buffer. (These commands operate on objects of any type, such as numbers, vectors, formulas, and incomplete objects.)

*** Stack Manipulation Commands

To duplicate the top object on the stack, press RET or SPC (two equivalent keys for the calc-enter command). Given a positive numeric prefix argument, these commands duplicate several elements at the top of the stack. Given a negative argument, these commands duplicate the specified element of the stack. Given an argument of zero, they duplicate the entire stack. For example, with ‘10 20 30’ on the stack, RET creates ‘10 20 30 30’, C-u 2 RET creates ‘10 20 30 20 30’, C-u - 2 RET creates ‘10 20 30 20’, and C-u 0 RET creates ‘10 20 30 10 20 30’.

The LFD (calc-over) command (on a key marked Line-Feed if you have it, else on C-j) is like calc-enter except that the sign of the numeric prefix argument is interpreted oppositely. Also, with no prefix argument the default argument is 2. Thus with ‘10 20 30’ on the stack, LFD and C-u 2 LFD are both equivalent to C-u - 2 RET, producing ‘10 20 30 20’.

To remove the top element from the stack, press DEL (calc-pop). The C-d key is a synonym for DEL. (If the top element is an incomplete object with at least one element, the last element is removed from it.) Given a positive numeric prefix argument, several elements are removed. Given a negative argument, the specified element of the stack is deleted. Given an argument of zero, the entire stack is emptied. For example, with ‘10 20 30’ on the stack, DEL leaves ‘10 20’, C-u 2 DEL leaves ‘10’, C-u - 2 DEL leaves ‘10 30’, and C-u 0 DEL leaves an empty stack.

The M-DEL (calc-pop-above) command is to DEL what LFD is to RET: It interprets the sign of the numeric prefix argument in the opposite way, and the default argument is 2. Thus M-DEL by itself removes the second-from-top stack element, leaving the first, third, fourth, and so on; M-3 M-DEL deletes the third stack element.

The above commands do not depend on the location of the cursor. If the customizable variable calc-context-sensitive-enter is non-nil (see Customizing Calc), these commands will become context sensitive. For example, instead of duplicating the top of the stack, RET will copy the element at the cursor to the top of the stack. With a positive numeric prefix, a copy of the element at the cursor and the appropriate number of preceding elements will be placed at the top of the stack. A negative prefix will still duplicate the specified element of the stack regardless of the cursor position. Similarly, DEL will remove the corresponding elements from the stack.

To exchange the top two elements of the stack, press TAB (calc-roll-down). Given a positive numeric prefix argument, the specified number of elements at the top of the stack are rotated downward. Given a negative argument, the entire stack is rotated downward the specified number of times. Given an argument of zero, the entire stack is reversed top-for-bottom. For example, with ‘10 20 30 40 50’ on the stack, TAB creates ‘10 20 30 50 40’, C-u 3 TAB creates ‘10 20 50 30 40’, C-u - 2 TAB creates ‘40 50 10 20 30’, and C-u 0 TAB creates ‘50 40 30 20 10’.

The command M-TAB (calc-roll-up) is analogous to TAB except that it rotates upward instead of downward. Also, the default with no prefix argument is to rotate the top 3 elements. For example, with ‘10 20 30 40 50’ on the stack, M-TAB creates ‘10 20 40 50 30’, C-u 4 M-TAB creates ‘10 30 40 50 20’, C-u - 2 M-TAB creates ‘30 40 50 10 20’, and C-u 0 M-TAB creates ‘50 40 30 20 10’.

A good way to view the operation of TAB and M-TAB is in terms of moving a particular element to a new position in the stack. With a positive argument n, TAB moves the top stack element down to level n, making room for it by pulling all the intervening stack elements toward the top. M-TAB moves the element at level n up to the top. (Compare with LFD, which copies instead of moving the element in level n.)

With a negative argument -n, TAB rotates the stack to move the object in level n to the deepest place in the stack, and the object in level n+1 to the top. M-TAB rotates the deepest stack element to be in level n, also putting the top stack element in level n+1.

See Selecting Sub-Formulas, for a way to apply these commands to any portion of a vector or formula on the stack.

The command C-x C-t (calc-transpose-lines) will transpose the stack object determined by the point with the stack object at the next higher level. For example, with ‘10 20 30 40 50’ on the stack and the point on the line containing ‘30’, C-x C-t creates ‘10 20 40 30 50’. More generally, C-x C-t acts on the stack objects determined by the current point (and mark) similar to how the text-mode command transpose-lines acts on lines. With argument n, C-x C-t will move the stack object at the level above the current point and move it past N other objects; for example, with ‘10 20 30 40 50’ on the stack and the point on the line containing ‘30’, C-u 2 C-x C-t creates ‘10 40 20 30 50’. With an argument of 0, C-x C-t will switch the stack objects at the levels determined by the point and the mark.


*** Editing Stack Entries

The ` (calc-edit) command creates a temporary buffer (*Calc Edit*) for editing the top-of-stack value using regular Emacs commands. Note that ` is a grave accent, not an apostrophe. With a numeric prefix argument, it edits the specified number of stack entries at once. (An argument of zero edits the entire stack; a negative argument edits one specific stack entry.)

When you are done editing, press C-c C-c to finish and return to Calc. The RET and LFD keys also work to finish most sorts of editing, though in some cases Calc leaves RET with its usual meaning (“insert a newline”) if it’s a situation where you might want to insert new lines into the editing buffer.

When you finish editing, the Calculator parses the lines of text in the *Calc Edit* buffer as numbers or formulas, replaces the original stack elements in the original buffer with these new values, then kills the *Calc Edit* buffer. The original Calculator buffer continues to exist during editing, but for best results you should be careful not to change it until you have finished the edit. You can also cancel the edit by killing the buffer with C-x k.

The formula is normally reevaluated as it is put onto the stack. For example, editing ‘a + 2’ to ‘3 + 2’ and pressing C-c C-c will push 5 on the stack. If you use LFD to finish, Calc will put the result on the stack without evaluating it.

If you give a prefix argument to C-c C-c, Calc will not kill the *Calc Edit* buffer. You can switch back to that buffer and continue editing if you wish. However, you should understand that if you initiated the edit with `, the C-c C-c operation will be programmed to replace the top of the stack with the new edited value, and it will do this even if you have rearranged the stack in the meanwhile. This is not so much of a problem with other editing commands, though, such as s e (calc-edit-variable; see Other Operations on Variables).

If the calc-edit command involves more than one stack entry, each line of the *Calc Edit* buffer is interpreted as a separate formula. Otherwise, the entire buffer is interpreted as one formula, with line breaks ignored. (You can use C-o or C-q C-j to insert a newline in the buffer without pressing RET.)

The ` key also works during numeric or algebraic entry. The text entered so far is moved to the *Calc Edit* buffer for more extensive editing than is convenient in the minibuffer.


*** Trail Commands

The commands for manipulating the Calc Trail buffer are two-key sequences beginning with the t prefix.

The t d (calc-trail-display) command turns display of the trail on and off. Normally the trail display is toggled on if it was off, off if it was on. With a numeric prefix of zero, this command always turns the trail off; with a prefix of one, it always turns the trail on. The other trail-manipulation commands described here automatically turn the trail on. Note that when the trail is off values are still recorded there; they are simply not displayed. To set Emacs to turn the trail off by default, type t d and then save the mode settings with m m (calc-save-modes).

The t i (calc-trail-in) and t o (calc-trail-out) commands switch the cursor into and out of the Calc Trail window. In practice they are rarely used, since the commands shown below are a more convenient way to move around in the trail, and they work “by remote control” when the cursor is still in the Calculator window.

There is a trail pointer which selects some entry of the trail at any given time. The trail pointer looks like a ‘>’ symbol right before the selected number. The following commands operate on the trail pointer in various ways.

The t y (calc-trail-yank) command reads the selected value in the trail and pushes it onto the Calculator stack. It allows you to reuse any previously computed value without retyping. With a numeric prefix argument n, it yanks the value n lines above the current trail pointer.

The t < (calc-trail-scroll-left) and t > (calc-trail-scroll-right) commands horizontally scroll the trail window left or right by one half of its width.

The t n (calc-trail-next) and t p (calc-trail-previous) commands move the trail pointer down or up one line. The t f (calc-trail-forward) and t b (calc-trail-backward) commands move the trail pointer down or up one screenful at a time. All of these commands accept numeric prefix arguments to move several lines or screenfuls at a time.

The t [ (calc-trail-first) and t ] (calc-trail-last) commands move the trail pointer to the first or last line of the trail. The t h (calc-trail-here) command moves the trail pointer to the cursor position; unlike the other trail commands, t h works only when Calc Trail is the selected window.

The t s (calc-trail-isearch-forward) and t r (calc-trail-isearch-backward) commands perform an incremental search forward or backward through the trail. You can press RET to terminate the search; the trail pointer moves to the current line. If you cancel the search with C-g, the trail pointer stays where it was when the search began.

The t m (calc-trail-marker) command allows you to enter a line of text of your own choosing into the trail. The text is inserted after the line containing the trail pointer; this usually means it is added to the end of the trail. Trail markers are useful mainly as the targets for later incremental searches in the trail.

The t k (calc-trail-kill) command removes the selected line from the trail. The line is saved in the Emacs kill ring suitable for yanking into another buffer, but it is not easy to yank the text back into the trail buffer. With a numeric prefix argument, this command kills the n lines below or above the selected one.

The t . (calc-full-trail-vectors) command is described elsewhere; see Vector and Matrix Display Formats.


*** Keep Arguments

The K (calc-keep-args) command acts like a prefix for the following command. It prevents that command from removing its arguments from the stack. For example, after 2 RET 3 +, the stack contains the sole number 5, but after 2 RET 3 K +, the stack contains the arguments and the result: ‘2 3 5’.

With the exception of keyboard macros, this works for all commands that take arguments off the stack. (To avoid potentially unpleasant behavior, a K prefix before a keyboard macro will be ignored. A K prefix called within the keyboard macro will still take effect.) As another example, K a s simplifies a formula, pushing the simplified version of the formula onto the stack after the original formula (rather than replacing the original formula). Note that you could get the same effect by typing RET a s, copying the formula and then simplifying the copy. One difference is that for a very large formula the time taken to format the intermediate copy in RET a s could be noticeable; K a s would avoid this extra work.

Even stack manipulation commands are affected. TAB works by popping two values and pushing them back in the opposite order, so 2 RET 3 K TAB produces ‘2 3 3 2’.

A few Calc commands provide other ways of doing the same thing. For example, ' sin($) replaces the number on the stack with its sine using algebraic entry; to push the sine and keep the original argument you could use either ' sin($1) or K ' sin($). See Algebraic Entry. Also, the s s command is effectively the same as K s t. See Storing Variables.

If you execute a command and then decide you really wanted to keep the argument, you can press M-RET (calc-last-args). This command pushes the last arguments that were popped by any command onto the stack. Note that the order of things on the stack will be different than with K: 2 RET 3 + M-RET leaves ‘5 2 3’ on the stack instead of ‘2 3 5’. See Undoing Mistakes.


** Mode Settings

This chapter describes commands that set modes in the Calculator. They do not affect the contents of the stack, although they may change the appearance or interpretation of the stack’s contents.

*** General Mode Commands

You can save all of the current mode settings in your Calc init file (the file given by the variable calc-settings-file, typically ~/.emacs.d/calc.el) with the m m (calc-save-modes) command. This will cause Emacs to reestablish these modes each time it starts up. The modes saved in the file include everything controlled by the m and d prefix keys, the current precision and binary word size, whether or not the trail is displayed, the current height of the Calc window, and more. The current interface (used when you type C-x * *) is also saved. If there were already saved mode settings in the file, they are replaced. Otherwise, the new mode information is appended to the end of the file.

The m R (calc-mode-record-mode) command tells Calc to record all the mode settings (as if by pressing m m) every time a mode setting changes. If the modes are saved this way, then this “automatic mode recording” mode is also saved. Type m R again to disable this method of recording the mode settings. To turn it off permanently, the m m command will also be necessary. (If Embedded mode is enabled, other options for recording the modes are available; see Mode Settings in Embedded Mode.)

The m F (calc-settings-file-name) command allows you to choose a different file than the current value of calc-settings-file for m m, Z P, and similar commands to save permanent information. You are prompted for a file name. All Calc modes are then reset to their default values, then settings from the file you named are loaded if this file exists, and this file becomes the one that Calc will use in the future for commands like m m. The default settings file name is ~/.emacs.d/calc.el. You can see the current file name by giving a blank response to the m F prompt. See also the discussion of the calc-settings-file variable; see Customizing Calc.

If the file name you give is your user init file (typically ~/.emacs), m F will not automatically load the new file. This is because your user init file may contain other things you don’t want to reread. You can give a numeric prefix argument of 1 to m F to force it to read the file no matter what. Conversely, an argument of -1 tells m F not to read the new file. An argument of 2 or -2 tells m F not to reset the modes to their defaults beforehand, which is useful if you intend your new file to have a variant of the modes present in the file you were using before.

The m x (calc-always-load-extensions) command enables a mode in which the first use of Calc loads the entire program, including all extensions modules. Otherwise, the extensions modules will not be loaded until the various advanced Calc features are used. Since this mode only has effect when Calc is first loaded, m x is usually followed by m m to make the mode-setting permanent. To load all of Calc just once, rather than always in the future, you can press C-x * L.

The m S (calc-shift-prefix) command enables a mode in which all of Calc’s letter prefix keys may be typed shifted as well as unshifted. If you are typing, say, a S (calc-solve-for) quite often you might find it easier to turn this mode on so that you can type A S instead. When this mode is enabled, the commands that used to be on those single shifted letters (e.g., A (calc-abs)) can now be invoked by pressing the shifted letter twice: A A. Note that the v prefix key always works both shifted and unshifted, and the z and Z prefix keys are always distinct. Also, the h prefix is not affected by this mode. Press m S again to disable shifted-prefix mode.


*** Precision

The p (calc-precision) command controls the precision to which floating-point calculations are carried. The precision must be at least 3 digits and may be arbitrarily high, within the limits of memory and time. This affects only floats: Integer and rational calculations are always carried out with as many digits as necessary.

The p key prompts for the current precision. If you wish you can instead give the precision as a numeric prefix argument.

Many internal calculations are carried to one or two digits higher precision than normal. Results are rounded down afterward to the current precision. Unless a special display mode has been selected, floats are always displayed with their full stored precision, i.e., what you see is what you get. Reducing the current precision does not round values already on the stack, but those values will be rounded down before being used in any calculation. The c 0 through c 9 commands (see Conversions) can be used to round an existing value to a new precision.

It is important to distinguish the concepts of precision and accuracy. In the normal usage of these words, the number 123.4567 has a precision of 7 digits but an accuracy of 4 digits. The precision is the total number of digits not counting leading or trailing zeros (regardless of the position of the decimal point). The accuracy is simply the number of digits after the decimal point (again not counting trailing zeros). In Calc you control the precision, not the accuracy of computations. If you were to set the accuracy instead, then calculations like ‘exp(100)’ would generate many more digits than you would typically need, while ‘exp(-100)’ would probably round to zero! In Calc, both these computations give you exactly 12 (or the requested number of) significant digits.

The only Calc features that deal with accuracy instead of precision are fixed-point display mode for floats (d f; see Float Formats), and the rounding functions like floor and round (see Integer Truncation). Also, c 0 through c 9 deal with both precision and accuracy depending on the magnitudes of the numbers involved.

If you need to work with a particular fixed accuracy (say, dollars and cents with two digits after the decimal point), one solution is to work with integers and an “implied” decimal point. For example, $8.99 divided by 6 would be entered 899 RET 6 /, yielding 149.833 (actually $1.49833 with our implied decimal point); pressing R would round this to 150 cents, i.e., $1.50.

See Floats, for still more on floating-point precision and related issues.


*** Inverse and Hyperbolic Flags

There is no single-key equivalent to the calc-arcsin function. Instead, you must first press I (calc-inverse) to set the Inverse Flag, then press S (calc-sin). The I key actually toggles the Inverse Flag. When this flag is set, the word ‘Inv’ appears in the mode line.

Likewise, the H key (calc-hyperbolic) sets or clears the Hyperbolic Flag, which transforms calc-sin into calc-sinh. If both of these flags are set at once, the effect will be calc-arcsinh. (The Hyperbolic flag is also used by some non-trigonometric commands; for example H L computes a base-10, instead of base-e, logarithm.)

Command names like calc-arcsin are provided for completeness, and may be executed with x or M-x. Their effect is simply to toggle the Inverse and/or Hyperbolic flags and then execute the corresponding base command (calc-sin in this case).

The O key (calc-option) sets another flag, the Option Flag, which also can alter the subsequent Calc command in various ways.

The Inverse, Hyperbolic and Option flags apply only to the next Calculator command, after which they are automatically cleared. (They are also cleared if the next keystroke is not a Calc command.) Digits you type after I, H or O (or K) are treated as prefix arguments for the next command, not as numeric entries. The same is true of C-u, but not of the minus sign (K - means to subtract and keep arguments).

Another Calc prefix flag, K (keep-arguments), is discussed elsewhere. See Keep Arguments.


*** Calculation Modes

The commands in this section are two-key sequences beginning with the m prefix. (That’s the letter m, not the META key.) The ‘m a’ (calc-algebraic-mode) command is described elsewhere (see Algebraic Entry).

**** Angular Modes

The Calculator supports three notations for angles: radians, degrees, and degrees-minutes-seconds. When a number is presented to a function like sin that requires an angle, the current angular mode is used to interpret the number as either radians or degrees. If an HMS form is presented to sin, it is always interpreted as degrees-minutes-seconds.

Functions that compute angles produce a number in radians, a number in degrees, or an HMS form depending on the current angular mode. If the result is a complex number and the current mode is HMS, the number is instead expressed in degrees. (Complex-number calculations would normally be done in Radians mode, though. Complex numbers are converted to degrees by calculating the complex result in radians and then multiplying by 180 over ‘pi’.)

The m r (calc-radians-mode), m d (calc-degrees-mode), and m h (calc-hms-mode) commands control the angular mode. The current angular mode is displayed on the Emacs mode line. The default angular mode is Degrees.


**** Polar Mode

The Calculator normally “prefers” rectangular complex numbers in the sense that rectangular form is used when the proper form can not be decided from the input. This might happen by multiplying a rectangular number by a polar one, by taking the square root of a negative real number, or by entering ( 2 SPC 3 ).

The m p (calc-polar-mode) command toggles complex-number preference between rectangular and polar forms. In Polar mode, all of the above example situations would produce polar complex numbers.


**** Fraction Mode

Division of two integers normally yields a floating-point number if the result cannot be expressed as an integer. In some cases you would rather get an exact fractional answer. One way to accomplish this is to use the : (calc-fdiv) [fdiv] command, which divides the two integers on the top of the stack to produce a fraction: 6 RET 4 : produces ‘3:2’ even though 6 RET 4 / produces ‘1.5’.

To set the Calculator to produce fractional results for normal integer divisions, use the m f (calc-frac-mode) command. For example, ‘8/4’ produces ‘2’ in either mode, but ‘6/4’ produces ‘3:2’ in Fraction mode, ‘1.5’ in Float mode.

At any time you can use c f (calc-float) to convert a fraction to a float, or c F (calc-fraction) to convert a float to a fraction. See Conversions.


**** Infinite Mode

The Calculator normally treats results like ‘1 / 0’ as errors; formulas like this are left in unsimplified form. But Calc can be put into a mode where such calculations instead produce “infinite” results.

The m i (calc-infinite-mode) command turns this mode on and off. When the mode is off, infinities do not arise except in calculations that already had infinities as inputs. (One exception is that infinite open intervals like ‘[0 .. inf)’ can be generated; however, intervals closed at infinity (‘[0 .. inf]’) will not be generated when Infinite mode is off.)

With Infinite mode turned on, ‘1 / 0’ will generate uinf, an undirected infinity. See Infinities, for a discussion of the difference between inf and uinf. Also, ‘0 / 0’ evaluates to nan, the “indeterminate” symbol. Various other functions can also return infinities in this mode; for example, ‘ln(0) = -inf’, and ‘gamma(-7) = uinf’. Once again, note that ‘exp(inf) = inf’ regardless of Infinite mode because this calculation has infinity as an input.

The m i command with a numeric prefix argument of zero, i.e., C-u 0 m i, turns on a Positive Infinite mode in which zero is treated as positive instead of being directionless. Thus, ‘1 / 0 = inf’ and ‘-1 / 0 = -inf’ in this mode. Note that zero never actually has a sign in Calc; there are no separate representations for +0 and -0. Positive Infinite mode merely changes the interpretation given to the single symbol, ‘0’. One consequence of this is that, while you might expect ‘1 / -0 = -inf’, actually ‘1 / -0’ is equivalent to ‘1 / 0’, which is equal to positive inf.


**** Symbolic Mode

Calculations are normally performed numerically wherever possible. For example, the calc-sqrt command, or sqrt function in an algebraic expression, produces a numeric answer if the argument is a number or a symbolic expression if the argument is an expression: 2 Q pushes 1.4142 but ' x+1 RET Q pushes ‘sqrt(x+1)’.

In Symbolic mode, controlled by the m s (calc-symbolic-mode) command, functions which would produce inexact, irrational results are left in symbolic form. Thus 16 Q pushes 4, but 2 Q pushes ‘sqrt(2)’.

The shift-N (calc-eval-num) command evaluates numerically the expression at the top of the stack, by temporarily disabling calc-symbolic-mode and executing = (calc-evaluate). Given a numeric prefix argument, it also sets the floating-point precision to the specified value for the duration of the command.

To evaluate a formula numerically without expanding the variables it contains, you can use the key sequence m s a v m s (this uses calc-alg-evaluate, which resimplifies but doesn’t evaluate variables.)


**** Matrix and Scalar Modes

Calc sometimes makes assumptions during algebraic manipulation that are awkward or incorrect when vectors and matrices are involved. Calc has two modes, Matrix mode and Scalar mode, which modify its behavior around vectors in useful ways.

Press m v (calc-matrix-mode) once to enter Matrix mode. In this mode, all objects are assumed to be matrices unless provably otherwise. One major effect is that Calc will no longer consider multiplication to be commutative. (Recall that in matrix arithmetic, ‘A*B’ is not the same as ‘B*A’.) This assumption affects rewrite rules and algebraic simplification. Another effect of this mode is that calculations that would normally produce constants like 0 and 1 (e.g., ‘a - a’ and ‘a / a’, respectively) will now produce function calls that represent “generic” zero or identity matrices: ‘idn(0)’, ‘idn(1)’. The idn function ‘idn(a,n)’ returns a times an nxn identity matrix; if n is omitted, it doesn’t know what dimension to use and so the idn call remains in symbolic form. However, if this generic identity matrix is later combined with a matrix whose size is known, it will be converted into a true identity matrix of the appropriate size. On the other hand, if it is combined with a scalar (as in ‘idn(1) + 2’), Calc will assume it really was a scalar after all and produce, e.g., 3.

Press m v a second time to get Scalar mode. Here, objects are assumed not to be vectors or matrices unless provably so. For example, normally adding a variable to a vector, as in ‘[x, y, z] + a’, will leave the sum in symbolic form because as far as Calc knows, ‘a’ could represent either a number or another 3-vector. In Scalar mode, ‘a’ is assumed to be a non-vector, and the addition is evaluated to ‘[x+a, y+a, z+a]’.

Press m v a third time to return to the normal mode of operation.

If you press m v with a numeric prefix argument n, you get a special “dimensioned” Matrix mode in which matrices of unknown size are assumed to be nxn square matrices. Then, the function call ‘idn(1)’ will expand into an actual matrix rather than representing a “generic” matrix. Simply typing C-u m v will get you a square Matrix mode, in which matrices of unknown size are assumed to be square matrices of unspecified size.

Of course these modes are approximations to the true state of affairs, which is probably that some quantities will be matrices and others will be scalars. One solution is to “declare” certain variables or functions to be scalar-valued. See Declarations, to see how to make declarations in Calc.

There is nothing stopping you from declaring a variable to be scalar and then storing a matrix in it; however, if you do, the results you get from Calc may not be valid. Suppose you let Calc get the result ‘[x+a, y+a, z+a]’ shown above, and then stored ‘[1, 2, 3]’ in ‘a’. The result would not be the same as for ‘[x, y, z] + [1, 2, 3]’, but that’s because you have broken your earlier promise to Calc that ‘a’ would be scalar.

Another way to mix scalars and matrices is to use selections (see Selecting Sub-Formulas). Use Matrix mode when operating on your formula normally; then, to apply Scalar mode to a certain part of the formula without affecting the rest just select that part, change into Scalar mode and press = to resimplify the part under this mode, then change back to Matrix mode before deselecting.


**** Automatic Recomputation

The evaluates-to operator, ‘=>’, has the special property that any ‘=>’ formulas on the stack are recomputed whenever variable values or mode settings that might affect them are changed. See The Evaluates-To Operator.

The m C (calc-auto-recompute) command turns this automatic recomputation on and off. If you turn it off, Calc will not update ‘=>’ operators on the stack (nor those in the attached Embedded mode buffer, if there is one). They will not be updated unless you explicitly do so by pressing = or until you press m C to turn recomputation back on. (While automatic recomputation is off, you can think of m C m C as a command to update all ‘=>’ operators while leaving recomputation off.)

To update ‘=>’ operators in an Embedded buffer while automatic recomputation is off, use C-x * u. See Embedded Mode.


**** Working Messages

Since the Calculator is written entirely in Emacs Lisp, which is not designed for heavy numerical work, many operations are quite slow. The Calculator normally displays the message ‘Working...’ in the echo area during any command that may be slow. In addition, iterative operations such as square roots and trigonometric functions display the intermediate result at each step. Both of these types of messages can be disabled if you find them distracting.

Type m w (calc-working) with a numeric prefix of 0 to disable all “working” messages. Use a numeric prefix of 1 to enable only the plain ‘Working...’ message. Use a numeric prefix of 2 to see intermediate results as well. With no numeric prefix this displays the current mode.

While it may seem that the “working” messages will slow Calc down considerably, experiments have shown that their impact is actually quite small. But if your terminal is slow you may find that it helps to turn the messages off.


*** Simplification Modes

The current simplification mode controls how numbers and formulas are “normalized” when being taken from or pushed onto the stack. Some normalizations are unavoidable, such as rounding floating-point results to the current precision, and reducing fractions to simplest form. Others, such as simplifying a formula like ‘a+a’ (or ‘2+3’), are done automatically but can be turned off when necessary.

When you press a key like + when ‘2’ and ‘3’ are on the stack, Calc pops these numbers, normalizes them, creates the formula ‘2+3’, normalizes it, and pushes the result. Of course the standard rules for normalizing ‘2+3’ will produce the result ‘5’.

Simplification mode commands consist of the lower-case m prefix key followed by a shifted letter.

The m O (calc-no-simplify-mode) command turns off all optional simplifications. These would leave a formula like ‘2+3’ alone. In fact, nothing except simple numbers are ever affected by normalization in this mode. Explicit simplification commands, such as = or a s, can still be given to simplify any formulas. See Programming with Formulas, for a sample use of No-Simplification mode.

The m N (calc-num-simplify-mode) command turns off simplification of any formulas except those for which all arguments are constants. For example, ‘1+2’ is simplified to ‘3’, and ‘a+(2-2)’ is simplified to ‘a+0’ but no further, since one argument of the sum is not a constant. Unfortunately, ‘(a+2)-2’ is not simplified because the top-level ‘-’ operator’s arguments are not both constant numbers (one of them is the formula ‘a+2’). A constant is a number or other numeric object (such as a constant error form or modulo form), or a vector all of whose elements are constant.

The m I (calc-basic-simplify-mode) command does some basic simplifications for all formulas. This includes many easy and fast algebraic simplifications such as ‘a+0’ to ‘a’, and ‘a + 2 a’ to ‘3 a’, as well as evaluating functions like ‘deriv(x^2, x)’ to ‘2 x’.

The m B (calc-bin-simplify-mode) mode applies the basic simplifications to a result and then, if the result is an integer, uses the b c (calc-clip) command to clip the integer according to the current binary word size. See Binary Number Functions. Real numbers are rounded to the nearest integer and then clipped; other kinds of results (after the basic simplifications) are left alone.

The m A (calc-alg-simplify-mode) mode does standard algebraic simplifications. See Algebraic Simplifications.

The m E (calc-ext-simplify-mode) mode does “extended”, or “unsafe”, algebraic simplification. See “Unsafe” Simplifications.

The m U (calc-units-simplify-mode) mode does units simplification. See Simplification of Units. These include the algebraic simplifications, plus variable names which are identifiable as unit names (like ‘mm’ for “millimeters”) are simplified with their unit definitions in mind.

A common technique is to set the simplification mode down to the lowest amount of simplification you will allow to be applied automatically, then use manual commands like a s and c c (calc-clean) to perform higher types of simplifications on demand.


*** Declarations

A declaration is a statement you make that promises you will use a certain variable or function in a restricted way. This may give Calc the freedom to do things that it couldn’t do if it had to take the fully general situation into account.

**** Declaration Basics

The s d (calc-declare-variable) command is the easiest way to make a declaration for a variable. This command prompts for the variable name, then prompts for the declaration. The default at the declaration prompt is the previous declaration, if any. You can edit this declaration, or press C-k to erase it and type a new declaration. (Or, erase it and press RET to clear the declaration, effectively “undeclaring” the variable.)

A declaration is in general a vector of type symbols and range values. If there is only one type symbol or range value, you can write it directly rather than enclosing it in a vector. For example, s d foo RET real RET declares foo to be a real number, and s d bar RET [int, const, [1..6]] RET declares bar to be a constant integer between 1 and 6. (Actually, you can omit the outermost brackets and Calc will provide them for you: s d bar RET int, const, [1..6] RET.)

Declarations in Calc are kept in a special variable called Decls. This variable encodes the set of all outstanding declarations in the form of a matrix. Each row has two elements: A variable or vector of variables declared by that row, and the declaration specifier as described above. You can use the s D command to edit this variable if you wish to see all the declarations at once. See Other Operations on Variables, for a description of this command and the s p command that allows you to save your declarations permanently if you wish.

Items being declared can also be function calls. The arguments in the call are ignored; the effect is to say that this function returns values of the declared type for any valid arguments. The s d command declares only variables, so if you wish to make a function declaration you will have to edit the Decls matrix yourself.

For example, the declaration matrix

[ [ foo,       real       ]
  [ [j, k, n], int        ]
  [ f(1,2,3),  [0 .. inf) ] ]
declares that foo represents a real number, j, k and n represent integers, and the function f always returns a real number in the interval shown.

If there is a declaration for the variable All, then that declaration applies to all variables that are not otherwise declared. It does not apply to function names. For example, using the row ‘[All, real]’ says that all your variables are real unless they are explicitly declared without real in some other row. The s d command declares All if you give a blank response to the variable-name prompt.


**** Kinds of Declarations

The type-specifier part of a declaration (that is, the second prompt in the s d command) can be a type symbol, an interval, or a vector consisting of zero or more type symbols followed by zero or more intervals or numbers that represent the set of possible values for the variable.

[ [ a, [1, 2, 3, 4, 5] ]
  [ b, [1 .. 5]        ]
  [ c, [int, 1 .. 5]   ] ]
Here a is declared to contain one of the five integers shown; b is any number in the interval from 1 to 5 (any real number since we haven’t specified), and c is any integer in that interval. Thus the declarations for a and c are nearly equivalent (see below).

The type-specifier can be the empty vector ‘[]’ to say that nothing is known about a given variable’s value. This is the same as not declaring the variable at all except that it overrides any All declaration which would otherwise apply.

The initial value of Decls is the empty vector ‘[]’. If Decls has no stored value or if the value stored in it is not valid, it is ignored and there are no declarations as far as Calc is concerned. (The s d command will replace such a malformed value with a fresh empty matrix, ‘[]’, before recording the new declaration.) Unrecognized type symbols are ignored.

The following type symbols describe what sorts of numbers will be stored in a variable:

int
Integers.

numint
Numerical integers. (Integers or integer-valued floats.)

frac
Fractions. (Rational numbers which are not integers.)

rat
Rational numbers. (Either integers or fractions.)

float
Floating-point numbers.

real
Real numbers. (Integers, fractions, or floats. Actually, intervals and error forms with real components also count as reals here.)

pos
Positive real numbers. (Strictly greater than zero.)

nonneg
Nonnegative real numbers. (Greater than or equal to zero.)

number
Numbers. (Real or complex.)

Calc uses this information to determine when certain simplifications of formulas are safe. For example, ‘(x^y)^z’ cannot be simplified to ‘x^(y z)’ in general; for example, ‘((-3)^2)^1:2’ is 3, but ‘(-3)^(2*1:2) = (-3)^1’ is -3. However, this simplification is safe if z is known to be an integer, or if x is known to be a nonnegative real number. If you have given declarations that allow Calc to deduce either of these facts, Calc will perform this simplification of the formula.

Calc can apply a certain amount of logic when using declarations. For example, ‘(x^y)^(2n+1)’ will be simplified if n has been declared int; Calc knows that an integer times an integer, plus an integer, must always be an integer. (In fact, Calc would simplify ‘(-x)^(2n+1)’ to ‘-(x^(2n+1))’ since it is able to determine that ‘2n+1’ must be an odd integer.)

Similarly, ‘(abs(x)^y)^z’ will be simplified to ‘abs(x)^(y z)’ because Calc knows that the abs function always returns a nonnegative real. If you had a myabs function that also had this property, you could get Calc to recognize it by adding the row ‘[myabs(), nonneg]’ to the Decls matrix.

One instance of this simplification is ‘sqrt(x^2)’ (since the sqrt function is effectively a one-half power). Normally Calc leaves this formula alone. After the command s d x RET real RET, however, it can simplify the formula to ‘abs(x)’. And after s d x RET nonneg RET, Calc can simplify this formula all the way to ‘x’.

If there are any intervals or real numbers in the type specifier, they comprise the set of possible values that the variable or function being declared can have. In particular, the type symbol real is effectively the same as the range ‘[-inf .. inf]’ (note that infinity is included in the range of possible values); pos is the same as ‘(0 .. inf]’, and nonneg is the same as ‘[0 .. inf]’. Saying ‘[real, [-5 .. 5]]’ is redundant because the fact that the variable is real can be deduced just from the interval, but ‘[int, [-5 .. 5]]’ and ‘[rat, [-5 .. 5]]’ are useful combinations.

Note that the vector of intervals or numbers is in the same format used by Calc’s set-manipulation commands. See Set Operations using Vectors.

The type specifier ‘[1, 2, 3]’ is equivalent to ‘[numint, 1, 2, 3]’, not to ‘[int, 1, 2, 3]’. In other words, the range of possible values means only that the variable’s value must be numerically equal to a number in that range, but not that it must be equal in type as well. Calc’s set operations act the same way; ‘in(2, [1., 2., 3.])’ and ‘in(1.5, [1:2, 3:2, 5:2])’ both report “true.”

If you use a conflicting combination of type specifiers, the results are unpredictable. An example is ‘[pos, [0 .. 5]]’, where the interval does not lie in the range described by the type symbol.

“Real” declarations mostly affect simplifications involving powers like the one described above. Another case where they are used is in the a P command which returns a list of all roots of a polynomial; if the variable has been declared real, only the real roots (if any) will be included in the list.

“Integer” declarations are used for simplifications which are valid only when certain values are integers (such as ‘(x^y)^z’ shown above).

Calc’s algebraic simplifications also make use of declarations when simplifying equations and inequalities. They will cancel x from both sides of ‘a x = b x’ only if it is sure x is non-zero, say, because it has a pos declaration. To declare specifically that x is real and non-zero, use ‘[[-inf .. 0), (0 .. inf]]’. (There is no way in the current notation to say that x is nonzero but not necessarily real.) The a e command does “unsafe” simplifications, including canceling ‘x’ from the equation when ‘x’ is not known to be nonzero.

Another set of type symbols distinguish between scalars and vectors.

scalar
The value is not a vector.

vector
The value is a vector.

matrix
The value is a matrix (a rectangular vector of vectors).

sqmatrix
The value is a square matrix.

These type symbols can be combined with the other type symbols described above; ‘[int, matrix]’ describes an object which is a matrix of integers.

Scalar/vector declarations are used to determine whether certain algebraic operations are safe. For example, ‘[a, b, c] + x’ is normally not simplified to ‘[a + x, b + x, c + x]’, but it will be if x has been declared scalar. On the other hand, multiplication is usually assumed to be commutative, but the terms in ‘x y’ will never be exchanged if both x and y are known to be vectors or matrices. (Calc currently never distinguishes between vector and matrix declarations.)

See Matrix and Scalar Modes, for a discussion of Matrix mode and Scalar mode, which are similar to declaring ‘[All, matrix]’ or ‘[All, scalar]’ but much more convenient.

One more type symbol that is recognized is used with the H a d command for taking total derivatives of a formula. See Calculus.

const
The value is a constant with respect to other variables.

Calc does not check the declarations for a variable when you store a value in it. However, storing -3.5 in a variable that has been declared pos, int, or matrix may have unexpected effects; Calc may evaluate ‘sqrt(x^2)’ to ‘3.5’ if it substitutes the value first, or to ‘-3.5’ if x was declared pos and the formula ‘sqrt(x^2)’ is simplified to ‘x’ before the value is substituted. Before using a variable for a new purpose, it is best to use s d or s D to check to make sure you don’t still have an old declaration for the variable that will conflict with its new meaning.


**** Functions for Declarations

Calc has a set of functions for accessing the current declarations in a convenient manner. These functions return 1 if the argument can be shown to have the specified property, or 0 if the argument can be shown not to have that property; otherwise they are left unevaluated. These functions are suitable for use with rewrite rules (see Conditional Rewrite Rules) or programming constructs (see Conditionals in Keyboard Macros). They can be entered only using algebraic notation. See Logical Operations, for functions that perform other tests not related to declarations.

For example, ‘dint(17)’ returns 1 because 17 is an integer, as do ‘dint(n)’ and ‘dint(2 n - 3)’ if n has been declared int, but ‘dint(2.5)’ and ‘dint(n + 0.5)’ return 0. Calc consults knowledge of its own built-in functions as well as your own declarations: ‘dint(floor(x))’ returns 1.

The dint function checks if its argument is an integer. The dnatnum function checks if its argument is a natural number, i.e., a nonnegative integer. The dnumint function checks if its argument is numerically an integer, i.e., either an integer or an integer-valued float. Note that these and the other data type functions also accept vectors or matrices composed of suitable elements, and that real infinities ‘inf’ and ‘-inf’ are considered to be integers for the purposes of these functions.

The drat function checks if its argument is rational, i.e., an integer or fraction. Infinities count as rational, but intervals and error forms do not.

The dreal function checks if its argument is real. This includes integers, fractions, floats, real error forms, and intervals.

The dimag function checks if its argument is imaginary, i.e., is mathematically equal to a real number times ‘i’.

The dpos function checks for positive (but nonzero) reals. The dneg function checks for negative reals. The dnonneg function checks for nonnegative reals, i.e., reals greater than or equal to zero. Note that Calc’s algebraic simplifications, which are effectively applied to all conditions in rewrite rules, can simplify an expression like ‘x > 0’ to 1 or 0 using dpos. So the actual functions dpos, dneg, and dnonneg are rarely necessary.

The dnonzero function checks that its argument is nonzero. This includes all nonzero real or complex numbers, all intervals that do not include zero, all nonzero modulo forms, vectors all of whose elements are nonzero, and variables or formulas whose values can be deduced to be nonzero. It does not include error forms, since they represent values which could be anything including zero. (This is also the set of objects considered “true” in conditional contexts.)

The deven function returns 1 if its argument is known to be an even integer (or integer-valued float); it returns 0 if its argument is known not to be even (because it is known to be odd or a non-integer). Calc’s algebraic simplifications use this to simplify a test of the form ‘x % 2 = 0’. There is also an analogous dodd function.

The drange function returns a set (an interval or a vector of intervals and/or numbers; see Set Operations using Vectors) that describes the set of possible values of its argument. If the argument is a variable or a function with a declaration, the range is copied from the declaration. Otherwise, the possible signs of the expression are determined using a method similar to dpos, etc., and a suitable set like ‘[0 .. inf]’ is returned. If the expression is not provably real, the drange function remains unevaluated.

The dscalar function returns 1 if its argument is provably scalar, or 0 if its argument is provably non-scalar. It is left unevaluated if this cannot be determined. (If Matrix mode or Scalar mode is in effect, this function returns 1 or 0, respectively, if it has no other information.) When Calc interprets a condition (say, in a rewrite rule) it considers an unevaluated formula to be “false.” Thus, ‘dscalar(a)’ is “true” only if a is provably scalar, and ‘!dscalar(a)’ is “true” only if a is provably non-scalar; both are “false” if there is insufficient information to tell.


*** Display Modes

The commands in this section are two-key sequences beginning with the d prefix. The d l (calc-line-numbering) and d b (calc-line-breaking) commands are described elsewhere; see Stack Basics and see Normal Language Modes, respectively. Display formats for vectors and matrices are also covered elsewhere; see Vector and Matrix Display Formats.

One thing all display modes have in common is their treatment of the H prefix. This prefix causes any mode command that would normally refresh the stack to leave the stack display alone. The word “Dirty” will appear in the mode line when Calc thinks the stack display may not reflect the latest mode settings.

The d RET (calc-refresh-top) command reformats the top stack entry according to all the current modes. Positive prefix arguments reformat the top n entries; negative prefix arguments reformat the specified entry, and a prefix of zero is equivalent to d SPC (calc-refresh), which reformats the entire stack. For example, H d s M-2 d RET changes to scientific notation but reformats only the top two stack entries in the new mode.

The I prefix has another effect on the display modes. The mode is set only temporarily; the top stack entry is reformatted according to that mode, then the original mode setting is restored. In other words, I d s is equivalent to H d s d RET H d (old mode).


**** Radix Modes

Calc normally displays numbers in decimal (base-10 or radix-10) notation. Calc can actually display in any radix from two (binary) to 36. When the radix is above 10, the letters A to Z are used as digits. When entering such a number, letter keys are interpreted as potential digits rather than terminating numeric entry mode.

The key sequences d 2, d 8, d 6, and d 0 select binary, octal, hexadecimal, and decimal as the current display radix, respectively. Numbers can always be entered in any radix, though the current radix is used as a default if you press # without any initial digits. A number entered without a # is always interpreted as decimal.

To set the radix generally, use d r (calc-radix) and enter an integer from 2 to 36. You can specify the radix as a numeric prefix argument; otherwise you will be prompted for it.

Integers normally are displayed with however many digits are necessary to represent the integer and no more. The d z (calc-leading-zeros) command causes integers to be padded out with leading zeros according to the current binary word size. (See Binary Number Functions, for a discussion of word size.) If the absolute value of the word size is ‘w’, all integers are displayed with at least enough digits to represent ‘(2^w)-1’ in the current radix. (Larger integers will still be displayed in their entirety.)

Calc can display ‘w’-bit integers using two’s complement notation, although this is most useful with the binary, octal and hexadecimal display modes. This option is selected by using the O option prefix before setting the display radix, and a negative word size might be appropriate (see Binary Number Functions). In two’s complement notation, the integers in the (nearly) symmetric interval from ‘-2^(w-1)’ to ‘2^(w-1)-1’ are represented by the integers from ‘0’ to ‘2^w-1’: the integers from ‘0’ to ‘2^(w-1)-1’ are represented by themselves and the integers from ‘-2^(w-1)’ to ‘-1’ are represented by the integers from ‘2^(w-1)’ to ‘2^w-1’ (the integer ‘k’ is represented by ‘k+2^w’). Calc will display a two’s complement integer by the radix (either ‘2’, ‘8’ or ‘16’), two # symbols, and then its representation (including any leading zeros necessary to include all ‘w’ bits). In a two’s complement display mode, numbers that are not displayed in two’s complement notation (i.e., that aren’t integers from ‘-2^(w-1)’ to ‘2^(w-1)-1’) will be represented using Calc’s usual notation (in the appropriate radix).


**** Grouping Digits

Long numbers can be hard to read if they have too many digits. For example, the factorial of 30 is 33 digits long! Press d g (calc-group-digits) to enable Grouping mode, in which digits are displayed in clumps of 3 or 4 (depending on the current radix) separated by commas.

The d g command toggles grouping on and off. With a numeric prefix of 0, this command displays the current state of the grouping flag; with an argument of minus one it disables grouping; with a positive argument ‘N’ it enables grouping on every ‘N’ digits. For floating-point numbers, grouping normally occurs only before the decimal point. A negative prefix argument ‘-N’ enables grouping every ‘N’ digits both before and after the decimal point.

The d , (calc-group-char) command allows you to choose any character as the grouping separator. The default is the comma character. If you find it difficult to read vectors of large integers grouped with commas, you may wish to use spaces or some other character instead. This command takes the next character you type, whatever it is, and uses it as the digit separator. As a special case, d , \ selects ‘\,’ (TeX’s thin-space symbol) as the digit separator.

Please note that grouped numbers will not generally be parsed correctly if re-read in textual form, say by the use of C-x * y and C-x * g. (See Kill and Yank Functions, for details on these commands.) One exception is the ‘\,’ separator, which doesn’t interfere with parsing because it is ignored by TeX language mode.


**** Float Formats

Floating-point quantities are normally displayed in standard decimal form, with scientific notation used if the exponent is especially high or low. All significant digits are normally displayed. The commands in this section allow you to choose among several alternative display formats for floats.

The d n (calc-normal-notation) command selects the normal display format. All significant figures in a number are displayed. With a positive numeric prefix, numbers are rounded if necessary to that number of significant digits. With a negative numerix prefix, the specified number of significant digits less than the current precision is used. (Thus C-u -2 d n displays 10 digits if the current precision is 12.)

The d f (calc-fix-notation) command selects fixed-point notation. The numeric argument is the number of digits after the decimal point, zero or more. This format will relax into scientific notation if a nonzero number would otherwise have been rounded all the way to zero. Specifying a negative number of digits is the same as for a positive number, except that small nonzero numbers will be rounded to zero rather than switching to scientific notation.

The d s (calc-sci-notation) command selects scientific notation. A positive argument sets the number of significant figures displayed, of which one will be before and the rest after the decimal point. A negative argument works the same as for d n format. The default is to display all significant digits.

The d e (calc-eng-notation) command selects engineering notation. This is similar to scientific notation except that the exponent is rounded down to a multiple of three, with from one to three digits before the decimal point. An optional numeric prefix sets the number of significant digits to display, as for d s.

It is important to distinguish between the current precision and the current display format. After the commands C-u 10 p and C-u 6 d n the Calculator computes all results to ten significant figures but displays only six. (In fact, intermediate calculations are often carried to one or two more significant figures, but values placed on the stack will be rounded down to ten figures.) Numbers are never actually rounded to the display precision for storage, except by commands like C-k and C-x * y which operate on the actual displayed text in the Calculator buffer.

The d . (calc-point-char) command selects the character used as a decimal point. Normally this is a period; users in some countries may wish to change this to a comma. Note that this is only a display style; on entry, periods must always be used to denote floating-point numbers, and commas to separate elements in a list.


**** Complex Formats

There are three supported notations for complex numbers in rectangular form. The default is as a pair of real numbers enclosed in parentheses and separated by a comma: ‘(a,b)’. The d c (calc-complex-notation) command selects this style.

The other notations are d i (calc-i-notation), in which numbers are displayed in ‘a+bi’ form, and d j (calc-j-notation) which displays the form ‘a+bj’ preferred in some disciplines.

Complex numbers are normally entered in ‘(a,b)’ format. If you enter ‘2+3i’ as an algebraic formula, it will be stored as the formula ‘2 + 3 * i’. However, if you use = to evaluate this formula and you have not changed the variable ‘i’, the ‘i’ will be interpreted as ‘(0,1)’ and the formula will be simplified to ‘(2,3)’. Other commands (like calc-sin) will not interpret the formula ‘2 + 3 * i’ as a complex number. See Variables, under “special constants.”


**** Fraction Formats

Display of fractional numbers is controlled by the d o (calc-over-notation) command. By default, a number like eight thirds is displayed in the form ‘8:3’. The d o command prompts for a one- or two-character format. If you give one character, that character is used as the fraction separator. Common separators are ‘:’ and ‘/’. (During input of numbers, the : key must be used regardless of the display format; in particular, the / is used for RPN-style division, not for entering fractions.)

If you give two characters, fractions use “integer-plus-fractional-part” notation. For example, the format ‘+/’ would display eight thirds as ‘2+2/3’. If two colons are present in a number being entered, the number is interpreted in this form (so that the entries 2:2:3 and 8:3 are equivalent).

It is also possible to follow the one- or two-character format with a number. For example: ‘:10’ or ‘+/3’. In this case, Calc adjusts all fractions that are displayed to have the specified denominator, if possible. Otherwise it adjusts the denominator to be a multiple of the specified value. For example, in ‘:6’ mode the fraction ‘1:6’ will be unaffected, but ‘2:3’ will be displayed as ‘4:6’, ‘1:2’ will be displayed as ‘3:6’, and ‘1:8’ will be displayed as ‘3:24’. Integers are also affected by this mode: 3 is displayed as ‘18:6’. Note that the format ‘:1’ writes fractions the same as ‘:’, but it writes integers as ‘n:1’.

The fraction format does not affect the way fractions or integers are stored, only the way they appear on the screen. The fraction format never affects floats.


**** HMS Formats

The d h (calc-hms-notation) command controls the display of HMS (hours-minutes-seconds) forms. It prompts for a string which consists basically of an “hours” marker, optional punctuation, a “minutes” marker, more optional punctuation, and a “seconds” marker. Punctuation is zero or more spaces, commas, or semicolons. The hours marker is one or more non-punctuation characters. The minutes and seconds markers must be single non-punctuation characters.

The default HMS format is ‘@ ' "’, producing HMS values of the form ‘23@ 30' 15.75"’. The format ‘deg, ms’ would display this same value as ‘23deg, 30m15.75s’. During numeric entry, the h or o keys are recognized as synonyms for @ regardless of display format. The m and s keys are recognized as synonyms for ' and ", respectively, but only if an @ (or h or o) has already been typed; otherwise, they have their usual meanings (m- prefix and s- prefix). Thus, 5 ", 0 @ 5 ", and 0 h 5 s are some of the ways to enter the quantity “five seconds.” The ' key is recognized as “minutes” only if @ (or h or o) has already been pressed; otherwise it means to switch to algebraic entry.


**** Date Formats

The d d (calc-date-notation) command controls the display of date forms (see Date Forms). It prompts for a string which contains letters that represent the various parts of a date and time. To show which parts should be omitted when the form represents a pure date with no time, parts of the string can be enclosed in ‘< >’ marks. If you don’t include ‘< >’ markers in the format, Calc guesses at which parts, if any, should be omitted when formatting pure dates.

The default format is: ‘<H:mm:SSpp >Www Mmm D, YYYY’. An example string in this format is ‘3:32pm Wed Jan 9, 1991’. If you enter a blank format string, this default format is reestablished.

Calc uses ‘< >’ notation for nameless functions as well as for dates. See Specifying Operators. To avoid confusion with nameless functions, your date formats should avoid using the ‘#’ character.

***** ISO 8601

The same date can be written down in different formats and Calc tries to allow you to choose your preferred format. Some common formats are ambiguous, however; for example, 10/11/2012 means October 11, 2012 in the United States but it means November 10, 2012 in Europe. To help avoid such ambiguities, the International Organization for Standardization (ISO) provides the ISO 8601 standard, which provides three different but easily distinguishable and unambiguous ways to represent a date.

The ISO 8601 calendar date representation is

   YYYY-MM-DD
where YYYY is the four digit year, MM is the two-digit month number (01 for January to 12 for December), and DD is the two-digit day of the month (01 to 31). (Note that YYYY does not correspond to Calc’s date formatting code, which will be introduced later.) The year, which should be padded with zeros to ensure it has at least four digits, is the Gregorian year, except that the year before 0001 (1 AD) is the year 0000 (1 BC). The date October 11, 2012 is written 2012-10-11 in this representation and November 10, 2012 is written 2012-11-10.

The ISO 8601 ordinal date representation is

  YYYY-DDD
where YYYY is the year, as above, and DDD is the day of the year. The date December 31, 2011 is written 2011-365 in this representation and January 1, 2012 is written 2012-001.

The ISO 8601 week date representation is

 YYYY-Www-D
where YYYY is the ISO week-numbering year, ww is the two digit week number (preceded by a literal “W”), and D is the day of the week (1 for Monday through 7 for Sunday). The ISO week-numbering year is based on the Gregorian year but can differ slightly. The first week of an ISO week-numbering year is the week with the Gregorian year’s first Thursday in it (equivalently, the week containing January 4); any day of that week (Monday through Sunday) is part of the same ISO week-numbering year, any day from the previous week is part of the previous year. For example, January 4, 2013 is on a Friday, and so the first week for the ISO week-numbering year 2013 starts on Monday, December 31, 2012. The day December 31, 2012 is then part of the Gregorian year 2012 but ISO week-numbering year 2013. In the week date representation, this week goes from 2013-W01-1 (December 31, 2012) to 2013-W01-7 (January 6, 2013).

All three ISO 8601 representations arrange the numbers from most significant to least significant; as well as being unambiguous representations, they are easy to sort since chronological order in this formats corresponds to lexicographical order. The hyphens are sometimes omitted.

The ISO 8601 standard uses a 24 hour clock; a particular time is represented by hh:mm:ss where hh is the two-digit hour (from 00 to 24), mm is the two-digit minute (from 00 to 59) and ss is the two-digit second. The seconds or minutes and seconds can be omitted, and decimals can be added. If a date with a time is represented, they should be separated by a literal “T”, so noon on December 13, 2012 can be represented as 2012-12-13T12:00.


***** Date Formatting Codes

When displaying a date, the current date format is used. All characters except for letters and ‘<’ and ‘>’ are copied literally when dates are formatted. The portion between ‘< >’ markers is omitted for pure dates, or included for date/time forms. Letters are interpreted according to the table below.

When dates are read in during algebraic entry, Calc first tries to match the input string to the current format either with or without the time part. The punctuation characters (including spaces) must match exactly; letter fields must correspond to suitable text in the input. If this doesn’t work, Calc checks if the input is a simple number; if so, the number is interpreted as a number of days since Dec 31, 1 BC. Otherwise, Calc tries a much more relaxed and flexible algorithm which is described in the next section.

Weekday names are ignored during reading.

Two-digit year numbers are interpreted as lying in the range from 1941 to 2039. Years outside that range are always entered and displayed in full. Year numbers with a leading ‘+’ sign are always interpreted exactly, allowing the entry and display of the years 1 through 99 AD.

Here is a complete list of the formatting codes for dates:

Y
Year: “91” for 1991, “7” for 2007, “+23” for 23 AD.

YY
Year: “91” for 1991, “07” for 2007, “+23” for 23 AD.

BY
Year: “91” for 1991, “ 7” for 2007, “+23” for 23 AD.

YYY
Year: “1991” for 1991, “23” for 23 AD.

YYYY
Year: “1991” for 1991, “+23” for 23 AD.

ZYYY
Year: “1991” for 1991, “0023” for 23 AD, “0000” for 1 BC.

IYYY
Year: ISO 8601 week-numbering year.

aa
Year: “ad” or blank.

AA
Year: “AD” or blank.

aaa
Year: “ad ” or blank. (Note trailing space.)

AAA
Year: “AD ” or blank.

aaaa
Year: “a.d.” or blank.

AAAA
Year: “A.D.” or blank.

bb
Year: “bc” or blank.

BB
Year: “BC” or blank.

bbb
Year: “ bc” or blank. (Note leading space.)

BBB
Year: “ BC” or blank.

bbbb
Year: “b.c.” or blank.

BBBB
Year: “B.C.” or blank.

M
Month: “8” for August.

MM
Month: “08” for August.

BM
Month: “ 8” for August.

MMM
Month: “AUG” for August.

Mmm
Month: “Aug” for August.

mmm
Month: “aug” for August.

MMMM
Month: “AUGUST” for August.

Mmmm
Month: “August” for August.

D
Day: “7” for 7th day of month.

DD
Day: “07” for 7th day of month.

BD
Day: “ 7” for 7th day of month.

W
Weekday: “0” for Sunday, “6” for Saturday.

w
Weekday: “1” for Monday, “7” for Sunday.

WWW
Weekday: “SUN” for Sunday.

Www
Weekday: “Sun” for Sunday.

www
Weekday: “sun” for Sunday.

WWWW
Weekday: “SUNDAY” for Sunday.

Wwww
Weekday: “Sunday” for Sunday.

Iww
Week number: ISO 8601 week number, “W01” for week 1.

d
Day of year: “34” for Feb. 3.

ddd
Day of year: “034” for Feb. 3.

bdd
Day of year: “ 34” for Feb. 3.

T
Letter: Literal “T”.

h
Hour: “5” for 5 AM; “17” for 5 PM.

hh
Hour: “05” for 5 AM; “17” for 5 PM.

bh
Hour: “ 5” for 5 AM; “17” for 5 PM.

H
Hour: “5” for 5 AM and 5 PM.

HH
Hour: “05” for 5 AM and 5 PM.

BH
Hour: “ 5” for 5 AM and 5 PM.

p
AM/PM: “a” or “p”.

P
AM/PM: “A” or “P”.

pp
AM/PM: “am” or “pm”.

PP
AM/PM: “AM” or “PM”.

pppp
AM/PM: “a.m.” or “p.m.”.

PPPP
AM/PM: “A.M.” or “P.M.”.

m
Minutes: “7” for 7.

mm
Minutes: “07” for 7.

bm
Minutes: “ 7” for 7.

s
Seconds: “7” for 7; “7.23” for 7.23.

ss
Seconds: “07” for 7; “07.23” for 7.23.

bs
Seconds: “ 7” for 7; “ 7.23” for 7.23.

SS
Optional seconds: “07” for 7; blank for 0.

BS
Optional seconds: “ 7” for 7; blank for 0.

N
Numeric date/time: “726842.25” for 6:00am Wed Jan 9, 1991.

n
Numeric date: “726842” for any time on Wed Jan 9, 1991.

J
Julian date/time: “2448265.75” for 6:00am Wed Jan 9, 1991.

j
Julian date: “2448266” for any time on Wed Jan 9, 1991.

U
Unix time: “663400800” for 6:00am Wed Jan 9, 1991.

X
Brackets suppression. An “X” at the front of the format causes the surrounding ‘< >’ delimiters to be omitted when formatting dates. Note that the brackets are still required for algebraic entry.

If “SS” or “BS” (optional seconds) is preceded by a colon, the colon is also omitted if the seconds part is zero.

If “bb,” “bbb” or “bbbb” or their upper-case equivalents appear in the format, then negative year numbers are displayed without a minus sign. Note that “aa” and “bb” are mutually exclusive. Some typical usages would be ‘YYYY AABB’; ‘AAAYYYYBBB’; ‘YYYYBBB’.

The formats “YY,” “YYYY,” “MM,” “DD,” “ddd,” “hh,” “HH,” “mm,” “ss,” and “SS” actually match any number of digits during reading unless several of these codes are strung together with no punctuation in between, in which case the input must have exactly as many digits as there are letters in the format.

The “j,” “J,” and “U” formats do not make any time zone adjustment. They effectively use ‘julian(x,0)’ and ‘unixtime(x,0)’ to make the conversion; see Date Arithmetic.


***** Free-Form Dates

When reading a date form during algebraic entry, Calc falls back on the algorithm described here if the input does not exactly match the current date format. This algorithm generally “does the right thing” and you don’t have to worry about it, but it is described here in full detail for the curious.

Calc does not distinguish between upper- and lower-case letters while interpreting dates.

First, the time portion, if present, is located somewhere in the text and then removed. The remaining text is then interpreted as the date.

A time is of the form ‘hh:mm:ss’, possibly with the seconds part omitted and possibly with an AM/PM indicator added to indicate 12-hour time. If the AM/PM is present, the minutes may also be omitted. The AM/PM part may be any of the words ‘am’, ‘pm’, ‘noon’, or ‘midnight’; each of these may be abbreviated to one letter, and the alternate forms ‘a.m.’, ‘p.m.’, and ‘mid’ are also understood. Obviously ‘noon’ and ‘midnight’ are allowed only on 12:00:00. The words ‘noon’, ‘mid’, and ‘midnight’ are also recognized with no number attached. Midnight will represent the beginning of a day.

If there is no AM/PM indicator, the time is interpreted in 24-hour format.

When reading the date portion, Calc first checks to see if it is an ISO 8601 week-numbering date; if the string contains an integer representing the year, a “W” followed by two digits for the week number, and an integer from 1 to 7 representing the weekday (in that order), then all other characters are ignored and this information determines the date. Otherwise, all words and numbers are isolated from the string; other characters are ignored. All words must be either month names or day-of-week names (the latter of which are ignored). Names can be written in full or as three-letter abbreviations.

Large numbers, or numbers with ‘+’ or ‘-’ signs, are interpreted as years. If one of the other numbers is greater than 12, then that must be the day and the remaining number in the input is therefore the month. Otherwise, Calc assumes the month, day and year are in the same order that they appear in the current date format. If the year is omitted, the current year is taken from the system clock.

If there are too many or too few numbers, or any unrecognizable words, then the input is rejected.

If there are any large numbers (of five digits or more) other than the year, they are ignored on the assumption that they are something like Julian dates that were included along with the traditional date components when the date was formatted.

One of the words ‘ad’, ‘a.d.’, ‘bc’, or ‘b.c.’ may optionally be used; the latter two are equivalent to a minus sign on the year value.

If you always enter a four-digit year, and use a name instead of a number for the month, there is no danger of ambiguity.


***** Standard Date Formats

There are actually ten standard date formats, numbered 0 through 9. Entering a blank line at the d d command’s prompt gives you format number 1, Calc’s usual format. You can enter any digit to select the other formats.

To create your own standard date formats, give a numeric prefix argument from 0 to 9 to the d d command. The format you enter will be recorded as the new standard format of that number, as well as becoming the new current date format. You can save your formats permanently with the m m command (see Mode Settings).

0
‘N’ (Numerical format)

1
‘<H:mm:SSpp >Www Mmm D, YYYY’ (American format)

2
‘D Mmm YYYY<, h:mm:SS>’ (European format)

3
‘Www Mmm BD< hh:mm:ss> YYYY’ (Unix written date format)

4
‘M/D/Y< H:mm:SSpp>’ (American slashed format)

5
‘D.M.Y< h:mm:SS>’ (European dotted format)

6
‘M-D-Y< H:mm:SSpp>’ (American dashed format)

7
‘D-M-Y< h:mm:SS>’ (European dashed format)

8
‘j<, h:mm:ss>’ (Julian day plus time)

9
‘YYddd< hh:mm:ss>’ (Year-day format)

10
‘ZYYY-MM-DD Www< hh:mm>’ (Org mode format)

11
‘IYYY-Iww-w<Thh:mm:ss>’ (ISO 8601 week numbering format)


**** Truncating the Stack

The d t (calc-truncate-stack) command moves the ‘.’ line that marks the top-of-stack up or down in the Calculator buffer. The number right above that line is considered to the be at the top of the stack. Any numbers below that line are “hidden” from all stack operations (although still visible to the user). This is similar to the Emacs “narrowing” feature, except that the values below the ‘.’ are visible, just temporarily frozen. This feature allows you to keep several independent calculations running at once in different parts of the stack, or to apply a certain command to an element buried deep in the stack.

Pressing d t by itself moves the ‘.’ to the line the cursor is on. Thus, this line and all those below it become hidden. To un-hide these lines, move down to the end of the buffer and press d t. With a positive numeric prefix argument ‘n’, d t hides the bottom ‘n’ values in the buffer. With a negative argument, it hides all but the top ‘n’ values. With an argument of zero, it hides zero values, i.e., moves the ‘.’ all the way down to the bottom.

The d [ (calc-truncate-up) and d ] (calc-truncate-down) commands move the ‘.’ up or down one line at a time (or several lines with a prefix argument).


**** Justification

Values on the stack are normally left-justified in the window. You can control this arrangement by typing d < (calc-left-justify), d > (calc-right-justify), or d = (calc-center-justify). For example, in Right-Justification mode, stack entries are displayed flush-right against the right edge of the window.

If you change the width of the Calculator window you may have to type d SPC (calc-refresh) to re-align right-justified or centered text.

Right-justification is especially useful together with fixed-point notation (see d f; calc-fix-notation). With these modes together, the decimal points on numbers will always line up.

With a numeric prefix argument, the justification commands give you a little extra control over the display. The argument specifies the horizontal “origin” of a display line. It is also possible to specify a maximum line width using the d b command (see Normal Language Modes). For reference, the precise rules for formatting and breaking lines are given below. Notice that the interaction between origin and line width is slightly different in each justification mode.

In Left-Justified mode, the line is indented by a number of spaces given by the origin (default zero). If the result is longer than the maximum line width, if given, or too wide to fit in the Calc window otherwise, then it is broken into lines which will fit; each broken line is indented to the origin.

In Right-Justified mode, lines are shifted right so that the rightmost character is just before the origin, or just before the current window width if no origin was specified. If the line is too long for this, then it is broken; the current line width is used, if specified, or else the origin is used as a width if that is specified, or else the line is broken to fit in the window.

In Centering mode, the origin is the column number of the center of each stack entry. If a line width is specified, lines will not be allowed to go past that width; Calc will either indent less or break the lines if necessary. If no origin is specified, half the line width or Calc window width is used.

Note that, in each case, if line numbering is enabled the display is indented an additional four spaces to make room for the line number. The width of the line number is taken into account when positioning according to the current Calc window width, but not when positioning by explicit origins and widths. In the latter case, the display is formatted as specified, and then uniformly shifted over four spaces to fit the line numbers.


**** Labels

The d { (calc-left-label) command prompts for a string, then displays that string to the left of every stack entry. If the entries are left-justified (see Justification), then they will appear immediately after the label (unless you specified an origin greater than the length of the label). If the entries are centered or right-justified, the label appears on the far left and does not affect the horizontal position of the stack entry.

Give a blank string (with d { RET) to turn the label off.

The d } (calc-right-label) command similarly adds a label on the righthand side. It does not affect positioning of the stack entries unless they are right-justified. Also, if both a line width and an origin are given in Right-Justified mode, the stack entry is justified to the origin and the righthand label is justified to the line width.

One application of labels would be to add equation numbers to formulas you are manipulating in Calc and then copying into a document (possibly using Embedded mode). The equations would typically be centered, and the equation numbers would be on the left or right as you prefer.


*** Language Modes

The commands in this section change Calc to use a different notation for entry and display of formulas, corresponding to the conventions of some other common language such as Pascal or LaTeX. Objects displayed on the stack or yanked from the Calculator to an editing buffer will be formatted in the current language; objects entered in algebraic entry or yanked from another buffer will be interpreted according to the current language.

The current language has no effect on things written to or read from the trail buffer, nor does it affect numeric entry. Only algebraic entry is affected. You can make even algebraic entry ignore the current language and use the standard notation by giving a numeric prefix, e.g., C-u '.

For example, suppose the formula ‘2*a[1] + atan(a[2])’ occurs in a C program; elsewhere in the program you need the derivatives of this formula with respect to ‘a[1]’ and ‘a[2]’. First, type d C to switch to C notation. Now use C-u C-x * g to grab the formula into the Calculator, a d a[1] RET to differentiate with respect to the first variable, and C-x * y to yank the formula for the derivative back into your C program. Press U to undo the differentiation and repeat with a d a[2] RET for the other derivative.

Without being switched into C mode first, Calc would have misinterpreted the brackets in ‘a[1]’ and ‘a[2]’, would not have known that atan was equivalent to Calc’s built-in arctan function, and would have written the formula back with notations (like implicit multiplication) which would not have been valid for a C program.

As another example, suppose you are maintaining a C program and a LaTeX document, each of which needs a copy of the same formula. You can grab the formula from the program in C mode, switch to LaTeX mode, and yank the formula into the document in LaTeX math-mode format.

Language modes are selected by typing the letter d followed by a shifted letter key.


**** Normal Language Modes

The d N (calc-normal-language) command selects the usual notation for Calc formulas, as described in the rest of this manual. Matrices are displayed in a multi-line tabular format, but all other objects are written in linear form, as they would be typed from the keyboard.

The d O (calc-flat-language) command selects a language identical with the normal one, except that matrices are written in one-line form along with everything else. In some applications this form may be more suitable for yanking data into other buffers.

Even in one-line mode, long formulas or vectors will still be split across multiple lines if they exceed the width of the Calculator window. The d b (calc-line-breaking) command turns this line-breaking feature on and off. (It works independently of the current language.) If you give a numeric prefix argument of five or greater to the d b command, that argument will specify the line width used when breaking long lines.

The d B (calc-big-language) command selects a language which uses textual approximations to various mathematical notations, such as powers, quotients, and square roots:

  ____________
 | a + 1    2
 | ----- + c
\|   b
in place of ‘sqrt((a+1)/b + c^2)’.

Subscripts like ‘a_i’ are displayed as actual subscripts in Big mode. Double subscripts, ‘a_i_j’ (‘subscr(subscr(a, i), j)’) are displayed as ‘a’ with subscripts separated by commas: ‘i, j’. They must still be entered in the usual underscore notation.

One slight ambiguity of Big notation is that

  3
- -
  4
can represent either the negative rational number ‘-3:4’, or the actual expression ‘-(3/4)’; but the latter formula would normally never be displayed because it would immediately be evaluated to ‘-3:4’ or ‘-0.75’, so this ambiguity is not a problem in typical use.

Non-decimal numbers are displayed with subscripts. Thus there is no way to tell the difference between ‘16#C2’ and ‘C2_16’, though generally you will know which interpretation is correct. Logarithms ‘log(x,b)’ and ‘log10(x)’ also use subscripts in Big mode.

In Big mode, stack entries often take up several lines. To aid readability, stack entries are separated by a blank line in this mode. You may find it useful to expand the Calc window’s height using C-x ^ (enlarge-window) or to make the Calc window the only one on the screen with C-x 1 (delete-other-windows).

Long lines are currently not rearranged to fit the window width in Big mode, so you may need to use the < and > keys to scroll across a wide formula. For really big formulas, you may even need to use { and } to scroll up and down.

The d U (calc-unformatted-language) command altogether disables the use of operator notation in formulas. In this mode, the formula shown above would be displayed:

sqrt(add(div(add(a, 1), b), pow(c, 2)))
These four modes differ only in display format, not in the format expected for algebraic entry. The standard Calc operators work in all four modes, and unformatted notation works in any language mode (except that Mathematica mode expects square brackets instead of parentheses).


**** C, FORTRAN, and Pascal Modes

The d C (calc-c-language) command selects the conventions of the C language for display and entry of formulas. This differs from the normal language mode in a variety of (mostly minor) ways. In particular, C language operators and operator precedences are used in place of Calc’s usual ones. For example, ‘a^b’ means ‘xor(a,b)’ in C mode; a value raised to a power is written as a function call, ‘pow(a,b)’.

In C mode, vectors and matrices use curly braces instead of brackets. Octal and hexadecimal values are written with leading ‘0’ or ‘0x’ rather than using the ‘#’ symbol. Array subscripting is translated into subscr calls, so that ‘a[i]’ in C mode is the same as ‘a_i’ in Normal mode. Assignments turn into the assign function, which Calc normally displays using the ‘:=’ symbol.

The variables pi and e would be displayed ‘pi’ and ‘e’ in Normal mode, but in C mode they are displayed as ‘M_PI’ and ‘M_E’, corresponding to the names of constants typically provided in the <math.h> header. Functions whose names are different in C are translated automatically for entry and display purposes. For example, entering ‘asin(x)’ will push the formula ‘arcsin(x)’ onto the stack; this formula will be displayed as ‘asin(x)’ as long as C mode is in effect.

The d P (calc-pascal-language) command selects Pascal conventions. Like C mode, Pascal mode interprets array brackets and uses a different table of operators. Hexadecimal numbers are entered and displayed with a preceding dollar sign. (Thus the regular meaning of $2 during algebraic entry does not work in Pascal mode, though $ (and $$, etc.) not followed by digits works the same as always.) No special provisions are made for other non-decimal numbers, vectors, and so on, since there is no universally accepted standard way of handling these in Pascal.

The d F (calc-fortran-language) command selects FORTRAN conventions. Various function names are transformed into FORTRAN equivalents. Vectors are written as ‘/1, 2, 3/’, and may be entered this way or using square brackets. Since FORTRAN uses round parentheses for both function calls and array subscripts, Calc displays both in the same way; ‘a(i)’ is interpreted as a function call upon reading, and subscripts must be entered as ‘subscr(a, i)’. If the variable a has been declared to have type vector or matrix, however, then ‘a(i)’ will be parsed as a subscript. (See Declarations.) Usually it doesn’t matter, though; if you enter the subscript expression ‘a(i)’ and Calc interprets it as a function call, you’ll never know the difference unless you switch to another language mode or replace a with an actual vector (or unless a happens to be the name of a built-in function!).

Underscores are allowed in variable and function names in all of these language modes. The underscore here is equivalent to the ‘#’ in Normal mode, or to hyphens in the underlying Emacs Lisp variable names.

FORTRAN and Pascal modes normally do not adjust the case of letters in formulas. Most built-in Calc names use lower-case letters. If you use a positive numeric prefix argument with d P or d F, these modes will use upper-case letters exclusively for display, and will convert to lower-case on input. With a negative prefix, these modes convert to lower-case for display and input.


**** TeX and LaTeX Language Modes

The d T (calc-tex-language) command selects the conventions of “math mode” in Donald Knuth’s TeX typesetting language, and the d L (calc-latex-language) command selects the conventions of “math mode” in LaTeX, a typesetting language that uses TeX as its formatting engine. Calc’s LaTeX language mode can read any formula that the TeX language mode can, although LaTeX mode may display it differently.

Formulas are entered and displayed in the appropriate notation; ‘sin(a/b)’ will appear as ‘\sin\left( {a \over b} \right)’ in TeX mode and ‘\sin\left(\frac{a}{b}\right)’ in LaTeX mode. Math formulas are often enclosed by ‘$ $’ signs in TeX and LaTeX; these should be omitted when interfacing with Calc. To Calc, the ‘$’ sign has the same meaning it always does in algebraic formulas (a reference to an existing entry on the stack).

Complex numbers are displayed as in ‘3 + 4i’. Fractions and quotients are written using \over in TeX mode (as in {a \over b}) and \frac in LaTeX mode (as in \frac{a}{b}); binomial coefficients are written with \choose in TeX mode (as in {a \choose b}) and \binom in LaTeX mode (as in \binom{a}{b}). Interval forms are written with \ldots, and error forms are written with \pm. Absolute values are written as in ‘|x + 1|’, and the floor and ceiling functions are written with \lfloor, \rfloor, etc. The words \left and \right are ignored when reading formulas in TeX and LaTeX modes. Both inf and uinf are written as \infty; when read, \infty always translates to inf.

Function calls are written the usual way, with the function name followed by the arguments in parentheses. However, functions for which TeX and LaTeX have special names (like \sin) will use curly braces instead of parentheses for very simple arguments. During input, curly braces and parentheses work equally well for grouping, but when the document is formatted the curly braces will be invisible. Thus the printed result is ‘sin 2x’ but ‘sin(2 + x)’.

The TeX specific unit names (see Predefined Units) will not use the ‘tex’ prefix; the unit name for a TeX point will be ‘pt’ instead of ‘texpt’, for example.

Function and variable names not treated specially by TeX and LaTeX are simply written out as-is, which will cause them to come out in italic letters in the printed document. If you invoke d T or d L with a positive numeric prefix argument, names of more than one character will instead be enclosed in a protective commands that will prevent them from being typeset in the math italics; they will be written ‘\hbox{name}’ in TeX mode and ‘\text{name}’ in LaTeX mode. The ‘\hbox{ }’ and ‘\text{ }’ notations are ignored during reading. If you use a negative prefix argument, such function names are written ‘\name’, and function names that begin with \ during reading have the \ removed. (Note that in this mode, long variable names are still written with \hbox or \text. However, you can always make an actual variable name like \bar in any TeX mode.)

During reading, text of the form ‘\matrix{ ... }’ is replaced by ‘[ ... ]’. The same also applies to \pmatrix and \bmatrix. In LaTeX mode this also applies to ‘\begin{matrix} ... \end{matrix}’, ‘\begin{bmatrix} ... \end{bmatrix}’, ‘\begin{pmatrix} ... \end{pmatrix}’, as well as ‘\begin{smallmatrix} ... \end{smallmatrix}’. The symbol ‘&’ is interpreted as a comma, and the symbols ‘\cr’ and ‘\\’ are interpreted as semicolons. During output, matrices are displayed in ‘\matrix{ a & b \\ c & d}’ format in TeX mode and in ‘\begin{pmatrix} a & b \\ c & d \end{pmatrix}’ format in LaTeX mode; you may need to edit this afterwards to change to your preferred matrix form. If you invoke d T or d L with an argument of 2 or -2, then matrices will be displayed in two-dimensional form, such as

\begin{pmatrix}
a & b \\
c & d
\end{pmatrix}
This may be convenient for isolated matrices, but could lead to expressions being displayed like

\begin{pmatrix} \times x
a & b \\
c & d
\end{pmatrix}
While this wouldn’t bother Calc, it is incorrect LaTeX. (Similarly for TeX.)

Accents like \tilde and \bar translate into function calls internally (‘tilde(x)’, ‘bar(x)’). The \underline sequence is treated as an accent. The \vec accent corresponds to the function name Vec, because vec is the name of a built-in Calc function. The following table shows the accents in Calc, TeX, LaTeX and eqn (described in the next section):

Calc      TeX           LaTeX         eqn
----      ---           -----         ---
acute     \acute        \acute
Acute                   \Acute
bar       \bar          \bar          bar
Bar                     \Bar
breve     \breve        \breve
Breve                   \Breve
check     \check        \check
Check                   \Check
dddot                   \dddot
ddddot                  \ddddot
dot       \dot          \dot          dot
Dot                     \Dot
dotdot    \ddot         \ddot         dotdot
DotDot                  \Ddot
dyad                                  dyad
grave     \grave        \grave
Grave                   \Grave
hat       \hat          \hat          hat
Hat                     \Hat
Prime                                 prime
tilde     \tilde        \tilde        tilde
Tilde                   \Tilde
under     \underline    \underline    under
Vec       \vec          \vec          vec
VEC                     \Vec
The ‘=>’ (evaluates-to) operator appears as a \to symbol: ‘{a \to b}’. TeX defines \to as an alias for \rightarrow. However, if the ‘=>’ is the top-level expression being formatted, a slightly different notation is used: ‘\evalto a \to b’. The \evalto word is ignored by Calc’s input routines, and is undefined in TeX. You will typically want to include one of the following definitions at the top of a TeX file that uses \evalto:

\def\evalto{}
\def\evalto#1\to{}
The first definition formats evaluates-to operators in the usual way. The second causes only the b part to appear in the printed document; the a part and the arrow are hidden. Another definition you may wish to use is ‘\let\to=\Rightarrow’ which causes \to to appear more like Calc’s ‘=>’ symbol. See The Evaluates-To Operator, for a discussion of evalto.

The complete set of TeX control sequences that are ignored during reading is:

\hbox  \mbox  \text  \left  \right
\,  \>  \:  \;  \!  \quad  \qquad  \hfil  \hfill
\displaystyle  \textstyle  \dsize  \tsize
\scriptstyle  \scriptscriptstyle  \ssize  \ssize
\rm  \bf  \it  \sl  \roman  \bold  \italic  \slanted
\cal  \mit  \Cal  \Bbb  \frak  \goth
\evalto
Note that, because these symbols are ignored, reading a TeX or LaTeX formula into Calc and writing it back out may lose spacing and font information.

Also, the “discretionary multiplication sign” ‘\*’ is read the same as ‘*’.

The TeX version of this manual includes some printed examples at the end of this section.


**** Eqn Language Mode

Eqn is another popular formatter for math formulas. It is designed for use with the TROFF text formatter, and comes standard with many versions of Unix. The d E (calc-eqn-language) command selects eqn notation.

The eqn language’s main idiosyncrasy is that whitespace plays a significant part in the parsing of the language. For example, ‘sqrt x+1 + y’ treats ‘x+1’ as the argument of the sqrt operator. Eqn also understands more conventional grouping using curly braces: ‘sqrt{x+1} + y’. Braces are required only when the argument contains spaces.

In Calc’s eqn mode, however, curly braces are required to delimit arguments of operators like sqrt. The first of the above examples would treat only the ‘x’ as the argument of sqrt, and in fact ‘sin x+1’ would be interpreted as ‘sin * x + 1’, because sin is not a special operator in the eqn language. If you always surround the argument with curly braces, Calc will never misunderstand.

Calc also understands parentheses as grouping characters. Another peculiarity of eqn’s syntax makes it advisable to separate words with spaces from any surrounding characters that aren’t curly braces, so Calc writes ‘sin ( x + y )’ in eqn mode. (The spaces around sin are important to make eqn recognize that sin should be typeset in a roman font, and the spaces around x and y are a good idea just in case the eqn document has defined special meanings for these names, too.)

Powers and subscripts are written with the sub and sup operators, respectively. Note that the caret symbol ‘^’ is treated the same as a space in eqn mode, as is the ‘~’ symbol (these are used to introduce spaces of various widths into the typeset output of eqn).

As in LaTeX mode, Calc’s formatter omits parentheses around the arguments of functions like ln and sin if they are “simple-looking”; in this case Calc surrounds the argument with braces, separated by a ‘~’ from the function name: ‘sin~{x}’.

Font change codes (like ‘roman x’) and positioning codes (like ‘~’ and ‘down n x’) are ignored by the eqn reader. Also ignored are the words left, right, mark, and lineup. Quotation marks in eqn mode input are treated the same as curly braces: ‘sqrt "1+x"’ is equivalent to ‘sqrt {1+x}’; this is only an approximation to the true meaning of quotes in eqn, but it is good enough for most uses.

Accent codes (‘x dot’) are handled by treating them as function calls (‘dot(x)’) internally. See TeX and LaTeX Language Modes, for a table of these accent functions. The prime accent is treated specially if it occurs on a variable or function name: ‘f prime prime ( x prime )’ is stored internally as ‘f''(x')’. For example, taking the derivative of ‘f(2 x)’ with a d x will produce ‘2 f'(2 x)’, which eqn mode will display as ‘2 f prime ( 2 x )’.

Assignments are written with the ‘<-’ (left-arrow) symbol, and evalto operators are written with ‘->’ or ‘evalto ... ->’ (see TeX and LaTeX Language Modes, for a discussion of this). The regular Calc symbols ‘:=’ and ‘=>’ are also recognized for these operators during reading.

Vectors in eqn mode use regular Calc square brackets, but matrices are formatted as ‘matrix { ccol { a above b } ... }’. The words lcol and rcol are recognized as synonyms for ccol during input, and are generated instead of ccol if the matrix justification mode so specifies.


**** Yacas Language Mode

The d Y (calc-yacas-language) command selects the conventions of Yacas, a free computer algebra system. While the operators and functions in Yacas are similar to those of Calc, the names of built-in functions in Yacas are capitalized. The Calc formula ‘sin(2 x)’, for example, is entered and displayed ‘Sin(2 x)’ in Yacas mode, and ‘arcsin(x^2)’ is ‘ArcSin(x^2)’ in Yacas mode. Complex numbers are written are written ‘3 + 4 I’. The standard special constants are written Pi, E, I, GoldenRatio and Gamma. Infinity represents both inf and uinf, and Undefined represents nan.

Certain operators on functions, such as D for differentiation and Integrate for integration, take a prefix form in Yacas. For example, the derivative of ‘e^x sin(x)’ can be computed with ‘D(x) Exp(x)*Sin(x)’.

Other notable differences between Yacas and standard Calc expressions are that vectors and matrices use curly braces in Yacas, and subscripts use square brackets. If, for example, ‘A’ represents the list ‘{a,2,c,4}’, then ‘A[3]’ would equal ‘c’.


**** Maxima Language Mode

The d X (calc-maxima-language) command selects the conventions of Maxima, another free computer algebra system. The function names in Maxima are similar, but not always identical, to Calc. For example, instead of ‘arcsin(x)’, Maxima will use ‘asin(x)’. Complex numbers are written ‘3 + 4 %i’. The standard special constants are written %pi, %e, %i, %phi and %gamma. In Maxima, inf means the same as in Calc, but infinity represents Calc’s uinf.

Underscores as well as percent signs are allowed in function and variable names in Maxima mode. The underscore again is equivalent to the ‘#’ in Normal mode, and the percent sign is equivalent to ‘o'o’.

Maxima uses square brackets for lists and vectors, and matrices are written as calls to the function matrix, given the row vectors of the matrix as arguments. Square brackets are also used as subscripts.


**** Giac Language Mode

The d A (calc-giac-language) command selects the conventions of Giac, another free computer algebra system. The function names in Giac are similar to Maxima. Complex numbers are written ‘3 + 4 i’. The standard special constants in Giac are the same as in Calc, except that infinity represents both Calc’s inf and uinf.

Underscores are allowed in function and variable names in Giac mode. Brackets are used for subscripts. In Giac, indexing of lists begins at 0, instead of 1 as in Calc. So if ‘A’ represents the list ‘[a,2,c,4]’, then ‘A[2]’ would equal ‘c’. In general, ‘A[n]’ in Giac mode corresponds to ‘A_(n+1)’ in Normal mode.

The Giac interval notation ‘2 .. 3’ has no surrounding brackets; Calc reads ‘2 .. 3’ as the closed interval ‘[2 .. 3]’ and writes any kind of interval as ‘2 .. 3’. This means you cannot see the difference between an open and a closed interval while in Giac mode.


**** Mathematica Language Mode

The d M (calc-mathematica-language) command selects the conventions of Mathematica. Notable differences in Mathematica mode are that the names of built-in functions are capitalized, and function calls use square brackets instead of parentheses. Thus the Calc formula ‘sin(2 x)’ is entered and displayed ‘Sin[2 x]’ in Mathematica mode.

Vectors and matrices use curly braces in Mathematica. Complex numbers are written ‘3 + 4 I’. The standard special constants in Calc are written Pi, E, I, GoldenRatio, EulerGamma, Infinity, ComplexInfinity, and Indeterminate in Mathematica mode. Non-decimal numbers are written, e.g., ‘16^^7fff’. Floating-point numbers in scientific notation are written ‘1.23*10.^3’. Subscripts use double square brackets: ‘a[[i]]’.


**** Maple Language Mode

The d W (calc-maple-language) command selects the conventions of Maple.

Maple’s language is much like C. Underscores are allowed in symbol names; square brackets are used for subscripts; explicit ‘*’s for multiplications are required. Use either ‘^’ or ‘**’ to denote powers.

Maple uses square brackets for lists and curly braces for sets. Calc interprets both notations as vectors, and displays vectors with square brackets. This means Maple sets will be converted to lists when they pass through Calc. As a special case, matrices are written as calls to the function matrix, given a list of lists as the argument, and can be read in this form or with all-capitals MATRIX.

The Maple interval notation ‘2 .. 3’ is like Giac’s interval notation, and is handled the same by Calc.

Maple writes complex numbers as ‘3 + 4*I’. Its special constants are Pi, E, I, and infinity (all three of inf, uinf, and nan display as infinity). Floating-point numbers are written ‘1.23*10.^3’.

Among things not currently handled by Calc’s Maple mode are the various quote symbols, procedures and functional operators, and inert (‘&’) operators.


**** Compositions

There are several composition functions which allow you to get displays in a variety of formats similar to those in Big language mode. Most of these functions do not evaluate to anything; they are placeholders which are left in symbolic form by Calc’s evaluator but are recognized by Calc’s display formatting routines.

Two of these, string and bstring, are described elsewhere. See Strings. For example, ‘string("ABC")’ is displayed as ‘ABC’. When viewed on the stack it will be indistinguishable from the variable ABC, but internally it will be stored as ‘string([65, 66, 67])’ and can still be manipulated this way; for example, the selection and vector commands j 1 v v j u would select the vector portion of this object and reverse the elements, then deselect to reveal a string whose characters had been reversed.

The composition functions do the same thing in all language modes (although their components will of course be formatted in the current language mode). The one exception is Unformatted mode (d U), which does not give the composition functions any special treatment. The functions are discussed here because of their relationship to the language modes.

***** Composition Basics

Compositions are generally formed by stacking formulas together horizontally or vertically in various ways. Those formulas are themselves compositions. TeX users will find this analogous to TeX’s “boxes.” Each multi-line composition has a baseline; horizontal compositions use the baselines to decide how formulas should be positioned relative to one another. For example, in the Big mode formula

          2
     a + b
17 + ------
       c
the second term of the sum is four lines tall and has line three as its baseline. Thus when the term is combined with 17, line three is placed on the same level as the baseline of 17.

Another important composition concept is precedence. This is an integer that represents the binding strength of various operators. For example, ‘*’ has higher precedence (195) than ‘+’ (180), which means that ‘(a * b) + c’ will be formatted without the parentheses, but ‘a * (b + c)’ will keep the parentheses.

The operator table used by normal and Big language modes has the following precedences:

_     1200    (subscripts)
%     1100    (as in n%)
!     1000    (as in !n)
mod    400
+/-    300
!!     210    (as in n!!)
!      210    (as in n!)
^      200
-      197    (as in -n)
;*      195    (or implicit multiplication)
/ % \  190
+ -    180    (as in a+b)
|      170
< =    160    (and other relations)
&&     110
||     100
? :     90
!!!     85
&&&     80
|||     75
:=      50
::      45
=>      40
The general rule is that if an operator with precedence ‘n’ occurs as an argument to an operator with precedence ‘m’, then the argument is enclosed in parentheses if ‘n < m’. Top-level expressions and expressions which are function arguments, vector components, etc., are formatted with precedence zero (so that they normally never get additional parentheses).

For binary left-associative operators like ‘+’, the righthand argument is actually formatted with one-higher precedence than shown in the table. This makes sure ‘(a + b) + c’ omits the parentheses, but the unnatural form ‘a + (b + c)’ keeps its parentheses. Right-associative operators like ‘^’ format the lefthand argument with one-higher precedence.

The cprec function formats an expression with an arbitrary precedence. For example, ‘cprec(abc, 185)’ will combine into sums and products as follows: ‘7 + abc’, ‘7 (abc)’ (because this cprec form has higher precedence than addition, but lower precedence than multiplication).

A final composition issue is line breaking. Calc uses two different strategies for “flat” and “non-flat” compositions. A non-flat composition is anything that appears on multiple lines (not counting line breaking). Examples would be matrices and Big mode powers and quotients. Non-flat compositions are displayed exactly as specified. If they come out wider than the current window, you must use horizontal scrolling (< and >) to view them.

Flat compositions, on the other hand, will be broken across several lines if they are too wide to fit the window. Certain points in a composition are noted internally as break points. Calc’s general strategy is to fill each line as much as possible, then to move down to the next line starting at the first break point that didn’t fit. However, the line breaker understands the hierarchical structure of formulas. It will not break an “inner” formula if it can use an earlier break point from an “outer” formula instead. For example, a vector of sums might be formatted as:

[ a + b + c, d + e + f,
  g + h + i, j + k + l, m ]
If the ‘m’ can fit, then so, it seems, could the ‘g’. But Calc prefers to break at the comma since the comma is part of a “more outer” formula. Calc would break at a plus sign only if it had to, say, if the very first sum in the vector had itself been too large to fit.

Of the composition functions described below, only choriz generates break points. The bstring function (see Strings) also generates breakable items: A break point is added after every space (or group of spaces) except for spaces at the very beginning or end of the string.

Composition functions themselves count as levels in the formula hierarchy, so a choriz that is a component of a larger choriz will be less likely to be broken. As a special case, if a bstring occurs as a component of a choriz or choriz-like object (such as a vector or a list of arguments in a function call), then the break points in that bstring will be on the same level as the break points of the surrounding object.


***** Horizontal Compositions

The choriz function takes a vector of objects and composes them horizontally. For example, ‘choriz([17, a b/c, d])’ formats as ‘17a b / cd’ in Normal language mode, or as

  a b
17---d
   c
in Big language mode. This is actually one case of the general function ‘choriz(vec, sep, prec)’, where either or both of sep and prec may be omitted. Prec gives the precedence to use when formatting each of the components of vec. The default precedence is the precedence from the surrounding environment.

Sep is a string (i.e., a vector of character codes as might be entered with " " notation) which should separate components of the composition. Also, if sep is given, the line breaker will allow lines to be broken after each occurrence of sep. If sep is omitted, the composition will not be breakable (unless any of its component compositions are breakable).

For example, ‘2 choriz([a, b c, d = e], " + ", 180)’ is formatted as ‘2 a + b c + (d = e)’. To get the choriz to have precedence 180 “outwards” as well as “inwards,” enclose it in a cprec form: ‘2 cprec(choriz(...), 180)’ formats as ‘2 (a + b c + (d = e))’.

The baseline of a horizontal composition is the same as the baselines of the component compositions, which are all aligned.


***** Vertical Compositions

The cvert function makes a vertical composition. Each component of the vector is centered in a column. The baseline of the result is by default the top line of the resulting composition. For example, ‘f(cvert([a, bb, ccc]), cvert([a^2 + 1, b^2]))’ formats in Big mode as

f( a ,  2    )
  bb   a  + 1
  ccc     2
         b
There are several special composition functions that work only as components of a vertical composition. The cbase function controls the baseline of the vertical composition; the baseline will be the same as the baseline of whatever component is enclosed in cbase. Thus ‘f(cvert([a, cbase(bb), ccc]), cvert([a^2 + 1, cbase(b^2)]))’ displays as

        2
       a  + 1
   a      2
f(bb ,   b   )
  ccc
There are also ctbase and cbbase functions which make the baseline of the vertical composition equal to the top or bottom line (rather than the baseline) of that component. Thus ‘cvert([cbase(a / b)]) + cvert([ctbase(a / b)]) + cvert([cbbase(a / b)])’ gives

        a
a       -
- + a + b
b   -
    b
There should be only one cbase, ctbase, or cbbase function in a given vertical composition. These functions can also be written with no arguments: ‘ctbase()’ is a zero-height object which means the baseline is the top line of the following item, and ‘cbbase()’ means the baseline is the bottom line of the preceding item.

The crule function builds a “rule,” or horizontal line, across a vertical composition. By itself ‘crule()’ uses ‘-’ characters to build the rule. You can specify any other character, e.g., ‘crule("=")’. The argument must be a character code or vector of exactly one character code. It is repeated to match the width of the widest item in the stack. For example, a quotient with a thick line is ‘cvert([a + 1, cbase(crule("=")), b^2])’:

a + 1
=====
  2
 b
Finally, the functions clvert and crvert act exactly like cvert except that the items are left- or right-justified in the stack. Thus ‘clvert([a, bb, ccc]) + crvert([a, bb, ccc])’ gives:

a   +   a
bb     bb
ccc   ccc
Like choriz, the vertical compositions accept a second argument which gives the precedence to use when formatting the components. Vertical compositions do not support separator strings.


***** Other Compositions

The csup function builds a superscripted expression. For example, ‘csup(a, b)’ looks the same as ‘a^b’ does in Big language mode. This is essentially a horizontal composition of ‘a’ and ‘b’, where ‘b’ is shifted up so that its bottom line is one above the baseline.

Likewise, the csub function builds a subscripted expression. This shifts ‘b’ down so that its top line is one below the bottom line of ‘a’ (note that this is not quite analogous to csup). Other arrangements can be obtained by using choriz and cvert directly.

The cflat function formats its argument in “flat” mode, as obtained by ‘d O’, if the current language mode is normal or Big. It has no effect in other language modes. For example, ‘a^(b/c)’ is formatted by Big mode like ‘csup(a, cflat(b/c))’ to improve its readability.

The cspace function creates horizontal space. For example, ‘cspace(4)’ is effectively the same as ‘string(" ")’. A second string (i.e., vector of characters) argument is repeated instead of the space character. For example, ‘cspace(4, "ab")’ looks like ‘abababab’. If the second argument is not a string, it is formatted in the normal way and then several copies of that are composed together: ‘cspace(4, a^2)’ yields

 2 2 2 2
a a a a
If the number argument is zero, this is a zero-width object.

The cvspace function creates vertical space, or a vertical stack of copies of a certain string or formatted object. The baseline is the center line of the resulting stack. A numerical argument of zero will produce an object which contributes zero height if used in a vertical composition.

There are also ctspace and cbspace functions which create vertical space with the baseline the same as the baseline of the top or bottom copy, respectively, of the second argument. Thus ‘cvspace(2, a/b) + ctspace(2, a/b) + cbspace(2, a/b)’ displays as:

        a
        -
a       b
-   a   a
b + - + -
a   b   b
-   a
b   -
    b


***** Information about Compositions

The functions in this section are actual functions; they compose their arguments according to the current language and other display modes, then return a certain measurement of the composition as an integer.

The cwidth function measures the width, in characters, of a composition. For example, ‘cwidth(a + b)’ is 5, and ‘cwidth(a / b)’ is 5 in Normal mode, 1 in Big mode, and 11 in TeX mode (for ‘{a \over b}’). The argument may involve the composition functions described in this section.

The cheight function measures the height of a composition. This is the total number of lines in the argument’s printed form.

The functions cascent and cdescent measure the amount of the height that is above (and including) the baseline, or below the baseline, respectively. Thus ‘cascent(x) + cdescent(x)’ always equals ‘cheight(x)’. For a one-line formula like ‘a + b’, cascent returns 1 and cdescent returns 0. For ‘a / b’ in Big mode, cascent returns 2 and cdescent returns 1. The only formula for which cascent will return zero is ‘cvspace(0)’ or equivalents.


***** User-Defined Compositions

The Z C (calc-user-define-composition) command lets you define the display format for any algebraic function. You provide a formula containing a certain number of argument variables on the stack. Any time Calc formats a call to the specified function in the current language mode and with that number of arguments, Calc effectively replaces the function call with that formula with the arguments replaced.

Calc builds the default argument list by sorting all the variable names that appear in the formula into alphabetical order. You can edit this argument list before pressing RET if you wish. Any variables in the formula that do not appear in the argument list will be displayed literally; any arguments that do not appear in the formula will not affect the display at all.

You can define formats for built-in functions, for functions you have defined with Z F (see Programming with Formulas), or for functions which have no definitions but are being used as purely syntactic objects. You can define different formats for each language mode, and for each number of arguments, using a succession of Z C commands. When Calc formats a function call, it first searches for a format defined for the current language mode (and number of arguments); if there is none, it uses the format defined for the Normal language mode. If neither format exists, Calc uses its built-in standard format for that function (usually just ‘func(args)’).

If you execute Z C with the number 0 on the stack instead of a formula, any defined formats for the function in the current language mode will be removed. The function will revert to its standard format.

For example, the default format for the binomial coefficient function ‘choose(n, m)’ in the Big language mode is

 n
( )
 m
You might prefer the notation,

 C
n m
To define this notation, first make sure you are in Big mode, then put the formula

choriz([cvert([cvspace(1), n]), C, cvert([cvspace(1), m])])
on the stack and type Z C. Answer the first prompt with choose. The second prompt will be the default argument list of ‘(C m n)’. Edit this list to be ‘(n m)’ and press RET. Now, try it out: For example, turn simplification off with m O and enter ‘choose(a,b) + choose(7,3)’ as an algebraic entry.

 C  +  C
a b   7 3
As another example, let’s define the usual notation for Stirling numbers of the first kind, ‘stir1(n, m)’. This is just like the regular format for binomial coefficients but with square brackets instead of parentheses.

choriz([string("["), cvert([n, cbase(cvspace(1)), m]), string("]")])
Now type Z C stir1 RET, edit the argument list to ‘(n m)’, and type RET.

The formula provided to Z C usually will involve composition functions, but it doesn’t have to. Putting the formula ‘a + b + c’ onto the stack and typing Z C foo RET RET would define the function ‘foo(x,y,z)’ to display like ‘x + y + z’. This “sum” will act exactly like a real sum for all formatting purposes (it will be parenthesized the same, and so on). However it will be computationally unrelated to a sum. For example, the formula ‘2 * foo(1, 2, 3)’ will display as ‘2 (1 + 2 + 3)’. Operator precedences have caused the “sum” to be written in parentheses, but the arguments have not actually been summed. (Generally a display format like this would be undesirable, since it can easily be confused with a real sum.)

The special function eval can be used inside a Z C composition formula to cause all or part of the formula to be evaluated at display time. For example, if the formula is ‘a + eval(b + c)’, then ‘foo(1, 2, 3)’ will be displayed as ‘1 + 5’. Evaluation will use the default simplifications, regardless of the current simplification mode. There are also evalsimp and evalextsimp which simplify as if by a s and a e (respectively). Note that these “functions” operate only in the context of composition formulas (and also in rewrite rules, where they serve a similar purpose; see Rewrite Rules). On the stack, a call to eval will be left in symbolic form.

It is not a good idea to use eval except as a last resort. It can cause the display of formulas to be extremely slow. For example, while ‘eval(a + b)’ might seem quite fast and simple, there are several situations where it could be slow. For example, ‘a’ and/or ‘b’ could be polar complex numbers, in which case doing the sum requires trigonometry. Or, ‘a’ could be the factorial ‘fact(100)’ which is unevaluated because you have typed m O; eval will evaluate it anyway to produce a large, unwieldy integer.

You can save your display formats permanently using the Z P command (see Creating User Keys).


**** Syntax Tables

Syntax tables do for input what compositions do for output: They allow you to teach custom notations to Calc’s formula parser. Calc keeps a separate syntax table for each language mode.

(Note that the Calc “syntax tables” discussed here are completely unrelated to the syntax tables described in the Emacs manual.)

The Z S (calc-edit-user-syntax) command edits the syntax table for the current language mode. If you want your syntax to work in any language, define it in the Normal language mode. Type C-c C-c to finish editing the syntax table, or C-x k to cancel the edit. The m m command saves all the syntax tables along with the other mode settings; see General Mode Commands.

***** Syntax Table Basics

Parsing is the process of converting a raw string of characters, such as you would type in during algebraic entry, into a Calc formula. Calc’s parser works in two stages. First, the input is broken down into tokens, such as words, numbers, and punctuation symbols like ‘+’, ‘:=’, and ‘+/-’. Space between tokens is ignored (except when it serves to separate adjacent words). Next, the parser matches this string of tokens against various built-in syntactic patterns, such as “an expression followed by ‘+’ followed by another expression” or “a name followed by ‘(’, zero or more expressions separated by commas, and ‘)’.”

A syntax table is a list of user-defined syntax rules, which allow you to specify new patterns to define your own favorite input notations. Calc’s parser always checks the syntax table for the current language mode, then the table for the Normal language mode, before it uses its built-in rules to parse an algebraic formula you have entered. Each syntax rule should go on its own line; it consists of a pattern, a ‘:=’ symbol, and a Calc formula with an optional condition. (Syntax rules resemble algebraic rewrite rules, but the notation for patterns is completely different.)

A syntax pattern is a list of tokens, separated by spaces. Except for a few special symbols, tokens in syntax patterns are matched literally, from left to right. For example, the rule,

foo ( ) := 2+3
would cause Calc to parse the formula ‘4+foo()*5’ as if it were ‘4+(2+3)*5’. Notice that the parentheses were written as two separate tokens in the rule. As a result, the rule works for both ‘foo()’ and ‘foo (  )’. If we had written the rule as ‘foo () := 2+3’, then Calc would treat ‘()’ as a single, indivisible token, so that ‘foo( )’ would not be recognized by the rule. (It would be parsed as a regular zero-argument function call instead.) In fact, this rule would also make trouble for the rest of Calc’s parser: An unrelated formula like ‘bar()’ would now be tokenized into ‘bar ()’ instead of ‘bar ( )’, so that the standard parser for function calls would no longer recognize it!

While it is possible to make a token with a mixture of letters and punctuation symbols, this is not recommended. It is better to break it into several tokens, as we did with ‘foo()’ above.

The symbol ‘#’ in a syntax pattern matches any Calc expression. On the righthand side, the things that matched the ‘#’s can be referred to as ‘#1’, ‘#2’, and so on (where ‘#1’ matches the leftmost ‘#’ in the pattern). For example, these rules match a user-defined function, prefix operator, infix operator, and postfix operator, respectively:

foo ( # ) := myfunc(#1)
foo # := myprefix(#1)
# foo # := myinfix(#1,#2)
# foo := mypostfix(#1)
Thus ‘foo(3)’ will parse as ‘myfunc(3)’, and ‘2+3 foo’ will parse as ‘mypostfix(2+3)’.

It is important to write the first two rules in the order shown, because Calc tries rules in order from first to last. If the pattern ‘foo #’ came first, it would match anything that could match the ‘foo ( # )’ rule, since an expression in parentheses is itself a valid expression. Thus the ‘foo ( # )’ rule would never get to match anything. Likewise, the last two rules must be written in the order shown or else ‘3 foo 4’ will be parsed as ‘mypostfix(3) * 4’. (Of course, the best way to avoid these ambiguities is not to use the same symbol in more than one way at the same time! In case you’re not convinced, try the following exercise: How will the above rules parse the input ‘foo(3,4)’, if at all? Work it out for yourself, then try it in Calc and see.)

Calc is quite flexible about what sorts of patterns are allowed. The only rule is that every pattern must begin with a literal token (like ‘foo’ in the first two patterns above), or with a ‘#’ followed by a literal token (as in the last two patterns). After that, any mixture is allowed, although putting two ‘#’s in a row will not be very useful since two expressions with nothing between them will be parsed as one expression that uses implicit multiplication.

As a more practical example, Maple uses the notation ‘sum(a(i), i=1..10)’ for sums, which Calc’s Maple mode doesn’t recognize at present. To handle this syntax, we simply add the rule,

sum ( # , # = # .. # ) := sum(#1,#2,#3,#4)
to the Maple mode syntax table. As another example, C mode can’t read assignment operators like ‘++’ and ‘*=’. We can define these operators quite easily:

# *= # := muleq(#1,#2)
# ++ := postinc(#1)
++ # := preinc(#1)
To complete the job, we would use corresponding composition functions and Z C to cause these functions to display in their respective Maple and C notations. (Note that the C example ignores issues of operator precedence, which are discussed in the next section.)

You can enclose any token in quotes to prevent its usual interpretation in syntax patterns:

# ":=" # := becomes(#1,#2)
Quotes also allow you to include spaces in a token, although once again it is generally better to use two tokens than one token with an embedded space. To include an actual quotation mark in a quoted token, precede it with a backslash. (This also works to include backslashes in tokens.)

# "bad token" # "/\"\\" # := silly(#1,#2,#3)
This will parse ‘3 bad token 4 /"\ 5’ to ‘silly(3,4,5)’.

The token # has a predefined meaning in Calc’s formula parser; it is not valid to use ‘"#"’ in a syntax rule. However, longer tokens that include the ‘#’ character are allowed. Also, while ‘"$"’ and ‘"\""’ are allowed as tokens, their presence in the syntax table will prevent those characters from working in their usual ways (referring to stack entries and quoting strings, respectively).

Finally, the notation ‘%%’ anywhere in a syntax table causes the rest of the line to be ignored as a comment.


***** Precedence

Different operators are generally assigned different precedences. By default, an operator defined by a rule like

# foo # := foo(#1,#2)
will have an extremely low precedence, so that ‘2*3+4 foo 5 == 6’ will be parsed as ‘(2*3+4) foo (5 == 6)’. To change the precedence of an operator, use the notation ‘#/p’ in place of ‘#’, where p is an integer precedence level. For example, 185 lies between the precedences for ‘+’ and ‘*’, so if we change this rule to

#/185 foo #/186 := foo(#1,#2)
then ‘2+3 foo 4*5’ will be parsed as ‘2+(3 foo (4*5))’. Also, because we’ve given the righthand expression slightly higher precedence, our new operator will be left-associative: ‘1 foo 2 foo 3’ will be parsed as ‘(1 foo 2) foo 3’. By raising the precedence of the lefthand expression instead, we can create a right-associative operator.

See Composition Basics, for a table of precedences of the standard Calc operators. For the precedences of operators in other language modes, look in the Calc source file calc-lang.el.


***** Advanced Syntax Patterns

To match a function with a variable number of arguments, you could write

foo ( # ) := myfunc(#1)
foo ( # , # ) := myfunc(#1,#2)
foo ( # , # , # ) := myfunc(#1,#2,#3)
but this isn’t very elegant. To match variable numbers of items, Calc uses some notations inspired regular expressions and the “extended BNF” style used by some language designers.

foo ( { # }*, ) := apply(myfunc,#1)
The token ‘{’ introduces a repeated or optional portion. One of the three tokens ‘}*’, ‘}+’, or ‘}?’ ends the portion. These will match zero or more, one or more, or zero or one copies of the enclosed pattern, respectively. In addition, ‘}*’ and ‘}+’ can be followed by a separator token (with no space in between, as shown above). Thus ‘{ # }*,’ matches nothing, or one expression, or several expressions separated by commas.

A complete ‘{ ... }’ item matches as a vector of the items that matched inside it. For example, the above rule will match ‘foo(1,2,3)’ to get ‘apply(myfunc,[1,2,3])’. The Calc apply function takes a function name and a vector of arguments and builds a call to the function with those arguments, so the net result is the formula ‘myfunc(1,2,3)’.

If the body of a ‘{ ... }’ contains several ‘#’s (or nested ‘{ ... }’ constructs), then the items will be strung together into the resulting vector. If the body does not contain anything but literal tokens, the result will always be an empty vector.

foo ( { # , # }+, ) := bar(#1)
foo ( { { # }*, }*; ) := matrix(#1)
will parse ‘foo(1, 2, 3, 4)’ as ‘bar([1, 2, 3, 4])’, and ‘foo(1, 2; 3, 4)’ as ‘matrix([[1, 2], [3, 4]])’. Also, after some thought it’s easy to see how this pair of rules will parse ‘foo(1, 2, 3)’ as ‘matrix([[1, 2, 3]])’, since the first rule will only match an even number of arguments. The rule

foo ( # { , # , # }? ) := bar(#1,#2)
will parse ‘foo(2,3,4)’ as ‘bar(2,[3,4])’, and ‘foo(2)’ as ‘bar(2,[])’.

The notation ‘{ ... }?.’ (note the trailing period) works just the same as regular ‘{ ... }?’, except that it does not count as an argument; the following two rules are equivalent:

foo ( # , { also }? # ) := bar(#1,#3)
foo ( # , { also }?. # ) := bar(#1,#2)
Note that in the first case the optional text counts as ‘#2’, which will always be an empty vector, but in the second case no empty vector is produced.

Another variant is ‘{ ... }?$’, which means the body is optional only at the end of the input formula. All built-in syntax rules in Calc use this for closing delimiters, so that during algebraic entry you can type [sqrt(2), sqrt(3 RET, omitting the closing parenthesis and bracket. Calc does this automatically for trailing ‘)’, ‘]’, and ‘>’ tokens in syntax rules, but you can use ‘{ ... }?$’ explicitly to get this effect with any token (such as ‘"}"’ or ‘end’). Like ‘{ ... }?.’, this notation does not count as an argument. Conversely, you can use quotes, as in ‘")"’, to prevent a closing-delimiter token from being automatically treated as optional.

Calc’s parser does not have full backtracking, which means some patterns will not work as you might expect:

foo ( { # , }? # , # ) := bar(#1,#2,#3)
Here we are trying to make the first argument optional, so that ‘foo(2,3)’ parses as ‘bar([],2,3)’. Unfortunately, Calc first tries to match ‘2,’ against the optional part of the pattern, finds a match, and so goes ahead to match the rest of the pattern. Later on it will fail to match the second comma, but it doesn’t know how to go back and try the other alternative at that point. One way to get around this would be to use two rules:

foo ( # , # , # ) := bar([#1],#2,#3)
foo ( # , # ) := bar([],#1,#2)
More precisely, when Calc wants to match an optional or repeated part of a pattern, it scans forward attempting to match that part. If it reaches the end of the optional part without failing, it “finalizes” its choice and proceeds. If it fails, though, it backs up and tries the other alternative. Thus Calc has “partial” backtracking. A fully backtracking parser would go on to make sure the rest of the pattern matched before finalizing the choice.


***** Conditional Syntax Rules

It is possible to attach a condition to a syntax rule. For example, the rules

foo ( # ) := ifoo(#1) :: integer(#1)
foo ( # ) := gfoo(#1)
will parse ‘foo(3)’ as ‘ifoo(3)’, but will parse ‘foo(3.5)’ and ‘foo(x)’ as calls to gfoo. Any number of conditions may be attached; all must be true for the rule to succeed. A condition is “true” if it evaluates to a nonzero number. See Logical Operations, for a list of Calc functions like integer that perform logical tests.

The exact sequence of events is as follows: When Calc tries a rule, it first matches the pattern as usual. It then substitutes ‘#1’, ‘#2’, etc., in the conditions, if any. Next, the conditions are simplified and evaluated in order from left to right, using the algebraic simplifications (see Simplifying Formulas). Each result is true if it is a nonzero number, or an expression that can be proven to be nonzero (see Declarations). If the results of all conditions are true, the expression (such as ‘ifoo(#1)’) has its ‘#’s substituted, and that is the result of the parse. If the result of any condition is false, Calc goes on to try the next rule in the syntax table.

Syntax rules also support let conditions, which operate in exactly the same way as they do in algebraic rewrite rules. See Other Features of Rewrite Rules, for details. A let condition is always true, but as a side effect it defines a variable which can be used in later conditions, and also in the expression after the ‘:=’ sign:

foo ( # ) := hifoo(x) :: let(x := #1 + 0.5) :: dnumint(x)
The dnumint function tests if a value is numerically an integer, i.e., either a true integer or an integer-valued float. This rule will parse foo with a half-integer argument, like ‘foo(3.5)’, to a call like ‘hifoo(4.)’.

The lefthand side of a syntax rule let must be a simple variable, not the arbitrary pattern that is allowed in rewrite rules.

The matches function is also treated specially in syntax rule conditions (again, in the same way as in rewrite rules). See Matching Commands. If the matching pattern contains meta-variables, then those meta-variables may be used in later conditions and in the result expression. The arguments to matches are not evaluated in this situation.

sum ( # , # ) := sum(#1,a,b,c) :: matches(#2, a=[b..c])
This is another way to implement the Maple mode sum notation. In this approach, we allow ‘#2’ to equal the whole expression ‘i=1..10’. Then, we use matches to break it apart into its components. If the expression turns out not to match the pattern, the syntax rule will fail. Note that Z S always uses Calc’s Normal language mode for editing expressions in syntax rules, so we must use regular Calc notation for the interval ‘[b..c]’ that will correspond to the Maple mode interval ‘1..10’.


*** The Modes Variable

The m g (calc-get-modes) command pushes onto the stack a vector of numbers that describes the various mode settings that are in effect. With a numeric prefix argument, it pushes only the nth mode, i.e., the nth element of this vector. Keyboard macros can use the m g command to modify their behavior based on the current mode settings.

The modes vector is also available in the special variable Modes. In other words, m g is like s r Modes RET. It will not work to store into this variable; in fact, if you do, Modes will cease to track the current modes. (The m g command will continue to work, however.)

In general, each number in this vector is suitable as a numeric prefix argument to the associated mode-setting command. (Recall that the ~ key takes a number from the stack and gives it as a numeric prefix to the next command.)

The elements of the modes vector are as follows:

Current precision. Default is 12; associated command is p.
Binary word size. Default is 32; associated command is b w.
Stack size (not counting the value about to be pushed by m g). This is zero if m g is executed with an empty stack.
Number radix. Default is 10; command is d r.
Floating-point format. This is the number of digits, plus the constant 0 for normal notation, 10000 for scientific notation, 20000 for engineering notation, or 30000 for fixed-point notation. These codes are acceptable as prefix arguments to the d n command, but note that this may lose information: For example, d s and C-u 12 d s have similar (but not quite identical) effects if the current precision is 12, but they both produce a code of 10012, which will be treated by d n as C-u 12 d s. If the precision then changes, the float format will still be frozen at 12 significant figures.
Angular mode. Default is 1 (degrees). Other values are 2 (radians) and 3 (HMS). The m d command accepts these prefixes.
Symbolic mode. Value is 0 or 1; default is 0. Command is m s.
Fraction mode. Value is 0 or 1; default is 0. Command is m f.
Polar mode. Value is 0 (rectangular) or 1 (polar); default is 0. Command is m p.
Matrix/Scalar mode. Default value is -1. Value is 0 for Scalar mode, -2 for Matrix mode, -3 for square Matrix mode, or N for NxN Matrix mode. Command is m v.
Simplification mode. Default is 1. Value is -1 for off (m O), 0 for m N, 2 for m B, 3 for m A, 4 for m E, or 5 for m U. The m D command accepts these prefixes.
Infinite mode. Default is -1 (off). Value is 1 if the mode is on, or 0 if the mode is on with positive zeros. Command is m i.
For example, the sequence M-1 m g RET 2 + ~ p increases the precision by two, leaving a copy of the old precision on the stack. Later, ~ p will restore the original precision using that stack value. (This sequence might be especially useful inside a keyboard macro.)

As another example, M-3 m g 1 - ~ DEL deletes all but the oldest (bottommost) stack entry.

Yet another example: The HP-48 “round” command rounds a number to the current displayed precision. You could roughly emulate this in Calc with the sequence M-5 m g 10000 % ~ c c. (This would not work for fixed-point mode, but it wouldn’t be hard to do a full emulation with the help of the Z [ and Z ] programming commands. See Conditionals in Keyboard Macros.)


*** The Calc Mode Line

This section is a summary of all symbols that can appear on the Calc mode line, the highlighted bar that appears under the Calc stack window (or under an editing window in Embedded mode).

The basic mode line format is:

--%*-Calc: 12 Deg other modes       (Calculator)
The ‘%*’ indicates that the buffer is “read-only”; it shows that regular Emacs commands are not allowed to edit the stack buffer as if it were text.

The word ‘Calc:’ changes to ‘CalcEmbed:’ if Embedded mode is enabled. The words after this describe the various Calc modes that are in effect.

The first mode is always the current precision, an integer. The second mode is always the angular mode, either Deg, Rad, or Hms.

Here is a complete list of the remaining symbols that can appear on the mode line:

Alg
Algebraic mode (m a; see Algebraic Entry).

Alg[(
Incomplete algebraic mode (C-u m a).

Alg*
Total algebraic mode (m t).

Symb
Symbolic mode (m s; see Symbolic Mode).

Matrix
Matrix mode (m v; see Matrix and Scalar Modes).

Matrixn
Dimensioned Matrix mode (C-u n m v; see Matrix and Scalar Modes).

SqMatrix
Square Matrix mode (C-u m v; see Matrix and Scalar Modes).

Scalar
Scalar mode (m v; see Matrix and Scalar Modes).

Polar
Polar complex mode (m p; see Polar Mode).

Frac
Fraction mode (m f; see Fraction Mode).

Inf
Infinite mode (m i; see Infinite Mode).

+Inf
Positive Infinite mode (C-u 0 m i).

NoSimp
Default simplifications off (m O; see Simplification Modes).

NumSimp
Default simplifications for numeric arguments only (m N).

BinSimpw
Binary-integer simplification mode; word size w (m B, b w).

BasicSimp
Basic simplification mode (m I).

ExtSimp
Extended algebraic simplification mode (m E).

UnitSimp
Units simplification mode (m U).

Bin
Current radix is 2 (d 2; see Radix Modes).

Oct
Current radix is 8 (d 8).

Hex
Current radix is 16 (d 6).

Radixn
Current radix is n (d r).

Zero
Leading zeros (d z; see Radix Modes).

Big
Big language mode (d B; see Normal Language Modes).

Flat
One-line normal language mode (d O).

Unform
Unformatted language mode (d U).

C
C language mode (d C; see C, FORTRAN, and Pascal Modes).

Pascal
Pascal language mode (d P).

Fortran
FORTRAN language mode (d F).

TeX
TeX language mode (d T; see TeX and LaTeX Language Modes).

LaTeX
LaTeX language mode (d L; see TeX and LaTeX Language Modes).

Eqn
Eqn language mode (d E; see Eqn Language Mode).

Math
Mathematica language mode (d M; see Mathematica Language Mode).

Maple
Maple language mode (d W; see Maple Language Mode).

Normn
Normal float mode with n digits (d n; see Float Formats).

Fixn
Fixed point mode with n digits after the point (d f).

Sci
Scientific notation mode (d s).

Scin
Scientific notation with n digits (d s).

Eng
Engineering notation mode (d e).

Engn
Engineering notation with n digits (d e).

Leftn
Left-justified display indented by n (d <; see Justification).

Right
Right-justified display (d >).

Rightn
Right-justified display with width n (d >).

Center
Centered display (d =).

Centern
Centered display with center column n (d =).

Widn
Line breaking with width n (d b; see Normal Language Modes).

Wide
No line breaking (d b).

Break
Selections show deep structure (j b; see Making Selections).

Save
Record modes in ~/.emacs.d/calc.el (m R; see General Mode Commands).

Local
Record modes in Embedded buffer (m R).

LocEdit
Record modes as editing-only in Embedded buffer (m R).

LocPerm
Record modes as permanent-only in Embedded buffer (m R).

Global
Record modes as global in Embedded buffer (m R).

Manual
Automatic recomputation turned off (m C; see Automatic Recomputation).

Graph
GNUPLOT process is alive in background (see Graphics).

Sel
Top-of-stack has a selection (Embedded only; see Making Selections).

Dirty
The stack display may not be up-to-date (see Display Modes).

Inv
“Inverse” prefix was pressed (I; see Inverse and Hyperbolic Flags).

Hyp
“Hyperbolic” prefix was pressed (H).

Keep
“Keep-arguments” prefix was pressed (K).

Narrow
Stack is truncated (d t; see Truncating the Stack).

In addition, the symbols Active and ~Active can appear as minor modes on an Embedded buffer’s mode line. See Embedded Mode.


** Arithmetic Functions

This chapter describes the Calc commands for doing simple calculations on numbers, such as addition, absolute value, and square roots. These commands work by removing the top one or two values from the stack, performing the desired operation, and pushing the result back onto the stack. If the operation cannot be performed, the result pushed is a formula instead of a number, such as ‘2/0’ (because division by zero is invalid) or ‘sqrt(x)’ (because the argument ‘x’ is a formula).

Most of the commands described here can be invoked by a single keystroke. Some of the more obscure ones are two-letter sequences beginning with the f (“functions”) prefix key.

See Numeric Prefix Arguments, for a discussion of the effect of numeric prefix arguments on commands in this chapter which do not otherwise interpret a prefix argument.

*** Basic Arithmetic

The + (calc-plus) command adds two numbers. The numbers may be any of the standard Calc data types. The resulting sum is pushed back onto the stack.

If both arguments of + are vectors or matrices (of matching dimensions), the result is a vector or matrix sum. If one argument is a vector and the other a scalar (i.e., a non-vector), the scalar is added to each of the elements of the vector to form a new vector. If the scalar is not a number, the operation is left in symbolic form: Suppose you added ‘x’ to the vector ‘[1,2]’. You may want the result ‘[1+x,2+x]’, or you may plan to substitute a 2-vector for ‘x’ in the future. Since the Calculator can’t tell which interpretation you want, it makes the safest assumption. See Reducing and Mapping Vectors, for a way to add ‘x’ to every element of a vector.

If either argument of + is a complex number, the result will in general be complex. If one argument is in rectangular form and the other polar, the current Polar mode determines the form of the result. If Symbolic mode is enabled, the sum may be left as a formula if the necessary conversions for polar addition are non-trivial.

If both arguments of + are HMS forms, the forms are added according to the usual conventions of hours-minutes-seconds notation. If one argument is an HMS form and the other is a number, that number is converted from degrees or radians (depending on the current Angular mode) to HMS format and then the two HMS forms are added.

If one argument of + is a date form, the other can be either a real number, which advances the date by a certain number of days, or an HMS form, which advances the date by a certain amount of time. Subtracting two date forms yields the number of days between them. Adding two date forms is meaningless, but Calc interprets it as the subtraction of one date form and the negative of the other. (The negative of a date form can be understood by remembering that dates are stored as the number of days before or after Jan 1, 1 AD.)

If both arguments of + are error forms, the result is an error form with an appropriately computed standard deviation. If one argument is an error form and the other is a number, the number is taken to have zero error. Error forms may have symbolic formulas as their mean and/or error parts; adding these will produce a symbolic error form result. However, adding an error form to a plain symbolic formula (as in ‘(a +/- b) + c’) will not work, for the same reasons just mentioned for vectors. Instead you must write ‘(a +/- b) + (c +/- 0)’.

If both arguments of + are modulo forms with equal values of ‘M’, or if one argument is a modulo form and the other a plain number, the result is a modulo form which represents the sum, modulo ‘M’, of the two values.

If both arguments of + are intervals, the result is an interval which describes all possible sums of the possible input values. If one argument is a plain number, it is treated as the interval ‘[x .. x]’.

If one argument of + is an infinity and the other is not, the result is that same infinity. If both arguments are infinite and in the same direction, the result is the same infinity, but if they are infinite in different directions the result is nan.

The - (calc-minus) command subtracts two values. The top number on the stack is subtracted from the one behind it, so that the computation 5 RET 2 - produces 3, not -3. All options available for + are available for - as well.

The * (calc-times) command multiplies two numbers. If one argument is a vector and the other a scalar, the scalar is multiplied by the elements of the vector to produce a new vector. If both arguments are vectors, the interpretation depends on the dimensions of the vectors: If both arguments are matrices, a matrix multiplication is done. If one argument is a matrix and the other a plain vector, the vector is interpreted as a row vector or column vector, whichever is dimensionally correct. If both arguments are plain vectors, the result is a single scalar number which is the dot product of the two vectors.

If one argument of * is an HMS form and the other a number, the HMS form is multiplied by that amount. It is an error to multiply two HMS forms together, or to attempt any multiplication involving date forms. Error forms, modulo forms, and intervals can be multiplied; see the comments for addition of those forms. When two error forms or intervals are multiplied they are considered to be statistically independent; thus, ‘[-2 .. 3] * [-2 .. 3]’ is ‘[-6 .. 9]’, whereas ‘[-2 .. 3] ^ 2’ is ‘[0 .. 9]’.

The / (calc-divide) command divides two numbers.

When combining multiplication and division in an algebraic formula, it is good style to use parentheses to distinguish between possible interpretations; the expression ‘a/b*c’ should be written ‘(a/b)*c’ or ‘a/(b*c)’, as appropriate. Without the parentheses, Calc will interpret ‘a/b*c’ as ‘a/(b*c)’, since in algebraic entry Calc gives division a lower precedence than multiplication. (This is not standard across all computer languages, and Calc may change the precedence depending on the language mode being used. See Language Modes.) This default ordering can be changed by setting the customizable variable calc-multiplication-has-precedence to nil (see Customizing Calc); this will give multiplication and division equal precedences. Note that Calc’s default choice of precedence allows ‘a b / c d’ to be used as a shortcut for

a b
---.
c d
When dividing a scalar ‘B’ by a square matrix ‘A’, the computation performed is ‘B’ times the inverse of ‘A’. This also occurs if ‘B’ is itself a vector or matrix, in which case the effect is to solve the set of linear equations represented by ‘B’. If ‘B’ is a matrix with the same number of rows as ‘A’, or a plain vector (which is interpreted here as a column vector), then the equation ‘A X = B’ is solved for the vector or matrix ‘X’. Otherwise, if ‘B’ is a non-square matrix with the same number of columns as ‘A’, the equation ‘X A = B’ is solved. If you wish a vector ‘B’ to be interpreted as a row vector to be solved as ‘X A = B’, make it into a one-row matrix with C-u 1 v p first. To force a left-handed solution with a square matrix ‘B’, transpose ‘A’ and ‘B’ before dividing, then transpose the result.

HMS forms can be divided by real numbers or by other HMS forms. Error forms can be divided in any combination of ways. Modulo forms where both values and the modulo are integers can be divided to get an integer modulo form result. Intervals can be divided; dividing by an interval that encompasses zero or has zero as a limit will result in an infinite interval.

The ^ (calc-power) command raises a number to a power. If the power is an integer, an exact result is computed using repeated multiplications. For non-integer powers, Calc uses Newton’s method or logarithms and exponentials. Square matrices can be raised to integer powers. If either argument is an error (or interval or modulo) form, the result is also an error (or interval or modulo) form.

If you press the I (inverse) key first, the I ^ command computes an Nth root: 125 RET 3 I ^ computes the number 5. (This is entirely equivalent to 125 RET 1:3 ^.)

The \ (calc-idiv) command divides two numbers on the stack to produce an integer result. It is equivalent to dividing with /, then rounding down with F (calc-floor), only a bit more convenient and efficient. Also, since it is an all-integer operation when the arguments are integers, it avoids problems that / F would have with floating-point roundoff.

The % (calc-mod) command performs a “modulo” (or “remainder”) operation. Mathematically, ‘a%b = a - (a\b)*b’, and is defined for all real numbers ‘a’ and ‘b’ (except ‘b=0’). For positive ‘b’, the result will always be between 0 (inclusive) and ‘b’ (exclusive). Modulo does not work for HMS forms and error forms. If ‘a’ is a modulo form, its modulo is changed to ‘b’, which must be positive real number.

The : (calc-fdiv) [fdiv] command divides the two integers on the top of the stack to produce a fractional result. This is a convenient shorthand for enabling Fraction mode (with m f) temporarily and using ‘/’. Note that during numeric entry the : key is interpreted as a fraction separator, so to divide 8 by 6 you would have to type 8 RET 6 RET :. (Of course, in this case, it would be much easier simply to enter the fraction directly as 8:6 RET!)

The n (calc-change-sign) command negates the number on the top of the stack. It works on numbers, vectors and matrices, HMS forms, date forms, error forms, intervals, and modulo forms.

The A (calc-abs) [abs] command computes the absolute value of a number. The result of abs is always a nonnegative real number: With a complex argument, it computes the complex magnitude. With a vector or matrix argument, it computes the Frobenius norm, i.e., the square root of the sum of the squares of the absolute values of the elements. The absolute value of an error form is defined by replacing the mean part with its absolute value and leaving the error part the same. The absolute value of a modulo form is undefined. The absolute value of an interval is defined in the obvious way.

The f A (calc-abssqr) [abssqr] command computes the absolute value squared of a number, vector or matrix, or error form.

The f s (calc-sign) [sign] command returns 1 if its argument is positive, -1 if its argument is negative, or 0 if its argument is zero. In algebraic form, you can also write ‘sign(a,x)’ which evaluates to ‘x * sign(a)’, i.e., either ‘x’, ‘-x’, or zero depending on the sign of ‘a’.

The & (calc-inv) [inv] command computes the reciprocal of a number, i.e., ‘1 / x’. Operating on a square matrix, it computes the inverse of that matrix.

The Q (calc-sqrt) [sqrt] command computes the square root of a number. For a negative real argument, the result will be a complex number whose form is determined by the current Polar mode.

The f h (calc-hypot) [hypot] command computes the square root of the sum of the squares of two numbers. That is, ‘hypot(a,b)’ is the length of the hypotenuse of a right triangle with sides ‘a’ and ‘b’. If the arguments are complex numbers, their squared magnitudes are used.

The f Q (calc-isqrt) [isqrt] command computes the integer square root of an integer. This is the true square root of the number, rounded down to an integer. For example, ‘isqrt(10)’ produces 3. Note that, like \ [idiv], this uses exact integer arithmetic throughout to avoid roundoff problems. If the input is a floating-point number or other non-integer value, this is exactly the same as ‘floor(sqrt(x))’.

The f n (calc-min) [min] and f x (calc-max) [max] commands take the minimum or maximum of two real numbers, respectively. These commands also work on HMS forms, date forms, intervals, and infinities. (In algebraic expressions, these functions take any number of arguments and return the maximum or minimum among all the arguments.)

The f M (calc-mant-part) [mant] function extracts the “mantissa” part ‘m’ of its floating-point argument; f X (calc-xpon-part) [xpon] extracts the “exponent” part ‘e’. The original number is equal to ‘m * 10^e’, where ‘m’ is in the interval ‘[1.0 .. 10.0)’ except that ‘m=e=0’ if the original number is zero. For integers and fractions, mant returns the number unchanged and xpon returns zero. The v u (calc-unpack) command can also be used to “unpack” a floating-point number; this produces an integer mantissa and exponent, with the constraint that the mantissa is not a multiple of ten (again except for the ‘m=e=0’ case).

The f S (calc-scale-float) [scf] function scales a number by a given power of ten. Thus, ‘scf(mant(x), xpon(x)) = x’ for any real ‘x’. The second argument must be an integer, but the first may actually be any numeric value. For example, ‘scf(5,-2) = 0.05’ or ‘1:20’ depending on the current Fraction mode.

The f [ (calc-decrement) [decr] and f ] (calc-increment) [incr] functions decrease or increase a number by one unit. For integers, the effect is obvious. For floating-point numbers, the change is by one unit in the last place. For example, incrementing ‘12.3456’ when the current precision is 6 digits yields ‘12.3457’. If the current precision had been 8 digits, the result would have been ‘12.345601’. Incrementing ‘0.0’ produces ‘10^-p’, where ‘p’ is the current precision. These operations are defined only on integers and floats. With numeric prefix arguments, they change the number by ‘n’ units.

Note that incrementing followed by decrementing, or vice-versa, will almost but not quite always cancel out. Suppose the precision is 6 digits and the number ‘9.99999’ is on the stack. Incrementing will produce ‘10.0000’; decrementing will produce ‘9.9999’. One digit has been dropped. This is an unavoidable consequence of the way floating-point numbers work.

Incrementing a date/time form adjusts it by a certain number of seconds. Incrementing a pure date form adjusts it by a certain number of days.


*** Integer Truncation

There are four commands for truncating a real number to an integer, differing mainly in their treatment of negative numbers. All of these commands have the property that if the argument is an integer, the result is the same integer. An integer-valued floating-point argument is converted to integer form.

If you press H (calc-hyperbolic) first, the result will be expressed as an integer-valued floating-point number.

The F (calc-floor) [floor or ffloor] command truncates a real number to the next lower integer, i.e., toward minus infinity. Thus 3.6 F produces 3, but _3.6 F produces -4.

The I F (calc-ceiling) [ceil or fceil] command truncates toward positive infinity. Thus 3.6 I F produces 4, and _3.6 I F produces -3.

The R (calc-round) [round or fround] command rounds to the nearest integer. When the fractional part is .5 exactly, this command rounds away from zero. (All other rounding in the Calculator uses this convention as well.) Thus 3.5 R produces 4 but 3.4 R produces 3; _3.5 R produces -4.

The I R (calc-trunc) [trunc or ftrunc] command truncates toward zero. In other words, it “chops off” everything after the decimal point. Thus 3.6 I R produces 3 and _3.6 I R produces -3.

These functions may not be applied meaningfully to error forms, but they do work for intervals. As a convenience, applying floor to a modulo form floors the value part of the form. Applied to a vector, these functions operate on all elements of the vector one by one. Applied to a date form, they operate on the internal numerical representation of dates, converting a date/time form into a pure date.

There are two more rounding functions which can only be entered in algebraic notation. The roundu function is like round except that it rounds up, toward plus infinity, when the fractional part is .5. This distinction matters only for negative arguments. Also, rounde rounds to an even number in the case of a tie, rounding up or down as necessary. For example, ‘rounde(3.5)’ and ‘rounde(4.5)’ both return 4, but ‘rounde(5.5)’ returns 6. The advantage of round-to-even is that the net error due to rounding after a long calculation tends to cancel out to zero. An important subtle point here is that the number being fed to rounde will already have been rounded to the current precision before rounde begins. For example, ‘rounde(2.500001)’ with a current precision of 6 will incorrectly, or at least surprisingly, yield 2 because the argument will first have been rounded down to ‘2.5’ (which rounde sees as an exact tie between 2 and 3).

Each of these functions, when written in algebraic formulas, allows a second argument which specifies the number of digits after the decimal point to keep. For example, ‘round(123.4567, 2)’ will produce the answer 123.46, and ‘round(123.4567, -1)’ will produce 120 (i.e., the cutoff is one digit to the left of the decimal point). A second argument of zero is equivalent to no second argument at all.

To compute the fractional part of a number (i.e., the amount which, when added to ‘floor(n)’, will produce n) just take n modulo 1 using the % command.

Note also the \ (integer quotient), f I (integer logarithm), and f Q (integer square root) commands, which are analogous to /, B, and Q, respectively, except that they take integer arguments and return the result rounded down to an integer.


*** Complex Number Functions

The J (calc-conj) [conj] command computes the complex conjugate of a number. For complex number ‘a+bi’, the complex conjugate is ‘a-bi’. If the argument is a real number, this command leaves it the same. If the argument is a vector or matrix, this command replaces each element by its complex conjugate.

The G (calc-argument) [arg] command computes the “argument” or polar angle of a complex number. For a number in polar notation, this is simply the second component of the pair ‘(r;theta)’. The result is expressed according to the current angular mode and will be in the range -180 degrees (exclusive) to +180 degrees (inclusive), or the equivalent range in radians.

The calc-imaginary command multiplies the number on the top of the stack by the imaginary number ‘i = (0,1)’. This command is not normally bound to a key in Calc, but it is available on the IMAG button in Keypad mode.

The f r (calc-re) [re] command replaces a complex number by its real part. This command has no effect on real numbers. (As an added convenience, re applied to a modulo form extracts the value part.)

The f i (calc-im) [im] command replaces a complex number by its imaginary part; real numbers are converted to zero. With a vector or matrix argument, these functions operate element-wise.

The v p (calc-pack) command can pack the top two numbers on the stack into a composite object such as a complex number. With a prefix argument of -1, it produces a rectangular complex number; with an argument of -2, it produces a polar complex number. (Also, see Building Vectors.)

The v u (calc-unpack) command takes the complex number (or other composite object) on the top of the stack and unpacks it into its separate components.


*** Conversions

The commands described in this section convert numbers from one form to another; they are two-key sequences beginning with the letter c.

The c f (calc-float) [pfloat] command converts the number on the top of the stack to floating-point form. For example, ‘23’ is converted to ‘23.0’, ‘3:2’ is converted to ‘1.5’, and ‘2.3’ is left the same. If the value is a composite object such as a complex number or vector, each of the components is converted to floating-point. If the value is a formula, all numbers in the formula are converted to floating-point. Note that depending on the current floating-point precision, conversion to floating-point format may lose information.

As a special exception, integers which appear as powers or subscripts are not floated by c f. If you really want to float a power, you can use a j s command to select the power followed by c f. Because c f cannot examine the formula outside of the selection, it does not notice that the thing being floated is a power. See Selecting Sub-Formulas.

The normal c f command is “pervasive” in the sense that it applies to all numbers throughout the formula. The pfloat algebraic function never stays around in a formula; ‘pfloat(a + 1)’ changes to ‘a + 1.0’ as soon as it is evaluated.

With the Hyperbolic flag, H c f [float] operates only on the number or vector of numbers at the top level of its argument. Thus, ‘float(1)’ is 1.0, but ‘float(a + 1)’ is left unevaluated because its argument is not a number.

You should use H c f if you wish to guarantee that the final value, once all the variables have been assigned, is a float; you would use c f if you wish to do the conversion on the numbers that appear right now.

The c F (calc-fraction) [pfrac] command converts a floating-point number into a fractional approximation. By default, it produces a fraction whose decimal representation is the same as the input number, to within the current precision. You can also give a numeric prefix argument to specify a tolerance, either directly, or, if the prefix argument is zero, by using the number on top of the stack as the tolerance. If the tolerance is a positive integer, the fraction is correct to within that many significant figures. If the tolerance is a non-positive integer, it specifies how many digits fewer than the current precision to use. If the tolerance is a floating-point number, the fraction is correct to within that absolute amount.

The pfrac function is pervasive, like pfloat. There is also a non-pervasive version, H c F [frac], which is analogous to H c f discussed above.

The c d (calc-to-degrees) [deg] command converts a number into degrees form. The value on the top of the stack may be an HMS form (interpreted as degrees-minutes-seconds), or a real number which will be interpreted in radians regardless of the current angular mode.

The c r (calc-to-radians) [rad] command converts an HMS form or angle in degrees into an angle in radians.

The c h (calc-to-hms) [hms] command converts a real number, interpreted according to the current angular mode, to an HMS form describing the same angle. In algebraic notation, the hms function also accepts three arguments: ‘hms(h, m, s)’. (The three-argument version is independent of the current angular mode.)

The calc-from-hms command converts the HMS form on the top of the stack into a real number according to the current angular mode.

The c p (calc-polar) command converts the complex number on the top of the stack from polar to rectangular form, or from rectangular to polar form, whichever is appropriate. Real numbers are left the same. This command is equivalent to the rect or polar functions in algebraic formulas, depending on the direction of conversion. (It uses polar, except that if the argument is already a polar complex number, it uses rect instead. The I c p command always uses rect.)

The c c (calc-clean) [pclean] command “cleans” the number on the top of the stack. Floating point numbers are re-rounded according to the current precision. Polar numbers whose angular components have strayed from the -180 to +180 degree range are normalized. (Note that results will be undesirable if the current angular mode is different from the one under which the number was produced!) Integers and fractions are generally unaffected by this operation. Vectors and formulas are cleaned by cleaning each component number (i.e., pervasively).

If the simplification mode is set below basic simplification, it is raised for the purposes of this command. Thus, c c applies the basic simplifications even if their automatic application is disabled. See Simplification Modes.

A numeric prefix argument to c c sets the floating-point precision to that value for the duration of the command. A positive prefix (of at least 3) sets the precision to the specified value; a negative or zero prefix decreases the precision by the specified amount.

The keystroke sequences c 0 through c 9 are equivalent to c c with the corresponding negative prefix argument. If roundoff errors have changed 2.0 into 1.999999, typing c 1 to clip off one decimal place often conveniently does the trick.

The c c command with a numeric prefix argument, and the c 0 through c 9 commands, also “clip” very small floating-point numbers to zero. If the exponent is less than or equal to the negative of the specified precision, the number is changed to 0.0. For example, if the current precision is 12, then c 2 changes the vector ‘[1e-8, 1e-9, 1e-10, 1e-11]’ to ‘[1e-8, 1e-9, 0, 0]’. Numbers this small generally arise from roundoff noise.

If the numbers you are using really are legitimately this small, you should avoid using the c 0 through c 9 commands. (The plain c c command rounds to the current precision but does not clip small numbers.)

One more property of c 0 through c 9, and of c c with a prefix argument, is that integer-valued floats are converted to plain integers, so that c 1 on ‘[1., 1.5, 2., 2.5, 3.]’ produces ‘[1, 1.5, 2, 2.5, 3]’. This is not done for huge numbers (‘1e100’ is technically an integer-valued float, but you wouldn’t want it automatically converted to a 100-digit integer).

With the Hyperbolic flag, H c c and H c 0 through H c 9 operate non-pervasively [clean].


*** Date Arithmetic

The commands described in this section perform various conversions and calculations involving date forms (see Date Forms). They use the t (for time/date) prefix key followed by shifted letters.

The simplest date arithmetic is done using the regular + and - commands. In particular, adding a number to a date form advances the date form by a certain number of days; adding an HMS form to a date form advances the date by a certain amount of time; and subtracting two date forms produces a difference measured in days. The commands described here provide additional, more specialized operations on dates.

Many of these commands accept a numeric prefix argument; if you give plain C-u as the prefix, these commands will instead take the additional argument from the top of the stack.

**** Date Conversions

The t D (calc-date) [date] command converts a date form into a number, measured in days since Jan 1, 1 AD. The result will be an integer if date is a pure date form, or a fraction or float if date is a date/time form. Or, if its argument is a number, it converts this number into a date form.

With a numeric prefix argument, t D takes that many objects (up to six) from the top of the stack and interprets them in one of the following ways:

The ‘date(year, month, day)’ function builds a pure date form out of the specified year, month, and day, which must all be integers. Year is a year number, such as 1991 (not the same as 91!). Month must be an integer in the range 1 to 12; day must be in the range 1 to 31. If the specified month has fewer than 31 days and day is too large, the equivalent day in the following month will be used.

The ‘date(month, day)’ function builds a pure date form using the current year, as determined by the real-time clock.

The ‘date(year, month, day, hms)’ function builds a date/time form using an hms form.

The ‘date(year, month, day, hour, minute, second)’ function builds a date/time form. hour should be an integer in the range 0 to 23; minute should be an integer in the range 0 to 59; second should be any real number in the range ‘[0 .. 60)’. The last two arguments default to zero if omitted.

The t J (calc-julian) [julian] command converts a date form into a Julian day count, which is the number of days since noon (GMT) on Jan 1, 4713 BC. A pure date is converted to an integer Julian count representing noon of that day. A date/time form is converted to an exact floating-point Julian count, adjusted to interpret the date form in the current time zone but the Julian day count in Greenwich Mean Time. A numeric prefix argument allows you to specify the time zone; see Time Zones. Use a prefix of zero to suppress the time zone adjustment. Note that pure date forms are never time-zone adjusted.

This command can also do the opposite conversion, from a Julian day count (either an integer day, or a floating-point day and time in the GMT zone), into a pure date form or a date/time form in the current or specified time zone.

The t U (calc-unix-time) [unixtime] command converts a date form into a Unix time value, which is the number of seconds since midnight on Jan 1, 1970, or vice-versa. The numeric result will be an integer if the current precision is 12 or less; for higher precision, the result may be a float with (precision-12) digits after the decimal. Just as for t J, the numeric time is interpreted in the GMT time zone and the date form is interpreted in the current or specified zone. Some systems use Unix-like numbering but with the local time zone; give a prefix of zero to suppress the adjustment if so.

The t C (calc-convert-time-zones) [tzconv] command converts a date form from one time zone to another. You are prompted for each time zone name in turn; you can answer with any suitable Calc time zone expression (see Time Zones). If you answer either prompt with a blank line, the local time zone is used for that prompt. You can also answer the first prompt with $ to take the two time zone names from the stack (and the date to be converted from the third stack level).


**** Date Functions

The t N (calc-now) [now] command pushes the current date and time on the stack as a date form. The time is reported in terms of the specified time zone; with no numeric prefix argument, t N reports for the current time zone.

The t P (calc-date-part) command extracts one part of a date form. The prefix argument specifies the part; with no argument, this command prompts for a part code from 1 to 9. The various part codes are described in the following paragraphs.

The M-1 t P [year] function extracts the year number from a date form as an integer, e.g., 1991. This and the following functions will also accept a real number for an argument, which is interpreted as a standard Calc day number. Note that this function will never return zero, since the year 1 BC immediately precedes the year 1 AD.

The M-2 t P [month] function extracts the month number from a date form as an integer in the range 1 to 12.

The M-3 t P [day] function extracts the day number from a date form as an integer in the range 1 to 31.

The M-4 t P [hour] function extracts the hour from a date form as an integer in the range 0 (midnight) to 23. Note that 24-hour time is always used. This returns zero for a pure date form. This function (and the following two) also accept HMS forms as input.

The M-5 t P [minute] function extracts the minute from a date form as an integer in the range 0 to 59.

The M-6 t P [second] function extracts the second from a date form. If the current precision is 12 or less, the result is an integer in the range 0 to 59. For higher precision, the result may instead be a floating-point number.

The M-7 t P [weekday] function extracts the weekday number from a date form as an integer in the range 0 (Sunday) to 6 (Saturday).

The M-8 t P [yearday] function extracts the day-of-year number from a date form as an integer in the range 1 (January 1) to 366 (December 31 of a leap year).

The M-9 t P [time] function extracts the time portion of a date form as an HMS form. This returns ‘0@ 0' 0"’ for a pure date form.

The t M (calc-new-month) [newmonth] command computes a new date form that represents the first day of the month specified by the input date. The result is always a pure date form; only the year and month numbers of the input are retained. With a numeric prefix argument n in the range from 1 to 31, t M computes the nth day of the month. (If n is greater than the actual number of days in the month, or if n is zero, the last day of the month is used.)

The t Y (calc-new-year) [newyear] command computes a new pure date form that represents the first day of the year specified by the input. The month, day, and time of the input date form are lost. With a numeric prefix argument n in the range from 1 to 366, t Y computes the nth day of the year (366 is treated as 365 in non-leap years). A prefix argument of 0 computes the last day of the year (December 31). A negative prefix argument from -1 to -12 computes the first day of the nth month of the year.

The t W (calc-new-week) [newweek] command computes a new pure date form that represents the Sunday on or before the input date. With a numeric prefix argument, it can be made to use any day of the week as the starting day; the argument must be in the range from 0 (Sunday) to 6 (Saturday). This function always subtracts between 0 and 6 days from the input date.

Here’s an example use of newweek: Find the date of the next Wednesday after a given date. Using M-3 t W or ‘newweek(d, 3)’ will give you the preceding Wednesday, so ‘newweek(d+7, 3)’ will give you the following Wednesday. A further look at the definition of newweek shows that if the input date is itself a Wednesday, this formula will return the Wednesday one week in the future. An exercise for the reader is to modify this formula to yield the same day if the input is already a Wednesday. Another interesting exercise is to preserve the time-of-day portion of the input (newweek resets the time to midnight; hint: how can newweek be defined in terms of the weekday function?).

The ‘pwday(date)’ function (not on any key) computes the day-of-month number of the Sunday on or before date. With two arguments, ‘pwday(date, day)’ computes the day number of the Sunday on or before day number day of the month specified by date. The day must be in the range from 7 to 31; if the day number is greater than the actual number of days in the month, the true number of days is used instead. Thus ‘pwday(date, 7)’ finds the first Sunday of the month, and ‘pwday(date, 31)’ finds the last Sunday of the month. With a third weekday argument, pwday can be made to look for any day of the week instead of Sunday.

The t I (calc-inc-month) [incmonth] command increases a date form by one month, or by an arbitrary number of months specified by a numeric prefix argument. The time portion, if any, of the date form stays the same. The day also stays the same, except that if the new month has fewer days the day number may be reduced to lie in the valid range. For example, ‘incmonth(<Jan 31, 1991>)’ produces ‘<Feb 28, 1991>’. Because of this, t I t I and M-2 t I do not always give the same results (‘<Mar 28, 1991>’ versus ‘<Mar 31, 1991>’ in this case).

The ‘incyear(date, step)’ function increases a date form by the specified number of years, which may be any positive or negative integer. Note that ‘incyear(d, n)’ is equivalent to ‘incmonth(d, 12*n)’, but these do not have simple equivalents in terms of day arithmetic because months and years have varying lengths. If the step argument is omitted, 1 year is assumed. There is no keyboard command for this function; use C-u 12 t I instead.

There is no newday function at all because F [floor] serves this purpose. Similarly, instead of incday and incweek simply use ‘d + n’ or ‘d + 7 n’.

See Basic Arithmetic, for the f ] [incr] command which can adjust a date/time form by a certain number of seconds.


**** Business Days

Often time is measured in “business days” or “working days,” where weekends and holidays are skipped. Calc’s normal date arithmetic functions use calendar days, so that subtracting two consecutive Mondays will yield a difference of 7 days. By contrast, subtracting two consecutive Mondays would yield 5 business days (assuming two-day weekends and the absence of holidays).

The t + (calc-business-days-plus) [badd] and t - (calc-business-days-minus) [bsub] commands perform arithmetic using business days. For t +, one argument must be a date form and the other must be a real number (positive or negative). If the number is not an integer, then a certain amount of time is added as well as a number of days; for example, adding 0.5 business days to a time in Friday evening will produce a time in Monday morning. It is also possible to add an HMS form; adding ‘12@ 0' 0"’ also adds half a business day. For t -, the arguments are either a date form and a number or HMS form, or two date forms, in which case the result is the number of business days between the two dates.

By default, Calc considers any day that is not a Saturday or Sunday to be a business day. You can define any number of additional holidays by editing the variable Holidays. (There is an s H convenience command for editing this variable.) Initially, Holidays contains the vector ‘[sat, sun]’. Entries in the Holidays vector may be any of the following kinds of objects:

Date forms (pure dates, not date/time forms). These specify particular days which are to be treated as holidays.
Intervals of date forms. These specify a range of days, all of which are holidays (e.g., Christmas week). See Interval Forms.
Nested vectors of date forms. Each date form in the vector is considered to be a holiday.
Any Calc formula which evaluates to one of the above three things. If the formula involves the variable ‘y’, it stands for a yearly repeating holiday; ‘y’ will take on various year numbers like 1992. For example, ‘date(y, 12, 25)’ specifies Christmas day, and ‘newweek(date(y, 11, 7), 4) + 21’ specifies Thanksgiving (which is held on the fourth Thursday of November). If the formula involves the variable ‘m’, that variable takes on month numbers from 1 to 12: ‘date(y, m, 15)’ is a holiday that takes place on the 15th of every month.
A weekday name, such as sat or sun. This is really a variable whose name is a three-letter, lower-case day name.
An interval of year numbers (integers). This specifies the span of years over which this holiday list is to be considered valid. Any business-day arithmetic that goes outside this range will result in an error message. Use this if you are including an explicit list of holidays, rather than a formula to generate them, and you want to make sure you don’t accidentally go beyond the last point where the holidays you entered are complete. If there is no limiting interval in the Holidays vector, the default ‘[1 .. 2737]’ is used. (This is the absolute range of years for which Calc’s business-day algorithms will operate.)
An interval of HMS forms. This specifies the span of hours that are to be considered one business day. For example, if this range is ‘[9@ 0' 0" .. 17@ 0' 0"]’ (i.e., 9am to 5pm), then the business day is only eight hours long, so that 1.5 t + on ‘<4:00pm Fri Dec 13, 1991>’ will add one business day and four business hours to produce ‘<12:00pm Tue Dec 17, 1991>’. Likewise, t - will now express differences in time as fractions of an eight-hour day. Times before 9am will be treated as 9am by business date arithmetic, and times at or after 5pm will be treated as 4:59:59pm. If there is no HMS interval in Holidays, the full 24-hour day ‘[0 0' 0" .. 24 0' 0"]’ is assumed. (Regardless of the type of bounds you specify, the interval is treated as inclusive on the low end and exclusive on the high end, so that the work day goes from 9am up to, but not including, 5pm.)
If the Holidays vector is empty, then t + and t - will act just like + and - because there will then be no difference between business days and calendar days.

Calc expands the intervals and formulas you give into a complete list of holidays for internal use. This is done mainly to make sure it can detect multiple holidays. (For example, ‘<Jan 1, 1989>’ is both New Year’s Day and a Sunday, but Calc’s algorithms take care to count it only once when figuring the number of holidays between two dates.)

Since the complete list of holidays for all the years from 1 to 2737 would be huge, Calc actually computes only the part of the list between the smallest and largest years that have been involved in business-day calculations so far. Normally, you won’t have to worry about this. Keep in mind, however, that if you do one calculation for 1992, and another for 1792, even if both involve only a small range of years, Calc will still work out all the holidays that fall in that 200-year span.

If you add a (positive) number of days to a date form that falls on a weekend or holiday, the date form is treated as if it were the most recent business day. (Thus adding one business day to a Friday, Saturday, or Sunday will all yield the following Monday.) If you subtract a number of days from a weekend or holiday, the date is effectively on the following business day. (So subtracting one business day from Saturday, Sunday, or Monday yields the preceding Friday.) The difference between two dates one or both of which fall on holidays equals the number of actual business days between them. These conventions are consistent in the sense that, if you add n business days to any date, the difference between the result and the original date will come out to n business days. (It can’t be completely consistent though; a subtraction followed by an addition might come out a bit differently, since t + is incapable of producing a date that falls on a weekend or holiday.)

There is a holiday function, not on any keys, that takes any date form and returns 1 if that date falls on a weekend or holiday, as defined in Holidays, or 0 if the date is a business day.


**** Time Zones

Time zones and daylight saving time are a complicated business. The conversions to and from Julian and Unix-style dates automatically compute the correct time zone and daylight saving adjustment to use, provided they can figure out this information. This section describes Calc’s time zone adjustment algorithm in detail, in case you want to do conversions in different time zones or in case Calc’s algorithms can’t determine the right correction to use.

Adjustments for time zones and daylight saving time are done by t U, t J, t N, and t C, but not by any other commands. In particular, ‘<may 1 1991> - <apr 1 1991>’ evaluates to exactly 30 days even though there is a daylight-saving transition in between. This is also true for Julian pure dates: ‘julian(<may 1 1991>) - julian(<apr 1 1991>)’. But Julian and Unix date/times will adjust for daylight saving time: using Calc’s default daylight saving time rule (see the explanation below), ‘julian(<12am may 1 1991>) - julian(<12am apr 1 1991>)’ evaluates to ‘29.95833’ (that’s 29 days and 23 hours) because one hour was lost when daylight saving commenced on April 7, 1991.

In brief, the idiom ‘julian(date1) - julian(date2)’ computes the actual number of 24-hour periods between two dates, whereas ‘date1 - date2’ computes the number of calendar days between two dates without taking daylight saving into account.

The calc-time-zone [tzone] command converts the time zone specified by its numeric prefix argument into a number of seconds difference from Greenwich mean time (GMT). If the argument is a number, the result is simply that value multiplied by 3600. Typical arguments for North America are 5 (Eastern) or 8 (Pacific). If Daylight Saving time is in effect, one hour should be subtracted from the normal difference.

If you give a prefix of plain C-u, calc-time-zone (like other date arithmetic commands that include a time zone argument) takes the zone argument from the top of the stack. (In the case of t J and t U, the normal argument is then taken from the second-to-top stack position.) This allows you to give a non-integer time zone adjustment. The time-zone argument can also be an HMS form, or it can be a variable which is a time zone name in upper- or lower-case. For example ‘tzone(PST) = tzone(8)’ and ‘tzone(pdt) = tzone(7)’ (for Pacific standard and daylight saving times, respectively).

North American and European time zone names are defined as follows; note that for each time zone there is one name for standard time, another for daylight saving time, and a third for “generalized” time in which the daylight saving adjustment is computed from context.

YST  PST  MST  CST  EST  AST    NST    GMT   WET     MET    MEZ
 9    8    7    6    5    4     3.5     0     -1      -2     -2

YDT  PDT  MDT  CDT  EDT  ADT    NDT    BST  WETDST  METDST  MESZ
 8    7    6    5    4    3     2.5     -1    -2      -3     -3

YGT  PGT  MGT  CGT  EGT  AGT    NGT    BGT   WEGT    MEGT   MEGZ
9/8  8/7  7/6  6/5  5/4  4/3  3.5/2.5  0/-1 -1/-2   -2/-3  -2/-3
To define time zone names that do not appear in the above table, you must modify the Lisp variable math-tzone-names. This is a list of lists describing the different time zone names; its structure is best explained by an example. The three entries for Pacific Time look like this:

( ( "PST" 8 0 )    ; Name as an upper-case string, then standard
  ( "PDT" 8 -1 )   ; adjustment, then daylight saving adjustment.
  ( "PGT" 8 "PST" "PDT" ) )   ; Generalized time zone.
With no arguments, calc-time-zone or ‘tzone()’ will by default get the time zone and daylight saving information from the calendar (see The Calendar and the Diary in The GNU Emacs Manual). To use a different time zone, or if the calendar does not give the desired result, you can set the Calc variable TimeZone (which is by default nil) to an appropriate time zone name. (The easiest way to do this is to edit the TimeZone variable using Calc’s s T command, then use the s p (calc-permanent-variable) command to save the value of TimeZone permanently.) If the time zone given by TimeZone is a generalized time zone, e.g., EGT, Calc examines the date being converted to tell whether to use standard or daylight saving time. But if the current time zone is explicit, e.g., EST or EDT, then that adjustment is used exactly and Calc’s daylight saving algorithm is not consulted. The special time zone name local is equivalent to no argument; i.e., it uses the information obtained from the calendar.

The t J and t U commands with no numeric prefix arguments do the same thing as ‘tzone()’; namely, use the information from the calendar if TimeZone is nil, otherwise use the time zone given by TimeZone.

When Calc computes the daylight saving information itself (i.e., when the TimeZone variable is set), it will by default consider daylight saving time to begin at 2 a.m. on the second Sunday of March (for years from 2007 on) or on the last Sunday in April (for years before 2007), and to end at 2 a.m. on the first Sunday of November. (for years from 2007 on) or the last Sunday in October (for years before 2007). These are the rules that have been in effect in much of North America since 1966 and take into account the rule change that began in 2007. If you are in a country that uses different rules for computing daylight saving time, you have two choices: Write your own daylight saving hook, or control time zones explicitly by setting the TimeZone variable and/or always giving a time-zone argument for the conversion functions.

The Lisp variable math-daylight-savings-hook holds the name of a function that is used to compute the daylight saving adjustment for a given date. The default is math-std-daylight-savings, which computes an adjustment (either 0 or -1) using the North American rules given above.

The daylight saving hook function is called with four arguments: The date, as a floating-point number in standard Calc format; a six-element list of the date decomposed into year, month, day, hour, minute, and second, respectively; a string which contains the generalized time zone name in upper-case, e.g., "WEGT"; and a special adjustment to be applied to the hour value when converting into a generalized time zone (see below).

The Lisp function math-prev-weekday-in-month is useful for daylight saving computations. This is an internal version of the user-level pwday function described in the previous section. It takes four arguments: The floating-point date value, the corresponding six-element date list, the day-of-month number, and the weekday number (0–6).

The default daylight saving hook ignores the time zone name, but a more sophisticated hook could use different algorithms for different time zones. It would also be possible to use different algorithms depending on the year number, but the default hook always uses the algorithm for 1987 and later. Here is a listing of the default daylight saving hook:

(defun math-std-daylight-savings (date dt zone bump)
  (cond ((< (nth 1 dt) 4) 0)
        ((= (nth 1 dt) 4)
         (let ((sunday (math-prev-weekday-in-month date dt 7 0)))
           (cond ((< (nth 2 dt) sunday) 0)
                 ((= (nth 2 dt) sunday)
                  (if (>= (nth 3 dt) (+ 3 bump)) -1 0))
                 (t -1))))
        ((< (nth 1 dt) 10) -1)
        ((= (nth 1 dt) 10)
         (let ((sunday (math-prev-weekday-in-month date dt 31 0)))
           (cond ((< (nth 2 dt) sunday) -1)
                 ((= (nth 2 dt) sunday)
                  (if (>= (nth 3 dt) (+ 2 bump)) 0 -1))
                 (t 0))))
        (t 0))
)
The bump parameter is equal to zero when Calc is converting from a date form in a generalized time zone into a GMT date value. It is -1 when Calc is converting in the other direction. The adjustments shown above ensure that the conversion behaves correctly and reasonably around the 2 a.m. transition in each direction.

There is a “missing” hour between 2 a.m. and 3 a.m. at the beginning of daylight saving time; converting a date/time form that falls in this hour results in a time value for the following hour, from 3 a.m. to 4 a.m. At the end of daylight saving time, the hour from 1 a.m. to 2 a.m. repeats itself; converting a date/time form that falls in this hour results in a time value for the first manifestation of that time (not the one that occurs one hour later).

If math-daylight-savings-hook is nil, then the daylight saving adjustment is always taken to be zero.

In algebraic formulas, ‘tzone(zone, date)’ computes the time zone adjustment for a given zone name at a given date. The date is ignored unless zone is a generalized time zone. If date is a date form, the daylight saving computation is applied to it as it appears. If date is a numeric date value, it is adjusted for the daylight-saving version of zone before being given to the daylight saving hook. This odd-sounding rule ensures that the daylight-saving computation is always done in local time, not in the GMT time that a numeric date is typically represented in.

The ‘dsadj(date, zone)’ function computes the daylight saving adjustment that is appropriate for date in time zone zone. If zone is explicitly in or not in daylight saving time (e.g., PDT or PST) the date is ignored. If zone is a generalized time zone, the algorithms described above are used. If zone is omitted, the computation is done for the current time zone.


*** Financial Functions

Calc’s financial or business functions use the b prefix key followed by a shifted letter. (The b prefix followed by a lower-case letter is used for operations on binary numbers.)

Note that the rate and the number of intervals given to these functions must be on the same time scale, e.g., both months or both years. Mixing an annual interest rate with a time expressed in months will give you very wrong answers!

It is wise to compute these functions to a higher precision than you really need, just to make sure your answer is correct to the last penny; also, you may wish to check the definitions at the end of this section to make sure the functions have the meaning you expect.

**** Percentages

The M-% (calc-percent) command takes a percentage value, say 5.4, and converts it to an equivalent actual number. For example, 5.4 M-% enters 0.054 on the stack. (That’s the META or ESC key combined with %.)

Actually, M-% creates a formula of the form ‘5.4%’. You can enter ‘5.4%’ yourself during algebraic entry. The ‘%’ operator simply means, “the preceding value divided by 100.” The ‘%’ operator has very high precedence, so that ‘1+8%’ is interpreted as ‘1+(8%)’, not as ‘(1+8)%’. (The ‘%’ operator is just a postfix notation for the percent function, just like ‘20!’ is the notation for ‘fact(20)’, or twenty-factorial.)

The formula ‘5.4%’ would normally evaluate immediately to 0.054, but the M-% command suppresses evaluation as it puts the formula onto the stack. However, the next Calc command that uses the formula ‘5.4%’ will evaluate it as its first step. The net effect is that you get to look at ‘5.4%’ on the stack, but Calc commands see it as ‘0.054’, which is what they expect.

In particular, ‘5.4%’ and ‘0.054’ are suitable values for the rate arguments of the various financial functions, but the number ‘5.4’ is probably not suitable—it represents a rate of 540 percent!

The key sequence M-% * effectively means “percent-of.” For example, 68 RET 25 M-% * computes 17, which is 25% of 68 (and also 68% of 25, which comes out to the same thing).

The c % (calc-convert-percent) command converts the value on the top of the stack from numeric to percentage form. For example, if 0.08 is on the stack, c % converts it to ‘8%’. The quantity is the same, it’s just represented differently. (Contrast this with M-%, which would convert this number to ‘0.08%’.) The = key is a convenient way to convert a formula like ‘8%’ back to numeric form, 0.08.

To compute what percentage one quantity is of another quantity, use / c %. For example, 17 RET 68 / c % displays ‘25%’.

The b % (calc-percent-change) [relch] command calculates the percentage change from one number to another. For example, 40 RET 50 b % produces the answer ‘25%’, since 50 is 25% larger than 40. A negative result represents a decrease: 50 RET 40 b % produces ‘-20%’, since 40 is 20% smaller than 50. (The answers are different in magnitude because, in the first case, we’re increasing by 25% of 40, but in the second case, we’re decreasing by 20% of 50.) The effect of 40 RET 50 b % is to compute ‘(50-40)/40’, converting the answer to percentage form as if by c %.


**** Future Value

The b F (calc-fin-fv) [fv] command computes the future value of an investment. It takes three arguments from the stack: ‘fv(rate, n, payment)’. If you give payments of payment every year for n years, and the money you have paid earns interest at rate per year, then this function tells you what your investment would be worth at the end of the period. (The actual interval doesn’t have to be years, as long as n and rate are expressed in terms of the same intervals.) This function assumes payments occur at the end of each interval.

The I b F [fvb] command does the same computation, but assuming your payments are at the beginning of each interval. Suppose you plan to deposit $1000 per year in a savings account earning 5.4% interest, starting right now. How much will be in the account after five years? fvb(5.4%, 5, 1000) = 5870.73. Thus you will have earned $870 worth of interest over the years. Using the stack, this calculation would have been 5.4 M-% 5 RET 1000 I b F. Note that the rate is expressed as a number between 0 and 1, not as a percentage.

The H b F [fvl] command computes the future value of an initial lump sum investment. Suppose you could deposit those five thousand dollars in the bank right now; how much would they be worth in five years? fvl(5.4%, 5, 5000) = 6503.89.

The algebraic functions fv and fvb accept an optional fourth argument, which is used as an initial lump sum in the sense of fvl. In other words, fv(rate, n, payment, initial) = fv(rate, n, payment) + fvl(rate, n, initial).

To illustrate the relationships between these functions, we could do the fvb calculation “by hand” using fvl. The final balance will be the sum of the contributions of our five deposits at various times. The first deposit earns interest for five years: fvl(5.4%, 5, 1000) = 1300.78. The second deposit only earns interest for four years: fvl(5.4%, 4, 1000) = 1234.13. And so on down to the last deposit, which earns one year’s interest: fvl(5.4%, 1, 1000) = 1054.00. The sum of these five values is, sure enough, $5870.73, just as was computed by fvb directly.

What does fv(5.4%, 5, 1000) = 5569.96 mean? The payments are now at the ends of the periods. The end of one year is the same as the beginning of the next, so what this really means is that we’ve lost the payment at year zero (which contributed $1300.78), but we’re now counting the payment at year five (which, since it didn’t have a chance to earn interest, counts as $1000). Indeed, ‘5569.96 = 5870.73 - 1300.78 + 1000’ (give or take a bit of roundoff error).


**** Present Value

The b P (calc-fin-pv) [pv] command computes the present value of an investment. Like fv, it takes three arguments: pv(rate, n, payment). It computes the present value of a series of regular payments. Suppose you have the chance to make an investment that will pay $2000 per year over the next four years; as you receive these payments you can put them in the bank at 9% interest. You want to know whether it is better to make the investment, or to keep the money in the bank where it earns 9% interest right from the start. The calculation pv(9%, 4, 2000) gives the result 6479.44. If your initial investment must be less than this, say, $6000, then the investment is worthwhile. But if you had to put up $7000, then it would be better just to leave it in the bank.

Here is the interpretation of the result of pv: You are trying to compare the return from the investment you are considering, which is fv(9%, 4, 2000) = 9146.26, with the return from leaving the money in the bank, which is fvl(9%, 4, x) where x is the amount of money you would have to put up in advance. The pv function finds the break-even point, ‘x = 6479.44’, at which fvl(9%, 4, 6479.44) is also equal to 9146.26. This is the largest amount you should be willing to invest.

The I b P [pvb] command solves the same problem, but with payments occurring at the beginning of each interval. It has the same relationship to fvb as pv has to fv. For example pvb(9%, 4, 2000) = 7062.59, a larger number than pv produced because we get to start earning interest on the return from our investment sooner.

The H b P [pvl] command computes the present value of an investment that will pay off in one lump sum at the end of the period. For example, if we get our $8000 all at the end of the four years, pvl(9%, 4, 8000) = 5667.40. This is much less than pv reported, because we don’t earn any interest on the return from this investment. Note that pvl and fvl are simple inverses: fvl(9%, 4, 5667.40) = 8000.

You can give an optional fourth lump-sum argument to pv and pvb; this is handled in exactly the same way as the fourth argument for fv and fvb.

The b N (calc-fin-npv) [npv] command computes the net present value of a series of irregular investments. The first argument is the interest rate. The second argument is a vector which represents the expected return from the investment at the end of each interval. For example, if the rate represents a yearly interest rate, then the vector elements are the return from the first year, second year, and so on.

Thus, npv(9%, [2000,2000,2000,2000]) = pv(9%, 4, 2000) = 6479.44. Obviously this function is more interesting when the payments are not all the same!

The npv function can actually have two or more arguments. Multiple arguments are interpreted in the same way as for the vector statistical functions like vsum. See Single-Variable Statistics. Basically, if there are several payment arguments, each either a vector or a plain number, all these values are collected left-to-right into the complete list of payments. A numeric prefix argument on the b N command says how many payment values or vectors to take from the stack.

The I b N [npvb] command computes the net present value where payments occur at the beginning of each interval rather than at the end.


**** Related Financial Functions

The functions in this section are basically inverses of the present value functions with respect to the various arguments.

The b M (calc-fin-pmt) [pmt] command computes the amount of periodic payment necessary to amortize a loan. Thus pmt(rate, n, amount) equals the value of payment such that pv(rate, n, payment) = amount.

The I b M [pmtb] command does the same computation but using pvb instead of pv. Like pv and pvb, these functions can also take a fourth argument which represents an initial lump-sum investment.

The H b M key just invokes the fvl function, which is the inverse of pvl. There is no explicit pmtl function.

The b # (calc-fin-nper) [nper] command computes the number of regular payments necessary to amortize a loan. Thus nper(rate, payment, amount) equals the value of n such that pv(rate, n, payment) = amount. If payment is too small ever to amortize a loan for amount at interest rate rate, the nper function is left in symbolic form.

The I b # [nperb] command does the same computation but using pvb instead of pv. You can give a fourth lump-sum argument to these functions, but the computation will be rather slow in the four-argument case.

The H b # [nperl] command does the same computation using pvl. By exchanging payment and amount you can also get the solution for fvl. For example, nperl(8%, 2000, 1000) = 9.006, so if you place $1000 in a bank account earning 8%, it will take nine years to grow to $2000.

The b T (calc-fin-rate) [rate] command computes the rate of return on an investment. This is also an inverse of pv: rate(n, payment, amount) computes the value of rate such that pv(rate, n, payment) = amount. The result is expressed as a formula like ‘6.3%’.

The I b T [rateb] and H b T [ratel] commands solve the analogous equations with pvb or pvl in place of pv. Also, rate and rateb can accept an optional fourth argument just like pv and pvb. To redo the above example from a different perspective, ratel(9, 2000, 1000) = 8.00597%, which says you will need an interest rate of 8% in order to double your account in nine years.

The b I (calc-fin-irr) [irr] command is the analogous function to rate but for net present value. Its argument is a vector of payments. Thus irr(payments) computes the rate such that npv(rate, payments) = 0; this rate is known as the internal rate of return.

The I b I [irrb] command computes the internal rate of return assuming payments occur at the beginning of each period.


**** Depreciation Functions

The functions in this section calculate depreciation, which is the amount of value that a possession loses over time. These functions are characterized by three parameters: cost, the original cost of the asset; salvage, the value the asset will have at the end of its expected “useful life”; and life, the number of years (or other periods) of the expected useful life.

There are several methods for calculating depreciation that differ in the way they spread the depreciation over the lifetime of the asset.

The b S (calc-fin-sln) [sln] command computes the “straight-line” depreciation. In this method, the asset depreciates by the same amount every year (or period). For example, ‘sln(12000, 2000, 5)’ returns 2000. The asset costs $12000 initially and will be worth $2000 after five years; it loses $2000 per year.

The b Y (calc-fin-syd) [syd] command computes the accelerated “sum-of-years’-digits” depreciation. Here the depreciation is higher during the early years of the asset’s life. Since the depreciation is different each year, b Y takes a fourth period parameter which specifies which year is requested, from 1 to life. If period is outside this range, the syd function will return zero.

The b D (calc-fin-ddb) [ddb] command computes an accelerated depreciation using the double-declining balance method. It also takes a fourth period parameter.

For symmetry, the sln function will accept a period parameter as well, although it will ignore its value except that the return value will as usual be zero if period is out of range.

For example, pushing the vector ‘[1,2,3,4,5]’ (perhaps with v x 5) and then mapping V M ' [sln(12000,2000,5,$), syd(12000,2000,5,$), ddb(12000,2000,5,$)] RET produces a matrix that allows us to compare the three depreciation methods:

[ [ 2000, 3333, 4800 ]
  [ 2000, 2667, 2880 ]
  [ 2000, 2000, 1728 ]
  [ 2000, 1333,  592 ]
  [ 2000,  667,   0  ] ]
(Values have been rounded to nearest integers in this figure.) We see that sln depreciates by the same amount each year, syd depreciates more at the beginning and less at the end, and ddb weights the depreciation even more toward the beginning.

Summing columns with V R : + yields ‘[10000, 10000, 10000]’; the total depreciation in any method is (by definition) the difference between the cost and the salvage value.


**** Definitions

For your reference, here are the actual formulas used to compute Calc’s financial functions.

Calc will not evaluate a financial function unless the rate or n argument is known. However, payment or amount can be a variable. Calc expands these functions according to the formulas below for symbolic arguments only when you use the a " (calc-expand-formula) command, or when taking derivatives or integrals or solving equations involving the functions.

These formulas are shown using the conventions of Big display mode (d B); for example, the formula for fv written linearly is ‘pmt * ((1 + rate)^n) - 1) / rate’.

                                        n
                              (1 + rate)  - 1
fv(rate, n, pmt) =      pmt * ---------------
                                   rate

                                         n
                              ((1 + rate)  - 1) (1 + rate)
fvb(rate, n, pmt) =     pmt * ----------------------------
                                         rate

                                        n
fvl(rate, n, pmt) =     pmt * (1 + rate)

                                            -n
                              1 - (1 + rate)
pv(rate, n, pmt) =      pmt * ----------------
                                    rate

                                             -n
                              (1 - (1 + rate)  ) (1 + rate)
pvb(rate, n, pmt) =     pmt * -----------------------------
                                         rate

                                        -n
pvl(rate, n, pmt) =     pmt * (1 + rate)

                                    -1               -2               -3
npv(rate, [a, b, c]) =  a*(1 + rate)   + b*(1 + rate)   + c*(1 + rate)

                                        -1               -2
npvb(rate, [a, b, c]) = a + b*(1 + rate)   + c*(1 + rate)

                                             -n
                        (amt - x * (1 + rate)  ) * rate
pmt(rate, n, amt, x) =  -------------------------------
                                             -n
                               1 - (1 + rate)

                                             -n
                        (amt - x * (1 + rate)  ) * rate
pmtb(rate, n, amt, x) = -------------------------------
                                        -n
                         (1 - (1 + rate)  ) (1 + rate)

                                   amt * rate
nper(rate, pmt, amt) =  - log(1 - ------------, 1 + rate)
                                      pmt

                                    amt * rate
nperb(rate, pmt, amt) = - log(1 - ---------------, 1 + rate)
                                  pmt * (1 + rate)

                              amt
nperl(rate, pmt, amt) = - log(---, 1 + rate)
                              pmt

                           1/n
                        pmt
ratel(n, pmt, amt) =    ------ - 1
                           1/n
                        amt

                        cost - salv
sln(cost, salv, life) = -----------
                           life

                             (cost - salv) * (life - per + 1)
syd(cost, salv, life, per) = --------------------------------
                                  life * (life + 1) / 2

                             book * 2
ddb(cost, salv, life, per) = --------,  book = cost - depreciation so far
                               life
In pmt and pmtb, ‘x=0’ if omitted.

These functions accept any numeric objects, including error forms, intervals, and even (though not very usefully) complex numbers. The above formulas specify exactly the behavior of these functions with all sorts of inputs.

Note that if the first argument to the log in nper is negative, nper leaves itself in symbolic form rather than returning a (financially meaningless) complex number.

‘rate(num, pmt, amt)’ solves the equation ‘pv(rate, num, pmt) = amt’ for ‘rate’ using H a R (calc-find-root), with the interval ‘[.01% .. 100%]’ for an initial guess. The rateb function is the same except that it uses pvb. Note that ratel can be solved directly; its formula is shown in the above list.

Similarly, ‘irr(pmts)’ solves the equation ‘npv(rate, pmts) = 0’ for ‘rate’.

If you give a fourth argument to nper or nperb, Calc will also use H a R to solve the equation using an initial guess interval of ‘[0 .. 100]’.

A fourth argument to fv simply sums the two components calculated from the above formulas for fv and fvl. The same is true of fvb, pv, and pvb.

The ddb function is computed iteratively; the “book” value starts out equal to cost, and decreases according to the above formula for the specified number of periods. If the book value would decrease below salvage, it only decreases to salvage and the depreciation is zero for all subsequent periods. The ddb function returns the amount the book value decreased in the specified period.


*** Binary Number Functions

The commands in this chapter all use two-letter sequences beginning with the b prefix.

The “binary” operations actually work regardless of the currently displayed radix, although their results make the most sense in a radix like 2, 8, or 16 (as obtained by the d 2, d 8, or d 6 commands, respectively). You may also wish to enable display of leading zeros with d z. See Radix Modes.

The Calculator maintains a current word size ‘w’, an arbitrary integer. For a positive word size, all of the binary operations described here operate modulo ‘2^w’. In particular, negative arguments are converted to positive integers modulo ‘2^w’ by all binary functions.

If the word size is negative, binary operations produce twos-complement integers from ‘-(2^(-w-1))’ to ‘2^(-w-1)-1’ inclusive. Either mode accepts inputs in any range; the sign of ‘w’ affects only the results produced.

If the word size is zero, binary operations work on the entire number without clipping, as if the word size had been negative infinity.

The b c (calc-clip) [clip] command can be used to clip a number by reducing it modulo ‘2^w’. The commands described in this chapter automatically clip their results to the current word size. Note that other operations like addition do not use the current word size, since integer addition generally is not “binary.” (However, see Simplification Modes, calc-bin-simplify-mode.) For example, with a word size of 8 bits b c converts a number to the range 0 to 255; with a word size of -8 b c converts to the range -128 to 127.

The default word size is 32 bits. All operations except the shifts and rotates allow you to specify a different word size for that one operation by giving a numeric prefix argument: C-u 8 b c clips the top of stack to the range 0 to 255 regardless of the current word size. To set the word size permanently, use b w (calc-word-size). This command displays a prompt with the current word size; press RET immediately to keep this word size, or type a new word size at the prompt.

When the binary operations are written in symbolic form, they take an optional second (or third) word-size parameter. When a formula like ‘and(a,b)’ is finally evaluated, the word size current at that time will be used, but when ‘and(a,b,-8)’ is evaluated, a word size of -8 will always be used. A symbolic binary function will be left in symbolic form unless the all of its argument(s) are integers or integer-valued floats.

If either or both arguments are modulo forms for which ‘M’ is a power of two, that power of two is taken as the word size unless a numeric prefix argument overrides it. The current word size is never consulted when modulo-power-of-two forms are involved.

The b a (calc-and) [and] command computes the bitwise AND of the two numbers on the top of the stack. In other words, for each of the ‘w’ binary digits of the two numbers (pairwise), the corresponding bit of the result is 1 if and only if both input bits are 1: ‘and(2#1100, 2#1010) = 2#1000’.

The b o (calc-or) [or] command computes the bitwise inclusive OR of two numbers. A bit is 1 if either of the input bits, or both, are 1: ‘or(2#1100, 2#1010) = 2#1110’.

The b x (calc-xor) [xor] command computes the bitwise exclusive OR of two numbers. A bit is 1 if exactly one of the input bits is 1: ‘xor(2#1100, 2#1010) = 2#0110’.

The b d (calc-diff) [diff] command computes the bitwise difference of two numbers; this is defined by ‘diff(a,b) = and(a,not(b))’, so that ‘diff(2#1100, 2#1010) = 2#0100’.

The b n (calc-not) [not] command computes the bitwise NOT of a number. A bit is 1 if the input bit is 0 and vice-versa.

The b l (calc-lshift-binary) [lsh] command shifts a number left by one bit, or by the number of bits specified in the numeric prefix argument. A negative prefix argument performs a logical right shift, in which zeros are shifted in on the left. In symbolic form, ‘lsh(a)’ is short for ‘lsh(a,1)’, which in turn is short for ‘lsh(a,n,w)’. Bits shifted “off the end,” according to the current word size, are lost.

The H b l command also does a left shift, but it takes two arguments from the stack (the value to shift, and, at top-of-stack, the number of bits to shift). This version interprets the prefix argument just like the regular binary operations, i.e., as a word size. The Hyperbolic flag has a similar effect on the rest of the binary shift and rotate commands.

The b r (calc-rshift-binary) [rsh] command shifts a number right by one bit, or by the number of bits specified in the numeric prefix argument: ‘rsh(a,n) = lsh(a,-n)’.

The b L (calc-lshift-arith) [ash] command shifts a number left. It is analogous to lsh, except that if the shift is rightward (the prefix argument is negative), an arithmetic shift is performed as described below.

The b R (calc-rshift-arith) [rash] command performs an “arithmetic” shift to the right, in which the leftmost bit (according to the current word size) is duplicated rather than shifting in zeros. This corresponds to dividing by a power of two where the input is interpreted as a signed, twos-complement number. (The distinction between the ‘rsh’ and ‘rash’ operations is totally independent from whether the word size is positive or negative.) With a negative prefix argument, this performs a standard left shift.

When the word size is zero, logical and arithmetic shift operations are identical: a negative value shifted right remains negative, since there is an infinite supply of ones to shift in.

The b t (calc-rotate-binary) [rot] command rotates a number one bit to the left. The leftmost bit (according to the current word size) is dropped off the left and shifted in on the right. With a numeric prefix argument, the number is rotated that many bits to the left or right.

Rotation is not possible with a zero word size.

See Set Operations using Vectors, for the b p and b u commands that pack and unpack binary integers into sets. (For example, b u unpacks the number ‘2#11001’ to the set of bit-numbers ‘[0, 3, 4]’.) Type b u V # to count the number of “1” bits in a binary integer.

Another interesting use of the set representation of binary integers is to reverse the bits in, say, a 32-bit integer. Type b u to unpack; type 31 TAB - to replace each bit-number in the set with 31 minus that bit-number; type b p to pack the set back into a binary integer.


** Scientific Functions

The functions described here perform trigonometric and other transcendental calculations. They generally produce floating-point answers correct to the full current precision. The H (Hyperbolic) and I (Inverse) flag keys must be used to get some of these functions from the keyboard.

One miscellaneous command is shift-P (calc-pi), which pushes the value of ‘pi’ (at the current precision) onto the stack. With the Hyperbolic flag, it pushes the value ‘e’, the base of natural logarithms. With the Inverse flag, it pushes Euler’s constant ‘gamma’ (about 0.5772). With both Inverse and Hyperbolic, it pushes the “golden ratio” ‘phi’ (about 1.618). (At present, Euler’s constant is not available to unlimited precision; Calc knows only the first 100 digits.) In Symbolic mode, these commands push the actual variables ‘pi’, ‘e’, ‘gamma’, and ‘phi’, respectively, instead of their values; see Symbolic Mode.

The Q (calc-sqrt) [sqrt] function is described elsewhere; see Basic Arithmetic. With the Inverse flag [sqr], this command computes the square of the argument.

See Numeric Prefix Arguments, for a discussion of the effect of numeric prefix arguments on commands in this chapter which do not otherwise interpret a prefix argument.

*** Logarithmic Functions

The shift-L (calc-ln) [ln] command computes the natural logarithm of the real or complex number on the top of the stack. With the Inverse flag it computes the exponential function instead, although this is redundant with the E command.

The shift-E (calc-exp) [exp] command computes the exponential, i.e., ‘e’ raised to the power of the number on the stack. The meanings of the Inverse and Hyperbolic flags follow from those for the calc-ln command.

The H L (calc-log10) [log10] command computes the common (base-10) logarithm of a number. (With the Inverse flag [exp10], it raises ten to a given power.) Note that the common logarithm of a complex number is computed by taking the natural logarithm and dividing by ‘ln(10)’.

The B (calc-log) [log] command computes a logarithm to any base. For example, 1024 RET 2 B produces 10, since ‘2^10 = 1024’. In certain cases like ‘log(3,9)’, the result will be either ‘1:2’ or ‘0.5’ depending on the current Fraction mode setting. With the Inverse flag [alog], this command is similar to ^ except that the order of the arguments is reversed.

The f I (calc-ilog) [ilog] command computes the integer logarithm of a number to any base. The number and the base must themselves be positive integers. This is the true logarithm, rounded down to an integer. Thus ilog(x,10) is 3 for all ‘x’ in the range from 1000 to 9999. If both arguments are positive integers, exact integer arithmetic is used; otherwise, this is equivalent to ‘floor(log(x,b))’.

The f E (calc-expm1) [expm1] command computes ‘exp(x)-1’, but using an algorithm that produces a more accurate answer when the result is close to zero, i.e., when ‘exp(x)’ is close to one.

The f L (calc-lnp1) [lnp1] command computes ‘ln(x+1)’, producing a more accurate answer when ‘x’ is close to zero.


*** Trigonometric/Hyperbolic Functions

The shift-S (calc-sin) [sin] command computes the sine of an angle or complex number. If the input is an HMS form, it is interpreted as degrees-minutes-seconds; otherwise, the input is interpreted according to the current angular mode. It is best to use Radians mode when operating on complex numbers.

Calc’s “units” mechanism includes angular units like deg, rad, and grad. While ‘sin(45 deg)’ is not evaluated all the time, the u s (calc-simplify-units) command will simplify ‘sin(45 deg)’ by taking the sine of 45 degrees, regardless of the current angular mode. See Basic Operations on Units.

Also, the symbolic variable pi is not ordinarily recognized in arguments to trigonometric functions, as in ‘sin(3 pi / 4)’, but the default algebraic simplifications recognize many such formulas when the current angular mode is Radians and Symbolic mode is enabled; this example would be replaced by ‘sqrt(2) / 2’. See Symbolic Mode. Beware, this simplification occurs even if you have stored a different value in the variable ‘pi’; this is one reason why changing built-in variables is a bad idea. Arguments of the form ‘x’ plus a multiple of ‘pi/2’ are also simplified. Calc includes similar formulas for cos and tan.

Calc’s algebraic simplifications know all angles which are integer multiples of ‘pi/12’, ‘pi/10’, or ‘pi/8’ radians. In Degrees mode, analogous simplifications occur for integer multiples of 15 or 18 degrees, and for arguments plus multiples of 90 degrees.

With the Inverse flag, calc-sin computes an arcsine. This is also available as the calc-arcsin command or arcsin algebraic function. The returned argument is converted to degrees, radians, or HMS notation depending on the current angular mode.

With the Hyperbolic flag, calc-sin computes the hyperbolic sine, also available as calc-sinh [sinh]. With the Hyperbolic and Inverse flags, it computes the hyperbolic arcsine (calc-arcsinh) [arcsinh].

The shift-C (calc-cos) [cos] command computes the cosine of an angle or complex number, and shift-T (calc-tan) [tan] computes the tangent, along with all the various inverse and hyperbolic variants of these functions.

The f T (calc-arctan2) [arctan2] command takes two numbers from the stack and computes the arc tangent of their ratio. The result is in the full range from -180 (exclusive) to +180 (inclusive) degrees, or the analogous range in radians. A similar result would be obtained with / followed by I T, but the value would only be in the range from -90 to +90 degrees since the division loses information about the signs of the two components, and an error might result from an explicit division by zero which arctan2 would avoid. By (arbitrary) definition, ‘arctan2(0,0)=0’.

The calc-sincos [sincos] command computes the sine and cosine of a number, returning them as a vector of the form ‘[cos, sin]’. With the Inverse flag [arcsincos], this command takes a two-element vector as an argument and computes arctan2 of the elements. (This command does not accept the Hyperbolic flag.)

The remaining trigonometric functions, calc-sec [sec], calc-csc [csc] and calc-cot [cot], are also available. With the Hyperbolic flag, these compute their hyperbolic counterparts, which are also available separately as calc-sech [sech], calc-csch [csch] and calc-coth [coth]. (These commands do not accept the Inverse flag.)


*** Advanced Mathematical Functions

Calc can compute a variety of less common functions that arise in various branches of mathematics. All of the functions described in this section allow arbitrary complex arguments and, except as noted, will work to arbitrarily large precision. They can not at present handle error forms or intervals as arguments.

NOTE: These functions are still experimental. In particular, their accuracy is not guaranteed in all domains. It is advisable to set the current precision comfortably higher than you actually need when using these functions. Also, these functions may be impractically slow for some values of the arguments.

The f g (calc-gamma) [gamma] command computes the Euler gamma function. For positive integer arguments, this is related to the factorial function: ‘gamma(n+1) = fact(n)’. For general complex arguments the gamma function can be defined by the following definite integral: ‘gamma(a) = integ(t^(a-1) exp(-t), t, 0, inf)’. (The actual implementation uses far more efficient computational methods.)

The f G (calc-inc-gamma) [gammaP] command computes the incomplete gamma function, denoted ‘P(a,x)’. This is defined by the integral, ‘gammaP(a,x) = integ(t^(a-1) exp(t), t, 0, x) / gamma(a)’. This implies that ‘gammaP(a,inf) = 1’ for any ‘a’ (see the definition of the normal gamma function).

Several other varieties of incomplete gamma function are defined. The complement of ‘P(a,x)’, called ‘Q(a,x) = 1-P(a,x)’ by some authors, is computed by the I f G [gammaQ] command. You can think of this as taking the other half of the integral, from ‘x’ to infinity.

The functions corresponding to the integrals that define ‘P(a,x)’ and ‘Q(a,x)’ but without the normalizing ‘1/gamma(a)’ factor are called ‘g(a,x)’ and ‘G(a,x)’, respectively (where ‘g’ and ‘G’ represent the lower- and upper-case Greek letter gamma). You can obtain these using the H f G [gammag] and H I f G [gammaG] commands.

The f b (calc-beta) [beta] command computes the Euler beta function, which is defined in terms of the gamma function as ‘beta(a,b) = gamma(a) gamma(b) / gamma(a+b)’, or by ‘beta(a,b) = integ(t^(a-1) (1-t)^(b-1), t, 0, 1)’.

The f B (calc-inc-beta) [betaI] command computes the incomplete beta function ‘I(x,a,b)’. It is defined by ‘betaI(x,a,b) = integ(t^(a-1) (1-t)^(b-1), t, 0, x) / beta(a,b)’. Once again, the H (hyperbolic) prefix gives the corresponding un-normalized version [betaB].

The f e (calc-erf) [erf] command computes the error function ‘erf(x) = 2 integ(exp(-(t^(2))), t, 0, x) / sqrt(pi)’. The complementary error function I f e (calc-erfc) [erfc] is the corresponding integral from ‘x’ to infinity; the sum ‘erf(x) + erfc(x) = 1’.

The f j (calc-bessel-J) [besJ] and f y (calc-bessel-Y) [besY] commands compute the Bessel functions of the first and second kinds, respectively. In ‘besJ(n,x)’ and ‘besY(n,x)’ the “order” parameter ‘n’ is often an integer, but is not required to be one. Calc’s implementation of the Bessel functions currently limits the precision to 8 digits, and may not be exact even to that precision. Use with care!


*** Branch Cuts and Principal Values

All of the logarithmic, trigonometric, and other scientific functions are defined for complex numbers as well as for reals. This section describes the values returned in cases where the general result is a family of possible values. Calc follows section 12.5.3 of Steele’s Common Lisp, the Language, second edition, in these matters. This section will describe each function briefly; for a more detailed discussion (including some nifty diagrams), consult Steele’s book.

Note that the branch cuts for arctan and arctanh were changed between the first and second editions of Steele. Recent versions of Calc follow the second edition.

The new branch cuts exactly match those of the HP-28/48 calculators. They also match those of Mathematica 1.2, except that Mathematica’s arctan cut is always in the right half of the complex plane, and its arctanh cut is always in the top half of the plane. Calc’s cuts are continuous with quadrants I and III for arctan, or II and IV for arctanh.

Note: The current implementations of these functions with complex arguments are designed with proper behavior around the branch cuts in mind, not efficiency or accuracy. You may need to increase the floating precision and wait a while to get suitable answers from them.

For ‘sqrt(a+bi)’: When ‘a<0’ and ‘b’ is small but positive or zero, the result is close to the ‘+i’ axis. For ‘b’ small and negative, the result is close to the ‘-i’ axis. The result always lies in the right half of the complex plane.

For ‘ln(a+bi)’: The real part is defined as ‘ln(abs(a+bi))’. The imaginary part is defined as ‘arg(a+bi) = arctan2(b,a)’. Thus the branch cuts for sqrt and ln both lie on the negative real axis.

The following table describes these branch cuts in another way. If the real and imaginary parts of ‘z’ are as shown, then the real and imaginary parts of ‘f(z)’ will be as shown. Here eps stands for a small positive value; each occurrence of eps may stand for a different small value.

     z           sqrt(z)       ln(z)
----------------------------------------
   +,   0         +,  0       any, 0
   -,   0         0,  +       any, pi
   -, +eps      +eps, +      +eps, +
   -, -eps      +eps, -      +eps, -
For ‘z1^z2’: This is defined by ‘exp(ln(z1)*z2)’. One interesting consequence of this is that ‘(-8)^1:3’ does not evaluate to -2 as you might expect, but to the complex number ‘(1., 1.732)’. Both of these are valid cube roots of -8 (as is ‘(1., -1.732)’); Calc chooses a perhaps less-obvious root for the sake of mathematical consistency.

For ‘arcsin(z)’: This is defined by ‘-i*ln(i*z + sqrt(1-z^2))’. The branch cuts are on the real axis, less than -1 and greater than 1.

For ‘arccos(z)’: This is defined by ‘-i*ln(z + i*sqrt(1-z^2))’, or equivalently by ‘pi/2 - arcsin(z)’. The branch cuts are on the real axis, less than -1 and greater than 1.

For ‘arctan(z)’: This is defined by ‘(ln(1+i*z) - ln(1-i*z)) / (2*i)’. The branch cuts are on the imaginary axis, below ‘-i’ and above ‘i’.

For ‘arcsinh(z)’: This is defined by ‘ln(z + sqrt(1+z^2))’. The branch cuts are on the imaginary axis, below ‘-i’ and above ‘i’.

For ‘arccosh(z)’: This is defined by ‘ln(z + (z+1)*sqrt((z-1)/(z+1)))’. The branch cut is on the real axis less than 1.

For ‘arctanh(z)’: This is defined by ‘(ln(1+z) - ln(1-z)) / 2’. The branch cuts are on the real axis, less than -1 and greater than 1.

The following tables for arcsin, arccos, and arctan assume the current angular mode is Radians. The hyperbolic functions operate independently of the angular mode.

       z             arcsin(z)            arccos(z)
-------------------------------------------------------
 (-1..1),  0      (-pi/2..pi/2), 0       (0..pi), 0
 (-1..1), +eps    (-pi/2..pi/2), +eps    (0..pi), -eps
 (-1..1), -eps    (-pi/2..pi/2), -eps    (0..pi), +eps
   <-1,    0          -pi/2,     +         pi,    -
   <-1,  +eps      -pi/2 + eps,  +      pi - eps, -
   <-1,  -eps      -pi/2 + eps,  -      pi - eps, +
    >1,    0           pi/2,     -          0,    +
    >1,  +eps       pi/2 - eps,  +        +eps,   -
    >1,  -eps       pi/2 - eps,  -        +eps,   +
       z            arccosh(z)         arctanh(z)
-----------------------------------------------------
 (-1..1),  0        0,  (0..pi)       any,     0
 (-1..1), +eps    +eps, (0..pi)       any,    +eps
 (-1..1), -eps    +eps, (-pi..0)      any,    -eps
   <-1,    0        +,    pi           -,     pi/2
   <-1,  +eps       +,  pi - eps       -,  pi/2 - eps
   <-1,  -eps       +, -pi + eps       -, -pi/2 + eps
    >1,    0        +,     0           +,    -pi/2
    >1,  +eps       +,   +eps          +,  pi/2 - eps
    >1,  -eps       +,   -eps          +, -pi/2 + eps
       z           arcsinh(z)           arctan(z)
-----------------------------------------------------
   0, (-1..1)    0, (-pi/2..pi/2)         0,     any
   0,   <-1      -,    -pi/2            -pi/2,    -
 +eps,  <-1      +, -pi/2 + eps       pi/2 - eps, -
 -eps,  <-1      -, -pi/2 + eps      -pi/2 + eps, -
   0,    >1      +,     pi/2             pi/2,    +
 +eps,   >1      +,  pi/2 - eps       pi/2 - eps, +
 -eps,   >1      -,  pi/2 - eps      -pi/2 + eps, +
Finally, the following identities help to illustrate the relationship between the complex trigonometric and hyperbolic functions. They are valid everywhere, including on the branch cuts.

sin(i*z)  = i*sinh(z)       arcsin(i*z)  = i*arcsinh(z)
cos(i*z)  =   cosh(z)       arcsinh(i*z) = i*arcsin(z)
tan(i*z)  = i*tanh(z)       arctan(i*z)  = i*arctanh(z)
sinh(i*z) = i*sin(z)        cosh(i*z)    =   cos(z)
The “advanced math” functions (gamma, Bessel, etc.) are also defined for general complex arguments, but their branch cuts and principal values are not rigorously specified at present.


*** Random Numbers

The k r (calc-random) [random] command produces random numbers of various sorts.

Given a positive numeric prefix argument ‘M’, it produces a random integer ‘N’ in the range ‘0 <= N < M’. Each possible value ‘N’ appears with equal probability.

With no numeric prefix argument, the k r command takes its argument from the stack instead. Once again, if this is a positive integer ‘M’ the result is a random integer less than ‘M’. If ‘M’ is negative, the result is a random integer in the range ‘M < N <= 0’.

If the value on the stack is a floating-point number ‘M’, the result is a random floating-point number ‘N’ in the range ‘0 <= N < M’ or ‘M < N <= 0’, according to the sign of ‘M’.

If ‘M’ is zero, the result is a Gaussian-distributed random real number; the distribution has a mean of zero and a standard deviation of one. The algorithm used generates random numbers in pairs; thus, every other call to this function will be especially fast.

If ‘M’ is an error form ‘m +/- s’ where m and s are both real numbers, the result uses a Gaussian distribution with mean m and standard deviation s.

If ‘M’ is an interval form, the lower and upper bounds specify the acceptable limits of the random numbers. If both bounds are integers, the result is a random integer in the specified range. If either bound is floating-point, the result is a random real number in the specified range. If the interval is open at either end, the result will be sure not to equal that end value. (This makes a big difference for integer intervals, but for floating-point intervals it’s relatively minor: with a precision of 6, ‘random([1.0..2.0))’ will return any of one million numbers from 1.00000 to 1.99999; ‘random([1.0..2.0])’ may additionally return 2.00000, but the probability of this happening is extremely small.)

If ‘M’ is a vector, the result is one element taken at random from the vector. All elements of the vector are given equal probabilities.

The sequence of numbers produced by k r is completely random by default, i.e., the sequence is seeded each time you start Calc using the current time and other information. You can get a reproducible sequence by storing a particular “seed value” in the Calc variable RandSeed. Any integer will do for a seed; integers of from 1 to 12 digits are good. If you later store a different integer into RandSeed, Calc will switch to a different pseudo-random sequence. If you “unstore” RandSeed, Calc will re-seed itself from the current time. If you store the same integer that you used before back into RandSeed, you will get the exact same sequence of random numbers as before.

The calc-rrandom command (not on any key) produces a random real number between zero and one. It is equivalent to ‘random(1.0)’.

The k a (calc-random-again) command produces another random number, re-using the most recent value of ‘M’. With a numeric prefix argument n, it produces n more random numbers using that value of ‘M’.

The k h (calc-shuffle) command produces a vector of several random values with no duplicates. The value on the top of the stack specifies the set from which the random values are drawn, and may be any of the ‘M’ formats described above. The numeric prefix argument gives the length of the desired list. (If you do not provide a numeric prefix argument, the length of the list is taken from the top of the stack, and ‘M’ from second-to-top.)

If ‘M’ is a floating-point number, zero, or an error form (so that the random values are being drawn from the set of real numbers) there is little practical difference between using k h and using k r several times. But if the set of possible values consists of just a few integers, or the elements of a vector, then there is a very real chance that multiple k r’s will produce the same number more than once. The k h command produces a vector whose elements are always distinct. (Actually, there is a slight exception: If ‘M’ is a vector, no given vector element will be drawn more than once, but if several elements of ‘M’ are equal, they may each make it into the result vector.)

One use of k h is to rearrange a list at random. This happens if the prefix argument is equal to the number of values in the list: [1, 1.5, 2, 2.5, 3] 5 k h might produce the permuted list ‘[2.5, 1, 1.5, 3, 2]’. As a convenient feature, if the argument n is negative it is replaced by the size of the set represented by ‘M’. Naturally, this is allowed only when ‘M’ specifies a small discrete set of possibilities.

To do the equivalent of k h but with duplications allowed, given ‘M’ on the stack and with n just entered as a numeric prefix, use v b to build a vector of copies of ‘M’, then use V M k r to “map” the normal k r function over the elements of this vector. See Vector/Matrix Functions.


**** Random Number Generator

Calc’s random number generator uses several methods to ensure that the numbers it produces are highly random. Knuth’s Art of Computer Programming, Volume II, contains a thorough description of the theory of random number generators and their measurement and characterization.

If RandSeed has no stored value, Calc calls Emacs’s built-in random function to get a stream of random numbers, which it then treats in various ways to avoid problems inherent in the simple random number generators that many systems use to implement random.

When Calc’s random number generator is first invoked, it “seeds” the low-level random sequence using the time of day, so that the random number sequence will be different every time you use Calc.

Since Emacs Lisp doesn’t specify the range of values that will be returned by its random function, Calc exercises the function several times to estimate the range. When Calc subsequently uses the random function, it takes only 10 bits of the result near the most-significant end. (It avoids at least the bottom four bits, preferably more, and also tries to avoid the top two bits.) This strategy works well with the linear congruential generators that are typically used to implement random.

If RandSeed contains an integer, Calc uses this integer to seed an “additive congruential” method (Knuth’s algorithm 3.2.2A, computing ‘X_n-55 - X_n-24’). This method expands the seed value into a large table which is maintained internally; the variable RandSeed is changed from, e.g., 42 to the vector ‘[42]’ to indicate that the seed has been absorbed into this table. When RandSeed contains a vector, k r and related commands continue to use the same internal table as last time. There is no way to extract the complete state of the random number generator so that you can restart it from any point; you can only restart it from the same initial seed value. A simple way to restart from the same seed is to type s r RandSeed to get the seed vector, v u to unpack it back into a number, then s t RandSeed to reseed the generator with that number.

Calc uses a “shuffling” method as described in algorithm 3.2.2B of Knuth. It fills a table with 13 random 10-bit numbers. Then, to generate a new random number, it uses the previous number to index into the table, picks the value it finds there as the new random number, then replaces that table entry with a new value obtained from a call to the base random number generator (either the additive congruential generator or the random function supplied by the system). If there are any flaws in the base generator, shuffling will tend to even them out. But if the system provides an excellent random function, shuffling will not damage its randomness.

To create a random integer of a certain number of digits, Calc builds the integer three decimal digits at a time. For each group of three digits, Calc calls its 10-bit shuffling random number generator (which returns a value from 0 to 1023); if the random value is 1000 or more, Calc throws it out and tries again until it gets a suitable value.

To create a random floating-point number with precision p, Calc simply creates a random p-digit integer and multiplies by ‘10^-p’. The resulting random numbers should be very clean, but note that relatively small numbers will have few significant random digits. In other words, with a precision of 12, you will occasionally get numbers on the order of ‘10^-9’ or ‘10^-10’, but those numbers will only have two or three random digits since they correspond to small integers times ‘10^-12’.

To create a random integer in the interval ‘[0 .. m)’, Calc counts the digits in m, creates a random integer with three additional digits, then reduces modulo m. Unless m is a power of ten the resulting values will be very slightly biased toward the lower numbers, but this bias will be less than 0.1%. (For example, if m is 42, Calc will reduce a random integer less than 100000 modulo 42 to get a result less than 42. It is easy to show that the numbers 40 and 41 will be only 2380/2381 as likely to result from this modulo operation as numbers 39 and below.) If m is a power of ten, however, the numbers should be completely unbiased.

The Gaussian random numbers generated by ‘random(0.0)’ use the “polar” method described in Knuth section 3.4.1C. This method generates a pair of Gaussian random numbers at a time, so only every other call to ‘random(0.0)’ will require significant calculations.


*** Combinatorial Functions

Commands relating to combinatorics and number theory begin with the k key prefix.

The k g (calc-gcd) [gcd] command computes the Greatest Common Divisor of two integers. It also accepts fractions; the GCD of two fractions is defined by taking the GCD of the numerators, and the LCM of the denominators. This definition is consistent with the idea that ‘a / gcd(a,x)’ should yield an integer for any ‘a’ and ‘x’. For other types of arguments, the operation is left in symbolic form.

The k l (calc-lcm) [lcm] command computes the Least Common Multiple of two integers or fractions. The product of the LCM and GCD of two numbers is equal to the absolute value of the product of the numbers.

The k E (calc-extended-gcd) [egcd] command computes the GCD of two integers ‘x’ and ‘y’ and returns a vector ‘[g, a, b]’ where ‘g = gcd(x,y) = a x + b y’.

The ! (calc-factorial) [fact] command computes the factorial of the number at the top of the stack. If the number is an integer, the result is an exact integer. If the number is an integer-valued float, the result is a floating-point approximation. If the number is a non-integral real number, the generalized factorial is used, as defined by the Euler Gamma function. Please note that computation of large factorials can be slow; using floating-point format will help since fewer digits must be maintained. The same is true of many of the commands in this section.

The k d (calc-double-factorial) [dfact] command computes the “double factorial” of an integer. For an even integer, this is the product of even integers from 2 to ‘N’. For an odd integer, this is the product of odd integers from 3 to ‘N’. If the argument is an integer-valued float, the result is a floating-point approximation. This function is undefined for negative even integers. The notation ‘N!!’ is also recognized for double factorials.

The k c (calc-choose) [choose] command computes the binomial coefficient ‘N’-choose-‘M’, where ‘M’ is the number on the top of the stack and ‘N’ is second-to-top. If both arguments are integers, the result is an exact integer. Otherwise, the result is a floating-point approximation. The binomial coefficient is defined for all real numbers by ‘N! / M! (N-M)!’.

The H k c (calc-perm) [perm] command computes the number-of-permutations function ‘N! / (N-M)!’.

The k b (calc-bernoulli-number) [bern] command computes a given Bernoulli number. The value at the top of the stack is a nonnegative integer ‘n’ that specifies which Bernoulli number is desired. The H k b command computes a Bernoulli polynomial, taking ‘n’ from the second-to-top position and ‘x’ from the top of the stack. If ‘x’ is a variable or formula the result is a polynomial in ‘x’; if ‘x’ is a number the result is a number.

The k e (calc-euler-number) [euler] command similarly computes an Euler number, and H k e computes an Euler polynomial. Bernoulli and Euler numbers occur in the Taylor expansions of several functions.

The k s (calc-stirling-number) [stir1] command computes a Stirling number of the first kind, given two integers ‘n’ and ‘m’ on the stack. The H k s [stir2] command computes a Stirling number of the second kind. These are the number of ‘m’-cycle permutations of ‘n’ objects, and the number of ways to partition ‘n’ objects into ‘m’ non-empty sets, respectively.

The k p (calc-prime-test) command checks if the integer on the top of the stack is prime. For integers less than eight million, the answer is always exact and reasonably fast. For larger integers, a probabilistic method is used (see Knuth vol. II, section 4.5.4, algorithm P). The number is first checked against small prime factors (up to 13). Then, any number of iterations of the algorithm are performed. Each step either discovers that the number is non-prime, or substantially increases the certainty that the number is prime. After a few steps, the chance that a number was mistakenly described as prime will be less than one percent. (Indeed, this is a worst-case estimate of the probability; in practice even a single iteration is quite reliable.) After the k p command, the number will be reported as definitely prime or non-prime if possible, or otherwise “probably” prime with a certain probability of error.

The normal k p command performs one iteration of the primality test. Pressing k p repeatedly for the same integer will perform additional iterations. Also, k p with a numeric prefix performs the specified number of iterations. There is also an algebraic function ‘prime(n)’ or ‘prime(n,iters)’ which returns 1 if ‘n’ is (probably) prime and 0 if not.

The k f (calc-prime-factors) [prfac] command attempts to decompose an integer into its prime factors. For numbers up to 25 million, the answer is exact although it may take some time. The result is a vector of the prime factors in increasing order. For larger inputs, prime factors above 5000 may not be found, in which case the last number in the vector will be an unfactored integer greater than 25 million (with a warning message). For negative integers, the first element of the list will be -1. For inputs -1, 0, and 1, the result is a list of the same number.

The k n (calc-next-prime) [nextprime] command finds the next prime above a given number. Essentially, it searches by calling calc-prime-test on successive integers until it finds one that passes the test. This is quite fast for integers less than eight million, but once the probabilistic test comes into play the search may be rather slow. Ordinarily this command stops for any prime that passes one iteration of the primality test. With a numeric prefix argument, a number must pass the specified number of iterations before the search stops. (This only matters when searching above eight million.) You can always use additional k p commands to increase your certainty that the number is indeed prime.

The I k n (calc-prev-prime) [prevprime] command analogously finds the next prime less than a given number.

The k t (calc-totient) [totient] command computes the Euler “totient” function, the number of integers less than ‘n’ which are relatively prime to ‘n’.

The k m (calc-moebius) [moebius] command computes the Möbius μ function. If the input number is a product of ‘k’ distinct factors, this is ‘(-1)^k’. If the input number has any duplicate factors (i.e., can be divided by the same prime more than once), the result is zero.


*** Probability Distribution Functions

The functions in this section compute various probability distributions. For continuous distributions, this is the integral of the probability density function from ‘x’ to infinity. (These are the “upper tail” distribution functions; there are also corresponding “lower tail” functions which integrate from minus infinity to ‘x’.) For discrete distributions, the upper tail function gives the sum from ‘x’ to infinity; the lower tail function gives the sum from minus infinity up to, but not including, ‘x’.

To integrate from ‘x’ to ‘y’, just use the distribution function twice and subtract. For example, the probability that a Gaussian random variable with mean 2 and standard deviation 1 will lie in the range from 2.5 to 2.8 is ‘utpn(2.5,2,1) - utpn(2.8,2,1)’ (“the probability that it is greater than 2.5, but not greater than 2.8”), or equivalently ‘ltpn(2.8,2,1) - ltpn(2.5,2,1)’.

The k B (calc-utpb) [utpb] function uses the binomial distribution. Push the parameters n, p, and then x onto the stack; the result (‘utpb(x,n,p)’) is the probability that an event will occur x or more times out of n trials, if its probability of occurring in any given trial is p. The I k B [ltpb] function is the probability that the event will occur fewer than x times.

The other probability distribution functions similarly take the form k X (calc-utpx) [utpx] and I k X [ltpx], for various letters x. The arguments to the algebraic functions are the value of the random variable first, then whatever other parameters define the distribution. Note these are among the few Calc functions where the order of the arguments in algebraic form differs from the order of arguments as found on the stack. (The random variable comes last on the stack, so that you can type, e.g., 2 RET 1 RET 2.5 k N M-RET DEL 2.8 k N -, using M-RET DEL to recover the original arguments but substitute a new value for ‘x’.)

The ‘utpc(x,v)’ function uses the chi-square distribution with ‘v’ degrees of freedom. It is the probability that a model is correct if its chi-square statistic is ‘x’.

The ‘utpf(F,v1,v2)’ function uses the F distribution, used in various statistical tests. The parameters ‘v1’ and ‘v2’ are the degrees of freedom in the numerator and denominator, respectively, used in computing the statistic ‘F’.

The ‘utpn(x,m,s)’ function uses a normal (Gaussian) distribution with mean ‘m’ and standard deviation ‘s’. It is the probability that such a normal-distributed random variable would exceed ‘x’.

The ‘utpp(n,x)’ function uses a Poisson distribution with mean ‘x’. It is the probability that ‘n’ or more such Poisson random events will occur.

The ‘utpt(t,v)’ function uses the Student’s “t” distribution with ‘v’ degrees of freedom. It is the probability that a t-distributed random variable will be greater than ‘t’. (Note: This computes the distribution function ‘A(t|v)’ where ‘A(0|v) = 1’ and ‘A(inf|v) -> 0’. The UTPT operation on the HP-48 uses a different definition which returns half of Calc’s value: ‘UTPT(t,v) = .5*utpt(t,v)’.)

While Calc does not provide inverses of the probability distribution functions, the a R command can be used to solve for the inverse. Since the distribution functions are monotonic, a R is guaranteed to be able to find a solution given any initial guess. See Numerical Solutions.


** Vector/Matrix Functions

Many of the commands described here begin with the v prefix. (For convenience, the shift-V prefix is equivalent to v.) The commands usually apply to both plain vectors and matrices; some apply only to matrices or only to square matrices. If the argument has the wrong dimensions the operation is left in symbolic form.

Vectors are entered and displayed using ‘[a,b,c]’ notation. Matrices are vectors of which all elements are vectors of equal length. (Though none of the standard Calc commands use this concept, a three-dimensional matrix or rank-3 tensor could be defined as a vector of matrices, and so on.)

*** Packing and Unpacking

Calc’s “pack” and “unpack” commands collect stack entries to build composite objects such as vectors and complex numbers. They are described in this chapter because they are most often used to build vectors.

The v p (calc-pack) [pack] command collects several elements from the stack into a matrix, complex number, HMS form, error form, etc. It uses a numeric prefix argument to specify the kind of object to be built; this argument is referred to as the “packing mode.” If the packing mode is a nonnegative integer, a vector of that length is created. For example, C-u 5 v p will pop the top five stack elements and push back a single vector of those five elements. (C-u 0 v p simply creates an empty vector.)

The same effect can be had by pressing [ to push an incomplete vector on the stack, using TAB (calc-roll-down) to sneak the incomplete object up past a certain number of elements, and then pressing ] to complete the vector.

Negative packing modes create other kinds of composite objects:

-1
Two values are collected to build a complex number. For example, 5 RET 7 C-u -1 v p creates the complex number ‘(5, 7)’. The result is always a rectangular complex number. The two input values must both be real numbers, i.e., integers, fractions, or floats. If they are not, Calc will instead build a formula like ‘a + (0, 1) b’. (The other packing modes also create a symbolic answer if the components are not suitable.)

-2
Two values are collected to build a polar complex number. The first is the magnitude; the second is the phase expressed in either degrees or radians according to the current angular mode.

-3
Three values are collected into an HMS form. The first two values (hours and minutes) must be integers or integer-valued floats. The third value may be any real number.

-4
Two values are collected into an error form. The inputs may be real numbers or formulas.

-5
Two values are collected into a modulo form. The inputs must be real numbers.

-6
Two values are collected into the interval ‘[a .. b]’. The inputs may be real numbers, HMS or date forms, or formulas.

-7
Two values are collected into the interval ‘[a .. b)’.

-8
Two values are collected into the interval ‘(a .. b]’.

-9
Two values are collected into the interval ‘(a .. b)’.

-10
Two integer values are collected into a fraction.

-11
Two values are collected into a floating-point number. The first is the mantissa; the second, which must be an integer, is the exponent. The result is the mantissa times ten to the power of the exponent.

-12
This is treated the same as -11 by the v p command. When unpacking, -12 specifies that a floating-point mantissa is desired.

-13
A real number is converted into a date form.

-14
Three numbers (year, month, day) are packed into a pure date form.

-15
Six numbers are packed into a date/time form.

With any of the two-input negative packing modes, either or both of the inputs may be vectors. If both are vectors of the same length, the result is another vector made by packing corresponding elements of the input vectors. If one input is a vector and the other is a plain number, the number is packed along with each vector element to produce a new vector. For example, C-u -4 v p could be used to convert a vector of numbers and a vector of errors into a single vector of error forms; C-u -5 v p could convert a vector of numbers and a single number M into a vector of numbers modulo M.

If you don’t give a prefix argument to v p, it takes the packing mode from the top of the stack. The elements to be packed then begin at stack level 2. Thus 1 RET 2 RET 4 n v p is another way to enter the error form ‘1 +/- 2’.

If the packing mode taken from the stack is a vector, the result is a matrix with the dimensions specified by the elements of the vector, which must each be integers. For example, if the packing mode is ‘[2, 3]’, then six numbers will be taken from the stack and returned in the form ‘[[a, b, c], [d, e, f]]’.

If any elements of the vector are negative, other kinds of packing are done at that level as described above. For example, ‘[2, 3, -4]’ takes 12 objects and creates a 2x3 matrix of error forms: ‘[[a +/- b, c +/- d ... ]]’. Also, ‘[-4, -10]’ will convert four integers into an error form consisting of two fractions: ‘a:b +/- c:d’.

There is an equivalent algebraic function, ‘pack(mode, items)’ where mode is a packing mode (an integer or a vector of integers) and items is a vector of objects to be packed (re-packed, really) according to that mode. For example, ‘pack([3, -4], [a,b,c,d,e,f])’ yields ‘[a +/- b, c +/- d, e +/- f]’. The function is left in symbolic form if the packing mode is invalid, or if the number of data items does not match the number of items required by the mode.

The v u (calc-unpack) command takes the vector, complex number, HMS form, or other composite object on the top of the stack and “unpacks” it, pushing each of its elements onto the stack as separate objects. Thus, it is the “inverse” of v p. If the value at the top of the stack is a formula, v u unpacks it by pushing each of the arguments of the top-level operator onto the stack.

You can optionally give a numeric prefix argument to v u to specify an explicit (un)packing mode. If the packing mode is negative and the input is actually a vector or matrix, the result will be two or more similar vectors or matrices of the elements. For example, given the vector ‘[a +/- b, c^2, d +/- 7]’, the result of C-u -4 v u will be the two vectors ‘[a, c^2, d]’ and ‘[b, 0, 7]’.

Note that the prefix argument can have an effect even when the input is not a vector. For example, if the input is the number -5, then c-u -1 v u yields -5 and 0 (the components of -5 when viewed as a rectangular complex number); C-u -2 v u yields 5 and 180 (assuming Degrees mode); and C-u -10 v u yields -5 and 1 (the numerator and denominator of -5, viewed as a rational number). Plain v u with this input would complain that the input is not a composite object.

Unpacking mode -11 converts a float into an integer mantissa and an integer exponent, where the mantissa is not divisible by 10 (except that 0.0 is represented by a mantissa and exponent of 0). Unpacking mode -12 converts a float into a floating-point mantissa and integer exponent, where the mantissa (for non-zero numbers) is guaranteed to lie in the range [1 .. 10). In both cases, the mantissa is shifted left or right (and the exponent adjusted to compensate) in order to satisfy these constraints.

Positive unpacking modes are treated differently than for v p. A mode of 1 is much like plain v u with no prefix argument, except that in addition to the components of the input object, a suitable packing mode to re-pack the object is also pushed. Thus, C-u 1 v u followed by v p will re-build the original object.

A mode of 2 unpacks two levels of the object; the resulting re-packing mode will be a vector of length 2. This might be used to unpack a matrix, say, or a vector of error forms. Higher unpacking modes unpack the input even more deeply.

There are two algebraic functions analogous to v u. The ‘unpack(mode, item)’ function unpacks the item using the given mode, returning the result as a vector of components. Here the mode must be an integer, not a vector. For example, ‘unpack(-4, a +/- b)’ returns ‘[a, b]’, as does ‘unpack(1, a +/- b)’.

The unpackt function is like unpack but instead of returning a simple vector of items, it returns a vector of two things: The mode, and the vector of items. For example, ‘unpackt(1, 2:3 +/- 1:4)’ returns ‘[-4, [2:3, 1:4]]’, and ‘unpackt(2, 2:3 +/- 1:4)’ returns ‘[[-4, -10], [2, 3, 1, 4]]’. The identity for re-building the original object is ‘apply(pack, unpackt(n, x)) = x’. (The apply function builds a function call given the function name and a vector of arguments.)

Subscript notation is a useful way to extract a particular part of an object. For example, to get the numerator of a rational number, you can use ‘unpack(-10, x)_1’.


*** Building Vectors

Vectors and matrices can be added, subtracted, multiplied, and divided; see Basic Arithmetic.

The | (calc-concat) [vconcat] command “concatenates” two vectors into one. For example, after [ 1 , 2 ] [ 3 , 4 ] |, the stack will contain the single vector ‘[1, 2, 3, 4]’. If the arguments are matrices, the rows of the first matrix are concatenated with the rows of the second. (In other words, two matrices are just two vectors of row-vectors as far as | is concerned.)

If either argument to | is a scalar (a non-vector), it is treated like a one-element vector for purposes of concatenation: 1 [ 2 , 3 ] | produces the vector ‘[1, 2, 3]’. Likewise, if one argument is a matrix and the other is a plain vector, the vector is treated as a one-row matrix.

The H | (calc-append) [append] command concatenates two vectors without any special cases. Both inputs must be vectors. Whether or not they are matrices is not taken into account. If either argument is a scalar, the append function is left in symbolic form. See also cons and rcons below.

The I | and H I | commands are similar, but they use their two stack arguments in the opposite order. Thus I | is equivalent to TAB |, but possibly more convenient and also a bit faster.

The v d (calc-diag) [diag] function builds a diagonal square matrix. The optional numeric prefix gives the number of rows and columns in the matrix. If the value at the top of the stack is a vector, the elements of the vector are used as the diagonal elements; the prefix, if specified, must match the size of the vector. If the value on the stack is a scalar, it is used for each element on the diagonal, and the prefix argument is required.

To build a constant square matrix, e.g., a 3x3 matrix filled with ones, use 0 M-3 v d 1 +, i.e., build a zero matrix first and then add a constant value to that matrix. (Another alternative would be to use v b and v a; see below.)

The v i (calc-ident) [idn] function builds an identity matrix of the specified size. It is a convenient form of v d where the diagonal element is always one. If no prefix argument is given, this command prompts for one.

In algebraic notation, ‘idn(a,n)’ acts much like ‘diag(a,n)’, except that ‘a’ is required to be a scalar (non-vector) quantity. If ‘n’ is omitted, ‘idn(a)’ represents ‘a’ times an identity matrix of unknown size. Calc can operate algebraically on such generic identity matrices, and if one is combined with a matrix whose size is known, it is converted automatically to an identity matrix of a suitable matching size. The v i command with an argument of zero creates a generic identity matrix, ‘idn(1)’. Note that in dimensioned Matrix mode (see Matrix and Scalar Modes), generic identity matrices are immediately expanded to the current default dimensions.

The v x (calc-index) [index] function builds a vector of consecutive integers from 1 to n, where n is the numeric prefix argument. If you do not provide a prefix argument, you will be prompted to enter a suitable number. If n is negative, the result is a vector of negative integers from n to -1.

With a prefix argument of just C-u, the v x command takes three values from the stack: n, start, and incr (with incr at top-of-stack). Counting starts at start and increases by incr for successive vector elements. If start or n is in floating-point format, the resulting vector elements will also be floats. Note that start and incr may in fact be any kind of numbers or formulas.

When start and incr are specified, a negative n has a different interpretation: It causes a geometric instead of arithmetic sequence to be generated. For example, ‘index(-3, a, b)’ produces ‘[a, a b, a b^2]’. If you omit incr in the algebraic form, ‘index(n, start)’, the default value for incr is one for positive n or two for negative n.

The v b (calc-build-vector) [cvec] function builds a vector of n copies of the value on the top of the stack, where n is the numeric prefix argument. In algebraic formulas, ‘cvec(x,n,m)’ can also be used to build an n-by-m matrix of copies of x. (Interactively, just use v b twice: once to build a row, then again to build a matrix of copies of that row.)

The v h (calc-head) [head] function returns the first element of a vector. The I v h (calc-tail) [tail] function returns the vector with its first element removed. In both cases, the argument must be a non-empty vector.

The v k (calc-cons) [cons] function takes a value h and a vector t from the stack, and produces the vector whose head is h and whose tail is t. This is similar to |, except if h is itself a vector, | will concatenate the two vectors whereas cons will insert h at the front of the vector t.

Each of these three functions also accepts the Hyperbolic flag [rhead, rtail, rcons] in which case t instead represents the last single element of the vector, with h representing the remainder of the vector. Thus the vector ‘[a, b, c, d] = cons(a, [b, c, d]) = rcons([a, b, c], d)’. Also, ‘head([a, b, c, d]) = a’, ‘tail([a, b, c, d]) = [b, c, d]’, ‘rhead([a, b, c, d]) = [a, b, c]’, and ‘rtail([a, b, c, d]) = d’.


*** Extracting Vector Elements

The v r (calc-mrow) [mrow] command extracts one row of the matrix on the top of the stack, or one element of the plain vector on the top of the stack. The row or element is specified by the numeric prefix argument; the default is to prompt for the row or element number. The matrix or vector is replaced by the specified row or element in the form of a vector or scalar, respectively.

With a prefix argument of C-u only, v r takes the index of the element or row from the top of the stack, and the vector or matrix from the second-to-top position. If the index is itself a vector of integers, the result is a vector of the corresponding elements of the input vector, or a matrix of the corresponding rows of the input matrix. This command can be used to obtain any permutation of a vector.

With C-u, if the index is an interval form with integer components, it is interpreted as a range of indices and the corresponding subvector or submatrix is returned.

Subscript notation in algebraic formulas (‘a_b’) stands for the Calc function subscr, which is synonymous with mrow. Thus, ‘[x, y, z]_k’ produces ‘x’, ‘y’, or ‘z’ if ‘k’ is one, two, or three, respectively. A double subscript (‘M_i_j’, equivalent to ‘subscr(subscr(M, i), j)’) will access the element at row ‘i’, column ‘j’ of a matrix. The a _ (calc-subscript) command creates a subscript formula ‘a_b’ out of two stack entries. (It is on the a “algebra” prefix because subscripted variables are often used purely as an algebraic notation.)

Given a negative prefix argument, v r instead deletes one row or element from the matrix or vector on the top of the stack. Thus C-u 2 v r replaces a matrix with its second row, but C-u -2 v r replaces the matrix with the same matrix with its second row removed. In algebraic form this function is called mrrow.

Given a prefix argument of zero, v r extracts the diagonal elements of a square matrix in the form of a vector. In algebraic form this function is called getdiag.

The v c (calc-mcol) [mcol or mrcol] command is the analogous operation on columns of a matrix. Given a plain vector it extracts (or removes) one element, just like v r. If the index in C-u v c is an interval or vector and the argument is a matrix, the result is a submatrix with only the specified columns retained (and possibly permuted in the case of a vector index).

To extract a matrix element at a given row and column, use v r to extract the row as a vector, then v c to extract the column element from that vector. In algebraic formulas, it is often more convenient to use subscript notation: ‘m_i_j’ gives row ‘i’, column ‘j’ of matrix ‘m’.

The v s (calc-subvector) [subvec] command extracts a subvector of a vector. The arguments are the vector, the starting index, and the ending index, with the ending index in the top-of-stack position. The starting index indicates the first element of the vector to take. The ending index indicates the first element past the range to be taken. Thus, ‘subvec([a, b, c, d, e], 2, 4)’ produces the subvector ‘[b, c]’. You could get the same result using ‘mrow([a, b, c, d, e], [2 .. 4))’.

If either the start or the end index is zero or negative, it is interpreted as relative to the end of the vector. Thus ‘subvec([a, b, c, d, e], 2, -2)’ also produces ‘[b, c]’. In the algebraic form, the end index can be omitted in which case it is taken as zero, i.e., elements from the starting element to the end of the vector are used. The infinity symbol, inf, also has this effect when used as the ending index.

With the Inverse flag, I v s [rsubvec] removes a subvector from a vector. The arguments are interpreted the same as for the normal v s command. Thus, ‘rsubvec([a, b, c, d, e], 2, 4)’ produces ‘[a, d, e]’. It is always true that subvec and rsubvec return complementary parts of the input vector.

See Selecting Sub-Formulas, for an alternative way to operate on vectors one element at a time.


*** Manipulating Vectors

The v l (calc-vlength) [vlen] command computes the length of a vector. The length of a non-vector is considered to be zero. Note that matrices are just vectors of vectors for the purposes of this command.

With the Hyperbolic flag, H v l [mdims] computes a vector of the dimensions of a vector, matrix, or higher-order object. For example, ‘mdims([[a,b,c],[d,e,f]])’ returns ‘[2, 3]’ since its argument is a 2x3 matrix.

The v f (calc-vector-find) [find] command searches along a vector for the first element equal to a given target. The target is on the top of the stack; the vector is in the second-to-top position. If a match is found, the result is the index of the matching element. Otherwise, the result is zero. The numeric prefix argument, if given, allows you to select any starting index for the search.

The v a (calc-arrange-vector) [arrange] command rearranges a vector to have a certain number of columns and rows. The numeric prefix argument specifies the number of columns; if you do not provide an argument, you will be prompted for the number of columns. The vector or matrix on the top of the stack is flattened into a plain vector. If the number of columns is nonzero, this vector is then formed into a matrix by taking successive groups of n elements. If the number of columns does not evenly divide the number of elements in the vector, the last row will be short and the result will not be suitable for use as a matrix. For example, with the matrix ‘[[1, 2], [3, 4]]’ on the stack, v a 4 produces ‘[[1, 2, 3, 4]]’ (a 1x4 matrix), v a 1 produces ‘[[1], [2], [3], [4]]’ (a 4x1 matrix), v a 2 produces ‘[[1, 2], [3, 4]]’ (the original 2x2 matrix), v a 3 produces ‘[[1, 2, 3], [4]]’ (not a matrix), and v a 0 produces the flattened list ‘[1, 2, 3, 4]’.

The V S (calc-sort) [sort] command sorts the elements of a vector into increasing order. Real numbers, real infinities, and constant interval forms come first in this ordering; next come other kinds of numbers, then variables (in alphabetical order), then finally come formulas and other kinds of objects; these are sorted according to a kind of lexicographic ordering with the useful property that one vector is less or greater than another if the first corresponding unequal elements are less or greater, respectively. Since quoted strings are stored by Calc internally as vectors of ASCII character codes (see Strings), this means vectors of strings are also sorted into alphabetical order by this command.

The I V S [rsort] command sorts a vector into decreasing order.

The V G (calc-grade) [grade, rgrade] command produces an index table or permutation vector which, if applied to the input vector (as the index of C-u v r, say), would sort the vector. A permutation vector is just a vector of integers from 1 to n, where each integer occurs exactly once. One application of this is to sort a matrix of data rows using one column as the sort key; extract that column, grade it with V G, then use the result to reorder the original matrix with C-u v r. Another interesting property of the V G command is that, if the input is itself a permutation vector, the result will be the inverse of the permutation. The inverse of an index table is a rank table, whose kth element says where the kth original vector element will rest when the vector is sorted. To get a rank table, just use V G V G.

With the Inverse flag, I V G produces an index table that would sort the input into decreasing order. Note that V S and V G use a “stable” sorting algorithm, i.e., any two elements which are equal will not be moved out of their original order. Generally there is no way to tell with V S, since two elements which are equal look the same, but with V G this can be an important issue. In the matrix-of-rows example, suppose you have names and telephone numbers as two columns and you wish to sort by phone number primarily, and by name when the numbers are equal. You can sort the data matrix by names first, and then again by phone numbers. Because the sort is stable, any two rows with equal phone numbers will remain sorted by name even after the second sort.

The V H (calc-histogram) [histogram] command builds a histogram of a vector of numbers. Vector elements are assumed to be integers or real numbers in the range [0..n) for some “number of bins” n, which is the numeric prefix argument given to the command. The result is a vector of n counts of how many times each value appeared in the original vector. Non-integers in the input are rounded down to integers. Any vector elements outside the specified range are ignored. (You can tell if elements have been ignored by noting that the counts in the result vector don’t add up to the length of the input vector.)

If no prefix is given, then you will be prompted for a vector which will be used to determine the bins. (If a positive integer is given at this prompt, it will be still treated as if it were given as a prefix.) Each bin will consist of the interval of numbers closest to the corresponding number of this new vector; if the vector ‘[a, b, c, ...]’ is entered at the prompt, the bins will be ‘(-inf, (a+b)/2]’, ‘((a+b)/2, (b+c)/2]’, etc. The result of this command will be a vector counting how many elements of the original vector are in each bin.

The result will then be a vector with the same length as this new vector; each element of the new vector will be replaced by the number of elements of the original vector which are closest to it.

With the Hyperbolic flag, H V H pulls two vectors from the stack. The second-to-top vector is the list of numbers as before. The top vector is an equal-sized list of “weights” to attach to the elements of the data vector. For example, if the first data element is 4.2 and the first weight is 10, then 10 will be added to bin 4 of the result vector. Without the hyperbolic flag, every element has a weight of one.

The v t (calc-transpose) [trn] command computes the transpose of the matrix at the top of the stack. If the argument is a plain vector, it is treated as a row vector and transposed into a one-column matrix.

The v v (calc-reverse-vector) [rev] command reverses a vector end-for-end. Given a matrix, it reverses the order of the rows. (To reverse the columns instead, just use v t v v v t. The same principle can be used to apply other vector commands to the columns of a matrix.)

The v m (calc-mask-vector) [vmask] command uses one vector as a mask to extract elements of another vector. The mask is in the second-to-top position; the target vector is on the top of the stack. These vectors must have the same length. The result is the same as the target vector, but with all elements which correspond to zeros in the mask vector deleted. Thus, for example, ‘vmask([1, 0, 1, 0, 1], [a, b, c, d, e])’ produces ‘[a, c, e]’. See Logical Operations.

The v e (calc-expand-vector) [vexp] command expands a vector according to another mask vector. The result is a vector the same length as the mask, but with nonzero elements replaced by successive elements from the target vector. The length of the target vector is normally the number of nonzero elements in the mask. If the target vector is longer, its last few elements are lost. If the target vector is shorter, the last few nonzero mask elements are left unreplaced in the result. Thus ‘vexp([2, 0, 3, 0, 7], [a, b])’ produces ‘[a, 0, b, 0, 7]’.

With the Hyperbolic flag, H v e takes a filler value from the top of the stack; the mask and target vectors come from the third and second elements of the stack. This filler is used where the mask is zero: ‘vexp([2, 0, 3, 0, 7], [a, b], z)’ produces ‘[a, z, c, z, 7]’. If the filler value is itself a vector, then successive values are taken from it, so that the effect is to interleave two vectors according to the mask: ‘vexp([2, 0, 3, 7, 0, 0], [a, b], [x, y])’ produces ‘[a, x, b, 7, y, 0]’.

Another variation on the masking idea is to combine ‘[a, b, c, d, e]’ with the mask ‘[1, 0, 1, 0, 1]’ to produce ‘[a, 0, c, 0, e]’. You can accomplish this with V M a &, mapping the logical “and” operation across the two vectors. See Logical Operations. Note that the ? : operation also discussed there allows other types of masking using vectors.


*** Vector and Matrix Arithmetic

Basic arithmetic operations like addition and multiplication are defined for vectors and matrices as well as for numbers. Division of matrices, in the sense of multiplying by the inverse, is supported. (Division by a matrix actually uses LU-decomposition for greater accuracy and speed.) See Basic Arithmetic.

The following functions are applied element-wise if their arguments are vectors or matrices: change-sign, conj, arg, re, im, polar, rect, clean, float, frac. See Index of Algebraic Functions.

The V J (calc-conj-transpose) [ctrn] command computes the conjugate transpose of its argument, i.e., ‘conj(trn(x))’.

The A (calc-abs) [abs] command computes the Frobenius norm of a vector or matrix argument. This is the square root of the sum of the squares of the absolute values of the elements of the vector or matrix. If the vector is interpreted as a point in two- or three-dimensional space, this is the distance from that point to the origin.

The v n (calc-rnorm) [rnorm] command computes the infinity-norm of a vector, or the row norm of a matrix. For a plain vector, this is the maximum of the absolute values of the elements. For a matrix, this is the maximum of the row-absolute-value-sums, i.e., of the sums of the absolute values of the elements along the various rows.

The V N (calc-cnorm) [cnorm] command computes the one-norm of a vector, or column norm of a matrix. For a plain vector, this is the sum of the absolute values of the elements. For a matrix, this is the maximum of the column-absolute-value-sums. General ‘k’-norms for ‘k’ other than one or infinity are not provided. However, the 2-norm (or Frobenius norm) is provided for vectors by the A (calc-abs) command.

The V C (calc-cross) [cross] command computes the right-handed cross product of two vectors, each of which must have exactly three elements.

The & (calc-inv) [inv] command computes the inverse of a square matrix. If the matrix is singular, the inverse operation is left in symbolic form. Matrix inverses are recorded so that once an inverse (or determinant) of a particular matrix has been computed, the inverse and determinant of the matrix can be recomputed quickly in the future.

If the argument to & is a plain number ‘x’, this command simply computes ‘1/x’. This is okay, because the ‘/’ operator also does a matrix inversion when dividing one by a matrix.

The V D (calc-mdet) [det] command computes the determinant of a square matrix.

The V L (calc-mlud) [lud] command computes the LU decomposition of a matrix. The result is a list of three matrices which, when multiplied together left-to-right, form the original matrix. The first is a permutation matrix that arises from pivoting in the algorithm, the second is lower-triangular with ones on the diagonal, and the third is upper-triangular.

The V T (calc-mtrace) [tr] command computes the trace of a square matrix. This is defined as the sum of the diagonal elements of the matrix.

The V K (calc-kron) [kron] command computes the Kronecker product of two matrices.


*** Set Operations using Vectors

Calc includes several commands which interpret vectors as sets of objects. A set is a collection of objects; any given object can appear only once in the set. Calc stores sets as vectors of objects in sorted order. Objects in a Calc set can be any of the usual things, such as numbers, variables, or formulas. Two set elements are considered equal if they are identical, except that numerically equal numbers like the integer 4 and the float 4.0 are considered equal even though they are not “identical.” Variables are treated like plain symbols without attached values by the set operations; subtracting the set ‘[b]’ from ‘[a, b]’ always yields the set ‘[a]’ even though if the variables ‘a’ and ‘b’ both equaled 17, you might expect the answer ‘[]’.

If a set contains interval forms, then it is assumed to be a set of real numbers. In this case, all set operations require the elements of the set to be only things that are allowed in intervals: Real numbers, plus and minus infinity, HMS forms, and date forms. If there are variables or other non-real objects present in a real set, all set operations on it will be left in unevaluated form.

If the input to a set operation is a plain number or interval form a, it is treated like the one-element vector ‘[a]’. The result is always a vector, except that if the set consists of a single interval, the interval itself is returned instead.

See Logical Operations, for the in function which tests if a certain value is a member of a given set. To test if the set ‘A’ is a subset of the set ‘B’, use ‘vdiff(A, B) = []’.

The V + (calc-remove-duplicates) [rdup] command converts an arbitrary vector into set notation. It works by sorting the vector as if by V S, then removing duplicates. (For example, [a, 5, 4, a, 4.0] is sorted to ‘[4, 4.0, 5, a, a]’ and then reduced to ‘[4, 5, a]’). Overlapping intervals are merged as necessary. You rarely need to use V + explicitly, since all the other set-based commands apply V + to their inputs before using them.

The V V (calc-set-union) [vunion] command computes the union of two sets. An object is in the union of two sets if and only if it is in either (or both) of the input sets. (You could accomplish the same thing by concatenating the sets with |, then using V +.)

The V ^ (calc-set-intersect) [vint] command computes the intersection of two sets. An object is in the intersection if and only if it is in both of the input sets. Thus if the input sets are disjoint, i.e., if they share no common elements, the result will be the empty vector ‘[]’. Note that the characters V and ^ were chosen to be close to the conventional mathematical notation for set union and intersection.

The V - (calc-set-difference) [vdiff] command computes the difference between two sets. An object is in the difference ‘A - B’ if and only if it is in ‘A’ but not in ‘B’. Thus subtracting ‘[y,z]’ from a set will remove the elements ‘y’ and ‘z’ if they are present. You can also think of this as a general set complement operator; if ‘A’ is the set of all possible values, then ‘A - B’ is the “complement” of ‘B’. Obviously this is only practical if the set of all possible values in your problem is small enough to list in a Calc vector (or simple enough to express in a few intervals).

The V X (calc-set-xor) [vxor] command computes the “exclusive-or,” or “symmetric difference” of two sets. An object is in the symmetric difference of two sets if and only if it is in one, but not both, of the sets. Objects that occur in both sets “cancel out.”

The V ~ (calc-set-complement) [vcompl] command computes the complement of a set with respect to the real numbers. Thus ‘vcompl(x)’ is equivalent to ‘vdiff([-inf .. inf], x)’. For example, ‘vcompl([2, (3 .. 4]])’ evaluates to ‘[[-inf .. 2), (2 .. 3], (4 .. inf]]’.

The V F (calc-set-floor) [vfloor] command reinterprets a set as a set of integers. Any non-integer values, and intervals that do not enclose any integers, are removed. Open intervals are converted to equivalent closed intervals. Successive integers are converted into intervals of integers. For example, the complement of the set ‘[2, 6, 7, 8]’ is messy, but if you wanted the complement with respect to the set of integers you could type V ~ V F to get ‘[[-inf .. 1], [3 .. 5], [9 .. inf]]’.

The V E (calc-set-enumerate) [venum] command converts a set of integers into an explicit vector. Intervals in the set are expanded out to lists of all integers encompassed by the intervals. This only works for finite sets (i.e., sets which do not involve ‘-inf’ or ‘inf’).

The V : (calc-set-span) [vspan] command converts any set of reals into an interval form that encompasses all its elements. The lower limit will be the smallest element in the set; the upper limit will be the largest element. For an empty set, ‘vspan([])’ returns the empty interval ‘[0 .. 0)’.

The V # (calc-set-cardinality) [vcard] command counts the number of integers in a set. The result is the length of the vector that would be produced by V E, although the computation is much more efficient than actually producing that vector.

Another representation for sets that may be more appropriate in some cases is binary numbers. If you are dealing with sets of integers in the range 0 to 49, you can use a 50-bit binary number where a particular bit is 1 if the corresponding element is in the set. See Binary Number Functions, for a list of commands that operate on binary numbers. Note that many of the above set operations have direct equivalents in binary arithmetic: b o (calc-or), b a (calc-and), b d (calc-diff), b x (calc-xor), and b n (calc-not), respectively. You can use whatever representation for sets is most convenient to you.

The b u (calc-unpack-bits) [vunpack] command converts an integer that represents a set in binary into a set in vector/interval notation. For example, ‘vunpack(67)’ returns ‘[[0 .. 1], 6]’. If the input is negative, the set it represents is semi-infinite: ‘vunpack(-4) = [2 .. inf)’. Use V E afterwards to expand intervals to individual values if you wish. Note that this command uses the b (binary) prefix key.

The b p (calc-pack-bits) [vpack] command converts the other way, from a vector or interval representing a set of nonnegative integers into a binary integer describing the same set. The set may include positive infinity, but must not include any negative numbers. The input is interpreted as a set of integers in the sense of V F (vfloor). Beware that a simple input like ‘[100]’ can result in a huge integer representation (‘2^100’, a 31-digit integer, in this case).


*** Statistical Operations on Vectors

The commands in this section take vectors as arguments and compute various statistical measures on the data stored in the vectors. The references used in the definitions of these functions are Bevington’s Data Reduction and Error Analysis for the Physical Sciences, and Numerical Recipes by Press, Flannery, Teukolsky and Vetterling.

The statistical commands use the u prefix key followed by a shifted letter or other character.

See Manipulating Vectors, for a description of V H (calc-histogram).

See Curve Fitting, for the a F command for doing least-squares fits to statistical data.

See Probability Distribution Functions, for several common probability distribution functions.

**** Single-Variable Statistics

These functions do various statistical computations on single vectors. Given a numeric prefix argument, they actually pop n objects from the stack and combine them into a data vector. Each object may be either a number or a vector; if a vector, any sub-vectors inside it are “flattened” as if by v a 0; see Manipulating Vectors. By default one object is popped, which (in order to be useful) is usually a vector.

If an argument is a variable name, and the value stored in that variable is a vector, then the stored vector is used. This method has the advantage that if your data vector is large, you can avoid the slow process of manipulating it directly on the stack.

These functions are left in symbolic form if any of their arguments are not numbers or vectors, e.g., if an argument is a formula, or a non-vector variable. However, formulas embedded within vector arguments are accepted; the result is a symbolic representation of the computation, based on the assumption that the formula does not itself represent a vector. All varieties of numbers such as error forms and interval forms are acceptable.

Some of the functions in this section also accept a single error form or interval as an argument. They then describe a property of the normal or uniform (respectively) statistical distribution described by the argument. The arguments are interpreted in the same way as the M argument of the random number function k r. In particular, an interval with integer limits is considered an integer distribution, so that ‘[2 .. 6)’ is the same as ‘[2 .. 5]’. An interval with at least one floating-point limit is a continuous distribution: ‘[2.0 .. 6.0)’ is not the same as ‘[2.0 .. 5.0]’!

The u # (calc-vector-count) [vcount] command computes the number of data values represented by the inputs. For example, ‘vcount(1, [2, 3], [[4, 5], [], x, y])’ returns 7. If the argument is a single vector with no sub-vectors, this simply computes the length of the vector.

The u + (calc-vector-sum) [vsum] command computes the sum of the data values. The u * (calc-vector-prod) [vprod] command computes the product of the data values. If the input is a single flat vector, these are the same as V R + and V R * (see Reducing and Mapping Vectors).

The u X (calc-vector-max) [vmax] command computes the maximum of the data values, and the u N (calc-vector-min) [vmin] command computes the minimum. If the argument is an interval, this finds the minimum or maximum value in the interval. (Note that ‘vmax([2..6)) = 5’ as described above.) If the argument is an error form, this returns plus or minus infinity.

The u M (calc-vector-mean) [vmean] command computes the average (arithmetic mean) of the data values. If the inputs are error forms ‘x +/- s’, this is the weighted mean of the ‘x’ values with weights ‘1 / s^2’. If the inputs are not error forms, this is simply the sum of the values divided by the count of the values.

Note that a plain number can be considered an error form with error ‘s = 0’. If the input to u M is a mixture of plain numbers and error forms, the result is the mean of the plain numbers, ignoring all values with non-zero errors. (By the above definitions it’s clear that a plain number effectively has an infinite weight, next to which an error form with a finite weight is completely negligible.)

This function also works for distributions (error forms or intervals). The mean of an error form ‘a +/- b’ is simply ‘a’. The mean of an interval is the mean of the minimum and maximum values of the interval.

The I u M (calc-vector-mean-error) [vmeane] command computes the mean of the data points expressed as an error form. This includes the estimated error associated with the mean. If the inputs are error forms, the error is the square root of the reciprocal of the sum of the reciprocals of the squares of the input errors. (I.e., the variance is the reciprocal of the sum of the reciprocals of the variances.) If the inputs are plain numbers, the error is equal to the standard deviation of the values divided by the square root of the number of values. (This works out to be equivalent to calculating the standard deviation and then assuming each value’s error is equal to this standard deviation.)

The H u M (calc-vector-median) [vmedian] command computes the median of the data values. The values are first sorted into numerical order; the median is the middle value after sorting. (If the number of data values is even, the median is taken to be the average of the two middle values.) The median function is different from the other functions in this section in that the arguments must all be real numbers; variables are not accepted even when nested inside vectors. (Otherwise it is not possible to sort the data values.) If any of the input values are error forms, their error parts are ignored.

The median function also accepts distributions. For both normal (error form) and uniform (interval) distributions, the median is the same as the mean.

The H I u M (calc-vector-harmonic-mean) [vhmean] command computes the harmonic mean of the data values. This is defined as the reciprocal of the arithmetic mean of the reciprocals of the values.

The u G (calc-vector-geometric-mean) [vgmean] command computes the geometric mean of the data values. This is the nth root of the product of the values. This is also equal to the exp of the arithmetic mean of the logarithms of the data values.

The H u G [agmean] command computes the “arithmetic-geometric mean” of two numbers taken from the stack. This is computed by replacing the two numbers with their arithmetic mean and geometric mean, then repeating until the two values converge.

The u R (calc-vector-rms) [rms] command computes the RMS (root-mean-square) of the data values. As its name suggests, this is the square root of the mean of the squares of the data values.

The u S (calc-vector-sdev) [vsdev] command computes the standard deviation of the data values. If the values are error forms, the errors are used as weights just as for u M. This is the sample standard deviation, whose value is the square root of the sum of the squares of the differences between the values and the mean of the ‘N’ values, divided by ‘N-1’.

This function also applies to distributions. The standard deviation of a single error form is simply the error part. The standard deviation of a continuous interval happens to equal the difference between the limits, divided by ‘sqrt(12)’. The standard deviation of an integer interval is the same as the standard deviation of a vector of those integers.

The I u S (calc-vector-pop-sdev) [vpsdev] command computes the population standard deviation. It is defined by the same formula as above but dividing by ‘N’ instead of by ‘N-1’. The population standard deviation is used when the input represents the entire set of data values in the distribution; the sample standard deviation is used when the input represents a sample of the set of all data values, so that the mean computed from the input is itself only an estimate of the true mean.

For error forms and continuous intervals, vpsdev works exactly like vsdev. For integer intervals, it computes the population standard deviation of the equivalent vector of integers.

The H u S (calc-vector-variance) [vvar] and H I u S (calc-vector-pop-variance) [vpvar] commands compute the variance of the data values. The variance is the square of the standard deviation, i.e., the sum of the squares of the deviations of the data values from the mean. (This definition also applies when the argument is a distribution.)

The vflat algebraic function returns a vector of its arguments, interpreted in the same way as the other functions in this section. For example, ‘vflat(1, [2, [3, 4]], 5)’ returns ‘[1, 2, 3, 4, 5]’.


**** Paired-Sample Statistics

The functions in this section take two arguments, which must be vectors of equal size. The vectors are each flattened in the same way as by the single-variable statistical functions. Given a numeric prefix argument of 1, these functions instead take one object from the stack, which must be an Nx2 matrix of data values. Once again, variable names can be used in place of actual vectors and matrices.

The u C (calc-vector-covariance) [vcov] command computes the sample covariance of two vectors. The covariance of vectors x and y is the sum of the products of the differences between the elements of x and the mean of x times the differences between the corresponding elements of y and the mean of y, all divided by ‘N-1’. Note that the variance of a vector is just the covariance of the vector with itself. Once again, if the inputs are error forms the errors are used as weight factors. If both x and y are composed of error forms, the error for a given data point is taken as the square root of the sum of the squares of the two input errors.

The I u C (calc-vector-pop-covariance) [vpcov] command computes the population covariance, which is the same as the sample covariance computed by u C except dividing by ‘N’ instead of ‘N-1’.

The H u C (calc-vector-correlation) [vcorr] command computes the linear correlation coefficient of two vectors. This is defined by the covariance of the vectors divided by the product of their standard deviations. (There is no difference between sample or population statistics here.)


*** Reducing and Mapping Vectors

The commands in this section allow for more general operations on the elements of vectors.

The simplest of these operations is V A (calc-apply) [apply], which applies a given operator to the elements of a vector. For example, applying the hypothetical function f to the vector ‘[1, 2, 3]’ would produce the function call ‘f(1, 2, 3)’. Applying the + function to the vector ‘[a, b]’ gives ‘a + b’. Applying + to the vector ‘[a, b, c]’ is an error, since the + function expects exactly two arguments.

While V A is useful in some cases, you will usually find that either V R or V M, described below, is closer to what you want.

**** Specifying Operators

Commands in this section (like V A) prompt you to press the key corresponding to the desired operator. Press ? for a partial list of the available operators. Generally, an operator is any key or sequence of keys that would normally take one or more arguments from the stack and replace them with a result. For example, V A H C uses the hyperbolic cosine operator, cosh. (Since cosh expects one argument, V A H C requires a vector with a single element as its argument.)

You can press x at the operator prompt to select any algebraic function by name to use as the operator. This includes functions you have defined yourself using the Z F command. (See Programming with Formulas.) If you give a name for which no function has been defined, the result is left in symbolic form, as in ‘f(1, 2, 3)’. Calc will prompt for the number of arguments the function takes if it can’t figure it out on its own (say, because you named a function that is currently undefined). It is also possible to type a digit key before the function name to specify the number of arguments, e.g., V M 3 x f RET calls f with three arguments even if it looks like it ought to have only two. This technique may be necessary if the function allows a variable number of arguments. For example, the v e [vexp] function accepts two or three arguments; if you want to map with the three-argument version, you will have to type V M 3 v e.

It is also possible to apply any formula to a vector by treating that formula as a function. When prompted for the operator to use, press ' (the apostrophe) and type your formula as an algebraic entry. You will then be prompted for the argument list, which defaults to a list of all variables that appear in the formula, sorted into alphabetic order. For example, suppose you enter the formula ‘x + 2y^x’. The default argument list would be ‘(x y)’, which means that if this function is applied to the arguments ‘[3, 10]’ the result will be ‘3 + 2*10^3’. (If you plan to use a certain formula in this way often, you might consider defining it as a function with Z F.)

Another way to specify the arguments to the formula you enter is with $, $$, and so on. For example, V A ' $$ + 2$^$$ has the same effect as the previous example. The argument list is automatically taken to be ‘($$ $)’. (The order of the arguments may seem backwards, but it is analogous to the way normal algebraic entry interacts with the stack.)

If you press $ at the operator prompt, the effect is similar to the apostrophe except that the relevant formula is taken from top-of-stack instead. The actual vector arguments of the V A $ or related command then start at the second-to-top stack position. You will still be prompted for an argument list.

A function can be written without a name using the notation ‘<#1 - #2>’, which means “a function of two arguments that computes the first argument minus the second argument.” The symbols ‘#1’ and ‘#2’ are placeholders for the arguments. You can use any names for these placeholders if you wish, by including an argument list followed by a colon: ‘<x, y : x - y>’. When you type V A ' $$ + 2$^$$ RET, Calc builds the nameless function ‘<#1 + 2 #2^#1>’ as the function to map across the vectors. When you type V A ' x + 2y^x RET RET, Calc builds the nameless function ‘<x, y : x + 2 y^x>’. In both cases, Calc also writes the nameless function to the Trail so that you can get it back later if you wish.

If there is only one argument, you can write ‘#’ in place of ‘#1’. (Note that ‘< >’ notation is also used for date forms. Calc tells that ‘<stuff>’ is a nameless function by the presence of ‘#’ signs inside stuff, or by the fact that stuff begins with a list of variables followed by a colon.)

You can type a nameless function directly to V A ', or put one on the stack and use it with V A $. Calc will not prompt for an argument list in this case, since the nameless function specifies the argument list as well as the function itself. In V A ', you can omit the ‘< >’ marks if you use ‘#’ notation for the arguments, so that V A ' #1+#2 RET is the same as V A ' <#1+#2> RET, which in turn is the same as V A ' $$+$ RET.

The internal format for ‘<x, y : x + y>’ is ‘lambda(x, y, x + y)’. (The word lambda derives from Lisp notation and the theory of functions.) The internal format for ‘<#1 + #2>’ is ‘lambda(ArgA, ArgB, ArgA + ArgB)’. Note that there is no actual Calc function called lambda; the whole point is that the lambda expression is used in its symbolic form, not evaluated for an answer until it is applied to specific arguments by a command like V A or V M.

(Actually, lambda does have one special property: Its arguments are never evaluated; for example, putting ‘<(2/3) #>’ on the stack will not simplify the ‘2/3’ until the nameless function is actually called.)

As usual, commands like V A have algebraic function name equivalents. For example, V A k g with an argument of ‘v’ is equivalent to ‘apply(gcd, v)’. The first argument specifies the operator name, and is either a variable whose name is the same as the function name, or a nameless function like ‘<#^3+1>’. Operators that are normally written as algebraic symbols have the names add, sub, mul, div, pow, neg, mod, and vconcat.

The call function builds a function call out of several arguments: ‘call(gcd, x, y)’ is the same as ‘apply(gcd, [x, y])’, which in turn is the same as ‘gcd(x, y)’. The first argument of call, like the other functions described here, may be either a variable naming a function, or a nameless function (‘call(<#1+2#2>, x, y)’ is the same as ‘x + 2y’).

(Experts will notice that it’s not quite proper to use a variable to name a function, since the name gcd corresponds to the Lisp variable var-gcd but to the Lisp function calcFunc-gcd. Calc automatically makes this translation, so you don’t have to worry about it.)


**** Mapping

The V M (calc-map) [map] command applies a given operator elementwise to one or more vectors. For example, mapping A [abs] produces a vector of the absolute values of the elements in the input vector. Mapping + pops two vectors from the stack, which must be of equal length, and produces a vector of the pairwise sums of the elements. If either argument is a non-vector, it is duplicated for each element of the other vector. For example, [1,2,3] 2 V M ^ squares the elements of the specified vector. With the 2 listed first, it would have computed a vector of powers of two. Mapping a user-defined function pops as many arguments from the stack as the function requires. If you give an undefined name, you will be prompted for the number of arguments to use.

If any argument to V M is a matrix, the operator is normally mapped across all elements of the matrix. For example, given the matrix ‘[[1, -2, 3], [-4, 5, -6]]’, V M A takes six absolute values to produce another 3x2 matrix, ‘[[1, 2, 3], [4, 5, 6]]’.

The command V M _ [mapr] (i.e., type an underscore at the operator prompt) maps by rows instead. For example, V M _ A views the above matrix as a vector of two 3-element row vectors. It produces a new vector which contains the absolute values of those row vectors, namely ‘[3.74, 8.77]’. (Recall, the absolute value of a vector is defined as the square root of the sum of the squares of the elements.) Some operators accept vectors and return new vectors; for example, v v reverses a vector, so V M _ v v would reverse each row of the matrix to get a new matrix, ‘[[3, -2, 1], [-6, 5, -4]]’.

Sometimes a vector of vectors (representing, say, strings, sets, or lists) happens to look like a matrix. If so, remember to use V M _ if you want to map a function across the whole strings or sets rather than across their individual elements.

The command V M : [mapc] maps by columns. Basically, it transposes the input matrix, maps by rows, and then, if the result is a matrix, transposes again. For example, V M : A takes the absolute values of the three columns of the matrix, treating each as a 2-vector, and V M : v v reverses the columns to get the matrix ‘[[-4, 5, -6], [1, -2, 3]]’.

(The symbols _ and : were chosen because they had row-like and column-like appearances, and were not already taken by useful operators. Also, they appear shifted on most keyboards so they are easy to type after V M.)

The _ and : modifiers have no effect on arguments that are not matrices (so if none of the arguments are matrices, they have no effect at all). If some of the arguments are matrices and others are plain numbers, the plain numbers are held constant for all rows of the matrix (so that 2 V M _ ^ squares every row of a matrix; squaring a vector takes a dot product of the vector with itself).

If some of the arguments are vectors with the same lengths as the rows (for V M _) or columns (for V M :) of the matrix arguments, those vectors are also held constant for every row or column.

Sometimes it is useful to specify another mapping command as the operator to use with V M. For example, V M _ V A + applies V A + to each row of the input matrix, which in turn adds the two values on that row. If you give another vector-operator command as the operator for V M, it automatically uses map-by-rows mode if you don’t specify otherwise; thus V M V A + is equivalent to V M _ V A +. (If you really want to map-by-elements another mapping command, you can use a triple-nested mapping command: V M V M V A + means to map V M V A + over the rows of the matrix; in turn, V A + is mapped over the elements of each row.)

Previous versions of Calc had “map across” and “map down” modes that are now considered obsolete; the old “map across” is now simply V M V A, and “map down” is now V M : V A. The algebraic functions mapa and mapd are still supported, though. Note also that, while the old mapping modes were persistent (once you set the mode, it would apply to later mapping commands until you reset it), the new : and _ modifiers apply only to the current mapping command. The default V M always means map-by-elements.

See Algebraic Manipulation, for the a M command, which is like V M but for equations and inequalities instead of vectors. See Storing Variables, for the s m command which modifies a variable’s stored value using a V M-like operator.


**** Reducing

The V R (calc-reduce) [reduce] command applies a given binary operator across all the elements of a vector. A binary operator is a function such as + or max which takes two arguments. For example, reducing + over a vector computes the sum of the elements of the vector. Reducing - computes the first element minus each of the remaining elements. Reducing max computes the maximum element and so on. In general, reducing f over the vector ‘[a, b, c, d]’ produces ‘f(f(f(a, b), c), d)’.

The I V R [rreduce] command is similar to V R except that works from right to left through the vector. For example, plain V R - on the vector ‘[a, b, c, d]’ produces ‘a - b - c - d’ but I V R - on the same vector produces ‘a - (b - (c - d))’, or ‘a - b + c - d’. This “alternating sum” occurs frequently in power series expansions.

The V U (calc-accumulate) [accum] command does an accumulation operation. Here Calc does the corresponding reduction operation, but instead of producing only the final result, it produces a vector of all the intermediate results. Accumulating + over the vector ‘[a, b, c, d]’ produces the vector ‘[a, a + b, a + b + c, a + b + c + d]’.

The I V U [raccum] command does a right-to-left accumulation. For example, I V U - on the vector ‘[a, b, c, d]’ produces the vector ‘[a - b + c - d, b - c + d, c - d, d]’.

As for V M, V R normally reduces a matrix elementwise. For example, given the matrix ‘[[a, b, c], [d, e, f]]’, V R + will compute ‘a + b + c + d + e + f’. You can type V R _ or V R : to modify this behavior. The V R _ [reducea] command reduces “across” the matrix; it reduces each row of the matrix as a vector, then collects the results. Thus V R _ + of this matrix would produce ‘[a + b + c, d + e + f]’. Similarly, V R : [reduced] reduces down; V R : + would produce ‘[a + d, b + e, c + f]’.

There is a third “by rows” mode for reduction that is occasionally useful; V R = [reducer] simply reduces the operator over the rows of the matrix themselves. Thus V R = + on the above matrix would get the same result as V R : +, since adding two row vectors is equivalent to adding their elements. But V R = * would multiply the two rows (to get a single number, their dot product), while V R : * would produce a vector of the products of the columns.

These three matrix reduction modes work with V R and I V R, but they are not currently supported with V U or I V U.

The obsolete reduce-by-columns function, reducec, is still supported but there is no way to get it through the V R command.

The commands C-x * : and C-x * _ are equivalent to typing C-x * r to grab a rectangle of data into Calc, and then typing V R : + or V R _ +, respectively, to sum the columns or rows of the matrix. See Grabbing from Other Buffers.


**** Nesting and Fixed Points

The H V R [nest] command applies a function to a given argument repeatedly. It takes two values, ‘a’ and ‘n’, from the stack, where ‘n’ must be an integer. It then applies the function nested ‘n’ times; if the function is ‘f’ and ‘n’ is 3, the result is ‘f(f(f(a)))’. The number ‘n’ may be negative if Calc knows an inverse for the function ‘f’; for example, ‘nest(sin, a, -2)’ returns ‘arcsin(arcsin(a))’.

The H V U [anest] command is an accumulating version of nest: It returns a vector of ‘n+1’ values, e.g., ‘[a, f(a), f(f(a)), f(f(f(a)))]’. If ‘n’ is negative and ‘F’ is the inverse of ‘f’, then the result is of the form ‘[a, F(a), F(F(a)), F(F(F(a)))]’.

The H I V R [fixp] command is like H V R, except that it takes only an ‘a’ value from the stack; the function is applied until it reaches a “fixed point,” i.e., until the result no longer changes.

The H I V U [afixp] command is an accumulating fixp. The first element of the return vector will be the initial value ‘a’; the last element will be the final result that would have been returned by fixp.

For example, 0.739085 is a fixed point of the cosine function (in radians): ‘cos(0.739085) = 0.739085’. You can find this value by putting, say, 1.0 on the stack and typing H I V U C. (We use the accumulating version so we can see the intermediate results: ‘[1, 0.540302, 0.857553, 0.65329, ...]’. With a precision of six, this command will take 36 steps to converge to 0.739085.)

Newton’s method for finding roots is a classic example of iteration to a fixed point. To find the square root of five starting with an initial guess, Newton’s method would look for a fixed point of the function ‘(x + 5/x) / 2’. Putting a guess of 1 on the stack and typing H I V R ' ($ + 5/$)/2 RET quickly yields the result 2.23607. This is equivalent to using the a R (calc-find-root) command to find a root of the equation ‘x^2 = 5’.

These examples used numbers for ‘a’ values. Calc keeps applying the function until two successive results are equal to within the current precision. For complex numbers, both the real parts and the imaginary parts must be equal to within the current precision. If ‘a’ is a formula (say, a variable name), then the function is applied until two successive results are exactly the same formula. It is up to you to ensure that the function will eventually converge; if it doesn’t, you may have to press C-g to stop the Calculator.

The algebraic fixp function takes two optional arguments, ‘n’ and ‘tol’. The first is the maximum number of steps to be allowed, and must be either an integer or the symbol ‘inf’ (infinity, the default). The second is a convergence tolerance. If a tolerance is specified, all results during the calculation must be numbers, not formulas, and the iteration stops when the magnitude of the difference between two successive results is less than or equal to the tolerance. (This implies that a tolerance of zero iterates until the results are exactly equal.)

Putting it all together, ‘fixp(<(# + A/#)/2>, B, 20, 1e-10)’ computes the square root of ‘A’ given the initial guess ‘B’, stopping when the result is correct within the specified tolerance, or when 20 steps have been taken, whichever is sooner.


**** Generalized Products

The V O (calc-outer-product) [outer] command applies a given binary operator to all possible pairs of elements from two vectors, to produce a matrix. For example, V O * with ‘[a, b]’ and ‘[x, y, z]’ on the stack produces a multiplication table: ‘[[a x, a y, a z], [b x, b y, b z]]’. Element r,c of the result matrix is obtained by applying the operator to element r of the lefthand vector and element c of the righthand vector.

The V I (calc-inner-product) [inner] command computes the generalized inner product of two vectors or matrices, given a “multiplicative” operator and an “additive” operator. These can each actually be any binary operators; if they are ‘*’ and ‘+’, respectively, the result is a standard matrix multiplication. Element r,c of the result matrix is obtained by mapping the multiplicative operator across row r of the lefthand matrix and column c of the righthand matrix, and then reducing with the additive operator. Just as for the standard * command, this can also do a vector-matrix or matrix-vector inner product, or a vector-vector generalized dot product.

Since V I requires two operators, it prompts twice. In each case, you can use any of the usual methods for entering the operator. If you use $ twice to take both operator formulas from the stack, the first (multiplicative) operator is taken from the top of the stack and the second (additive) operator is taken from second-to-top.


*** Vector and Matrix Display Formats

Commands for controlling vector and matrix display use the v prefix instead of the usual d prefix. But they are display modes; in particular, they are influenced by the I and H prefix keys in the same way (see Display Modes). Matrix display is also influenced by the d O (calc-flat-language) mode; see Normal Language Modes.

The commands v < (calc-matrix-left-justify), v > (calc-matrix-right-justify), and v = (calc-matrix-center-justify) control whether matrix elements are justified to the left, right, or center of their columns.

The v [ (calc-vector-brackets) command turns the square brackets that surround vectors and matrices displayed in the stack on and off. The v { (calc-vector-braces) and v ( (calc-vector-parens) commands use curly braces or parentheses, respectively, instead of square brackets. For example, v { might be used in preparation for yanking a matrix into a buffer running Mathematica. (In fact, the Mathematica language mode uses this mode; see Mathematica Language Mode.) Note that, regardless of the display mode, either brackets or braces may be used to enter vectors, and parentheses may never be used for this purpose.

The v ] (calc-matrix-brackets) command controls the “big” style display of matrices, for matrices which have more than one row. It prompts for a string of code letters; currently implemented letters are R, which enables brackets on each row of the matrix; O, which enables outer brackets in opposite corners of the matrix; and C, which enables commas or semicolons at the ends of all rows but the last. The default format is ‘RO’. (Before Calc 2.00, the format was fixed at ‘ROC’.) Here are some example matrices:

[ [ 123,  0,   0  ]       [ [ 123,  0,   0  ],
  [  0,  123,  0  ]         [  0,  123,  0  ],
  [  0,   0,  123 ] ]       [  0,   0,  123 ] ]

         RO                        ROC

  [ 123,  0,   0            [ 123,  0,   0 ;
     0,  123,  0               0,  123,  0 ;
     0,   0,  123 ]            0,   0,  123 ]

          O                        OC

  [ 123,  0,   0  ]           123,  0,   0
  [  0,  123,  0  ]            0,  123,  0
  [  0,   0,  123 ]            0,   0,  123

          R                       blank
Note that of the formats shown here, ‘RO’, ‘ROC’, and ‘OC’ are all recognized as matrices during reading, while the others are useful for display only.

The v , (calc-vector-commas) command turns commas on and off in vector and matrix display.

In vectors of length one, and in all vectors when commas have been turned off, Calc adds extra parentheses around formulas that might otherwise be ambiguous. For example, ‘[a b]’ could be a vector of the one formula ‘a b’, or it could be a vector of two variables with commas turned off. Calc will display the former case as ‘[(a b)]’. You can disable these extra parentheses (to make the output less cluttered at the expense of allowing some ambiguity) by adding the letter P to the control string you give to v ] (as described above).

The v . (calc-full-vectors) command turns abbreviated display of long vectors on and off. In this mode, vectors of six or more elements, or matrices of six or more rows or columns, will be displayed in an abbreviated form that displays only the first three elements and the last element: ‘[a, b, c, ..., z]’. When very large vectors are involved this will substantially improve Calc’s display speed.

The t . (calc-full-trail-vectors) command controls a similar mode for recording vectors in the Trail. If you turn on this mode, vectors of six or more elements and matrices of six or more rows or columns will be abbreviated when they are put in the Trail. The t y (calc-trail-yank) command will be unable to recover those vectors. If you are working with very large vectors, this mode will improve the speed of all operations that involve the trail.

The v / (calc-break-vectors) command turns multi-line vector display on and off. Normally, matrices are displayed with one row per line but all other types of vectors are displayed in a single line. This mode causes all vectors, whether matrices or not, to be displayed with a single element per line. Sub-vectors within the vectors will still use the normal linear form.


** Algebra

This section covers the Calc features that help you work with algebraic formulas. First, the general sub-formula selection mechanism is described; this works in conjunction with any Calc commands. Then, commands for specific algebraic operations are described. Finally, the flexible rewrite rule mechanism is discussed.

The algebraic commands use the a key prefix; selection commands use the j (for “just a letter that wasn’t used for anything else”) prefix.

See Editing Stack Entries, to see how to manipulate formulas using regular Emacs editing commands.

When doing algebraic work, you may find several of the Calculator’s modes to be helpful, including Algebraic Simplification mode (m A) or No-Simplification mode (m O), Algebraic entry mode (m a), Fraction mode (m f), and Symbolic mode (m s). See Mode Settings, for discussions of these modes. You may also wish to select Big display mode (d B). See Normal Language Modes.


*** Selecting Sub-Formulas

When working with an algebraic formula it is often necessary to manipulate a portion of the formula rather than the formula as a whole. Calc allows you to “select” a portion of any formula on the stack. Commands which would normally operate on that stack entry will now operate only on the sub-formula, leaving the surrounding part of the stack entry alone.

One common non-algebraic use for selection involves vectors. To work on one element of a vector in-place, simply select that element as a “sub-formula” of the vector.

**** Making Selections

To select a sub-formula, move the Emacs cursor to any character in that sub-formula, and press j s (calc-select-here). Calc will highlight the smallest portion of the formula that contains that character. By default the sub-formula is highlighted by blanking out all of the rest of the formula with dots. Selection works in any display mode but is perhaps easiest in Big mode (d B). Suppose you enter the following formula:

           3    ___
    (a + b)  + V c
1:  ---------------
        2 x + 1
(by typing ' ((a+b)^3 + sqrt(c)) / (2x+1)). If you move the cursor to the letter ‘b’ and press j s, the display changes to

           .    ...
    .. . b.  . . .
1*  ...............
        . . . .
Every character not part of the sub-formula ‘b’ has been changed to a dot. (If the customizable variable calc-highlight-selections-with-faces is non-nil, then the characters not part of the sub-formula are de-emphasized by using a less noticeable face instead of using dots. see Displaying Selections.) The ‘*’ next to the line number is to remind you that the formula has a portion of it selected. (In this case, it’s very obvious, but it might not always be. If Embedded mode is enabled, the word ‘Sel’ also appears in the mode line because the stack may not be visible. see Embedded Mode.)

If you had instead placed the cursor on the parenthesis immediately to the right of the ‘b’, the selection would have been:

           .    ...
    (a + b)  . . .
1*  ...............
        . . . .
The portion selected is always large enough to be considered a complete formula all by itself, so selecting the parenthesis selects the whole formula that it encloses. Putting the cursor on the ‘+’ sign would have had the same effect.

(Strictly speaking, the Emacs cursor is really the manifestation of the Emacs “point,” which is a position between two characters in the buffer. So purists would say that Calc selects the smallest sub-formula which contains the character to the right of “point.”)

If you supply a numeric prefix argument n, the selection is expanded to the nth enclosing sub-formula. Thus, positioning the cursor on the ‘b’ and typing C-u 1 j s will select ‘a + b’; typing C-u 2 j s will select ‘(a + b)^3’, and so on.

If the cursor is not on any part of the formula, or if you give a numeric prefix that is too large, the entire formula is selected.

If the cursor is on the ‘.’ line that marks the top of the stack (i.e., its normal “rest position”), this command selects the entire formula at stack level 1. Most selection commands similarly operate on the formula at the top of the stack if you haven’t positioned the cursor on any stack entry.

The j a (calc-select-additional) command enlarges the current selection to encompass the cursor. To select the smallest sub-formula defined by two different points, move to the first and press j s, then move to the other and press j a. This is roughly analogous to using C-@ (set-mark-command) to select the two ends of a region of text during normal Emacs editing.

The j o (calc-select-once) command selects a formula in exactly the same way as j s, except that the selection will last only as long as the next command that uses it. For example, j o 1 + is a handy way to add one to the sub-formula indicated by the cursor.

(A somewhat more precise definition: The j o command sets a flag such that the next command involving selected stack entries will clear the selections on those stack entries afterwards. All other selection commands except j a and j O clear this flag.)

The j S (calc-select-here-maybe) and j O (calc-select-once-maybe) commands are equivalent to j s and j o, respectively, except that if the formula already has a selection they have no effect. This is analogous to the behavior of some commands such as j r (calc-rewrite-selection; see Selections with Rewrite Rules) and is mainly intended to be used in keyboard macros that implement your own selection-oriented commands.

Selection of sub-formulas normally treats associative terms like ‘a + b - c + d’ and ‘x * y * z’ as single levels of the formula. If you place the cursor anywhere inside ‘a + b - c + d’ except on one of the variable names and use j s, you will select the entire four-term sum.

The j b (calc-break-selections) command controls a mode in which the “deep structure” of these associative formulas shows through. Calc actually stores the above formulas as ‘((a + b) - c) + d’ and ‘x * (y * z)’. (Note that for certain obscure reasons, by default Calc treats multiplication as right-associative.) Once you have enabled j b mode, selecting with the cursor on the ‘-’ sign would only select the ‘a + b - c’ portion, which makes sense when the deep structure of the sum is considered. There is no way to select the ‘b - c + d’ portion; although this might initially look like just as legitimate a sub-formula as ‘a + b - c’, the deep structure shows that it isn’t. The d U command can be used to view the deep structure of any formula (see Normal Language Modes).

When j b mode has not been enabled, the deep structure is generally hidden by the selection commands—what you see is what you get.

The j u (calc-unselect) command unselects the formula that the cursor is on. If there was no selection in the formula, this command has no effect. With a numeric prefix argument, it unselects the nth stack element rather than using the cursor position.

The j c (calc-clear-selections) command unselects all stack elements.


**** Changing Selections

Once you have selected a sub-formula, you can expand it using the j m (calc-select-more) command. If ‘a + b’ is selected, pressing j m repeatedly works as follows:

           3    ...                3    ___                3    ___
    (a + b)  . . .          (a + b)  + V c          (a + b)  + V c
1*  ...............     1*  ...............     1*  ---------------
        . . . .                 . . . .                 2 x + 1
In the last example, the entire formula is selected. This is roughly the same as having no selection at all, but because there are subtle differences the ‘*’ character is still there on the line number.

With a numeric prefix argument n, j m expands n times (or until the entire formula is selected). Note that j s with argument n is equivalent to plain j s followed by j m with argument n. If j m is used when there is no current selection, it is equivalent to j s.

Even though j m does not explicitly use the location of the cursor within the formula, it nevertheless uses the cursor to determine which stack element to operate on. As usual, j m when the cursor is not on any stack element operates on the top stack element.

The j l (calc-select-less) command reduces the current selection around the cursor position. That is, it selects the immediate sub-formula of the current selection which contains the cursor, the opposite of j m. If the cursor is not inside the current selection, the command de-selects the formula.

The j 1 through j 9 (calc-select-part) commands select the nth sub-formula of the current selection. They are like j l (calc-select-less) except they use counting rather than the cursor position to decide which sub-formula to select. For example, if the current selection is a + b + c or f(a, b, c) or [a, b, c], then j 1 selects ‘a’, j 2 selects ‘b’, and j 3 selects ‘c’; in each of these cases, j 4 through j 9 would be errors.

If there is no current selection, j 1 through j 9 select the nth top-level sub-formula. (In other words, they act as if the entire stack entry were selected first.) To select the nth sub-formula where n is greater than nine, you must instead invoke j 1 with n as a numeric prefix argument.

The j n (calc-select-next) and j p (calc-select-previous) commands change the current selection to the next or previous sub-formula at the same level. For example, if ‘b’ is selected in ‘2 + a*b*c + x’, then j n selects ‘c’. Further j n commands would be in error because, even though there is something to the right of ‘c’ (namely, ‘x’), it is not at the same level; in this case, it is not a term of the same product as ‘b’ and ‘c’. However, j m (to select the whole product ‘a*b*c’ as a term of the sum) followed by j n would successfully select the ‘x’.

Similarly, j p moves the selection from the ‘b’ in this sample formula to the ‘a’. Both commands accept numeric prefix arguments to move several steps at a time.

It is interesting to compare Calc’s selection commands with the Emacs Info system’s commands for navigating through hierarchically organized documentation. Calc’s j n command is completely analogous to Info’s n command. Likewise, j p maps to p, j 2 maps to 2, and Info’s u is like j m. (Note that j u stands for calc-unselect, not “up”.) The Info m command is somewhat similar to Calc’s j s and j l; in each case, you can jump directly to a sub-component of the hierarchy simply by pointing to it with the cursor.


**** Displaying Selections

The j d (calc-show-selections) command controls how selected sub-formulas are displayed. One of the alternatives is illustrated in the above examples; if we press j d we switch to the other style in which the selected portion itself is obscured by ‘#’ signs:

           3    ...                  #    ___
    (a + b)  . . .            ## # ##  + V c
1*  ...............       1*  ---------------
        . . . .                   2 x + 1
If the customizable variable calc-highlight-selections-with-faces is non-nil, then the non-selected portion of the formula will be de-emphasized by using a less noticeable face (calc-nonselected-face) instead of dots and the selected sub-formula will be highlighted by using a more noticeable face (calc-selected-face) instead of ‘#’ signs. (see Customizing Calc.)


**** Operating on Selections

Once a selection is made, all Calc commands that manipulate items on the stack will operate on the selected portions of the items instead. (Note that several stack elements may have selections at once, though there can be only one selection at a time in any given stack element.)

The j e (calc-enable-selections) command disables the effect that selections have on Calc commands. The current selections still exist, but Calc commands operate on whole stack elements anyway. This mode can be identified by the fact that the ‘*’ markers on the line numbers are gone, even though selections are visible. To reactivate the selections, press j e again.

To extract a sub-formula as a new formula, simply select the sub-formula and press RET. This normally duplicates the top stack element; here it duplicates only the selected portion of that element.

To replace a sub-formula with something different, you can enter the new value onto the stack and press TAB. This normally exchanges the top two stack elements; here it swaps the value you entered into the selected portion of the formula, returning the old selected portion to the top of the stack.

           3    ...                    ...                    ___
    (a + b)  . . .           17 x y . . .           17 x y + V c
2*  ...............      2*  .............      2:  -------------
        . . . .                 . . . .                2 x + 1

                                    3                      3
1:  17 x y               1:  (a + b)            1:  (a + b)
In this example we select a sub-formula of our original example, enter a new formula, TAB it into place, then deselect to see the complete, edited formula.

If you want to swap whole formulas around even though they contain selections, just use j e before and after.

The j ' (calc-enter-selection) command is another way to replace a selected sub-formula. This command does an algebraic entry just like the regular ' key. When you press RET, the formula you type replaces the original selection. You can use the ‘$’ symbol in the formula to refer to the original selection. If there is no selection in the formula under the cursor, the cursor is used to make a temporary selection for the purposes of the command. Thus, to change a term of a formula, all you have to do is move the Emacs cursor to that term and press j '.

The j ` (calc-edit-selection) command is a similar analogue of the ` (calc-edit) command. It edits the selected sub-formula in a separate buffer. If there is no selection, it edits the sub-formula indicated by the cursor.

To delete a sub-formula, press DEL. This generally replaces the sub-formula with the constant zero, but in a few suitable contexts it uses the constant one instead. The DEL key automatically deselects and re-simplifies the entire formula afterwards. Thus:

              ###
    17 x y + # #          17 x y         17 # y          17 y
1*  -------------     1:  -------    1*  -------    1:  -------
       2 x + 1            2 x + 1        2 x + 1        2 x + 1
In this example, we first delete the ‘sqrt(c)’ term; Calc accomplishes this by replacing ‘sqrt(c)’ with zero and resimplifying. We then delete the x in the numerator; since this is part of a product, Calc replaces it with ‘1’ and resimplifies.

If you select an element of a vector and press DEL, that element is deleted from the vector. If you delete one side of an equation or inequality, only the opposite side remains.

The j DEL (calc-del-selection) command is like DEL but with the auto-selecting behavior of j ' and j `. It deletes the selected portion of the formula indicated by the cursor, or, in the absence of a selection, it deletes the sub-formula indicated by the cursor position.

(There is also an auto-selecting j RET (calc-copy-selection) command.)

Normal arithmetic operations also apply to sub-formulas. Here we select the denominator, press 5 - to subtract five from the denominator, press n to negate the denominator, then press Q to take the square root.

     .. .           .. .           .. .             .. .
1*  .......    1*  .......    1*  .......    1*  ..........
    2 x + 1        2 x - 4        4 - 2 x         _________
                                                 V 4 - 2 x
Certain types of operations on selections are not allowed. For example, for an arithmetic function like - no more than one of the arguments may be a selected sub-formula. (As the above example shows, the result of the subtraction is spliced back into the argument which had the selection; if there were more than one selection involved, this would not be well-defined.) If you try to subtract two selections, the command will abort with an error message.

Operations on sub-formulas sometimes leave the formula as a whole in an “un-natural” state. Consider negating the ‘2 x’ term of our sample formula by selecting it and pressing n (calc-change-sign).

       .. .                .. .
1*  ..........      1*  ...........
     .........           ..........
    . . . 2 x           . . . -2 x
Unselecting the sub-formula reveals that the minus sign, which would normally have canceled out with the subtraction automatically, has not been able to do so because the subtraction was not part of the selected portion. Pressing = (calc-evaluate) or doing any other mathematical operation on the whole formula will cause it to be simplified.

       17 y                17 y
1:  -----------     1:  ----------
     __________          _________
    V 4 - -2 x          V 4 + 2 x

**** Rearranging Formulas using Selections

The j R (calc-commute-right) command moves the selected sub-formula to the right in its surrounding formula. Generally the selection is one term of a sum or product; the sum or product is rearranged according to the commutative laws of algebra.

As with j ' and j DEL, the term under the cursor is used if there is no selection in the current formula. All commands described in this section share this property. In this example, we place the cursor on the ‘a’ and type j R, then repeat.

1:  a + b - c          1:  b + a - c          1:  b - c + a
Note that in the final step above, the ‘a’ is switched with the ‘c’ but the signs are adjusted accordingly. When moving terms of sums and products, j R will never change the mathematical meaning of the formula.

The selected term may also be an element of a vector or an argument of a function. The term is exchanged with the one to its right. In this case, the “meaning” of the vector or function may of course be drastically changed.

1:  [a, b, c]          1:  [b, a, c]          1:  [b, c, a]

1:  f(a, b, c)         1:  f(b, a, c)         1:  f(b, c, a)
The j L (calc-commute-left) command is like j R except that it swaps the selected term with the one to its left.

With numeric prefix arguments, these commands move the selected term several steps at a time. It is an error to try to move a term left or right past the end of its enclosing formula. With numeric prefix arguments of zero, these commands move the selected term as far as possible in the given direction.

The j D (calc-sel-distribute) command mixes the selected sum or product into the surrounding formula using the distributive law. For example, in ‘a * (b - c)’ with the ‘b - c’ selected, the result is ‘a b - a c’. This also distributes products or quotients into surrounding powers, and can also do transformations like ‘exp(a + b)’ to ‘exp(a) exp(b)’, where ‘a + b’ is the selected term, and ‘ln(a ^ b)’ to ‘ln(a) b’, where ‘a ^ b’ is the selected term.

For multiple-term sums or products, j D takes off one term at a time: ‘a * (b + c - d)’ goes to ‘a * (c - d) + a b’ with the ‘c - d’ selected so that you can type j D repeatedly to expand completely. The j D command allows a numeric prefix argument which specifies the maximum number of times to expand at once; the default is one time only.

The j D command is implemented using rewrite rules. See Selections with Rewrite Rules. The rules are stored in the Calc variable DistribRules. A convenient way to view these rules is to use s e (calc-edit-variable) which displays and edits the stored value of a variable. Press C-c C-c to return from editing mode; be careful not to make any actual changes or else you will affect the behavior of future j D commands!

To extend j D to handle new cases, just edit DistribRules as described above. You can then use the s p command to save this variable’s value permanently for future Calc sessions. See Other Operations on Variables.

The j M (calc-sel-merge) command is the complement of j D; given ‘a b - a c’ with either ‘a b’ or ‘a c’ selected, the result is ‘a * (b - c)’. Once again, j M can also merge calls to functions like exp and ln; examine the variable MergeRules to see all the relevant rules.

The j C (calc-sel-commute) command swaps the arguments of the selected sum, product, or equation. It always behaves as if j b mode were in effect, i.e., the sum ‘a + b + c’ is treated as the nested sums ‘(a + b) + c’ by this command. If you put the cursor on the first ‘+’, the result is ‘(b + a) + c’; if you put the cursor on the second ‘+’, the result is ‘c + (a + b)’ (which the default simplifications will rearrange to ‘(c + a) + b’). The relevant rules are stored in the variable CommuteRules.

You may need to turn default simplifications off (with the m O command) in order to get the full benefit of j C. For example, commuting ‘a - b’ produces ‘-b + a’, but the default simplifications will “simplify” this right back to ‘a - b’ if you don’t turn them off. The same is true of some of the other manipulations described in this section.

The j N (calc-sel-negate) command replaces the selected term with the negative of that term, then adjusts the surrounding formula in order to preserve the meaning. For example, given ‘exp(a - b)’ where ‘a - b’ is selected, the result is ‘1 / exp(b - a)’. By contrast, selecting a term and using the regular n (calc-change-sign) command negates the term without adjusting the surroundings, thus changing the meaning of the formula as a whole. The rules variable is NegateRules.

The j & (calc-sel-invert) command is similar to j N except it takes the reciprocal of the selected term. For example, given ‘a - ln(b)’ with ‘b’ selected, the result is ‘a + ln(1/b)’. The rules variable is InvertRules.

The j E (calc-sel-jump-equals) command moves the selected term from one side of an equation to the other. Given ‘a + b = c + d’ with ‘c’ selected, the result is ‘a + b - c = d’. This command also works if the selected term is part of a ‘*’, ‘/’, or ‘^’ formula. The relevant rules variable is JumpRules.

The j I (calc-sel-isolate) command isolates the selected term on its side of an equation. It uses the a S (calc-solve-for) command to solve the equation, and the Hyperbolic flag affects it in the same way. See Solving Equations. When it applies, j I is often easier to use than j E. It understands more rules of algebra, and works for inequalities as well as equations.

The j * (calc-sel-mult-both-sides) command prompts for a formula using algebraic entry, then multiplies both sides of the selected quotient or equation by that formula. It performs the default algebraic simplifications before re-forming the quotient or equation. You can suppress this simplification by providing a prefix argument: C-u j *. There is also a j / (calc-sel-div-both-sides) which is similar to j * but dividing instead of multiplying by the factor you enter.

If the selection is a quotient with numerator 1, then Calc’s default simplifications would normally cancel the new factors. To prevent this, when the j * command is used on a selection whose numerator is 1 or -1, the denominator is expanded at the top level using the distributive law (as if using the C-u 1 a x command). Suppose the formula on the stack is ‘1 / (a + 1)’ and you wish to multiplying the top and bottom by ‘a - 1’. Calc’s default simplifications would normally change the result ‘(a - 1) /(a + 1) (a - 1)’ back to the original form by cancellation; when j * is used, Calc expands the denominator to ‘a (a - 1) + a - 1’ to prevent this.

If you wish the j * command to completely expand the denominator of a quotient you can call it with a zero prefix: C-u 0 j *. For example, if the formula on the stack is ‘1 / (sqrt(a) + 1)’, you may wish to eliminate the square root in the denominator by multiplying the top and bottom by ‘sqrt(a) - 1’. If you did this simply by using a simple j * command, you would get ‘(sqrt(a)-1)/ (sqrt(a) (sqrt(a) - 1) + sqrt(a) - 1)’. Instead, you would probably want to use C-u 0 j *, which would expand the bottom and give you the desired result ‘(sqrt(a)-1)/(a-1)’. More generally, if j * is called with an argument of a positive integer n, then the denominator of the expression will be expanded n times (as if with the C-u n a x command).

If the selection is an inequality, j * and j / will accept any factor, but will warn unless they can prove the factor is either positive or negative. (In the latter case the direction of the inequality will be switched appropriately.) See Declarations, for ways to inform Calc that a given variable is positive or negative. If Calc can’t tell for sure what the sign of the factor will be, it will assume it is positive and display a warning message.

For selections that are not quotients, equations, or inequalities, these commands pull out a multiplicative factor: They divide (or multiply) by the entered formula, simplify, then multiply (or divide) back by the formula.

The j + (calc-sel-add-both-sides) and j - (calc-sel-sub-both-sides) commands analogously add to or subtract from both sides of an equation or inequality. For other types of selections, they extract an additive factor. A numeric prefix argument suppresses simplification of the intermediate results.

The j U (calc-sel-unpack) command replaces the selected function call with its argument. For example, given ‘a + sin(x^2)’ with ‘sin(x^2)’ selected, the result is ‘a + x^2’. (The ‘x^2’ will remain selected; if you wanted to change the sin to cos, just press C now to take the cosine of the selected part.)

The j v (calc-sel-evaluate) command performs the basic simplifications on the selected sub-formula. These simplifications would normally be done automatically on all results, but may have been partially inhibited by previous selection-related operations, or turned off altogether by the m O command. This command is just an auto-selecting version of the a v command (see Algebraic Manipulation).

With a numeric prefix argument of 2, C-u 2 j v applies the default algebraic simplifications to the selected sub-formula. With a prefix argument of 3 or more, e.g., C-u j v applies the a e (calc-simplify-extended) command. See Simplifying Formulas. With a negative prefix argument it simplifies at the top level only, just as with a v. Here the “top” level refers to the top level of the selected sub-formula.

The j " (calc-sel-expand-formula) command is to a " (see Algebraic Manipulation) what j v is to a v.

You can use the j r (calc-rewrite-selection) command to define other algebraic operations on sub-formulas. See Rewrite Rules.


*** Algebraic Manipulation

The commands in this section perform general-purpose algebraic manipulations. They work on the whole formula at the top of the stack (unless, of course, you have made a selection in that formula).

Many algebra commands prompt for a variable name or formula. If you answer the prompt with a blank line, the variable or formula is taken from top-of-stack, and the normal argument for the command is taken from the second-to-top stack level.

The a v (calc-alg-evaluate) command performs the normal default simplifications on a formula; for example, ‘a - -b’ is changed to ‘a + b’. These simplifications are normally done automatically on all Calc results, so this command is useful only if you have turned default simplifications off with an m O command. See Simplification Modes.

It is often more convenient to type =, which is like a v but which also substitutes stored values for variables in the formula. Use a v if you want the variables to ignore their stored values.

If you give a numeric prefix argument of 2 to a v, it simplifies using Calc’s algebraic simplifications; see Simplifying Formulas. If you give a numeric prefix of 3 or more, it uses Extended Simplification mode (a e).

If you give a negative prefix argument -1, -2, or -3, it simplifies in the corresponding mode but only works on the top-level function call of the formula. For example, ‘(2 + 3) * (2 + 3)’ will simplify to ‘(2 + 3)^2’, without simplifying the sub-formulas ‘2 + 3’. As another example, typing V R + to sum the vector ‘[1, 2, 3, 4]’ produces the formula ‘reduce(add, [1, 2, 3, 4])’ in No-Simplify mode. Using a v will evaluate this all the way to 10; using C-u - a v will evaluate it only to ‘1 + 2 + 3 + 4’. (See Reducing and Mapping Vectors.)

The = command corresponds to the evalv function, and the related N command, which is like = but temporarily disables Symbolic mode (m s) during the evaluation, corresponds to the evalvn function. (These commands interpret their prefix arguments differently than a v; = treats the prefix as the number of stack elements to evaluate at once, and N treats it as a temporary different working precision.)

The evalvn function can take an alternate working precision as an optional second argument. This argument can be either an integer, to set the precision absolutely, or a vector containing a single integer, to adjust the precision relative to the current precision. Note that evalvn with a larger than current precision will do the calculation at this higher precision, but the result will as usual be rounded back down to the current precision afterward. For example, ‘evalvn(pi - 3.1415)’ at a precision of 12 will return ‘9.265359e-5’; ‘evalvn(pi - 3.1415, 30)’ will return ‘9.26535897932e-5’ (computing a 25-digit result which is then rounded down to 12); and ‘evalvn(pi - 3.1415, [-2])’ will return ‘9.2654e-5’.

The a " (calc-expand-formula) command expands functions into their defining formulas wherever possible. For example, ‘deg(x^2)’ is changed to ‘180 x^2 / pi’. Most functions, like sin and gcd, are not defined by simple formulas and so are unaffected by this command. One important class of functions which can be expanded is the user-defined functions created by the Z F command. See Programming with Formulas. Other functions which a " can expand include the probability distribution functions, most of the financial functions, and the hyperbolic and inverse hyperbolic functions. A numeric prefix argument affects a " in the same way as it does a v: A positive argument expands all functions in the formula and then simplifies in various ways; a negative argument expands and simplifies only the top-level function call.

The a M (calc-map-equation) [mapeq] command applies a given function or operator to one or more equations. It is analogous to V M, which operates on vectors instead of equations. see Reducing and Mapping Vectors. For example, a M S changes ‘x = y+1’ to ‘sin(x) = sin(y+1)’, and a M + with ‘x = y+1’ and ‘6’ on the stack produces ‘x+6 = y+7’. With two equations on the stack, a M + would add the lefthand sides together and the righthand sides together to get the two respective sides of a new equation.

Mapping also works on inequalities. Mapping two similar inequalities produces another inequality of the same type. Mapping an inequality with an equation produces an inequality of the same type. Mapping a ‘<=’ with a ‘<’ or ‘!=’ (not-equal) produces a ‘<’. If inequalities with opposite direction (e.g., ‘<’ and ‘>’) are mapped, the direction of the second inequality is reversed to match the first: Using a M + on ‘a < b’ and ‘a > 2’ reverses the latter to get ‘2 < a’, which then allows the combination ‘a + 2 < b + a’, which the algebraic simplifications can reduce to ‘2 < b’.

Using a M *, a M /, a M n, or a M & to negate or invert an inequality will reverse the direction of the inequality. Other adjustments to inequalities are not done automatically; a M S will change ‘x < y’ to ‘sin(x) < sin(y)’ even though this is not true for all values of the variables.

With the Hyperbolic flag, H a M [mapeqp] does a plain mapping operation without reversing the direction of any inequalities. Thus, H a M & would change x > 2 to 1/x > 0.5. (This change is mathematically incorrect, but perhaps you were fixing an inequality which was already incorrect.)

With the Inverse flag, I a M [mapeqr] always reverses the direction of the inequality. You might use I a M C to change ‘x < y’ to ‘cos(x) > cos(y)’ if you know you are working with small positive angles.

The a b (calc-substitute) [subst] command substitutes all occurrences of some variable or sub-expression of an expression with a new sub-expression. For example, substituting ‘sin(x)’ with ‘cos(y)’ in ‘2 sin(x)^2 + x sin(x) + sin(2 x)’ produces ‘2 cos(y)^2 + x cos(y) + sin(2 x)’. Note that this is a purely structural substitution; the lone ‘x’ and the ‘sin(2 x)’ stayed the same because they did not look like ‘sin(x)’. See Rewrite Rules, for a more general method for doing substitutions.

The a b command normally prompts for two formulas, the old one and the new one. If you enter a blank line for the first prompt, all three arguments are taken from the stack (new, then old, then target expression). If you type an old formula but then enter a blank line for the new one, the new formula is taken from top-of-stack and the target from second-to-top. If you answer both prompts, the target is taken from top-of-stack as usual.

Note that a b has no understanding of commutativity or associativity. The pattern ‘x+y’ will not match the formula ‘y+x’. Also, ‘y+z’ will not match inside the formula ‘x+y+z’ because the ‘+’ operator is left-associative, so the “deep structure” of that formula is ‘(x+y) + z’. Use d U (calc-unformatted-language) mode to see the true structure of a formula. The rewrite rule mechanism, discussed later, does not have these limitations.

As an algebraic function, subst takes three arguments: Target expression, old, new. Note that subst is always evaluated immediately, even if its arguments are variables, so if you wish to put a call to subst onto the stack you must turn the default simplifications off first (with m O).


*** Simplifying Formulas

The sections below describe all the various kinds of simplifications Calc provides in full detail. None of Calc’s simplification commands are designed to pull rabbits out of hats; they simply apply certain specific rules to put formulas into less redundant or more pleasing forms. Serious algebra in Calc must be done manually, usually with a combination of selections and rewrite rules. See Rearranging Formulas using Selections. See Rewrite Rules.

See Simplification Modes, for commands to control what level of simplification occurs automatically. Normally the algebraic simplifications described below occur. If you have turned on a simplification mode which does not do these algebraic simplifications, you can still apply them to a formula with the a s (calc-simplify) [simplify] command.

There are some simplifications that, while sometimes useful, are never done automatically. For example, the I prefix can be given to a s; the I a s command will change any trigonometric function to the appropriate combination of ‘sin’s and ‘cos’s before simplifying. This can be useful in simplifying even mildly complicated trigonometric expressions. For example, while the algebraic simplifications can reduce ‘sin(x) csc(x)’ to ‘1’, they will not simplify ‘sin(x)^2 csc(x)’. The command I a s can be used to simplify this latter expression; it will transform ‘sin(x)^2 csc(x)’ into ‘sin(x)’. However, I a s will also perform some “simplifications” which may not be desired; for example, it will transform ‘tan(x)^2’ into ‘sin(x)^2 / cos(x)^2’. The Hyperbolic prefix H can be used similarly; the H a s will replace any hyperbolic functions in the formula with the appropriate combinations of ‘sinh’s and ‘cosh’s before simplifying.


**** Basic Simplifications

This section describes basic simplifications which Calc performs in many situations. For example, both binary simplifications and algebraic simplifications begin by performing these basic simplifications. You can type m I to restrict the simplifications done on the stack to these simplifications.

The most basic simplification is the evaluation of functions. For example, ‘2 + 3’ is evaluated to ‘5’, and ‘sqrt(9)’ is evaluated to ‘3’. Evaluation does not occur if the arguments to a function are somehow of the wrong type ‘tan([2,3,4])’), range (‘tan(90)’), or number (‘tan(3,5)’), or if the function name is not recognized (‘f(5)’), or if Symbolic mode (see Symbolic Mode) prevents evaluation (‘sqrt(2)’).

Calc simplifies (evaluates) the arguments to a function before it simplifies the function itself. Thus ‘sqrt(5+4)’ is simplified to ‘sqrt(9)’ before the sqrt function itself is applied. There are very few exceptions to this rule: quote, lambda, and condition (the :: operator) do not evaluate their arguments, if (the ? : operator) does not evaluate all of its arguments, and evalto does not evaluate its lefthand argument.

Most commands apply at least these basic simplifications to all arguments they take from the stack, perform a particular operation, then simplify the result before pushing it back on the stack. In the common special case of regular arithmetic commands like + and Q [sqrt], the arguments are simply popped from the stack and collected into a suitable function call, which is then simplified (the arguments being simplified first as part of the process, as described above).

Even the basic set of simplifications are too numerous to describe completely here, but this section will describe the ones that apply to the major arithmetic operators. This list will be rather technical in nature, and will probably be interesting to you only if you are a serious user of Calc’s algebra facilities.

As well as the simplifications described here, if you have stored any rewrite rules in the variable EvalRules then these rules will also be applied before any of the basic simplifications. See Automatic Rewrites, for details.

And now, on with the basic simplifications:

Arithmetic operators like + and * always take two arguments in Calc’s internal form. Sums and products of three or more terms are arranged by the associative law of algebra into a left-associative form for sums, ‘((a + b) + c) + d’, and (by default) a right-associative form for products, ‘a * (b * (c * d))’. Formulas like ‘(a + b) + (c + d)’ are rearranged to left-associative form, though this rarely matters since Calc’s algebra commands are designed to hide the inner structure of sums and products as much as possible. Sums and products in their proper associative form will be written without parentheses in the examples below.

Sums and products are not rearranged according to the commutative law (‘a + b’ to ‘b + a’) except in a few special cases described below. Some algebra programs always rearrange terms into a canonical order, which enables them to see that ‘a b + b a’ can be simplified to ‘2 a b’. If you are using Basic Simplification mode, Calc assumes you have put the terms into the order you want and generally leaves that order alone, with the consequence that formulas like the above will only be simplified if you explicitly give the a s command. See Algebraic Simplifications.

Differences ‘a - b’ are treated like sums ‘a + (-b)’ for purposes of simplification; one of the default simplifications is to rewrite ‘a + (-b)’ or ‘(-b) + a’, where ‘-b’ represents a “negative-looking” term, into ‘a - b’ form. “Negative-looking” means negative numbers, negated formulas like ‘-x’, and products or quotients in which either term is negative-looking.

Other simplifications involving negation are ‘-(-x)’ to ‘x’; ‘-(a b)’ or ‘-(a/b)’ where either ‘a’ or ‘b’ is negative-looking, simplified by negating that term, or else where ‘a’ or ‘b’ is any number, by negating that number; ‘-(a + b)’ to ‘-a - b’, and ‘-(b - a)’ to ‘a - b’. (This, and rewriting ‘(-b) + a’ to ‘a - b’, are the only cases where the order of terms in a sum is changed by the default simplifications.)

The distributive law is used to simplify sums in some cases: ‘a x + b x’ to ‘(a + b) x’, where ‘a’ represents a number or an implicit 1 or -1 (as in ‘x’ or ‘-x’) and similarly for ‘b’. Use the a c, a f, or j M commands to merge sums with non-numeric coefficients using the distributive law.

The distributive law is only used for sums of two terms, or for adjacent terms in a larger sum. Thus ‘a + b + b + c’ is simplified to ‘a + 2 b + c’, but ‘a + b + c + b’ is not simplified. The reason is that comparing all terms of a sum with one another would require time proportional to the square of the number of terms; Calc omits potentially slow operations like this in basic simplification mode.

Finally, ‘a + 0’ and ‘0 + a’ are simplified to ‘a’. A consequence of the above rules is that ‘0 - a’ is simplified to ‘-a’.

The products ‘1 a’ and ‘a 1’ are simplified to ‘a’; ‘(-1) a’ and ‘a (-1)’ are simplified to ‘-a’; ‘0 a’ and ‘a 0’ are simplified to ‘0’, except that in Matrix mode where ‘a’ is not provably scalar the result is the generic zero matrix ‘idn(0)’, and that if ‘a’ is infinite the result is ‘nan’.

Also, ‘(-a) b’ and ‘a (-b)’ are simplified to ‘-(a b)’, where this occurs for negated formulas but not for regular negative numbers.

Products are commuted only to move numbers to the front: ‘a b 2’ is commuted to ‘2 a b’.

The product ‘a (b + c)’ is distributed over the sum only if ‘a’ and at least one of ‘b’ and ‘c’ are numbers: ‘2 (x + 3)’ goes to ‘2 x + 6’. The formula ‘(-a) (b - c)’, where ‘-a’ is a negative number, is rewritten to ‘a (c - b)’.

The distributive law of products and powers is used for adjacent terms of the product: ‘x^a x^b’ goes to ‘x^(a+b)’ where ‘a’ is a number, or an implicit 1 (as in ‘x’), or the implicit one-half of ‘sqrt(x)’, and similarly for ‘b’. The result is written using ‘sqrt’ or ‘1/sqrt’ if the sum of the powers is ‘1/2’ or ‘-1/2’, respectively. If the sum of the powers is zero, the product is simplified to ‘1’ or to ‘idn(1)’ if Matrix mode is enabled.

The product of a negative power times anything but another negative power is changed to use division: ‘x^(-2) y’ goes to ‘y / x^2’ unless Matrix mode is in effect and neither ‘x’ nor ‘y’ are scalar (in which case it is considered unsafe to rearrange the order of the terms).

Finally, ‘a (b/c)’ is rewritten to ‘(a b)/c’, and also ‘(a/b) c’ is changed to ‘(a c)/b’ unless in Matrix mode.

Simplifications for quotients are analogous to those for products. The quotient ‘0 / x’ is simplified to ‘0’, with the same exceptions that were noted for ‘0 x’. Likewise, ‘x / 1’ and ‘x / (-1)’ are simplified to ‘x’ and ‘-x’, respectively.

The quotient ‘x / 0’ is left unsimplified or changed to an infinite quantity, as directed by the current infinite mode. See Infinite Mode.

The expression ‘a / b^(-c)’ is changed to ‘a b^c’, where ‘-c’ is any negative-looking power. Also, ‘1 / b^c’ is changed to ‘b^(-c)’ for any power ‘c’.

Also, ‘(-a) / b’ and ‘a / (-b)’ go to ‘-(a/b)’; ‘(a/b) / c’ goes to ‘a / (b c)’; and ‘a / (b/c)’ goes to ‘(a c) / b’ unless Matrix mode prevents this rearrangement. Similarly, ‘a / (b:c)’ is simplified to ‘(c:b) a’ for any fraction ‘b:c’.

The distributive law is applied to ‘(a + b) / c’ only if ‘c’ and at least one of ‘a’ and ‘b’ are numbers. Quotients of powers and square roots are distributed just as described for multiplication.

Quotients of products cancel only in the leading terms of the numerator and denominator. In other words, ‘a x b / a y b’ is canceled to ‘x b / y b’ but not to ‘x / y’. Once again this is because full cancellation can be slow; use a s to cancel all terms of the quotient.

Quotients of negative-looking values are simplified according to ‘(-a) / (-b)’ to ‘a / b’, ‘(-a) / (b - c)’ to ‘a / (c - b)’, and ‘(a - b) / (-c)’ to ‘(b - a) / c’.

The formula ‘x^0’ is simplified to ‘1’, or to ‘idn(1)’ in Matrix mode. The formula ‘0^x’ is simplified to ‘0’ unless ‘x’ is a negative number, complex number or zero. If ‘x’ is negative, complex or ‘0.0’, ‘0^x’ is an infinity or an unsimplified formula according to the current infinite mode. The expression ‘0^0’ is simplified to ‘1’.

Powers of products or quotients ‘(a b)^c’, ‘(a/b)^c’ are distributed to ‘a^c b^c’, ‘a^c / b^c’ only if ‘c’ is an integer, or if either ‘a’ or ‘b’ are nonnegative real numbers. Powers of powers ‘(a^b)^c’ are simplified to ‘a^(b c)’ only when ‘c’ is an integer and ‘b c’ also evaluates to an integer. Without these restrictions these simplifications would not be safe because of problems with principal values. (In other words, ‘((-3)^1:2)^2’ is safe to simplify, but ‘((-3)^2)^1:2’ is not.) See Declarations, for ways to inform Calc that your variables satisfy these requirements.

As a special case of this rule, ‘sqrt(x)^n’ is simplified to ‘x^(n/2)’ only for even integers ‘n’.

If ‘a’ is known to be real, ‘b’ is an even integer, and ‘c’ is a half- or quarter-integer, then ‘(a^b)^c’ is simplified to ‘abs(a^(b c))’.

Also, ‘(-a)^b’ is simplified to ‘a^b’ if ‘b’ is an even integer, or to ‘-(a^b)’ if ‘b’ is an odd integer, for any negative-looking expression ‘-a’.

Square roots ‘sqrt(x)’ generally act like one-half powers ‘x^1:2’ for the purposes of the above-listed simplifications.

Also, note that ‘1 / x^1:2’ is changed to ‘x^(-1:2)’, but ‘1 / sqrt(x)’ is left alone.

Generic identity matrices (see Matrix and Scalar Modes) are simplified by the following rules: ‘idn(a) + b’ to ‘a + b’ if ‘b’ is provably scalar, or expanded out if ‘b’ is a matrix; ‘idn(a) + idn(b)’ to ‘idn(a + b)’; ‘-idn(a)’ to ‘idn(-a)’; ‘a idn(b)’ to ‘idn(a b)’ if ‘a’ is provably scalar, or to ‘a b’ if ‘a’ is provably non-scalar; ‘idn(a) idn(b)’ to ‘idn(a b)’; analogous simplifications for quotients involving idn; and ‘idn(a)^n’ to ‘idn(a^n)’ where ‘n’ is an integer.

The floor function and other integer truncation functions vanish if the argument is provably integer-valued, so that ‘floor(round(x))’ simplifies to ‘round(x)’. Also, combinations of float, floor and its friends, and ffloor and its friends, are simplified in appropriate ways. See Integer Truncation.

The expression ‘abs(-x)’ changes to ‘abs(x)’. The expression ‘abs(abs(x))’ changes to ‘abs(x)’; in fact, ‘abs(x)’ changes to ‘x’ or ‘-x’ if ‘x’ is provably nonnegative or nonpositive (see Declarations).

While most functions do not recognize the variable i as an imaginary number, the arg function does handle the two cases ‘arg(i)’ and ‘arg(-i)’ just for convenience.

The expression ‘conj(conj(x))’ simplifies to ‘x’. Various other expressions involving conj, re, and im are simplified, especially if some of the arguments are provably real or involve the constant i. For example, ‘conj(a + b i)’ is changed to ‘conj(a) - conj(b) i’, or to ‘a - b i’ if ‘a’ and ‘b’ are known to be real.

Functions like sin and arctan generally don’t have any default simplifications beyond simply evaluating the functions for suitable numeric arguments and infinity. The algebraic simplifications described in the next section do provide some simplifications for these functions, though.

One important simplification that does occur is that ‘ln(e)’ is simplified to 1, and ‘ln(e^x)’ is simplified to ‘x’ for any ‘x’. This occurs even if you have stored a different value in the Calc variable ‘e’; but this would be a bad idea in any case if you were also using natural logarithms!

Among the logical functions, !(a <= b) changes to a > b and so on. Equations and inequalities where both sides are either negative-looking or zero are simplified by negating both sides and reversing the inequality. While it might seem reasonable to simplify ‘!!x’ to ‘x’, this would not be valid in general because ‘!!2’ is 1, not 2.

Most other Calc functions have few if any basic simplifications defined, aside of course from evaluation when the arguments are suitable numbers.


**** Algebraic Simplifications

This section describes all simplifications that are performed by the algebraic simplification mode, which is the default simplification mode. If you have switched to a different simplification mode, you can switch back with the m A command. Even in other simplification modes, the a s command will use these algebraic simplifications to simplify the formula.

There is a variable, AlgSimpRules, in which you can put rewrites to be applied. Its use is analogous to EvalRules, but without the special restrictions. Basically, the simplifier does ‘a r AlgSimpRules’ with an infinite repeat count on the whole expression being simplified, then it traverses the expression applying the built-in rules described below. If the result is different from the original expression, the process repeats with the basic simplifications (including EvalRules), then AlgSimpRules, then the built-in simplifications, and so on.

Sums are simplified in two ways. Constant terms are commuted to the end of the sum, so that ‘a + 2 + b’ changes to ‘a + b + 2’. The only exception is that a constant will not be commuted away from the first position of a difference, i.e., ‘2 - x’ is not commuted to ‘-x + 2’.

Also, terms of sums are combined by the distributive law, as in ‘x + y + 2 x’ to ‘y + 3 x’. This always occurs for adjacent terms, but Calc’s algebraic simplifications compare all pairs of terms including non-adjacent ones.

Products are sorted into a canonical order using the commutative law. For example, ‘b c a’ is commuted to ‘a b c’. This allows easier comparison of products; for example, the basic simplifications will not change ‘x y + y x’ to ‘2 x y’, but the algebraic simplifications; it first rewrites the sum to ‘x y + x y’ which can then be recognized as a sum of identical terms.

The canonical ordering used to sort terms of products has the property that real-valued numbers, interval forms and infinities come first, and are sorted into increasing order. The V S command uses the same ordering when sorting a vector.

Sorting of terms of products is inhibited when Matrix mode is turned on; in this case, Calc will never exchange the order of two terms unless it knows at least one of the terms is a scalar.

Products of powers are distributed by comparing all pairs of terms, using the same method that the default simplifications use for adjacent terms of products.

Even though sums are not sorted, the commutative law is still taken into account when terms of a product are being compared. Thus ‘(x + y) (y + x)’ will be simplified to ‘(x + y)^2’. A subtle point is that ‘(x - y) (y - x)’ will not be simplified to ‘-(x - y)^2’; Calc does not notice that one term can be written as a constant times the other, even if that constant is -1.

A fraction times any expression, ‘(a:b) x’, is changed to a quotient involving integers: ‘a x / b’. This is not done for floating-point numbers like ‘0.5’, however. This is one reason why you may find it convenient to turn Fraction mode on while doing algebra; see Fraction Mode.

Quotients are simplified by comparing all terms in the numerator with all terms in the denominator for possible cancellation using the distributive law. For example, ‘a x^2 b / c x^3 d’ will cancel ‘x^2’ from the top and bottom to get ‘a b / c x d’. (The terms in the denominator will then be rearranged to ‘c d x’ as described above.) If there is any common integer or fractional factor in the numerator and denominator, it is canceled out; for example, ‘(4 x + 6) / 8 x’ simplifies to ‘(2 x + 3) / 4 x’.

Non-constant common factors are not found even by algebraic simplifications. To cancel the factor ‘a’ in ‘(a x + a) / a^2’ you could first use j M on the product ‘a x’ to Merge the numerator to ‘a (1+x)’, which can then be simplified successfully.

Integer powers of the variable i are simplified according to the identity ‘i^2 = -1’. If you store a new value other than the complex number ‘(0,1)’ in i, this simplification will no longer occur. This is not done by the basic simplifications; in case someone (unwisely) wants to use the name i for a variable unrelated to complex numbers, they can use basic simplification mode.

Square roots of integer or rational arguments are simplified in several ways. (Note that these will be left unevaluated only in Symbolic mode.) First, square integer or rational factors are pulled out so that ‘sqrt(8)’ is rewritten as ‘2 sqrt(2)’. Conceptually speaking this implies factoring the argument into primes and moving pairs of primes out of the square root, but for reasons of efficiency Calc only looks for primes up to 29.

Square roots in the denominator of a quotient are moved to the numerator: ‘1 / sqrt(3)’ changes to ‘sqrt(3) / 3’. The same effect occurs for the square root of a fraction: ‘sqrt(2:3)’ changes to ‘sqrt(6) / 3’.

The % (modulo) operator is simplified in several ways when the modulus ‘M’ is a positive real number. First, if the argument is of the form ‘x + n’ for some real number ‘n’, then ‘n’ is itself reduced modulo ‘M’. For example, ‘(x - 23) % 10’ is simplified to ‘(x + 7) % 10’.

If the argument is multiplied by a constant, and this constant has a common integer divisor with the modulus, then this factor is canceled out. For example, ‘12 x % 15’ is changed to ‘3 (4 x % 5)’ by factoring out 3. Also, ‘(12 x + 1) % 15’ is changed to ‘3 ((4 x + 1:3) % 5)’. While these forms may not seem “simpler,” they allow Calc to discover useful information about modulo forms in the presence of declarations.

If the modulus is 1, then Calc can use int declarations to evaluate the expression. For example, the idiom ‘x % 2’ is often used to check whether a number is odd or even. As described above, ‘2 n % 2’ and ‘(2 n + 1) % 2’ are simplified to ‘2 (n % 1)’ and ‘2 ((n + 1:2) % 1)’, respectively; Calc can simplify these to 0 and 1 (respectively) if n has been declared to be an integer.

Trigonometric functions are simplified in several ways. Whenever a products of two trigonometric functions can be replaced by a single function, the replacement is made; for example, ‘tan(x) cos(x)’ is simplified to ‘sin(x)’. Reciprocals of trigonometric functions are replaced by their reciprocal function; for example, ‘1/sec(x)’ is simplified to ‘cos(x)’. The corresponding simplifications for the hyperbolic functions are also handled.

Trigonometric functions of their inverse functions are simplified. The expression ‘sin(arcsin(x))’ is simplified to ‘x’, and similarly for cos and tan. Trigonometric functions of inverses of different trigonometric functions can also be simplified, as in ‘sin(arccos(x))’ to ‘sqrt(1 - x^2)’.

If the argument to sin is negative-looking, it is simplified to ‘-sin(x)’, and similarly for cos and tan. Finally, certain special values of the argument are recognized; see Trigonometric/Hyperbolic Functions.

Hyperbolic functions of their inverses and of negative-looking arguments are also handled, as are exponentials of inverse hyperbolic functions.

No simplifications for inverse trigonometric and hyperbolic functions are known, except for negative arguments of arcsin, arctan, arcsinh, and arctanh. Note that ‘arcsin(sin(x))’ can not safely change to ‘x’, since this only correct within an integer multiple of ‘2 pi’ radians or 360 degrees. However, ‘arcsinh(sinh(x))’ is simplified to ‘x’ if ‘x’ is known to be real.

Several simplifications that apply to logarithms and exponentials are that ‘exp(ln(x))’, ‘e^ln(x)’, and ‘10^log10(x)’ all reduce to ‘x’. Also, ‘ln(exp(x))’, etc., can reduce to ‘x’ if ‘x’ is provably real. The form ‘exp(x)^y’ is simplified to ‘exp(x y)’. If ‘x’ is a suitable multiple of ‘pi i’ (as described above for the trigonometric functions), then ‘exp(x)’ or ‘e^x’ will be expanded. Finally, ‘ln(x)’ is simplified to a form involving pi and i where ‘x’ is provably negative, positive imaginary, or negative imaginary.

The error functions erf and erfc are simplified when their arguments are negative-looking or are calls to the conj function.

Equations and inequalities are simplified by canceling factors of products, quotients, or sums on both sides. Inequalities change sign if a negative multiplicative factor is canceled. Non-constant multiplicative factors as in ‘a b = a c’ are canceled from equations only if they are provably nonzero (generally because they were declared so; see Declarations). Factors are canceled from inequalities only if they are nonzero and their sign is known.

Simplification also replaces an equation or inequality with 1 or 0 (“true” or “false”) if it can through the use of declarations. If ‘x’ is declared to be an integer greater than 5, then ‘x < 3’, ‘x = 3’, and ‘x = 7.5’ are all simplified to 0, but ‘x > 3’ is simplified to 1. By a similar analysis, ‘abs(x) >= 0’ is simplified to 1, as is ‘x^2 >= 0’ if ‘x’ is known to be real.


**** “Unsafe” Simplifications

Calc is capable of performing some simplifications which may sometimes be desired but which are not “safe” in all cases. The a e (calc-simplify-extended) [esimplify] command applies the algebraic simplifications as well as these extended, or “unsafe”, simplifications. Use this only if you know the values in your formula lie in the restricted ranges for which these simplifications are valid. You can use Extended Simplification mode (m E) to have these simplifications done automatically.

The symbolic integrator uses these extended simplifications; one effect of this is that the integrator’s results must be used with caution. Where an integral table will often attach conditions like “for positive ‘a’ only,” Calc (like most other symbolic integration programs) will simply produce an unqualified result.

Because a e’s simplifications are unsafe, it is sometimes better to type C-u -3 a v, which does extended simplification only on the top level of the formula without affecting the sub-formulas. In fact, C-u -3 j v allows you to target extended simplification to any specific part of a formula.

The variable ExtSimpRules contains rewrites to be applied when the extended simplifications are used. These are applied in addition to EvalRules and AlgSimpRules. (The a r AlgSimpRules step described above is simply followed by an a r ExtSimpRules step.)

Following is a complete list of the “unsafe” simplifications.

Inverse trigonometric or hyperbolic functions, called with their corresponding non-inverse functions as arguments, are simplified. For example, ‘arcsin(sin(x))’ changes to ‘x’. Also, ‘arcsin(cos(x))’ and ‘arccos(sin(x))’ both change to ‘pi/2 - x’. These simplifications are unsafe because they are valid only for values of ‘x’ in a certain range; outside that range, values are folded down to the 360-degree range that the inverse trigonometric functions always produce.

Powers of powers ‘(x^a)^b’ are simplified to ‘x^(a b)’ for all ‘a’ and ‘b’. These results will be valid only in a restricted range of ‘x’; for example, in ‘(x^2)^1:2’ the powers cancel to get ‘x’, which is valid for positive values of ‘x’ but not for negative or complex values.

Similarly, ‘sqrt(x^a)’ and ‘sqrt(x)^a’ are both simplified (possibly unsafely) to ‘x^(a/2)’.

Forms like ‘sqrt(1 - sin(x)^2)’ are simplified to, e.g., ‘cos(x)’. Calc has identities of this sort for sin, cos, tan, sinh, and cosh.

Arguments of square roots are partially factored to look for squared terms that can be extracted. For example, ‘sqrt(a^2 b^3 + a^3 b^2)’ simplifies to ‘a b sqrt(a+b)’.

The simplifications of ‘ln(exp(x))’, ‘ln(e^x)’, and ‘log10(10^x)’ to ‘x’ are also unsafe because of problems with principal values (although these simplifications are safe if ‘x’ is known to be real).

Common factors are canceled from products on both sides of an equation, even if those factors may be zero: ‘a x / b x’ to ‘a / b’. Such factors are never canceled from inequalities: Even the extended simplifications are not bold enough to reduce ‘a x < b x’ to ‘a < b’ (or ‘a > b’, depending on whether you believe ‘x’ is positive or negative). The a M / command can be used to divide a factor out of both sides of an inequality.


**** Simplification of Units

The simplifications described in this section (as well as the algebraic simplifications) are applied when units need to be simplified. They can be applied using the u s (calc-simplify-units) command, or will be done automatically in Units Simplification mode (m U). See Basic Operations on Units.

The variable UnitSimpRules contains rewrites to be applied by units simplifications. These are applied in addition to EvalRules and AlgSimpRules.

Scalar mode is automatically put into effect when simplifying units. See Matrix and Scalar Modes.

Sums ‘a + b’ involving units are simplified by extracting the units of ‘a’ as if by the u x command (call the result ‘u_a’), then simplifying the expression ‘b / u_a’ using u b and u s. If the result has units then the sum is inconsistent and is left alone. Otherwise, it is rewritten in terms of the units ‘u_a’.

If units auto-ranging mode is enabled, products or quotients in which the first argument is a number which is out of range for the leading unit are modified accordingly.

When canceling and combining units in products and quotients, Calc accounts for unit names that differ only in the prefix letter. For example, ‘2 km m’ is simplified to ‘2000 m^2’. However, compatible but different units like ft and in are not combined in this way.

Quotients ‘a / b’ are simplified in three additional ways. First, if ‘b’ is a number or a product beginning with a number, Calc computes the reciprocal of this number and moves it to the numerator.

Second, for each pair of unit names from the numerator and denominator of a quotient, if the units are compatible (e.g., they are both units of area) then they are replaced by the ratio between those units. For example, in ‘3 s in N / kg cm’ the units ‘in / cm’ will be replaced by ‘2.54’.

Third, if the units in the quotient exactly cancel out, so that a u b command on the quotient would produce a dimensionless number for an answer, then the quotient simplifies to that number.

For powers and square roots, the “unsafe” simplifications ‘(a b)^c’ to ‘a^c b^c’, ‘(a/b)^c’ to ‘a^c / b^c’, and ‘(a^b)^c’ to ‘a^(b c)’ are done if the powers are real numbers. (These are safe in the context of units because all numbers involved can reasonably be assumed to be real.)

Also, if a unit name is raised to a fractional power, and the base units in that unit name all occur to powers which are a multiple of the denominator of the power, then the unit name is expanded out into its base units, which can then be simplified according to the previous paragraph. For example, ‘acre^1.5’ is simplified by noting that ‘1.5 = 3:2’, that ‘acre’ is defined in terms of ‘m^2’, and that the 2 in the power of m is a multiple of 2 in ‘3:2’. Thus, acre^1.5 is replaced by approximately ‘(4046 m^2)^1.5’, which is then changed to ‘4046^1.5 (m^2)^1.5’, then to ‘257440 m^3’.

The functions float, frac, clean, abs, as well as floor and the other integer truncation functions, applied to unit names or products or quotients involving units, are simplified. For example, ‘round(1.6 in)’ is changed to ‘round(1.6) round(in)’; the lefthand term evaluates to 2, and the righthand term simplifies to in.

The functions sin, cos, and tan with arguments that have angular units like rad or arcmin are simplified by converting to base units (radians), then evaluating with the angular mode temporarily set to radians.


*** Polynomials

A polynomial is a sum of terms which are coefficients times various powers of a “base” variable. For example, ‘2 x^2 + 3 x - 4’ is a polynomial in ‘x’. Some formulas can be considered polynomials in several different variables: ‘1 + 2 x + 3 y + 4 x y^2’ is a polynomial in both ‘x’ and ‘y’. Polynomial coefficients are often numbers, but they may in general be any formulas not involving the base variable.

The a f (calc-factor) [factor] command factors a polynomial into a product of terms. For example, the polynomial ‘x^3 + 2 x^2 + x’ is factored into ‘x*(x+1)^2’. As another example, ‘a c + b d + b c + a d’ is factored into the product ‘(a + b) (c + d)’.

Calc currently has three algorithms for factoring. Formulas which are linear in several variables, such as the second example above, are merged according to the distributive law. Formulas which are polynomials in a single variable, with constant integer or fractional coefficients, are factored into irreducible linear and/or quadratic terms. The first example above factors into three linear terms (‘x’, ‘x+1’, and ‘x+1’ again). Finally, formulas which do not fit the above criteria are handled by the algebraic rewrite mechanism.

Calc’s polynomial factorization algorithm works by using the general root-finding command (a P) to solve for the roots of the polynomial. It then looks for roots which are rational numbers or complex-conjugate pairs, and converts these into linear and quadratic terms, respectively. Because it uses floating-point arithmetic, it may be unable to find terms that involve large integers (whose number of digits approaches the current precision). Also, irreducible factors of degree higher than quadratic are not found, and polynomials in more than one variable are not treated. (A more robust factorization algorithm may be included in a future version of Calc.)

The rewrite-based factorization method uses rules stored in the variable FactorRules. See Rewrite Rules, for a discussion of the operation of rewrite rules. The default FactorRules are able to factor quadratic forms symbolically into two linear terms, ‘(a x + b) (c x + d)’. You can edit these rules to include other cases if you wish. To use the rules, Calc builds the formula ‘thecoefs(x, [a, b, c, ...])’ where x is the polynomial base variable and a, b, etc., are polynomial coefficients (which may be numbers or formulas). The constant term is written first, i.e., in the a position. When the rules complete, they should have changed the formula into the form ‘thefactors(x, [f1, f2, f3, ...])’ where each fi should be a factored term, e.g., ‘x - ai’. Calc then multiplies these terms together to get the complete factored form of the polynomial. If the rules do not change the thecoefs call to a thefactors call, a f leaves the polynomial alone on the assumption that it is unfactorable. (Note that the function names thecoefs and thefactors are used only as placeholders; there are no actual Calc functions by those names.)

The H a f [factors] command also factors a polynomial, but it returns a list of factors instead of an expression which is the product of the factors. Each factor is represented by a sub-vector of the factor, and the power with which it appears. For example, ‘x^5 + x^4 - 33 x^3 + 63 x^2’ factors to ‘(x + 7) x^2 (x - 3)^2’ in a f, or to ‘[ [x, 2], [x+7, 1], [x-3, 2] ]’ in H a f. If there is an overall numeric factor, it always comes first in the list. The functions factor and factors allow a second argument when written in algebraic form; ‘factor(x,v)’ factors ‘x’ with respect to the specific variable ‘v’. The default is to factor with respect to all the variables that appear in ‘x’.

The a c (calc-collect) [collect] command rearranges a formula as a polynomial in a given variable, ordered in decreasing powers of that variable. For example, given ‘1 + 2 x + 3 y + 4 x y^2’ on the stack, a c x would produce ‘(2 + 4 y^2) x + (1 + 3 y)’, and a c y would produce ‘(4 x) y^2 + 3 y + (1 + 2 x)’. The polynomial will be expanded out using the distributive law as necessary: Collecting ‘x’ in ‘(x - 1)^3’ produces ‘x^3 - 3 x^2 + 3 x - 1’. Terms not involving ‘x’ will not be expanded.

The “variable” you specify at the prompt can actually be any expression: a c ln(x+1) will collect together all terms multiplied by ‘ln(x+1)’ or integer powers thereof. If ‘x’ also appears in the formula in a context other than ‘ln(x+1)’, a c will treat those occurrences as unrelated to ‘ln(x+1)’, i.e., as constants.

The a x (calc-expand) [expand] command expands an expression by applying the distributive law everywhere. It applies to products, quotients, and powers involving sums. By default, it fully distributes all parts of the expression. With a numeric prefix argument, the distributive law is applied only the specified number of times, then the partially expanded expression is left on the stack.

The a x and j D commands are somewhat redundant. Use a x if you want to expand all products of sums in your formula. Use j D if you want to expand a particular specified term of the formula. There is an exactly analogous correspondence between a f and j M. (The j D and j M commands also know many other kinds of expansions, such as ‘exp(a + b) = exp(a) exp(b)’, which a x and a f do not do.)

Calc’s automatic simplifications will sometimes reverse a partial expansion. For example, the first step in expanding ‘(x+1)^3’ is to write ‘(x+1) (x+1)^2’. If a x stops there and tries to put this formula onto the stack, though, Calc will automatically simplify it back to ‘(x+1)^3’ form. The solution is to turn simplification off first (see Simplification Modes), or to run a x without a numeric prefix argument so that it expands all the way in one step.

The a a (calc-apart) [apart] command expands a rational function by partial fractions. A rational function is the quotient of two polynomials; apart pulls this apart into a sum of rational functions with simple denominators. In algebraic notation, the apart function allows a second argument that specifies which variable to use as the “base”; by default, Calc chooses the base variable automatically.

The a n (calc-normalize-rat) [nrat] command attempts to arrange a formula into a quotient of two polynomials. For example, given ‘1 + (a + b/c) / d’, the result would be ‘(b + a c + c d) / c d’. The quotient is reduced, so that a n will simplify ‘(x^2 + 2x + 1) / (x^2 - 1)’ by dividing out the common factor ‘x + 1’, yielding ‘(x + 1) / (x - 1)’.

The a \ (calc-poly-div) [pdiv] command divides two polynomials ‘u’ and ‘v’, yielding a new polynomial ‘q’. If several variables occur in the inputs, the inputs are considered multivariate polynomials. (Calc divides by the variable with the largest power in ‘u’ first, or, in the case of equal powers, chooses the variables in alphabetical order.) For example, dividing ‘x^2 + 3 x + 2’ by ‘x + 2’ yields ‘x + 1’. The remainder from the division, if any, is reported at the bottom of the screen and is also placed in the Trail along with the quotient.

Using pdiv in algebraic notation, you can specify the particular variable to be used as the base: pdiv(a,b,x). If pdiv is given only two arguments (as is always the case with the a \ command), then it does a multivariate division as outlined above.

The a % (calc-poly-rem) [prem] command divides two polynomials and keeps the remainder ‘r’. The quotient ‘q’ is discarded. For any formulas ‘a’ and ‘b’, the results of a \ and a % satisfy ‘a = q b + r’. (This is analogous to plain \ and %, which compute the integer quotient and remainder from dividing two numbers.)

The a / (calc-poly-div-rem) [pdivrem] command divides two polynomials and reports both the quotient and the remainder as a vector ‘[q, r]’. The H a / [pdivide] command divides two polynomials and constructs the formula ‘q + r/b’ on the stack. (Naturally if the remainder is zero, this will immediately simplify to ‘q’.)

The a g (calc-poly-gcd) [pgcd] command computes the greatest common divisor of two polynomials. (The GCD actually is unique only to within a constant multiplier; Calc attempts to choose a GCD which will be unsurprising.) For example, the a n command uses a g to take the GCD of the numerator and denominator of a quotient, then divides each by the result using a \. (The definition of GCD ensures that this division can take place without leaving a remainder.)

While the polynomials used in operations like a / and a g often have integer coefficients, this is not required. Calc can also deal with polynomials over the rationals or floating-point reals. Polynomials with modulo-form coefficients are also useful in many applications; if you enter ‘(x^2 + 3 x - 1) mod 5’, Calc automatically transforms this into a polynomial over the field of integers mod 5: ‘(1 mod 5) x^2 + (3 mod 5) x + (4 mod 5)’.

Congratulations and thanks go to Ove Ewerlid (ewerlid@mizar.DoCS.UU.SE), who contributed many of the polynomial routines used in the above commands.

See Decomposing Polynomials, for several useful functions for extracting the individual coefficients of a polynomial.


*** Calculus

The following calculus commands do not automatically simplify their inputs or outputs using calc-simplify. You may find it helps to do this by hand by typing a s or a e. It may also help to use a x and/or a c to arrange a result in the most readable way.

**** Differentiation

The a d (calc-derivative) [deriv] command computes the derivative of the expression on the top of the stack with respect to some variable, which it will prompt you to enter. Normally, variables in the formula other than the specified differentiation variable are considered constant, i.e., ‘deriv(y,x)’ is reduced to zero. With the Hyperbolic flag, the tderiv (total derivative) operation is used instead, in which derivatives of variables are not reduced to zero unless those variables are known to be “constant,” i.e., independent of any other variables. (The built-in special variables like pi are considered constant, as are variables that have been declared const; see Declarations.)

With a numeric prefix argument n, this command computes the nth derivative.

When working with trigonometric functions, it is best to switch to Radians mode first (with m r). The derivative of ‘sin(x)’ in degrees is ‘(pi/180) cos(x)’, probably not the expected answer!

If you use the deriv function directly in an algebraic formula, you can write ‘deriv(f,x,x0)’ which represents the derivative of ‘f’ with respect to ‘x’, evaluated at the point ‘x=x0’.

If the formula being differentiated contains functions which Calc does not know, the derivatives of those functions are produced by adding primes (apostrophe characters). For example, ‘deriv(f(2x), x)’ produces ‘2 f'(2 x)’, where the function f' represents the derivative of f.

For functions you have defined with the Z F command, Calc expands the functions according to their defining formulas unless you have also defined f' suitably. For example, suppose we define ‘sinc(x) = sin(x)/x’ using Z F. If we then differentiate the formula ‘sinc(2 x)’, the formula will be expanded to ‘sin(2 x) / (2 x)’ and differentiated. However, if we also define ‘sinc'(x) = dsinc(x)’, say, then Calc will write the result as ‘2 dsinc(2 x)’. See Programming with Formulas.

For multi-argument functions ‘f(x,y,z)’, the derivative with respect to the first argument is written ‘f'(x,y,z)’; derivatives with respect to the other arguments are ‘f'2(x,y,z)’ and ‘f'3(x,y,z)’. Various higher-order derivatives can be formed in the obvious way, e.g., ‘f''(x)’ (the second derivative of f) or ‘f''2'3(x,y,z)’ (f differentiated with respect to each argument once).


**** Integration

The a i (calc-integral) [integ] command computes the indefinite integral of the expression on the top of the stack with respect to a prompted-for variable. The integrator is not guaranteed to work for all integrable functions, but it is able to integrate several large classes of formulas. In particular, any polynomial or rational function (a polynomial divided by a polynomial) is acceptable. (Rational functions don’t have to be in explicit quotient form, however; ‘x/(1+x^-2)’ is not strictly a quotient of polynomials, but it is equivalent to ‘x^3/(x^2+1)’, which is.) Also, square roots of terms involving ‘x’ and ‘x^2’ may appear in rational functions being integrated. Finally, rational functions involving trigonometric or hyperbolic functions can be integrated.

With an argument (C-u a i), this command will compute the definite integral of the expression on top of the stack. In this case, the command will again prompt for an integration variable, then prompt for a lower limit and an upper limit.

If you use the integ function directly in an algebraic formula, you can also write ‘integ(f,x,v)’ which expresses the resulting indefinite integral in terms of variable v instead of x. With four arguments, ‘integ(f(x),x,a,b)’ represents a definite integral from a to b.

Please note that the current implementation of Calc’s integrator sometimes produces results that are significantly more complex than they need to be. For example, the integral Calc finds for ‘1/(x+sqrt(x^2+1))’ is several times more complicated than the answer Mathematica returns for the same input, although the two forms are numerically equivalent. Also, any indefinite integral should be considered to have an arbitrary constant of integration added to it, although Calc does not write an explicit constant of integration in its result. For example, Calc’s solution for ‘1/(1+tan(x))’ differs from the solution given in the CRC Math Tables by a constant factor of ‘pi i / 2’, due to a different choice of constant of integration.

The Calculator remembers all the integrals it has done. If conditions change in a way that would invalidate the old integrals, say, a switch from Degrees to Radians mode, then they will be thrown out. If you suspect this is not happening when it should, use the calc-flush-caches command; see Caches.

Calc normally will pursue integration by substitution or integration by parts up to 3 nested times before abandoning an approach as fruitless. If the integrator is taking too long, you can lower this limit by storing a number (like 2) in the variable IntegLimit. (The s I command is a convenient way to edit IntegLimit.) If this variable has no stored value or does not contain a nonnegative integer, a limit of 3 is used. The lower this limit is, the greater the chance that Calc will be unable to integrate a function it could otherwise handle. Raising this limit allows the Calculator to solve more integrals, though the time it takes may grow exponentially. You can monitor the integrator’s actions by creating an Emacs buffer called *Trace*. If such a buffer exists, the a i command will write a log of its actions there.

If you want to manipulate integrals in a purely symbolic way, you can set the integration nesting limit to 0 to prevent all but fast table-lookup solutions of integrals. You might then wish to define rewrite rules for integration by parts, various kinds of substitutions, and so on. See Rewrite Rules.


**** Customizing the Integrator

Calc has two built-in rewrite rules called IntegRules and IntegAfterRules which you can edit to define new integration methods. See Rewrite Rules. At each step of the integration process, Calc wraps the current integrand in a call to the fictitious function ‘integtry(expr,var)’, where expr is the integrand and var is the integration variable. If your rules rewrite this to be a plain formula (not a call to integtry), then Calc will use this formula as the integral of expr. For example, the rule ‘integtry(mysin(x),x) := -mycos(x)’ would define a rule to integrate a function mysin that acts like the sine function. Then, putting ‘4 mysin(2y+1)’ on the stack and typing a i y will produce the integral ‘-2 mycos(2y+1)’. Note that Calc has automatically made various transformations on the integral to allow it to use your rule; integral tables generally give rules for ‘mysin(a x + b)’, but you don’t need to use this much generality in your IntegRules.

As a more serious example, the expression ‘exp(x)/x’ cannot be integrated in terms of the standard functions, so the “exponential integral” function ‘Ei(x)’ was invented to describe it. We can get Calc to do this integral in terms of a made-up Ei function by adding the rule ‘[integtry(exp(x)/x, x) := Ei(x)]’ to IntegRules. Now entering ‘exp(2x)/x’ on the stack and typing a i x yields ‘Ei(2 x)’. This new rule will work with Calc’s various built-in integration methods (such as integration by substitution) to solve a variety of other problems involving Ei: For example, now Calc will also be able to integrate ‘exp(exp(x))’ and ‘ln(ln(x))’ (to get ‘Ei(exp(x))’ and ‘x ln(ln(x)) - Ei(ln(x))’, respectively).

Your rule may do further integration by calling integ. For example, ‘integtry(twice(u),x) := twice(integ(u))’ allows Calc to integrate ‘twice(sin(x))’ to get ‘twice(-cos(x))’. Note that integ was called with only one argument. This notation is allowed only within IntegRules; it means “integrate this with respect to the same integration variable.” If Calc is unable to integrate u, the integration that invoked IntegRules also fails. Thus integrating ‘twice(f(x))’ fails, returning the unevaluated integral ‘integ(twice(f(x)), x)’. It is still valid to call integ with two or more arguments, however; in this case, if u is not integrable, twice itself will still be integrated: If the above rule is changed to ‘... := twice(integ(u,x))’, then integrating ‘twice(f(x))’ will yield ‘twice(integ(f(x),x))’.

If a rule instead produces the formula ‘integsubst(sexpr, svar)’, either replacing the top-level integtry call or nested anywhere inside the expression, then Calc will apply the substitution ‘u = sexpr(svar)’ to try to integrate the original expr. For example, the rule ‘sqrt(a) := integsubst(sqrt(x),x)’ says that if Calc ever finds a square root in the integrand, it should attempt the substitution ‘u = sqrt(x)’. (This particular rule is unnecessary because Calc always tries “obvious” substitutions where sexpr actually appears in the integrand.) The variable svar may be the same as the var that appeared in the call to integtry, but it need not be.

When integrating according to an integsubst, Calc uses the equation solver to find the inverse of sexpr (if the integrand refers to var anywhere except in subexpressions that exactly match sexpr). It uses the differentiator to find the derivative of sexpr and/or its inverse (it has two methods that use one derivative or the other). You can also specify these items by adding extra arguments to the integsubst your rules construct; the general form is ‘integsubst(sexpr, svar, sinv, sprime)’, where sinv is the inverse of sexpr (still written as a function of svar), and sprime is the derivative of sexpr with respect to svar. If you don’t specify these things, and Calc is not able to work them out on its own with the information it knows, then your substitution rule will work only in very specific, simple cases.

Calc applies IntegRules as if by C-u 1 a r IntegRules; in other words, Calc stops rewriting as soon as any rule in your rule set succeeds. (If it weren’t for this, the ‘integsubst(sqrt(x),x)’ example above would keep on adding layers of integsubst calls forever!)

Another set of rules, stored in IntegSimpRules, are applied every time the integrator uses algebraic simplifications to simplify an intermediate result. For example, putting the rule ‘twice(x) := 2 x’ into IntegSimpRules would tell Calc to convert the twice function into a form it knows whenever integration is attempted.

One more way to influence the integrator is to define a function with the Z F command (see Programming with Formulas). Calc’s integrator automatically expands such functions according to their defining formulas, even if you originally asked for the function to be left unevaluated for symbolic arguments. (Certain other Calc systems, such as the differentiator and the equation solver, also do this.)

Sometimes Calc is able to find a solution to your integral, but it expresses the result in a way that is unnecessarily complicated. If this happens, you can either use integsubst as described above to try to hint at a more direct path to the desired result, or you can use IntegAfterRules. This is an extra rule set that runs after the main integrator returns its result; basically, Calc does an a r IntegAfterRules on the result before showing it to you. (It also does algebraic simplifications, without IntegSimpRules, after that to further simplify the result.) For example, Calc’s integrator sometimes produces expressions of the form ‘ln(1+x) - ln(1-x)’; the default IntegAfterRules rewrite this into the more readable form ‘2 arctanh(x)’. Note that, unlike IntegRules, IntegSimpRules and IntegAfterRules are applied any number of times until no further changes are possible. Rewriting by IntegAfterRules occurs only after the main integrator has finished, not at every step as for IntegRules and IntegSimpRules.


**** Numerical Integration

If you want a purely numerical answer to an integration problem, you can use the a I (calc-num-integral) [ninteg] command. This command prompts for an integration variable, a lower limit, and an upper limit. Except for the integration variable, all other variables that appear in the integrand formula must have stored values. (A stored value, if any, for the integration variable itself is ignored.)

Numerical integration works by evaluating your formula at many points in the specified interval. Calc uses an “open Romberg” method; this means that it does not evaluate the formula actually at the endpoints (so that it is safe to integrate ‘sin(x)/x’ from zero, for example). Also, the Romberg method works especially well when the function being integrated is fairly smooth. If the function is not smooth, Calc will have to evaluate it at quite a few points before it can accurately determine the value of the integral.

Integration is much faster when the current precision is small. It is best to set the precision to the smallest acceptable number of digits before you use a I. If Calc appears to be taking too long, press C-g to halt it and try a lower precision. If Calc still appears to need hundreds of evaluations, check to make sure your function is well-behaved in the specified interval.

It is possible for the lower integration limit to be ‘-inf’ (minus infinity). Likewise, the upper limit may be plus infinity. Calc internally transforms the integral into an equivalent one with finite limits. However, integration to or across singularities is not supported: The integral of ‘1/sqrt(x)’ from 0 to 1 exists (it can be found by Calc’s symbolic integrator, for example), but a I will fail because the integrand goes to infinity at one of the endpoints.


**** Taylor Series

The a t (calc-taylor) [taylor] command computes a power series expansion or Taylor series of a function. You specify the variable and the desired number of terms. You may give an expression of the form ‘var = a’ or ‘var - a’ instead of just a variable to produce a Taylor expansion about the point a. You may specify the number of terms with a numeric prefix argument; otherwise the command will prompt you for the number of terms. Note that many series expansions have coefficients of zero for some terms, so you may appear to get fewer terms than you asked for.

If the a i command is unable to find a symbolic integral for a function, you can get an approximation by integrating the function’s Taylor series.


*** Solving Equations

The a S (calc-solve-for) [solve] command rearranges an equation to solve for a specific variable. An equation is an expression of the form ‘L = R’. For example, the command a S x will rearrange ‘y = 3x + 6’ to the form, ‘x = y/3 - 2’. If the input is not an equation, it is treated like an equation of the form ‘X = 0’.

This command also works for inequalities, as in ‘y < 3x + 6’. Some inequalities cannot be solved where the analogous equation could be; for example, solving ‘a < b c’ for ‘b’ is impossible without knowing the sign of ‘c’. In this case, a S will produce the result ‘b != a/c’ (using the not-equal-to operator) to signify that the direction of the inequality is now unknown. The inequality ‘a <= b c’ is not even partially solved. See Declarations, for a way to tell Calc that the signs of the variables in a formula are in fact known.

Two useful commands for working with the result of a S are a . (see Logical Operations), which converts ‘x = y/3 - 2’ to ‘y/3 - 2’, and s l (see The Let Command) which evaluates another formula with ‘x’ set equal to ‘y/3 - 2’.

**** Multiple Solutions

Some equations have more than one solution. The Hyperbolic flag (H a S) [fsolve] tells the solver to report the fully general family of solutions. It will invent variables n1, n2, …, which represent independent arbitrary integers, and s1, s2, …, which represent independent arbitrary signs (either +1 or -1). If you don’t use the Hyperbolic flag, Calc will use zero in place of all arbitrary integers, and plus one in place of all arbitrary signs. Note that variables like n1 and s1 are not given any special interpretation in Calc except by the equation solver itself. As usual, you can use the s l (calc-let) command to obtain solutions for various actual values of these variables.

For example, ' x^2 = y RET H a S x RET solves to get ‘x = s1 sqrt(y)’, indicating that the two solutions to the equation are ‘sqrt(y)’ and ‘-sqrt(y)’. Another way to think about it is that the square-root operation is really a two-valued function; since every Calc function must return a single result, sqrt chooses to return the positive result. Then H a S doctors this result using s1 to indicate the full set of possible values of the mathematical square-root.

There is a similar phenomenon going the other direction: Suppose we solve ‘sqrt(y) = x’ for y. Calc squares both sides to get ‘y = x^2’. This is correct, except that it introduces some dubious solutions. Consider solving ‘sqrt(y) = -3’: Calc will report ‘y = 9’ as a valid solution, which is true in the mathematical sense of square-root, but false (there is no solution) for the actual Calc positive-valued sqrt. This happens for both a S and H a S.

If you store a positive integer in the Calc variable GenCount, then Calc will generate formulas of the form ‘as(n)’ for arbitrary signs, and ‘an(n)’ for arbitrary integers, where n represents successive values taken by incrementing GenCount by one. While the normal arbitrary sign and integer symbols start over at s1 and n1 with each new Calc command, the GenCount approach will give each arbitrary value a name that is unique throughout the entire Calc session. Also, the arbitrary values are function calls instead of variables, which is advantageous in some cases. For example, you can make a rewrite rule that recognizes all arbitrary signs using a pattern like ‘as(n)’. The s l command only works on variables, but you can use the a b (calc-substitute) command to substitute actual values for function calls like ‘as(3)’.

The s G (calc-edit-GenCount) command is a convenient way to create or edit this variable. Press C-c C-c to finish.

If you have not stored a value in GenCount, or if the value in that variable is not a positive integer, the regular s1/n1 notation is used.

With the Inverse flag, I a S [finv] treats the expression on top of the stack as a function of the specified variable and solves to find the inverse function, written in terms of the same variable. For example, I a S x inverts ‘2x + 6’ to ‘x/2 - 3’. You can use both Inverse and Hyperbolic [ffinv] to obtain a fully general inverse, as described above.

Some equations, specifically polynomials, have a known, finite number of solutions. The a P (calc-poly-roots) [roots] command uses H a S to solve an equation in general form, then, for all arbitrary-sign variables like s1, and all arbitrary-integer variables like n1 for which n1 only usefully varies over a finite range, it expands these variables out to all their possible values. The results are collected into a vector, which is returned. For example, ‘roots(x^4 = 1, x)’ returns the four solutions ‘[1, -1, (0, 1), (0, -1)]’. Generally an nth degree polynomial will always have n roots on the complex plane. (If you have given a real declaration for the solution variable, then only the real-valued solutions, if any, will be reported; see Declarations.)

Note that because a P uses H a S, it is able to deliver symbolic solutions if the polynomial has symbolic coefficients. Also note that Calc’s solver is not able to get exact symbolic solutions to all polynomials. Polynomials containing powers up to ‘x^4’ can always be solved exactly; polynomials of higher degree sometimes can be: ‘x^6 + x^3 + 1’ is converted to ‘(x^3)^2 + (x^3) + 1’, which can be solved for ‘x^3’ using the quadratic equation, and then for ‘x’ by taking cube roots. But in many cases, like ‘x^6 + x + 1’, Calc does not know how to rewrite the polynomial into a form it can solve. The a P command can still deliver a list of numerical roots, however, provided that Symbolic mode (m s) is not turned on. (If you work with Symbolic mode on, recall that the N (calc-eval-num) key is a handy way to reevaluate the formula on the stack with Symbolic mode temporarily off.) Naturally, a P can only provide numerical roots if the polynomial coefficients are all numbers (real or complex).


**** Solving Systems of Equations

You can also use the commands described above to solve systems of simultaneous equations. Just create a vector of equations, then specify a vector of variables for which to solve. (You can omit the surrounding brackets when entering the vector of variables at the prompt.)

For example, putting ‘[x + y = a, x - y = b]’ on the stack and typing a S x,y RET produces the vector of solutions ‘[x = a - (a-b)/2, y = (a-b)/2]’. The result vector will have the same length as the variables vector, and the variables will be listed in the same order there. Note that the solutions are not always simplified as far as possible; the solution for ‘x’ here could be improved by an application of the a n command.

Calc’s algorithm works by trying to eliminate one variable at a time by solving one of the equations for that variable and then substituting into the other equations. Calc will try all the possibilities, but you can speed things up by noting that Calc first tries to eliminate the first variable with the first equation, then the second variable with the second equation, and so on. It also helps to put the simpler (e.g., more linear) equations toward the front of the list. Calc’s algorithm will solve any system of linear equations, and also many kinds of nonlinear systems.

Normally there will be as many variables as equations. If you give fewer variables than equations (an “over-determined” system of equations), Calc will find a partial solution. For example, typing a S y RET with the above system of equations would produce ‘[y = a - x]’. There are now several ways to express this solution in terms of the original variables; Calc uses the first one that it finds. You can control the choice by adding variable specifiers of the form ‘elim(v)’ to the variables list. This says that v should be eliminated from the equations; the variable will not appear at all in the solution. For example, typing a S y,elim(x) would yield ‘[y = a - (b+a)/2]’.

If the variables list contains only elim specifiers, Calc simply eliminates those variables from the equations and then returns the resulting set of equations. For example, a S elim(x) produces ‘[a - 2 y = b]’. Every variable eliminated will reduce the number of equations in the system by one.

Again, a S gives you one solution to the system of equations. If there are several solutions, you can use H a S to get a general family of solutions, or, if there is a finite number of solutions, you can use a P to get a list. (In the latter case, the result will take the form of a matrix where the rows are different solutions and the columns correspond to the variables you requested.)

Another way to deal with certain kinds of overdetermined systems of equations is the a F command, which does least-squares fitting to satisfy the equations. See Curve Fitting.


**** Decomposing Polynomials

The poly function takes a polynomial and a variable as arguments, and returns a vector of polynomial coefficients (constant coefficient first). For example, ‘poly(x^3 + 2 x, x)’ returns ‘[0, 2, 0, 1]’. If the input is not a polynomial in ‘x’, the call to poly is left in symbolic form. If the input does not involve the variable ‘x’, the input is returned in a list of length one, representing a polynomial with only a constant coefficient. The call ‘poly(x, x)’ returns the vector ‘[0, 1]’. The last element of the returned vector is guaranteed to be nonzero; note that ‘poly(0, x)’ returns the empty vector ‘[]’. Note also that ‘x’ may actually be any formula; for example, ‘poly(sin(x)^2 - sin(x) + 3, sin(x))’ returns ‘[3, -1, 1]’.

To get the ‘x^k’ coefficient of polynomial ‘p’, use ‘poly(p, x)_(k+1)’. To get the degree of polynomial ‘p’, use ‘vlen(poly(p, x)) - 1’. For example, ‘poly((x+1)^4, x)’ returns ‘[1, 4, 6, 4, 1]’, so ‘poly((x+1)^4, x)_(2+1)’ gives the ‘x^2’ coefficient of this polynomial, 6.

One important feature of the solver is its ability to recognize formulas which are “essentially” polynomials. This ability is made available to the user through the gpoly function, which is used just like poly: ‘gpoly(expr, var)’. If expr is a polynomial in some term which includes var, then this function will return a vector ‘[x, c, a]’ where x is the term that depends on var, c is a vector of polynomial coefficients (like the one returned by poly), and a is a multiplier which is usually 1. Basically, ‘expr = a*(c_1 + c_2 x + c_3 x^2 + ...)’. The last element of c is guaranteed to be non-zero, and c will not equal ‘[1]’ (i.e., the trivial decomposition expr = x is not considered a polynomial). One side effect is that ‘gpoly(x, x)’ and ‘gpoly(6, x)’, both of which might be expected to recognize their arguments as polynomials, will not because the decomposition is considered trivial.

For example, ‘gpoly((x-2)^2, x)’ returns ‘[x, [4, -4, 1], 1]’, since the expanded form of this polynomial is ‘4 - 4 x + x^2’.

The term x may itself be a polynomial in var. This is done to reduce the size of the c vector. For example, ‘gpoly(x^4 + x^2 - 1, x)’ returns ‘[x^2, [-1, 1, 1], 1]’, since a quadratic polynomial in ‘x^2’ is easier to solve than a quartic polynomial in ‘x’.

A few more examples of the kinds of polynomials gpoly can discover:

sin(x) - 1               [sin(x), [-1, 1], 1]
x + 1/x - 1              [x, [1, -1, 1], 1/x]
x + 1/x                  [x^2, [1, 1], 1/x]
x^3 + 2 x                [x^2, [2, 1], x]
x + x^2:3 + sqrt(x)      [x^1:6, [1, 1, 0, 1], x^1:2]
x^(2a) + 2 x^a + 5       [x^a, [5, 2, 1], 1]
(exp(-x) + exp(x)) / 2   [e^(2 x), [0.5, 0.5], e^-x]
The poly and gpoly functions accept a third integer argument which specifies the largest degree of polynomial that is acceptable. If this is ‘n’, then only c vectors of length ‘n+1’ or less will be returned. Otherwise, the poly or gpoly call will remain in symbolic form. For example, the equation solver can handle quartics and smaller polynomials, so it calls ‘gpoly(expr, var, 4)’ to discover whether expr can be treated by its linear, quadratic, cubic, or quartic formulas.

The pdeg function computes the degree of a polynomial; ‘pdeg(p,x)’ is the highest power of x that appears in p. This is the same as ‘vlen(poly(p,x))-1’, but is much more efficient. If p is constant with respect to x, then ‘pdeg(p,x) = 0’. If p is not a polynomial in x (e.g., ‘pdeg(2 cos(x), x)’, the function remains unevaluated. It is possible to omit the second argument x, in which case ‘pdeg(p)’ returns the highest total degree of any term of the polynomial, counting all variables that appear in p. Note that pdeg(c) = pdeg(c,x) = 0 for any nonzero constant c; the degree of the constant zero is considered to be -inf (minus infinity).

The plead function finds the leading term of a polynomial. Thus ‘plead(p,x)’ is equivalent to ‘poly(p,x)_vlen(poly(p,x))’, though again more efficient. In particular, ‘plead((2x+1)^10, x)’ returns 1024 without expanding out the list of coefficients. The value of plead(p,x) will be zero only if ‘p = 0’.

The pcont function finds the content of a polynomial. This is the greatest common divisor of all the coefficients of the polynomial. With two arguments, pcont(p,x) effectively uses ‘poly(p,x)’ to get a list of coefficients, then uses pgcd (the polynomial GCD function) to combine these into an answer. For example, ‘pcont(4 x y^2 + 6 x^2 y, x)’ is ‘2 y’. The content is basically the “biggest” polynomial that can be divided into p exactly. The sign of the content is the same as the sign of the leading coefficient.

With only one argument, ‘pcont(p)’ computes the numerical content of the polynomial, i.e., the gcd of the numerical coefficients of all the terms in the formula. Note that gcd is defined on rational numbers as well as integers; it computes the gcd of the numerators and the lcm of the denominators. Thus ‘pcont(4:3 x y^2 + 6 x^2 y)’ returns 2:3. Dividing the polynomial by this number will clear all the denominators, as well as dividing by any common content in the numerators. The numerical content of a polynomial is negative only if all the coefficients in the polynomial are negative.

The pprim function finds the primitive part of a polynomial, which is simply the polynomial divided (using pdiv if necessary) by its content. If the input polynomial has rational coefficients, the result will have integer coefficients in simplest terms.


*** Numerical Solutions

Not all equations can be solved symbolically. The commands in this section use numerical algorithms that can find a solution to a specific instance of an equation to any desired accuracy. Note that the numerical commands are slower than their algebraic cousins; it is a good idea to try a S before resorting to these commands.

(See Curve Fitting, for some other, more specialized, operations on numerical data.)

**** Root Finding

The a R (calc-find-root) [root] command finds a numerical solution (or root) of an equation. (This command treats inequalities the same as equations. If the input is any other kind of formula, it is interpreted as an equation of the form ‘X = 0’.)

The a R command requires an initial guess on the top of the stack, and a formula in the second-to-top position. It prompts for a solution variable, which must appear in the formula. All other variables that appear in the formula must have assigned values, i.e., when a value is assigned to the solution variable and the formula is evaluated with =, it should evaluate to a number. Any assigned value for the solution variable itself is ignored and unaffected by this command.

When the command completes, the initial guess is replaced on the stack by a vector of two numbers: The value of the solution variable that solves the equation, and the difference between the lefthand and righthand sides of the equation at that value. Ordinarily, the second number will be zero or very nearly zero. (Note that Calc uses a slightly higher precision while finding the root, and thus the second number may be slightly different from the value you would compute from the equation yourself.)

The v h (calc-head) command is a handy way to extract the first element of the result vector, discarding the error term.

The initial guess can be a real number, in which case Calc searches for a real solution near that number, or a complex number, in which case Calc searches the whole complex plane near that number for a solution, or it can be an interval form which restricts the search to real numbers inside that interval.

Calc tries to use a d to take the derivative of the equation. If this succeeds, it uses Newton’s method. If the equation is not differentiable Calc uses a bisection method. (If Newton’s method appears to be going astray, Calc switches over to bisection if it can, or otherwise gives up. In this case it may help to try again with a slightly different initial guess.) If the initial guess is a complex number, the function must be differentiable.

If the formula (or the difference between the sides of an equation) is negative at one end of the interval you specify and positive at the other end, the root finder is guaranteed to find a root. Otherwise, Calc subdivides the interval into small parts looking for positive and negative values to bracket the root. When your guess is an interval, Calc will not look outside that interval for a root.

The H a R [wroot] command is similar to a R, except that if the initial guess is an interval for which the function has the same sign at both ends, then rather than subdividing the interval Calc attempts to widen it to enclose a root. Use this mode if you are not sure if the function has a root in your interval.

If the function is not differentiable, and you give a simple number instead of an interval as your initial guess, Calc uses this widening process even if you did not type the Hyperbolic flag. (If the function is differentiable, Calc uses Newton’s method which does not require a bounding interval in order to work.)

If Calc leaves the root or wroot function in symbolic form on the stack, it will normally display an explanation for why no root was found. If you miss this explanation, press w (calc-why) to get it back.


**** Minimization

The a N (calc-find-minimum) [minimize] command finds a minimum value for a formula. It is very similar in operation to a R (calc-find-root): You give the formula and an initial guess on the stack, and are prompted for the name of a variable. The guess may be either a number near the desired minimum, or an interval enclosing the desired minimum. The function returns a vector containing the value of the variable which minimizes the formula’s value, along with the minimum value itself.

Note that this command looks for a local minimum. Many functions have more than one minimum; some, like ‘x sin(x)’, have infinitely many. In fact, there is no easy way to define the “global” minimum of ‘x sin(x)’ but Calc can still locate any particular local minimum for you. Calc basically goes downhill from the initial guess until it finds a point at which the function’s value is greater both to the left and to the right. Calc does not use derivatives when minimizing a function.

If your initial guess is an interval and it looks like the minimum occurs at one or the other endpoint of the interval, Calc will return that endpoint only if that endpoint is closed; thus, minimizing ‘17 x’ over ‘[2..3]’ will return ‘[2, 38]’, but minimizing over ‘(2..3]’ would report no minimum found. In general, you should use closed intervals to find literally the minimum value in that range of ‘x’, or open intervals to find the local minimum, if any, that happens to lie in that range.

Most functions are smooth and flat near their minimum values. Because of this flatness, if the current precision is, say, 12 digits, the variable can only be determined meaningfully to about six digits. Thus you should set the precision to twice as many digits as you need in your answer.

The H a N [wminimize] command, analogously to H a R, expands the guess interval to enclose a minimum rather than requiring that the minimum lie inside the interval you supply.

The a X (calc-find-maximum) [maximize] and H a X [wmaximize] commands effectively minimize the negative of the formula you supply.

The formula must evaluate to a real number at all points inside the interval (or near the initial guess if the guess is a number). If the initial guess is a complex number the variable will be minimized over the complex numbers; if it is real or an interval it will be minimized over the reals.


**** Systems of Equations

The a R command can also solve systems of equations. In this case, the equation should instead be a vector of equations, the guess should instead be a vector of numbers (intervals are not supported), and the variable should be a vector of variables. You can omit the brackets while entering the list of variables. Each equation must be differentiable by each variable for this mode to work. The result will be a vector of two vectors: The variable values that solved the system of equations, and the differences between the sides of the equations with those variable values. There must be the same number of equations as variables. Since only plain numbers are allowed as guesses, the Hyperbolic flag has no effect when solving a system of equations.

It is also possible to minimize over many variables with a N (or maximize with a X). Once again the variable name should be replaced by a vector of variables, and the initial guess should be an equal-sized vector of initial guesses. But, unlike the case of multidimensional a R, the formula being minimized should still be a single formula, not a vector. Beware that multidimensional minimization is currently very slow.


*** Curve Fitting

The a F command fits a set of data to a model formula, such as ‘y = m x + b’ where ‘m’ and ‘b’ are parameters to be determined. For a typical set of measured data there will be no single ‘m’ and ‘b’ that exactly fit the data; in this case, Calc chooses values of the parameters that provide the closest possible fit. The model formula can be entered in various ways after the key sequence a F is pressed.

If the letter P is pressed after a F but before the model description is entered, the data as well as the model formula will be plotted after the formula is determined. This will be indicated by a “P” in the minibuffer after the help message.

**** Linear Fits

The a F (calc-curve-fit) [fit] command attempts to fit a set of data (‘x’ and ‘y’ vectors of numbers) to a straight line, polynomial, or other function of ‘x’. For the moment we will consider only the case of fitting to a line, and we will ignore the issue of whether or not the model was in fact a good fit for the data.

In a standard linear least-squares fit, we have a set of ‘(x,y)’ data points that we wish to fit to the model ‘y = m x + b’ by adjusting the parameters ‘m’ and ‘b’ to make the ‘y’ values calculated from the formula be as close as possible to the actual ‘y’ values in the data set. (In a polynomial fit, the model is instead, say, ‘y = a x^3 + b x^2 + c x + d’. In a multilinear fit, we have data points of the form ‘(x_1,x_2,x_3,y)’ and our model is ‘y = a x_1 + b x_2 + c x_3 + d’. These will be discussed later.)

In the model formula, variables like ‘x’ and ‘x_2’ are called the independent variables, and ‘y’ is the dependent variable. Variables like ‘m’, ‘a’, and ‘b’ are called the parameters of the model.

The a F command takes the data set to be fitted from the stack. By default, it expects the data in the form of a matrix. For example, for a linear or polynomial fit, this would be a 2xN matrix where the first row is a list of ‘x’ values and the second row has the corresponding ‘y’ values. For the multilinear fit shown above, the matrix would have four rows (‘x_1’, ‘x_2’, ‘x_3’, and ‘y’, respectively).

If you happen to have an Nx2 matrix instead of a 2xN matrix, just press v t first to transpose the matrix.

After you type a F, Calc prompts you to select a model. For a linear fit, press the digit 1.

Calc then prompts for you to name the variables. By default it chooses high letters like ‘x’ and ‘y’ for independent variables and low letters like ‘a’ and ‘b’ for parameters. (The dependent variable doesn’t need a name.) The two kinds of variables are separated by a semicolon. Since you generally care more about the names of the independent variables than of the parameters, Calc also allows you to name only those and let the parameters use default names.

For example, suppose the data matrix

[ [ 1, 2, 3, 4,  5  ]
  [ 5, 7, 9, 11, 13 ] ]
is on the stack and we wish to do a simple linear fit. Type a F, then 1 for the model, then RET to use the default names. The result will be the formula ‘3. + 2. x’ on the stack. Calc has created the model expression a + b x, then found the optimal values of ‘a’ and ‘b’ to fit the data. (In this case, it was able to find an exact fit.) Calc then substituted those values for ‘a’ and ‘b’ in the model formula.

The a F command puts two entries in the trail. One is, as always, a copy of the result that went to the stack; the other is a vector of the actual parameter values, written as equations: ‘[a = 3, b = 2]’, in case you’d rather read them in a list than pick them out of the formula. (You can type t y to move this vector to the stack; see Trail Commands.

Specifying a different independent variable name will affect the resulting formula: a F 1 k RET produces 3 + 2 k. Changing the parameter names (say, a F 1 k;b,m RET) will affect the equations that go into the trail.

To see what happens when the fit is not exact, we could change the number 13 in the data matrix to 14 and try the fit again. The result is:

2.6 + 2.2 x
Evaluating this formula, say with v x 5 RET TAB V M $ RET, shows a reasonably close match to the y-values in the data.

[4.8, 7., 9.2, 11.4, 13.6]
Since there is no line which passes through all the n data points, Calc has chosen a line that best approximates the data points using the method of least squares. The idea is to define the chi-square error measure

chi^2 = sum((y_i - (a + b x_i))^2, i, 1, N)
which is clearly zero if ‘a + b x’ exactly fits all data points, and increases as various ‘a + b x_i’ values fail to match the corresponding ‘y_i’ values. There are several reasons why the summand is squared, one of them being to ensure that ‘chi^2 >= 0’. Least-squares fitting simply chooses the values of ‘a’ and ‘b’ for which the error ‘chi^2’ is as small as possible.

Other kinds of models do the same thing but with a different model formula in place of ‘a + b x_i’.

A numeric prefix argument causes the a F command to take the data in some other form than one big matrix. A positive argument n will take N items from the stack, corresponding to the n rows of a data matrix. In the linear case, n must be 2 since there is always one independent variable and one dependent variable.

A prefix of zero or plain C-u is a compromise; Calc takes two items from the stack, an n-row matrix of ‘x’ values, and a vector of ‘y’ values. If there is only one independent variable, the ‘x’ values can be either a one-row matrix or a plain vector, in which case the C-u prefix is the same as a C-u 2 prefix.


**** Polynomial and Multilinear Fits

To fit the data to higher-order polynomials, just type one of the digits 2 through 9 when prompted for a model. For example, we could fit the original data matrix from the previous section (with 13, not 14) to a parabola instead of a line by typing a F 2 RET.

2.00000000001 x - 1.5e-12 x^2 + 2.99999999999
Note that since the constant and linear terms are enough to fit the data exactly, it’s no surprise that Calc chose a tiny contribution for ‘x^2’. (The fact that it’s not exactly zero is due only to roundoff error. Since our data are exact integers, we could get an exact answer by typing m f first to get Fraction mode. Then the ‘x^2’ term would vanish altogether. Usually, though, the data being fitted will be approximate floats so Fraction mode won’t help.)

Doing the a F 2 fit on the data set with 14 instead of 13 gives a much larger ‘x^2’ contribution, as Calc bends the line slightly to improve the fit.

0.142857142855 x^2 + 1.34285714287 x + 3.59999999998
An important result from the theory of polynomial fitting is that it is always possible to fit n data points exactly using a polynomial of degree n-1, sometimes called an interpolating polynomial. Using the modified (14) data matrix, a model number of 4 gives a polynomial that exactly matches all five data points:

0.04167 x^4 - 0.4167 x^3 + 1.458 x^2 - 0.08333 x + 4.
The actual coefficients we get with a precision of 12, like ‘0.0416666663588’, clearly suffer from loss of precision. It is a good idea to increase the working precision to several digits beyond what you need when you do a fitting operation. Or, if your data are exact, use Fraction mode to get exact results.

You can type i instead of a digit at the model prompt to fit the data exactly to a polynomial. This just counts the number of columns of the data matrix to choose the degree of the polynomial automatically.

Fitting data “exactly” to high-degree polynomials is not always a good idea, though. High-degree polynomials have a tendency to wiggle uncontrollably in between the fitting data points. Also, if the exact-fit polynomial is going to be used to interpolate or extrapolate the data, it is numerically better to use the a p command described below. See Polynomial Interpolation.

Another generalization of the linear model is to assume the ‘y’ values are a sum of linear contributions from several ‘x’ values. This is a multilinear fit, and it is also selected by the 1 digit key. (Calc decides whether the fit is linear or multilinear by counting the rows in the data matrix.)

Given the data matrix,

[ [  1,   2,   3,    4,   5  ]
  [  7,   2,   3,    5,   2  ]
  [ 14.5, 15, 18.5, 22.5, 24 ] ]
the command a F 1 RET will call the first row ‘x’ and the second row ‘y’, and will fit the values in the third row to the model ‘a + b x + c y’.

8. + 3. x + 0.5 y
Calc can do multilinear fits with any number of independent variables (i.e., with any number of data rows).

Yet another variation is homogeneous linear models, in which the constant term is known to be zero. In the linear case, this means the model formula is simply ‘a x’; in the multilinear case, the model might be ‘a x + b y + c z’; and in the polynomial case, the model could be ‘a x + b x^2 + c x^3’. You can get a homogeneous linear or multilinear model by pressing the letter h followed by a regular model key, like 1 or 2. This will be indicated by an “h” in the minibuffer after the help message.

It is certainly possible to have other constrained linear models, like ‘2.3 + a x’ or ‘a - 4 x’. While there is no single key to select models like these, a later section shows how to enter any desired model by hand. In the first case, for example, you would enter a F ' 2.3 + a x.

Another class of models that will work but must be entered by hand are multinomial fits, e.g., ‘a + b x + c y + d x^2 + e y^2 + f x y’.


**** Error Estimates for Fits

With the Hyperbolic flag, H a F [efit] performs the same fitting operation as a F, but reports the coefficients as error forms instead of plain numbers. Fitting our two data matrices (first with 13, then with 14) to a line with H a F gives the results,

3. + 2. x
2.6 +/- 0.382970843103 + 2.2 +/- 0.115470053838 x
In the first case the estimated errors are zero because the linear fit is perfect. In the second case, the errors are nonzero but moderately small, because the data are still very close to linear.

It is also possible for the input to a fitting operation to contain error forms. The data values must either all include errors or all be plain numbers. Error forms can go anywhere but generally go on the numbers in the last row of the data matrix. If the last row contains error forms ‘y_i +/- sigma_i’, then the ‘chi^2’ statistic is now,

chi^2 = sum(((y_i - (a + b x_i)) / sigma_i)^2, i, 1, N)
so that data points with larger error estimates contribute less to the fitting operation.

If there are error forms on other rows of the data matrix, all the errors for a given data point are combined; the square root of the sum of the squares of the errors forms the ‘sigma_i’ used for the data point.

Both a F and H a F can accept error forms in the input matrix, although if you are concerned about error analysis you will probably use H a F so that the output also contains error estimates.

If the input contains error forms but all the ‘sigma_i’ values are the same, it is easy to see that the resulting fitted model will be the same as if the input did not have error forms at all (‘chi^2’ is simply scaled uniformly by ‘1 / sigma^2’, which doesn’t affect where it has a minimum). But there will be a difference in the estimated errors of the coefficients reported by H a F.

Consult any text on statistical modeling of data for a discussion of where these error estimates come from and how they should be interpreted.

With the Inverse flag, I a F [xfit] produces even more information. The result is a vector of six items:

The model formula with error forms for its coefficients or parameters. This is the result that H a F would have produced.
A vector of “raw” parameter values for the model. These are the polynomial coefficients or other parameters as plain numbers, in the same order as the parameters appeared in the final prompt of the I a F command. For polynomials of degree ‘d’, this vector will have length ‘M = d+1’ with the constant term first.
The covariance matrix ‘C’ computed from the fit. This is an mxm symmetric matrix; the diagonal elements ‘C_j_j’ are the variances ‘sigma_j^2’ of the parameters. The other elements are covariances ‘sigma_i_j^2’ that describe the correlation between pairs of parameters. (A related set of numbers, the linear correlation coefficients ‘r_i_j’, are defined as ‘sigma_i_j^2 / sigma_i sigma_j’.)
A vector of ‘M’ “parameter filter” functions whose meanings are described below. If no filters are necessary this will instead be an empty vector; this is always the case for the polynomial and multilinear fits described so far.
The value of ‘chi^2’ for the fit, calculated by the formulas shown above. This gives a measure of the quality of the fit; statisticians consider ‘chi^2 = N - M’ to indicate a moderately good fit (where again ‘N’ is the number of data points and ‘M’ is the number of parameters).
A measure of goodness of fit expressed as a probability ‘Q’. This is computed from the utpc probability distribution function using ‘chi^2’ with ‘N - M’ degrees of freedom. A value of 0.5 implies a good fit; some texts recommend that often ‘Q = 0.1’ or even 0.001 can signify an acceptable fit. In particular, ‘chi^2’ statistics assume the errors in your inputs follow a normal (Gaussian) distribution; if they don’t, you may have to accept smaller values of ‘Q’.
The ‘Q’ value is computed only if the input included error estimates. Otherwise, Calc will report the symbol nan for ‘Q’. The reason is that in this case the ‘chi^2’ value has effectively been used to estimate the original errors in the input, and thus there is no redundant information left over to use for a confidence test.


**** Standard Nonlinear Models

The a F command also accepts other kinds of models besides lines and polynomials. Some common models have quick single-key abbreviations; others must be entered by hand as algebraic formulas.

Here is a complete list of the standard models recognized by a F:

1
Linear or multilinear. a + b x + c y + d z.

2-9
Polynomials. a + b x + c x^2 + d x^3.

e
Exponential. a exp(b x) exp(c y).

E
Base-10 exponential. a 10^(b x) 10^(c y).

x
Exponential (alternate notation). exp(a + b x + c y).

X
Base-10 exponential (alternate). 10^(a + b x + c y).

l
Logarithmic. a + b ln(x) + c ln(y).

L
Base-10 logarithmic. a + b log10(x) + c log10(y).

^
General exponential. a b^x c^y.

p
Power law. a x^b y^c.

q
Quadratic. a + b (x-c)^2 + d (x-e)^2.

g
Gaussian. (a / b sqrt(2 pi)) exp(-0.5*((x-c)/b)^2).

s
Logistic s curve. a/(1 + exp(b (x - c))).

b
Logistic bell curve. a exp(b (x - c))/(1 + exp(b (x - c)))^2.

o
Hubbert linearization. (y/x) = a (1 - x/b).

All of these models are used in the usual way; just press the appropriate letter at the model prompt, and choose variable names if you wish. The result will be a formula as shown in the above table, with the best-fit values of the parameters substituted. (You may find it easier to read the parameter values from the vector that is placed in the trail.)

All models except Gaussian, logistics, Hubbert and polynomials can generalize as shown to any number of independent variables. Also, all the built-in models except for the logistic and Hubbert curves have an additive or multiplicative parameter shown as ‘a’ in the above table which can be replaced by zero or one, as appropriate, by typing h before the model key.

Note that many of these models are essentially equivalent, but express the parameters slightly differently. For example, ‘a b^x’ and the other two exponential models are all algebraic rearrangements of each other. Also, the “quadratic” model is just a degree-2 polynomial with the parameters expressed differently. Use whichever form best matches the problem.

The HP-28/48 calculators support four different models for curve fitting, called LIN, LOG, EXP, and PWR. These correspond to Calc models ‘a + b x’, ‘a + b ln(x)’, ‘a exp(b x)’, and ‘a x^b’, respectively. In each case, ‘a’ is what the HP-48 identifies as the “intercept,” and ‘b’ is what it calls the “slope.”

If the model you want doesn’t appear on this list, press ' (the apostrophe key) at the model prompt to enter any algebraic formula, such as m x - b, as the model. (Not all models will work, though—see the next section for details.)

The model can also be an equation like ‘y = m x + b’. In this case, Calc thinks of all the rows of the data matrix on equal terms; this model effectively has two parameters (‘m’ and ‘b’) and two independent variables (‘x’ and ‘y’), with no “dependent” variables. Model equations do not need to take this ‘y =’ form. For example, the implicit line equation ‘a x + b y = 1’ works fine as a model.

When you enter a model, Calc makes an alphabetical list of all the variables that appear in the model. These are used for the default parameters, independent variables, and dependent variable (in that order). If you enter a plain formula (not an equation), Calc assumes the dependent variable does not appear in the formula and thus does not need a name.

For example, if the model formula has the variables ‘a,mu,sigma,t,x’, and the data matrix has three rows (meaning two independent variables), Calc will use ‘a,mu,sigma’ as the default parameters, and the data rows will be named ‘t’ and ‘x’, respectively. If you enter an equation instead of a plain formula, Calc will use ‘a,mu’ as the parameters, and ‘sigma,t,x’ as the three independent variables.

You can, of course, override these choices by entering something different at the prompt. If you leave some variables out of the list, those variables must have stored values and those stored values will be used as constants in the model. (Stored values for the parameters and independent variables are ignored by the a F command.) If you list only independent variables, all the remaining variables in the model formula will become parameters.

If there are $ signs in the model you type, they will stand for parameters and all other variables (in alphabetical order) will be independent. Use $ for one parameter, $$ for another, and so on. Thus $ x + $$ is another way to describe a linear model.

If you type a $ instead of ' at the model prompt itself, Calc will take the model formula from the stack. (The data must then appear at the second stack level.) The same conventions are used to choose which variables in the formula are independent by default and which are parameters.

Models taken from the stack can also be expressed as vectors of two or three elements, ‘[model, vars]’ or ‘[model, vars, params]’. Each of vars and params may be either a variable or a vector of variables. (If params is omitted, all variables in model except those listed as vars are parameters.)

When you enter a model manually with ', Calc puts a 3-vector describing the model in the trail so you can get it back if you wish.

Finally, you can store a model in one of the Calc variables Model1 or Model2, then use this model by typing a F u or a F U (respectively). The value stored in the variable can be any of the formats that a F $ would accept for a model on the stack.

Calc uses the principal values of inverse functions like ln and arcsin when doing fits. For example, when you enter the model ‘y = sin(a t + b)’ Calc actually uses the easier form ‘arcsin(y) = a t + b’. The arcsin function always returns results in the range from -90 to 90 degrees (or the equivalent range in radians). Suppose you had data that you believed to represent roughly three oscillations of a sine wave, so that the argument of the sine might go from zero to 3*360 degrees. The above model would appear to be a good way to determine the true frequency and phase of the sine wave, but in practice it would fail utterly. The righthand side of the actual model ‘arcsin(y) = a t + b’ will grow smoothly with ‘t’, but the lefthand side will bounce back and forth between -90 and 90. No values of ‘a’ and ‘b’ can make the two sides match, even approximately.

There is no good solution to this problem at present. You could restrict your data to small enough ranges so that the above problem doesn’t occur (i.e., not straddling any peaks in the sine wave). Or, in this case, you could use a totally different method such as Fourier analysis, which is beyond the scope of the a F command. (Unfortunately, Calc does not currently have any facilities for taking Fourier and related transforms.)


**** Curve Fitting Details

Calc’s internal least-squares fitter can only handle multilinear models. More precisely, it can handle any model of the form ‘a f(x,y,z) + b g(x,y,z) + c h(x,y,z)’, where ‘a,b,c’ are the parameters and ‘x,y,z’ are the independent variables (of course there can be any number of each, not just three).

In a simple multilinear or polynomial fit, it is easy to see how to convert the model into this form. For example, if the model is ‘a + b x + c x^2’, then ‘f(x) = 1’, ‘g(x) = x’, and ‘h(x) = x^2’ are suitable functions.

For most other models, Calc uses a variety of algebraic manipulations to try to put the problem into the form

Y(x,y,z) = A(a,b,c) F(x,y,z) + B(a,b,c) G(x,y,z) + C(a,b,c) H(x,y,z)
where ‘Y,A,B,C,F,G,H’ are arbitrary functions. It computes ‘Y’, ‘F’, ‘G’, and ‘H’ for all the data points, does a standard linear fit to find the values of ‘A’, ‘B’, and ‘C’, then uses the equation solver to solve for ‘a,b,c’ in terms of ‘A,B,C’.

A remarkable number of models can be cast into this general form. We’ll look at two examples here to see how it works. The power-law model ‘y = a x^b’ with two independent variables and two parameters can be rewritten as follows:

y = a x^b
y = a exp(b ln(x))
y = exp(ln(a) + b ln(x))
ln(y) = ln(a) + b ln(x)
which matches the desired form with ‘Y = ln(y)’, ‘A = ln(a)’, ‘F = 1’, ‘B = b’, and ‘G = ln(x)’. Calc thus computes the logarithms of your ‘y’ and ‘x’ values, does a linear fit for ‘A’ and ‘B’, then solves to get ‘a = exp(A)’ and ‘b = B’.

Another interesting example is the “quadratic” model, which can be handled by expanding according to the distributive law.

y = a + b*(x - c)^2
y = a + b c^2 - 2 b c x + b x^2
which matches with ‘Y = y’, ‘A = a + b c^2’, ‘F = 1’, ‘B = -2 b c’, ‘G = x’ (the -2 factor could just as easily have been put into ‘G’ instead of ‘B’), ‘C = b’, and ‘H = x^2’.

The Gaussian model looks quite complicated, but a closer examination shows that it’s actually similar to the quadratic model but with an exponential that can be brought to the top and moved into ‘Y’.

The logistic models cannot be put into general linear form. For these models, and the Hubbert linearization, Calc computes a rough approximation for the parameters, then uses the Levenberg-Marquardt iterative method to refine the approximations.

Another model that cannot be put into general linear form is a Gaussian with a constant background added on, i.e., ‘d’ + the regular Gaussian formula. If you have a model like this, your best bet is to replace enough of your parameters with constants to make the model linearizable, then adjust the constants manually by doing a series of fits. You can compare the fits by graphing them, by examining the goodness-of-fit measures returned by I a F, or by some other method suitable to your application. Note that some models can be linearized in several ways. The Gaussian-plus-d model can be linearized by setting ‘d’ (the background) to a constant, or by setting ‘b’ (the standard deviation) and ‘c’ (the mean) to constants.

To fit a model with constants substituted for some parameters, just store suitable values in those parameter variables, then omit them from the list of parameters when you answer the variables prompt.

A last desperate step would be to use the general-purpose minimize function rather than fit. After all, both functions solve the problem of minimizing an expression (the ‘chi^2’ sum) by adjusting certain parameters in the expression. The a F command is able to use a vastly more efficient algorithm due to its special knowledge about linear chi-square sums, but the a N command can do the same thing by brute force.

A compromise would be to pick out a few parameters without which the fit is linearizable, and use minimize on a call to fit which efficiently takes care of the rest of the parameters. The thing to be minimized would be the value of ‘chi^2’ returned as the fifth result of the xfit function:

minimize(xfit(gaus(a,b,c,d,x), x, [a,b,c], data)_5, d, guess)
where gaus represents the Gaussian model with background, data represents the data matrix, and guess represents the initial guess for ‘d’ that minimize requires. This operation will only be, shall we say, extraordinarily slow rather than astronomically slow (as would be the case if minimize were used by itself to solve the problem).

The I a F [xfit] command is somewhat trickier when nonlinear models are used. The second item in the result is the vector of “raw” parameters ‘A’, ‘B’, ‘C’. The covariance matrix is written in terms of those raw parameters. The fifth item is a vector of filter expressions. This is the empty vector ‘[]’ if the raw parameters were the same as the requested parameters, i.e., if ‘A = a’, ‘B = b’, and so on (which is always true if the model is already linear in the parameters as written, e.g., for polynomial fits). If the parameters had to be rearranged, the fifth item is instead a vector of one formula per parameter in the original model. The raw parameters are expressed in these “filter” formulas as ‘fitdummy(1)’ for ‘A’, ‘fitdummy(2)’ for ‘B’, and so on.

When Calc needs to modify the model to return the result, it replaces ‘fitdummy(1)’ in all the filters with the first item in the raw parameters list, and so on for the other raw parameters, then evaluates the resulting filter formulas to get the actual parameter values to be substituted into the original model. In the case of H a F and I a F where the parameters must be error forms, Calc uses the square roots of the diagonal entries of the covariance matrix as error values for the raw parameters, then lets Calc’s standard error-form arithmetic take it from there.

If you use I a F with a nonlinear model, be sure to remember that the covariance matrix is in terms of the raw parameters, not the actual requested parameters. It’s up to you to figure out how to interpret the covariances in the presence of nontrivial filter functions.

Things are also complicated when the input contains error forms. Suppose there are three independent and dependent variables, ‘x’, ‘y’, and ‘z’, one or more of which are error forms in the data. Calc combines all the error values by taking the square root of the sum of the squares of the errors. It then changes ‘x’ and ‘y’ to be plain numbers, and makes ‘z’ into an error form with this combined error. The ‘Y(x,y,z)’ part of the linearized model is evaluated, and the result should be an error form. The error part of that result is used for ‘sigma_i’ for the data point. If for some reason ‘Y(x,y,z)’ does not return an error form, the combined error from ‘z’ is used directly for ‘sigma_i’. Finally, ‘z’ is also stripped of its error for use in computing ‘F(x,y,z)’, ‘G(x,y,z)’ and so on; the righthand side of the linearized model is computed in regular arithmetic with no error forms.

(While these rules may seem complicated, they are designed to do the most reasonable thing in the typical case that ‘Y(x,y,z)’ depends only on the dependent variable ‘z’, and in fact is often simply equal to ‘z’. For common cases like polynomials and multilinear models, the combined error is simply used as the ‘sigma’ for the data point with no further ado.)

It may be the case that the model you wish to use is linearizable, but Calc’s built-in rules are unable to figure it out. Calc uses its algebraic rewrite mechanism to linearize a model. The rewrite rules are kept in the variable FitRules. You can edit this variable using the s e FitRules command; in fact, there is a special s F command just for editing FitRules. See Other Operations on Variables.

See Rewrite Rules, for a discussion of rewrite rules.

Calc uses FitRules as follows. First, it converts the model to an equation if necessary and encloses the model equation in a call to the function fitmodel (which is not actually a defined function in Calc; it is only used as a placeholder by the rewrite rules). Parameter variables are renamed to function calls ‘fitparam(1)’, ‘fitparam(2)’, and so on, and independent variables are renamed to ‘fitvar(1)’, ‘fitvar(2)’, etc. The dependent variable is the highest-numbered fitvar. For example, the power law model ‘a x^b’ is converted to ‘y = a x^b’, then to

fitmodel(fitvar(2) = fitparam(1) fitvar(1)^fitparam(2))
Calc then applies the rewrites as if by ‘C-u 0 a r FitRules’. (The zero prefix means that rewriting should continue until no further changes are possible.)

When rewriting is complete, the fitmodel call should have been replaced by a fitsystem call that looks like this:

fitsystem(Y, FGH, abc)
where Y is a formula that describes the function ‘Y(x,y,z)’, FGH is the vector of formulas ‘[F(x,y,z), G(x,y,z), H(x,y,z)]’, and abc is the vector of parameter filters which refer to the raw parameters as ‘fitdummy(1)’ for ‘A’, ‘fitdummy(2)’ for ‘B’, etc. While the number of raw parameters (the length of the FGH vector) is usually the same as the number of original parameters (the length of the abc vector), this is not required.

The power law model eventually boils down to

fitsystem(ln(fitvar(2)),
          [1, ln(fitvar(1))],
          [exp(fitdummy(1)), fitdummy(2)])
The actual implementation of FitRules is complicated; it proceeds in four phases. First, common rearrangements are done to try to bring linear terms together and to isolate functions like exp and ln either all the way “out” (so that they can be put into Y) or all the way “in” (so that they can be put into abc or FGH). In particular, all non-constant powers are converted to logs-and-exponentials form, and the distributive law is used to expand products of sums. Quotients are rewritten to use the ‘fitinv’ function, where ‘fitinv(x)’ represents ‘1/x’ while the FitRules are operating. (The use of fitinv makes recognition of linear-looking forms easier.) If you modify FitRules, you will probably only need to modify the rules for this phase.

Phase two, whose rules can actually also apply during phases one and three, first rewrites fitmodel to a two-argument form ‘fitmodel(Y, model)’, where Y is initially zero and model has been changed from ‘a=b’ to ‘a-b’ form. It then tries to peel off invertible functions from the outside of model and put them into Y instead, calling the equation solver to invert the functions. Finally, when this is no longer possible, the fitmodel is changed to a four-argument fitsystem, where the fourth argument is model and the FGH and abc vectors are initially empty. (The last vector is really ABC, corresponding to raw parameters, for now.)

Phase three converts a sum of items in the model to a sum of ‘fitpart(a, b, c)’ terms which represent terms ‘a*b*c’ of the sum, where a is all factors that do not involve any variables, b is all factors that involve only parameters, and c is the factors that involve only independent variables. (If this decomposition is not possible, the rule set will not complete and Calc will complain that the model is too complex.) Then fitparts with equal b or c components are merged back together using the distributive law in order to minimize the number of raw parameters needed.

Phase four moves the fitpart terms into the FGH and ABC vectors. Also, some of the algebraic expansions that were done in phase 1 are undone now to make the formulas more computationally efficient. Finally, it calls the solver one more time to convert the ABC vector to an abc vector, and removes the fourth model argument (which by now will be zero) to obtain the three-argument fitsystem that the linear least-squares solver wants to see.

Two functions which are useful in connection with FitRules are ‘hasfitparams(x)’ and ‘hasfitvars(x)’, which check whether ‘x’ refers to any parameters or independent variables, respectively. Specifically, these functions return “true” if the argument contains any fitparam (or fitvar) function calls, and “false” otherwise. (Recall that “true” means a nonzero number, and “false” means zero. The actual nonzero number returned is the largest n from all the ‘fitparam(n)’s or ‘fitvar(n)’s, respectively, that appear in the formula.)

The fit function in algebraic notation normally takes four arguments, ‘fit(model, vars, params, data)’, where model is the model formula as it would be typed after a F ', vars is the independent variable or a vector of independent variables, params likewise gives the parameter(s), and data is the data matrix. Note that the length of vars must be equal to the number of rows in data if model is an equation, or one less than the number of rows if model is a plain formula. (Actually, a name for the dependent variable is allowed but will be ignored in the plain-formula case.)

If params is omitted, the parameters are all variables in model except those that appear in vars. If vars is also omitted, Calc sorts all the variables that appear in model alphabetically and uses the higher ones for vars and the lower ones for params.

Alternatively, ‘fit(modelvec, data)’ is allowed where modelvec is a 2- or 3-vector describing the model and variables, as discussed previously.

If Calc is unable to do the fit, the fit function is left in symbolic form, ordinarily with an explanatory message. The message will be “Model expression is too complex” if the linearizer was unable to put the model into the required form.

The efit (corresponding to H a F) and xfit (for I a F) functions are completely analogous.


**** Polynomial Interpolation

The a p (calc-poly-interp) [polint] command does a polynomial interpolation at a particular ‘x’ value. It takes two arguments from the stack: A data matrix of the sort used by a F, and a single number which represents the desired ‘x’ value. Calc effectively does an exact polynomial fit as if by a F i, then substitutes the ‘x’ value into the result in order to get an approximate ‘y’ value based on the fit. (Calc does not actually use a F i, however; it uses a direct method which is both more efficient and more numerically stable.)

The result of a p is actually a vector of two values: The ‘y’ value approximation, and an error measure ‘dy’ that reflects Calc’s estimation of the probable error of the approximation at that value of ‘x’. If the input ‘x’ is equal to any of the ‘x’ values in the data matrix, the output ‘y’ will be the corresponding ‘y’ value from the matrix, and the output ‘dy’ will be exactly zero.

A prefix argument of 2 causes a p to take separate x- and y-vectors from the stack instead of one data matrix.

If ‘x’ is a vector of numbers, a p will return a matrix of interpolated results for each of those ‘x’ values. (The matrix will have two columns, the ‘y’ values and the ‘dy’ values.) If ‘x’ is a formula instead of a number, the polint function remains in symbolic form; use the a " command to expand it out to a formula that describes the fit in symbolic terms.

In all cases, the a p command leaves the data vectors or matrix on the stack. Only the ‘x’ value is replaced by the result.

The H a p [ratint] command does a rational function interpolation. It is used exactly like a p, except that it uses as its model the quotient of two polynomials. If there are ‘N’ data points, the numerator and denominator polynomials will each have degree ‘N/2’ (if ‘N’ is odd, the denominator will have degree one higher than the numerator).

Rational approximations have the advantage that they can accurately describe functions that have poles (points at which the function’s value goes to infinity, so that the denominator polynomial of the approximation goes to zero). If ‘x’ corresponds to a pole of the fitted rational function, then the result will be a division by zero. If Infinite mode is enabled, the result will be ‘[uinf, uinf]’.

There is no way to get the actual coefficients of the rational function used by H a p. (The algorithm never generates these coefficients explicitly, and quotients of polynomials are beyond a F’s capabilities to fit.)


*** Summations

The a + (calc-summation) [sum] command computes the sum of a formula over a certain range of index values. The formula is taken from the top of the stack; the command prompts for the name of the summation index variable, the lower limit of the sum (any formula), and the upper limit of the sum. If you enter a blank line at any of these prompts, that prompt and any later ones are answered by reading additional elements from the stack. Thus, ' k^2 RET ' k RET 1 RET 5 RET a + RET produces the result 55.

The choice of index variable is arbitrary, but it’s best not to use a variable with a stored value. In particular, while i is often a favorite index variable, it should be avoided in Calc because i has the imaginary constant ‘(0, 1)’ as a value. If you pressed = on a sum over i, it would be changed to a nonsensical sum over the “variable” ‘(0, 1)’! If you really want to use i as an index variable, use s u i RET first to “unstore” this variable. (See Storing Variables.)

A numeric prefix argument steps the index by that amount rather than by one. Thus ' a_k RET C-u -2 a + k RET 10 RET 0 RET yields ‘a_10 + a_8 + a_6 + a_4 + a_2 + a_0’. A prefix argument of plain C-u causes a + to prompt for the step value, in which case you can enter any formula or enter a blank line to take the step value from the stack. With the C-u prefix, a + can take up to five arguments from the stack: The formula, the variable, the lower limit, the upper limit, and (at the top of the stack), the step value.

Calc knows how to do certain sums in closed form. For example, ‘sum(6 k^2, k, 1, n) = 2 n^3 + 3 n^2 + n’. In particular, this is possible if the formula being summed is polynomial or exponential in the index variable. Sums of logarithms are transformed into logarithms of products. Sums of trigonometric and hyperbolic functions are transformed to sums of exponentials and then done in closed form. Also, of course, sums in which the lower and upper limits are both numbers can always be evaluated just by grinding them out, although Calc will use closed forms whenever it can for the sake of efficiency.

The notation for sums in algebraic formulas is ‘sum(expr, var, low, high, step)’. If step is omitted, it defaults to one. If high is omitted, low is actually the upper limit and the lower limit is one. If low is also omitted, the limits are ‘-inf’ and ‘inf’, respectively.

Infinite sums can sometimes be evaluated: ‘sum(.5^k, k, 1, inf)’ returns ‘1’. This is done by evaluating the sum in closed form (to ‘1. - 0.5^n’ in this case), then evaluating this formula with n set to inf. Calc’s usual rules for “infinite” arithmetic can find the answer from there. If infinite arithmetic yields a ‘nan’, or if the sum cannot be solved in closed form, Calc leaves the sum function in symbolic form. See Infinities.

As a special feature, if the limits are infinite (or omitted, as described above) but the formula includes vectors subscripted by expressions that involve the iteration variable, Calc narrows the limits to include only the range of integers which result in valid subscripts for the vector. For example, the sum ‘sum(k [a,b,c,d,e,f,g]_(2k),k)’ evaluates to ‘b + 2 d + 3 f’.

The limits of a sum do not need to be integers. For example, ‘sum(a_k, k, 0, 2 n, n)’ produces ‘a_0 + a_n + a_(2 n)’. Calc computes the number of iterations using the formula ‘1 + (high - low) / step’, which must, after algebraic simplification, evaluate to an integer.

If the number of iterations according to the above formula does not come out to an integer, the sum is invalid and will be left in symbolic form. However, closed forms are still supplied, and you are on your honor not to misuse the resulting formulas by substituting mismatched bounds into them. For example, ‘sum(k, k, 1, 10, 2)’ is invalid, but Calc will go ahead and evaluate the closed form solution for the limits 1 and 10 to get the rather dubious answer, 29.25.

If the lower limit is greater than the upper limit (assuming a positive step size), the result is generally zero. However, Calc only guarantees a zero result when the upper limit is exactly one step less than the lower limit, i.e., if the number of iterations is -1. Thus ‘sum(f(k), k, n, n-1)’ is zero but the sum from ‘n’ to ‘n-2’ may report a nonzero value if Calc used a closed form solution.

Calc’s logical predicates like ‘a < b’ return 1 for “true” and 0 for “false.” See Logical Operations. This can be used to advantage for building conditional sums. For example, ‘sum(prime(k)*k^2, k, 1, 20)’ is the sum of the squares of all prime numbers from 1 to 20; the prime predicate returns 1 if its argument is prime and 0 otherwise. You can read this expression as “the sum of ‘k^2’, where ‘k’ is prime.” Indeed, ‘sum(prime(k)*k^2, k)’ would represent the sum of all primes squared, since the limits default to plus and minus infinity, but there are no such sums that Calc’s built-in rules can do in closed form.

As another example, ‘sum((k != k_0) * f(k), k, 1, n)’ is the sum of ‘f(k)’ for all ‘k’ from 1 to ‘n’, excluding one value ‘k_0’. Slightly more tricky is the summand ‘(k != k_0) / (k - k_0)’, which is an attempt to describe the sum of all ‘1/(k-k_0)’ except at ‘k = k_0’, where this would be a division by zero. But at ‘k = k_0’, this formula works out to the indeterminate form ‘0 / 0’, which Calc will not assume is zero. Better would be to use ‘(k != k_0) ? 1/(k-k_0) : 0’; the ‘? :’ operator does an “if-then-else” test: This expression says, “if ‘k != k_0’, then ‘1/(k-k_0)’, else zero.” Now the formula ‘1/(k-k_0)’ will not even be evaluated by Calc when ‘k = k_0’.

The a - (calc-alt-summation) [asum] command computes an alternating sum. Successive terms of the sequence are given alternating signs, with the first term (corresponding to the lower index value) being positive. Alternating sums are converted to normal sums with an extra term of the form ‘(-1)^(k-low)’. This formula is adjusted appropriately if the step value is other than one. For example, the Taylor series for the sine function is ‘asum(x^k / k!, k, 1, inf, 2)’. (Calc cannot evaluate this infinite series, but it can approximate it if you replace inf with any particular odd number.) Calc converts this series to a regular sum with a step of one, namely ‘sum((-1)^k x^(2k+1) / (2k+1)!, k, 0, inf)’.

The a * (calc-product) [prod] command is the analogous way to take a product of many terms. Calc also knows some closed forms for products, such as ‘prod(k, k, 1, n) = n!’. Conditional products can be written ‘prod(k^prime(k), k, 1, n)’ or ‘prod(prime(k) ? k : 1, k, 1, n)’.

The a T (calc-tabulate) [table] command evaluates a formula at a series of iterated index values, just like sum and prod, but its result is simply a vector of the results. For example, ‘table(a_i, i, 1, 7, 2)’ produces ‘[a_1, a_3, a_5, a_7]’.


*** Logical Operations

The following commands and algebraic functions return true/false values, where 1 represents “true” and 0 represents “false.” In cases where a truth value is required (such as for the condition part of a rewrite rule, or as the condition for a Z [ Z ] control structure), any nonzero value is accepted to mean “true.” (Specifically, anything for which dnonzero returns 1 is “true,” and anything for which dnonzero returns 0 or cannot decide is assumed “false.” Note that this means that Z [ Z ] will execute the “then” portion if its condition is provably true, but it will execute the “else” portion for any condition like ‘a = b’ that is not provably true, even if it might be true. Algebraic functions that have conditions as arguments, like ? : and &&, remain unevaluated if the condition is neither provably true nor provably false. See Declarations.)

The a = (calc-equal-to) command, or ‘eq(a,b)’ function (which can also be written ‘a = b’ or ‘a == b’ in an algebraic formula) is true if ‘a’ and ‘b’ are equal, either because they are identical expressions, or because they are numbers which are numerically equal. (Thus the integer 1 is considered equal to the float 1.0.) If the equality of ‘a’ and ‘b’ cannot be determined, the comparison is left in symbolic form. Note that as a command, this operation pops two values from the stack and pushes back either a 1 or a 0, or a formula ‘a = b’ if the values’ equality cannot be determined.

Many Calc commands use ‘=’ formulas to represent equations. For example, the a S (calc-solve-for) command rearranges an equation to solve for a given variable. The a M (calc-map-equation) command can be used to apply any function to both sides of an equation; for example, 2 a M * multiplies both sides of the equation by two. Note that just 2 * would not do the same thing; it would produce the formula ‘2 (a = b)’ which represents 2 if the equality is true or zero if not.

The eq function with more than two arguments (e.g., C-u 3 a = or ‘a = b = c’) tests if all of its arguments are equal. In algebraic notation, the ‘=’ operator is unusual in that it is neither left- nor right-associative: ‘a = b = c’ is not the same as ‘(a = b) = c’ or ‘a = (b = c)’ (which each compare one variable with the 1 or 0 that results from comparing two other variables).

The a # (calc-not-equal-to) command, or ‘neq(a,b)’ or ‘a != b’ function, is true if ‘a’ and ‘b’ are not equal. This also works with more than two arguments; ‘a != b != c != d’ tests that all four of ‘a’, ‘b’, ‘c’, and ‘d’ are distinct numbers.

The a < (calc-less-than) [‘lt(a,b)’ or ‘a < b’] operation is true if ‘a’ is less than ‘b’. Similar functions are a > (calc-greater-than) [‘gt(a,b)’ or ‘a > b’], a [ (calc-less-equal) [‘leq(a,b)’ or ‘a <= b’], and a ] (calc-greater-equal) [‘geq(a,b)’ or ‘a >= b’].

While the inequality functions like lt do not accept more than two arguments, the syntax ‘a <= b < c’ is translated to an equivalent expression involving intervals: ‘b in [a .. c)’. (See the description of in below.) All four combinations of ‘<’ and ‘<=’ are allowed, or any of the four combinations of ‘>’ and ‘>=’. Four-argument constructions like ‘a < b < c < d’, and mixtures like ‘a < b = c’ that involve both equations and inequalities, are not allowed.

The a . (calc-remove-equal) [rmeq] command extracts the righthand side of the equation or inequality on the top of the stack. It also works elementwise on vectors. For example, if ‘[x = 2.34, y = z / 2]’ is on the stack, then a . produces ‘[2.34, z / 2]’. As a special case, if the righthand side is a variable and the lefthand side is a number (as in ‘2.34 = x’), then Calc keeps the lefthand side instead. Finally, this command works with assignments ‘x := 2.34’ as well as equations, always taking the righthand side, and for ‘=>’ (evaluates-to) operators, always taking the lefthand side.

The a & (calc-logical-and) [‘land(a,b)’ or ‘a && b’] function is true if both of its arguments are true, i.e., are non-zero numbers. In this case, the result will be either ‘a’ or ‘b’, chosen arbitrarily. If either argument is zero, the result is zero. Otherwise, the formula is left in symbolic form.

The a | (calc-logical-or) [‘lor(a,b)’ or ‘a || b’] function is true if either or both of its arguments are true (nonzero). The result is whichever argument was nonzero, choosing arbitrarily if both are nonzero. If both ‘a’ and ‘b’ are zero, the result is zero.

The a ! (calc-logical-not) [‘lnot(a)’ or ‘! a’] function is true if ‘a’ is false (zero), or false if ‘a’ is true (nonzero). It is left in symbolic form if ‘a’ is not a number.

The a : (calc-logical-if) [‘if(a,b,c)’ or ‘a ? b : c’] function is equal to either ‘b’ or ‘c’ if ‘a’ is a nonzero number or zero, respectively. If ‘a’ is not a number, the test is left in symbolic form and neither ‘b’ nor ‘c’ is evaluated in any way. In algebraic formulas, this is one of the few Calc functions whose arguments are not automatically evaluated when the function itself is evaluated. The others are lambda, quote, and condition.

One minor surprise to watch out for is that the formula ‘a?3:4’ will not work because the ‘3:4’ is parsed as a fraction instead of as three separate symbols. Type something like ‘a ? 3 : 4’ or ‘a?(3):4’ instead.

As a special case, if ‘a’ evaluates to a vector, then both ‘b’ and ‘c’ are evaluated; the result is a vector of the same length as ‘a’ whose elements are chosen from corresponding elements of ‘b’ and ‘c’ according to whether each element of ‘a’ is zero or nonzero. Each of ‘b’ and ‘c’ must be either a vector of the same length as ‘a’, or a non-vector which is matched with all elements of ‘a’.

The a { (calc-in-set) [‘in(a,b)’] function is true if the number ‘a’ is in the set of numbers represented by ‘b’. If ‘b’ is an interval form, ‘a’ must be one of the values encompassed by the interval. If ‘b’ is a vector, ‘a’ must be equal to one of the elements of the vector. (If any vector elements are intervals, ‘a’ must be in any of the intervals.) If ‘b’ is a plain number, ‘a’ must be numerically equal to ‘b’. See Set Operations using Vectors, for a group of commands that manipulate sets of this sort.

The ‘typeof(a)’ function produces an integer or variable which characterizes ‘a’. If ‘a’ is a number, vector, or variable, the result will be one of the following numbers:

 1   Integer
 2   Fraction
 3   Floating-point number
 4   HMS form
 5   Rectangular complex number
 6   Polar complex number
 7   Error form
 8   Interval form
 9   Modulo form
10   Date-only form
11   Date/time form
12   Infinity (inf, uinf, or nan)
100  Variable
101  Vector (but not a matrix)
102  Matrix
Otherwise, ‘a’ is a formula, and the result is a variable which represents the name of the top-level function call.

The ‘integer(a)’ function returns true if ‘a’ is an integer. The ‘real(a)’ function is true if ‘a’ is a real number, either integer, fraction, or float. The ‘constant(a)’ function returns true if ‘a’ is any of the objects for which typeof would produce an integer code result except for variables, and provided that the components of an object like a vector or error form are themselves constant. Note that infinities do not satisfy any of these tests, nor do special constants like pi and e.

See Declarations, for a set of similar functions that recognize formulas as well as actual numbers. For example, ‘dint(floor(x))’ is true because ‘floor(x)’ is provably integer-valued, but ‘integer(floor(x))’ does not because ‘floor(x)’ is not literally an integer constant.

The ‘refers(a,b)’ function is true if the variable (or sub-expression) ‘b’ appears in ‘a’, or false otherwise. Unlike the other tests described here, this function returns a definite “no” answer even if its arguments are still in symbolic form. The only case where refers will be left unevaluated is if ‘a’ is a plain variable (different from ‘b’).

The ‘negative(a)’ function returns true if ‘a’ “looks” negative, because it is a negative number, because it is of the form ‘-x’, or because it is a product or quotient with a term that looks negative. This is most useful in rewrite rules. Beware that ‘negative(a)’ evaluates to 1 or 0 for any argument ‘a’, so it can only be stored in a formula if the default simplifications are turned off first with m O (or if it appears in an unevaluated context such as a rewrite rule condition).

The ‘variable(a)’ function is true if ‘a’ is a variable, or false if not. If ‘a’ is a function call, this test is left in symbolic form. Built-in variables like pi and inf are considered variables like any others by this test.

The ‘nonvar(a)’ function is true if ‘a’ is a non-variable. If its argument is a variable it is left unsimplified; it never actually returns zero. However, since Calc’s condition-testing commands consider “false” anything not provably true, this is often good enough.

The functions lin, linnt, islin, and islinnt check if an expression is “linear,” i.e., can be written in the form ‘a + b x’ for some constants ‘a’ and ‘b’, and some variable or subformula ‘x’. The function ‘islin(f,x)’ checks if formula ‘f’ is linear in ‘x’, returning 1 if so. For example, ‘islin(x,x)’, ‘islin(-x,x)’, ‘islin(3,x)’, and ‘islin(x y / 3 - 2, x)’ all return 1. The ‘lin(f,x)’ function is similar, except that instead of returning 1 it returns the vector ‘[a, b, x]’. For the above examples, this vector would be ‘[0, 1, x]’, ‘[0, -1, x]’, ‘[3, 0, x]’, and ‘[-2, y/3, x]’, respectively. Both lin and islin generally remain unevaluated for expressions which are not linear, e.g., ‘lin(2 x^2, x)’ and ‘lin(sin(x), x)’. The second argument can also be a formula; ‘islin(2 + 3 sin(x), sin(x))’ returns true.

The linnt and islinnt functions perform a similar check, but require a “non-trivial” linear form, which means that the ‘b’ coefficient must be non-zero. For example, ‘lin(2,x)’ returns ‘[2, 0, x]’ and ‘lin(y,x)’ returns ‘[y, 0, x]’, but ‘linnt(2,x)’ and ‘linnt(y,x)’ are left unevaluated (in other words, these formulas are considered to be only “trivially” linear in ‘x’).

All four linearity-testing functions allow you to omit the second argument, in which case the input may be linear in any non-constant formula. Here, the ‘a=0’, ‘b=1’ case is also considered trivial, and only constant values for ‘a’ and ‘b’ are recognized. Thus, ‘lin(2 x y)’ returns ‘[0, 2, x y]’, ‘lin(2 - x y)’ returns ‘[2, -1, x y]’, and ‘lin(x y)’ returns ‘[0, 1, x y]’. The linnt function would allow the first two cases but not the third. Also, neither lin nor linnt accept plain constants as linear in the one-argument case: ‘islin(2,x)’ is true, but ‘islin(2)’ is false.

The ‘istrue(a)’ function returns 1 if ‘a’ is a nonzero number or provably nonzero formula, or 0 if ‘a’ is anything else. Calls to istrue can only be manipulated if m O mode is used to make sure they are not evaluated prematurely. (Note that declarations are used when deciding whether a formula is true; istrue returns 1 when dnonzero would return 1, and it returns 0 when dnonzero would return 0 or leave itself in symbolic form.)


*** Rewrite Rules

The a r (calc-rewrite) [rewrite] command makes substitutions in a formula according to a specified pattern or patterns known as rewrite rules. Whereas a b (calc-substitute) matches literally, so that substituting ‘sin(x)’ with ‘cos(x)’ matches only the sin function applied to the variable x, rewrite rules match general kinds of formulas; rewriting using the rule ‘sin(x) := cos(x)’ matches sin of any argument and replaces it with cos of that same argument. The only significance of the name x is that the same name is used on both sides of the rule.

Rewrite rules rearrange formulas already in Calc’s memory. See Syntax Tables, to read about syntax rules, which are similar to algebraic rewrite rules but operate when new algebraic entries are being parsed, converting strings of characters into Calc formulas.

**** Entering Rewrite Rules

Rewrite rules normally use the “assignment” operator ‘old := new’. This operator is equivalent to the function call ‘assign(old, new)’. The assign function is undefined by itself in Calc, so an assignment formula such as a rewrite rule will be left alone by ordinary Calc commands. But certain commands, like the rewrite system, interpret assignments in special ways.

For example, the rule ‘sin(x)^2 := 1-cos(x)^2’ says to replace every occurrence of the sine of something, squared, with one minus the square of the cosine of that same thing. All by itself as a formula on the stack it does nothing, but when given to the a r command it turns that command into a sine-squared-to-cosine-squared converter.

To specify a set of rules to be applied all at once, make a vector of rules.

When a r prompts you to enter the rewrite rules, you can answer in several ways:

With a rule: f(x) := g(x) RET.
With a vector of rules: [f1(x) := g1(x), f2(x) := g2(x)] RET. (You can omit the enclosing square brackets if you wish.)
With the name of a variable that contains the rule or rules vector: myrules RET.
With any formula except a rule, a vector, or a variable name; this will be interpreted as the old half of a rewrite rule, and you will be prompted a second time for the new half: f(x) RET g(x) RET.
With a blank line, in which case the rule, rules vector, or variable will be taken from the top of the stack (and the formula to be rewritten will come from the second-to-top position).
If you enter the rules directly (as opposed to using rules stored in a variable), those rules will be put into the Trail so that you can retrieve them later. See Trail Commands.

It is most convenient to store rules you use often in a variable and invoke them by giving the variable name. The s e (calc-edit-variable) command is an easy way to create or edit a rule set stored in a variable. You may also wish to use s p (calc-permanent-variable) to save your rules permanently; see Other Operations on Variables.

Rewrite rules are compiled into a special internal form for faster matching. If you enter a rule set directly it must be recompiled every time. If you store the rules in a variable and refer to them through that variable, they will be compiled once and saved away along with the variable for later reference. This is another good reason to store your rules in a variable.

Calc also accepts an obsolete notation for rules, as vectors ‘[old, new]’. But because it is easily confused with a vector of two rules, the use of this notation is no longer recommended.


**** Basic Rewrite Rules

To match a particular formula ‘x’ with a particular rewrite rule ‘old := new’, Calc compares the structure of ‘x’ with the structure of old. Variables that appear in old are treated as meta-variables; the corresponding positions in ‘x’ may contain any sub-formulas. For example, the pattern ‘f(x,y)’ would match the expression ‘f(12, a+1)’ with the meta-variable ‘x’ corresponding to 12 and with ‘y’ corresponding to ‘a+1’. However, this pattern would not match ‘f(12)’ or ‘g(12, a+1)’, since there is no assignment of the meta-variables that will make the pattern match these expressions. Notice that if the pattern is a single meta-variable, it will match any expression.

If a given meta-variable appears more than once in old, the corresponding sub-formulas of ‘x’ must be identical. Thus the pattern ‘f(x,x)’ would match ‘f(12, 12)’ and ‘f(a+1, a+1)’ but not ‘f(12, a+1)’ or ‘f(a+b, b+a)’. (See Conditional Rewrite Rules, for a way to match the latter.)

Things other than variables must match exactly between the pattern and the target formula. To match a particular variable exactly, use the pseudo-function ‘quote(v)’ in the pattern. For example, the pattern ‘x+quote(y)’ matches ‘x+y’, ‘2+y’, or ‘sin(a)+y’.

The special variable names ‘e’, ‘pi’, ‘i’, ‘phi’, ‘gamma’, ‘inf’, ‘uinf’, and ‘nan’ always match literally. Thus the pattern ‘sin(d + e + f)’ acts exactly like ‘sin(d + quote(e) + f)’.

If the old pattern is found to match a given formula, that formula is replaced by new, where any occurrences in new of meta-variables from the pattern are replaced with the sub-formulas that they matched. Thus, applying the rule ‘f(x,y) := g(y+x,x)’ to ‘f(12, a+1)’ would produce ‘g(a+13, 12)’.

The normal a r command applies rewrite rules over and over throughout the target formula until no further changes are possible (up to a limit of 100 times). Use C-u 1 a r to make only one change at a time.


**** Conditional Rewrite Rules

A rewrite rule can also be conditional, written in the form ‘old := new :: cond’. (There is also the obsolete form ‘[old, new, cond]’.) If a cond part is present in the rule, this is an additional condition that must be satisfied before the rule is accepted. Once old has been successfully matched to the target expression, cond is evaluated (with all the meta-variables substituted for the values they matched) and simplified with Calc’s algebraic simplifications. If the result is a nonzero number or any other object known to be nonzero (see Declarations), the rule is accepted. If the result is zero or if it is a symbolic formula that is not known to be nonzero, the rule is rejected. See Logical Operations, for a number of functions that return 1 or 0 according to the results of various tests.

For example, the formula ‘n > 0’ simplifies to 1 or 0 if ‘n’ is replaced by a positive or nonpositive number, respectively (or if ‘n’ has been declared to be positive or nonpositive). Thus, the rule ‘f(x,y) := g(y+x,x) :: x+y > 0’ would apply to ‘f(0, 4)’ but not to ‘f(-3, 2)’ or ‘f(12, a+1)’ (assuming no outstanding declarations for ‘a’). In the case of ‘f(-3, 2)’, the condition can be shown not to be satisfied; in the case of ‘f(12, a+1)’, the condition merely cannot be shown to be satisfied, but that is enough to reject the rule.

While Calc will use declarations to reason about variables in the formula being rewritten, declarations do not apply to meta-variables. For example, the rule ‘f(a) := g(a+1)’ will match for any values of ‘a’, such as complex numbers, vectors, or formulas, even if ‘a’ has been declared to be real or scalar. If you want the meta-variable ‘a’ to match only literal real numbers, use ‘f(a) := g(a+1) :: real(a)’. If you want ‘a’ to match only reals and formulas which are provably real, use ‘dreal(a)’ as the condition.

The ‘::’ operator is a shorthand for the condition function; ‘old := new :: cond’ is equivalent to the formula ‘condition(assign(old, new), cond)’.

If you have several conditions, you can use ‘... :: c1 :: c2 :: c3’ or ‘... :: c1 && c2 && c3’. The two are entirely equivalent.

It is also possible to embed conditions inside the pattern: ‘f(x :: x>0, y) := g(y+x, x)’. This is purely a notational convenience, though; where a condition appears in a rule has no effect on when it is tested. The rewrite-rule compiler automatically decides when it is best to test each condition while a rule is being matched.

Certain conditions are handled as special cases by the rewrite rule system and are tested very efficiently: Where ‘x’ is any meta-variable, these conditions are ‘integer(x)’, ‘real(x)’, ‘constant(x)’, ‘negative(x)’, ‘x >= y’ where ‘y’ is either a constant or another meta-variable and ‘>=’ may be replaced by any of the six relational operators, and ‘x % a = b’ where ‘a’ and ‘b’ are constants. Other conditions, like ‘x >= y+1’ or ‘dreal(x)’, will be less efficient to check since Calc must bring the whole evaluator and simplifier into play.

An interesting property of ‘::’ is that neither of its arguments will be touched by Calc’s default simplifications. This is important because conditions often are expressions that cannot safely be evaluated early. For example, the typeof function never remains in symbolic form; entering ‘typeof(a)’ will put the number 100 (the type code for variables like ‘a’) on the stack. But putting the condition ‘... :: typeof(a) = 6’ on the stack is safe since ‘::’ prevents the typeof from being evaluated until the condition is actually used by the rewrite system.

Since ‘::’ protects its lefthand side, too, you can use a dummy condition to protect a rule that must itself not evaluate early. For example, it’s not safe to put ‘a(f,x) := apply(f, [x])’ on the stack because it will immediately evaluate to ‘a(f,x) := f(x)’, where the meta-variable-ness of f on the righthand side has been lost. But ‘a(f,x) := apply(f, [x]) :: 1’ is safe, and of course the condition ‘1’ is always true (nonzero) so it has no effect on the functioning of the rule. (The rewrite compiler will ensure that it doesn’t even impact the speed of matching the rule.)


**** Algebraic Properties of Rewrite Rules

The rewrite mechanism understands the algebraic properties of functions like ‘+’ and ‘*’. In particular, pattern matching takes the associativity and commutativity of the following functions into account:

+ - *  = !=  && ||  and or xor  vint vunion vxor  gcd lcm  max min  beta
For example, the rewrite rule:

a x + b x  :=  (a + b) x
will match formulas of the form,

a x + b x,  x a + x b,  a x + x b,  x a + b x
Rewrites also understand the relationship between the ‘+’ and ‘-’ operators. The above rewrite rule will also match the formulas,

a x - b x,  x a - x b,  a x - x b,  x a - b x
by matching ‘b’ in the pattern to ‘-b’ from the formula.

Applied to a sum of many terms like ‘r + a x + s + b x + t’, this pattern will check all pairs of terms for possible matches. The rewrite will take whichever suitable pair it discovers first.

In general, a pattern using an associative operator like ‘a + b’ will try 2 n different ways to match a sum of n terms like ‘x + y + z - w’. First, ‘a’ is matched against each of ‘x’, ‘y’, ‘z’, and ‘-w’ in turn, with ‘b’ being matched to the remainders ‘y + z - w’, ‘x + z - w’, etc. If none of these succeed, then ‘b’ is matched against each of the four terms with ‘a’ matching the remainder. Half-and-half matches, like ‘(x + y) + (z - w)’, are not tried.

Note that ‘*’ is not commutative when applied to matrices, but rewrite rules pretend that it is. If you type m v to enable Matrix mode (see Matrix and Scalar Modes), rewrite rules will match ‘*’ literally, ignoring its usual commutativity property. (In the current implementation, the associativity also vanishes—it is as if the pattern had been enclosed in a plain marker; see below.) If you are applying rewrites to formulas with matrices, it’s best to enable Matrix mode first to prevent algebraically incorrect rewrites from occurring.

The pattern ‘-x’ will actually match any expression. For example, the rule

f(-x)  :=  -f(x)
will rewrite ‘f(a)’ to ‘-f(-a)’. To avoid this, either use a plain marker as described below, or add a ‘negative(x)’ condition. The negative function is true if its argument “looks” negative, for example, because it is a negative number or because it is a formula like ‘-x’. The new rule using this condition is:

f(x)  :=  -f(-x)  :: negative(x)    or, equivalently,
f(-x)  :=  -f(x)  :: negative(-x)
In the same way, the pattern ‘x - y’ will match the sum ‘a + b’ by matching ‘y’ to ‘-b’.

The pattern ‘a b’ will also match the formula ‘x/y’ if ‘y’ is a number. Thus the rule ‘a x + b x := (a+b) x’ will also convert ‘a x + x / 2’ to ‘(a + 0.5) x’ (or ‘(a + 1:2) x’, depending on the current fraction mode).

Calc will not take other liberties with ‘*’, ‘/’, and ‘^’. For example, the pattern ‘f(a b)’ will not match ‘f(x^2)’, and ‘f(a + b)’ will not match ‘f(2 x)’, even though conceivably these patterns could match with ‘a = b = x’. Nor will ‘f(a b)’ match ‘f(x / y)’ if ‘y’ is not a constant, even though it could be considered to match with ‘a = x’ and ‘b = 1/y’. The reasons are partly for efficiency, and partly because while few mathematical operations are substantively different for addition and subtraction, often it is preferable to treat the cases of multiplication, division, and integer powers separately.

Even more subtle is the rule set

[ f(a) + f(b) := f(a + b),  -f(a) := f(-a) ]
attempting to match ‘f(x) - f(y)’. You might think that Calc will view this subtraction as ‘f(x) + (-f(y))’ and then apply the above two rules in turn, but actually this will not work because Calc only does this when considering rules for ‘+’ (like the first rule in this set). So it will see first that ‘f(x) + (-f(y))’ does not match ‘f(a) + f(b)’ for any assignments of the meta-variables, and then it will see that ‘f(x) - f(y)’ does not match ‘-f(a)’ for any assignment of ‘a’. Because Calc tries only one rule at a time, it will not be able to rewrite ‘f(x) - f(y)’ with this rule set. An explicit ‘f(a) - f(b)’ rule will have to be added.

Another thing patterns will not do is break up complex numbers. The pattern ‘myconj(a + b i) := a - b i’ will work for formulas involving the special constant ‘i’ (such as ‘3 - 4 i’), but it will not match actual complex numbers like ‘(3, -4)’. A version of the above rule for complex numbers would be

myconj(a)  :=  re(a) - im(a) (0,1)  :: im(a) != 0
(Because the re and im functions understand the properties of the special constant ‘i’, this rule will also work for ‘3 - 4 i’. In fact, this particular rule would probably be better without the ‘im(a) != 0’ condition, since if ‘im(a) = 0’ the righthand side of the rule will still give the correct answer for the conjugate of a real number.)

It is also possible to specify optional arguments in patterns. The rule

opt(a) x + opt(b) (x^opt(c) + opt(d))  :=  f(a, b, c, d)
will match the formula

5 (x^2 - 4) + 3 x
in a fairly straightforward manner, but it will also match reduced formulas like

x + x^2,    2(x + 1) - x,    x + x
producing, respectively,

f(1, 1, 2, 0),   f(-1, 2, 1, 1),   f(1, 1, 1, 0)
(The latter two formulas can be entered only if default simplifications have been turned off with m O.)

The default value for a term of a sum is zero. The default value for a part of a product, for a power, or for the denominator of a quotient, is one. Also, ‘-x’ matches the pattern ‘opt(a) b’ with ‘a = -1’.

In particular, the distributive-law rule can be refined to

opt(a) x + opt(b) x  :=  (a + b) x
so that it will convert, e.g., ‘a x - x’, to ‘(a - 1) x’.

The pattern ‘opt(a) + opt(b) x’ matches almost any formulas which are linear in ‘x’. You can also use the lin and islin functions with rewrite conditions to test for this; see Logical Operations. These functions are not as convenient to use in rewrite rules, but they recognize more kinds of formulas as linear: ‘x/z’ is considered linear with ‘b = 1/z’ by lin, but it will not match the above pattern because that pattern calls for a multiplication, not a division.

As another example, the obvious rule to replace ‘sin(x)^2 + cos(x)^2’ by 1,

sin(x)^2 + cos(x)^2  :=  1
misses many cases because the sine and cosine may both be multiplied by an equal factor. Here’s a more successful rule:

opt(a) sin(x)^2 + opt(a) cos(x)^2  :=  a
Note that this rule will not match ‘sin(x)^2 + 6 cos(x)^2’ because one ‘a’ would have “matched” 1 while the other matched 6.

Calc automatically converts a rule like

f(x-1, x)  :=  g(x)
into the form

f(temp, x)  :=  g(x)  :: temp = x-1
(where temp stands for a new, invented meta-variable that doesn’t actually have a name). This modified rule will successfully match ‘f(6, 7)’, binding ‘temp’ and ‘x’ to 6 and 7, respectively, then verifying that they differ by one even though ‘6’ does not superficially look like ‘x-1’.

However, Calc does not solve equations to interpret a rule. The following rule,

f(x-1, x+1)  :=  g(x)
will not work. That is, it will match ‘f(a - 1 + b, a + 1 + b)’ but not ‘f(6, 8)’. Calc always interprets at least one occurrence of a variable by literal matching. If the variable appears “isolated” then Calc is smart enough to use it for literal matching. But in this last example, Calc is forced to rewrite the rule to ‘f(x-1, temp) := g(x) :: temp = x+1’ where the ‘x-1’ term must correspond to an actual “something-minus-one” in the target formula.

A successful way to write this would be ‘f(x, x+2) := g(x+1)’. You could make this resemble the original form more closely by using let notation, which is described in the next section:

f(xm1, x+1)  :=  g(x)  :: let(x := xm1+1)
Calc does this rewriting or “conditionalizing” for any sub-pattern which involves only the functions in the following list, operating only on constants and meta-variables which have already been matched elsewhere in the pattern. When matching a function call, Calc is careful to match arguments which are plain variables before arguments which are calls to any of the functions below, so that a pattern like ‘f(x-1, x)’ can be conditionalized even though the isolated ‘x’ comes after the ‘x-1’.

+ - * / \ % ^  abs sign  round rounde roundu trunc floor ceil
max min  re im conj arg
You can suppress all of the special treatments described in this section by surrounding a function call with a plain marker. This marker causes the function call which is its argument to be matched literally, without regard to commutativity, associativity, negation, or conditionalization. When you use plain, the “deep structure” of the formula being matched can show through. For example,

plain(a - a b)  :=  f(a, b)
will match only literal subtractions. However, the plain marker does not affect its arguments’ arguments. In this case, commutativity and associativity is still considered while matching the ‘a b’ sub-pattern, so the whole pattern will match ‘x - y x’ as well as ‘x - x y’. We could go still further and use

plain(a - plain(a b))  :=  f(a, b)
which would do a completely strict match for the pattern.

By contrast, the quote marker means that not only the function name but also the arguments must be literally the same. The above pattern will match ‘x - x y’ but

quote(a - a b)  :=  f(a, b)
will match only the single formula ‘a - a b’. Also,

quote(a - quote(a b))  :=  f(a, b)
will match only ‘a - quote(a b)’—probably not the desired effect!

A certain amount of algebra is also done when substituting the meta-variables on the righthand side of a rule. For example, in the rule

a + f(b)  :=  f(a + b)
matching ‘f(x) - y’ would produce ‘f((-y) + x)’ if taken literally, but the rewrite mechanism will simplify the righthand side to ‘f(x - y)’ automatically. (Of course, the default simplifications would do this anyway, so this special simplification is only noticeable if you have turned the default simplifications off.) This rewriting is done only when a meta-variable expands to a “negative-looking” expression. If this simplification is not desirable, you can use a plain marker on the righthand side:

a + f(b)  :=  f(plain(a + b))
In this example, we are still allowing the pattern-matcher to use all the algebra it can muster, but the righthand side will always simplify to a literal addition like ‘f((-y) + x)’.


**** Other Features of Rewrite Rules

Certain “function names” serve as markers in rewrite rules. Here is a complete list of these markers. First are listed the markers that work inside a pattern; then come the markers that work in the righthand side of a rule.

One kind of marker, ‘import(x)’, takes the place of a whole rule. Here ‘x’ is the name of a variable containing another rule set; those rules are “spliced into” the rule set that imports them. For example, if ‘[f(a+b) := f(a) + f(b), f(a b) := a f(b) :: real(a)]’ is stored in variable ‘linearF’, then the rule set ‘[f(0) := 0, import(linearF)]’ will apply all three rules. It is possible to modify the imported rules slightly: ‘import(x, v1, x1, v2, x2, …)’ imports the rule set ‘x’ with all occurrences of ‘v1’, as either a variable name or a function name, replaced with ‘x1’ and so on. (If ‘v1’ is used as a function name, then ‘x1’ must be either a function name itself or a ‘< >’ nameless function; see Specifying Operators.) For example, ‘[g(0) := 0, import(linearF, f, g)]’ applies the linearity rules to the function ‘g’ instead of ‘f’. Imports can be nested, but the import-with-renaming feature may fail to rename sub-imports properly.

The special functions allowed in patterns are:

‘quote(x)’
This pattern matches exactly ‘x’; variable names in ‘x’ are not interpreted as meta-variables. The only flexibility is that numbers are compared for numeric equality, so that the pattern ‘f(quote(12))’ will match both ‘f(12)’ and ‘f(12.0)’. (Numbers are always treated this way by the rewrite mechanism: The rule ‘f(x,x) := g(x)’ will match ‘f(12, 12.0)’. The rewrite may produce either ‘g(12)’ or ‘g(12.0)’ as a result in this case.)

‘plain(x)’
Here ‘x’ must be a function call ‘f(x1,x2,…)’. This pattern matches a call to function ‘f’ with the specified argument patterns. No special knowledge of the properties of the function ‘f’ is used in this case; ‘+’ is not commutative or associative. Unlike quote, the arguments ‘x1,x2,…’ are treated as patterns. If you wish them to be treated “plainly” as well, you must enclose them with more plain markers: ‘plain(plain(-a) + plain(b c))’.

‘opt(x,def)’
Here ‘x’ must be a variable name. This must appear as an argument to a function or an element of a vector; it specifies that the argument or element is optional. As an argument to ‘+’, ‘-’, ‘*’, ‘&&’, or ‘||’, or as the second argument to ‘/’ or ‘^’, the value def may be omitted. The pattern ‘x + opt(y)’ matches a sum by binding one summand to ‘x’ and the other to ‘y’, and it matches anything else by binding the whole expression to ‘x’ and zero to ‘y’. The other operators above work similarly.

For general miscellaneous functions, the default value def must be specified. Optional arguments are dropped starting with the rightmost one during matching. For example, the pattern ‘f(opt(a,0), b, opt(c,b))’ will match ‘f(b)’, ‘f(a,b)’, or ‘f(a,b,c)’. Default values of zero and ‘b’ are supplied in this example for the omitted arguments. Note that the literal variable ‘b’ will be the default in the latter case, not the value that matched the meta-variable ‘b’. In other words, the default def is effectively quoted.

‘condition(x,c)’
This matches the pattern ‘x’, with the attached condition ‘c’. It is the same as ‘x :: c’.

‘pand(x,y)’
This matches anything that matches both pattern ‘x’ and pattern ‘y’. It is the same as ‘x &&& y’. see Composing Patterns in Rewrite Rules.

‘por(x,y)’
This matches anything that matches either pattern ‘x’ or pattern ‘y’. It is the same as ‘x ||| y’.

‘pnot(x)’
This matches anything that does not match pattern ‘x’. It is the same as ‘!!! x’.

‘cons(h,t)’
This matches any vector of one or more elements. The first element is matched to ‘h’; a vector of the remaining elements is matched to ‘t’. Note that vectors of fixed length can also be matched as actual vectors: The rule ‘cons(a,cons(b,[])) := cons(a+b,[])’ is equivalent to the rule ‘[a,b] := [a+b]’.

‘rcons(t,h)’
This is like cons, except that the last element is matched to ‘h’, with the remaining elements matched to ‘t’.

‘apply(f,args)’
This matches any function call. The name of the function, in the form of a variable, is matched to ‘f’. The arguments of the function, as a vector of zero or more objects, are matched to ‘args’. Constants, variables, and vectors do not match an apply pattern. For example, ‘apply(f,x)’ matches any function call, ‘apply(quote(f),x)’ matches any call to the function ‘f’, ‘apply(f,[a,b])’ matches any function call with exactly two arguments, and ‘apply(quote(f), cons(a,cons(b,x)))’ matches any call to the function ‘f’ with two or more arguments. Another way to implement the latter, if the rest of the rule does not need to refer to the first two arguments of ‘f’ by name, would be ‘apply(quote(f), x :: vlen(x) >= 2)’. Here’s a more interesting sample use of apply:

apply(f,[x+n])  :=  n + apply(f,[x])
   :: in(f, [floor,ceil,round,trunc]) :: integer(n)
Note, however, that this will be slower to match than a rule set with four separate rules. The reason is that Calc sorts the rules of a rule set according to top-level function name; if the top-level function is apply, Calc must try the rule for every single formula and sub-formula. If the top-level function in the pattern is, say, floor, then Calc invokes the rule only for sub-formulas which are calls to floor.

Formulas normally written with operators like + are still considered function calls: apply(f,x) matches ‘a+b’ with ‘f = add’, ‘x = [a,b]’.

You must use apply for meta-variables with function names on both sides of a rewrite rule: ‘apply(f, [x]) := f(x+1)’ is not correct, because it rewrites ‘spam(6)’ into ‘f(7)’. The righthand side should be ‘apply(f, [x+1])’. Also note that you will have to use No-Simplify mode (m O) when entering this rule so that the apply isn’t evaluated immediately to get the new rule ‘f(x) := f(x+1)’. Or, use s e to enter the rule without going through the stack, or enter the rule as ‘apply(f, [x]) := apply(f, [x+1]) :: 1’. See Conditional Rewrite Rules.

‘select(x)’
This is used for applying rules to formulas with selections; see Selections with Rewrite Rules.

Special functions for the righthand sides of rules are:

‘quote(x)’
The notation ‘quote(x)’ is changed to ‘x’ when the righthand side is used. As far as the rewrite rule is concerned, quote is invisible. However, quote has the special property in Calc that its argument is not evaluated. Thus, while it will not work to put the rule ‘t(a) := typeof(a)’ on the stack because ‘typeof(a)’ is evaluated immediately to produce ‘t(a) := 100’, you can use quote to protect the righthand side: ‘t(a) := quote(typeof(a))’. (See Conditional Rewrite Rules, for another trick for protecting rules from evaluation.)

‘plain(x)’
Special properties of and simplifications for the function call ‘x’ are not used. One interesting case where plain is useful is the rule, ‘q(x) := quote(x)’, trying to expand a shorthand notation for the quote function. This rule will not work as shown; instead of replacing ‘q(foo)’ with ‘quote(foo)’, it will replace it with ‘foo’! The correct rule would be ‘q(x) := plain(quote(x))’.

‘cons(h,t)’
Where ‘t’ is a vector, this is converted into an expanded vector during rewrite processing. Note that cons is a regular Calc function which normally does this anyway; the only way cons is treated specially by rewrites is that cons on the righthand side of a rule will be evaluated even if default simplifications have been turned off.

‘rcons(t,h)’
Analogous to cons except putting ‘h’ at the end of the vector ‘t’.

‘apply(f,args)’
Where ‘f’ is a variable and args is a vector, this is converted to a function call. Once again, note that apply is also a regular Calc function.

‘eval(x)’
The formula ‘x’ is handled in the usual way, then the default simplifications are applied to it even if they have been turned off normally. This allows you to treat any function similarly to the way cons and apply are always treated. However, there is a slight difference: ‘cons(2+3, [])’ with default simplifications off will be converted to ‘[2+3]’, whereas ‘eval(cons(2+3, []))’ will be converted to ‘[5]’.

‘evalsimp(x)’
The formula ‘x’ has meta-variables substituted in the usual way, then algebraically simplified.

‘evalextsimp(x)’
The formula ‘x’ has meta-variables substituted in the normal way, then “extendedly” simplified as if by the a e command.

‘select(x)’
See Selections with Rewrite Rules.

There are also some special functions you can use in conditions.

‘let(v := x)’
The expression ‘x’ is evaluated with meta-variables substituted. The algebraic simplifications are not applied by default, but ‘x’ can include calls to evalsimp or evalextsimp as described above to invoke higher levels of simplification. The result of ‘x’ is then bound to the meta-variable ‘v’. As usual, if this meta-variable has already been matched to something else the two values must be equal; if the meta-variable is new then it is bound to the result of the expression. This variable can then appear in later conditions, and on the righthand side of the rule. In fact, ‘v’ may be any pattern in which case the result of evaluating ‘x’ is matched to that pattern, binding any meta-variables that appear in that pattern. Note that let can only appear by itself as a condition, or as one term of an ‘&&’ which is a whole condition: It cannot be inside an ‘||’ term or otherwise buried.

The alternate, equivalent form ‘let(v, x)’ is also recognized. Note that the use of ‘:=’ by let, while still being assignment-like in character, is unrelated to the use of ‘:=’ in the main part of a rewrite rule.

As an example, ‘f(a) := g(ia) :: let(ia := 1/a) :: constant(ia)’ replaces ‘f(a)’ with ‘g’ of the inverse of ‘a’, if that inverse exists and is constant. For example, if ‘a’ is a singular matrix the operation ‘1/a’ is left unsimplified and ‘constant(ia)’ fails, but if ‘a’ is an invertible matrix then the rule succeeds. Without let there would be no way to express this rule that didn’t have to invert the matrix twice. Note that, because the meta-variable ‘ia’ is otherwise unbound in this rule, the let condition itself always “succeeds” because no matter what ‘1/a’ evaluates to, it can successfully be bound to ia.

Here’s another example, for integrating cosines of linear terms: ‘myint(cos(y),x) := sin(y)/b :: let([a,b,x] := lin(y,x))’. The lin function returns a 3-vector if its argument is linear, or leaves itself unevaluated if not. But an unevaluated lin call will not match the 3-vector on the lefthand side of the let, so this let both verifies that y is linear, and binds the coefficients a and b for use elsewhere in the rule. (It would have been possible to use ‘sin(a x + b)/b’ for the righthand side instead, but using ‘sin(y)/b’ avoids gratuitous rearrangement of the argument of the sine.)

Similarly, here is a rule that implements an inverse-erf function. It uses root to search for a solution. If root succeeds, it will return a vector of two numbers where the first number is the desired solution. If no solution is found, root remains in symbolic form. So we use let to check that the result was indeed a vector.

ierf(x)  :=  y  :: let([y,z] := root(erf(a) = x, a, .5))
‘matches(v,p)’
The meta-variable v, which must already have been matched to something elsewhere in the rule, is compared against pattern p. Since matches is a standard Calc function, it can appear anywhere in a condition. But if it appears alone or as a term of a top-level ‘&&’, then you get the special extra feature that meta-variables which are bound to things inside p can be used elsewhere in the surrounding rewrite rule.

The only real difference between ‘let(p := v)’ and ‘matches(v, p)’ is that the former evaluates ‘v’ using the default simplifications, while the latter does not.

‘remember’ ¶
This is actually a variable, not a function. If remember appears as a condition in a rule, then when that rule succeeds the original expression and rewritten expression are added to the front of the rule set that contained the rule. If the rule set was not stored in a variable, remember is ignored. The lefthand side is enclosed in quote in the added rule if it contains any variables.

For example, the rule ‘f(n) := n f(n-1) :: remember’ applied to ‘f(7)’ will add the rule ‘f(7) := 7 f(6)’ to the front of the rule set. The rule set EvalRules works slightly differently: There, the evaluation of ‘f(6)’ will complete before the result is added to the rule set, in this case as ‘f(7) := 5040’. Thus remember is most useful inside EvalRules.

It is up to you to ensure that the optimization performed by remember is safe. For example, the rule ‘foo(n) := n :: evalv(eatfoo) > 0 :: remember’ is a bad idea (evalv is the function equivalent of the = command); if the variable eatfoo ever contains 1, rules like ‘foo(7) := 7’ will be added to the rule set and will continue to operate even if eatfoo is later changed to 0.

‘remember(c)’
Remember the match as described above, but only if condition ‘c’ is true. For example, ‘remember(n % 4 = 0)’ in the above factorial rule remembers only every fourth result. Note that ‘remember(1)’ is equivalent to ‘remember’, and ‘remember(0)’ has no effect.


**** Composing Patterns in Rewrite Rules

There are three operators, ‘&&&’, ‘|||’, and ‘!!!’, that combine rewrite patterns to make larger patterns. The combinations are “and,” “or,” and “not,” respectively, and these operators are the pattern equivalents of ‘&&’, ‘||’ and ‘!’ (which operate on zero-or-nonzero logical values).

Note that ‘&&&’, ‘|||’, and ‘!!!’ are left in symbolic form by all regular Calc features; they have special meaning only in the context of rewrite rule patterns.

The pattern ‘p1 &&& p2’ matches anything that matches both p1 and p2. One especially useful case is when one of p1 or p2 is a meta-variable. For example, here is a rule that operates on error forms:

f(x &&& a +/- b, x)  :=  g(x)
This does the same thing, but is arguably simpler than, the rule

f(a +/- b, a +/- b)  :=  g(a +/- b)
Here’s another interesting example:

ends(cons(a, x) &&& rcons(y, b))  :=  [a, b]
which effectively clips out the middle of a vector leaving just the first and last elements. This rule will change a one-element vector ‘[a]’ to ‘[a, a]’. The similar rule

ends(cons(a, rcons(y, b)))  :=  [a, b]
would do the same thing except that it would fail to match a one-element vector.

The pattern ‘p1 ||| p2’ matches anything that matches either p1 or p2. Calc first tries matching against p1; if that fails, it goes on to try p2.

A simple example of ‘|||’ is

curve(inf ||| -inf)  :=  0
which converts both ‘curve(inf)’ and ‘curve(-inf)’ to zero.

Here is a larger example:

log(a, b) ||| (ln(a) :: let(b := e))  :=  mylog(a, b)
This matches both generalized and natural logarithms in a single rule. Note that the ‘::’ term must be enclosed in parentheses because that operator has lower precedence than ‘|||’ or ‘:=’.

(In practice this rule would probably include a third alternative, omitted here for brevity, to take care of log10.)

While Calc generally treats interior conditions exactly the same as conditions on the outside of a rule, it does guarantee that if all the variables in the condition are special names like e, or already bound in the pattern to which the condition is attached (say, if ‘a’ had appeared in this condition), then Calc will process this condition right after matching the pattern to the left of the ‘::’. Thus, we know that ‘b’ will be bound to ‘e’ only if the ln branch of the ‘|||’ was taken.

Note that this rule was careful to bind the same set of meta-variables on both sides of the ‘|||’. Calc does not check this, but if you bind a certain meta-variable only in one branch and then use that meta-variable elsewhere in the rule, results are unpredictable:

f(a,b) ||| g(b)  :=  h(a,b)
Here if the pattern matches ‘g(17)’, Calc makes no promises about the value that will be substituted for ‘a’ on the righthand side.

The pattern ‘!!! pat’ matches anything that does not match pat. Any meta-variables that are bound while matching pat remain unbound outside of pat.

For example,

f(x &&& !!! a +/- b, !!![])  :=  g(x)
converts f whose first argument is anything except an error form, and whose second argument is not the empty vector, into a similar call to g (but without the second argument).

If we know that the second argument will be a vector (empty or not), then an equivalent rule would be:

f(x, y)  :=  g(x)  :: typeof(x) != 7 :: vlen(y) > 0
where of course 7 is the typeof code for error forms. Another final condition, that works for any kind of ‘y’, would be ‘!istrue(y == [])’. (The istrue function returns an explicit 0 if its argument was left in symbolic form; plain ‘!(y == [])’ or ‘y != []’ would not work to replace ‘!!![]’ since these would be left unsimplified, and thus cause the rule to fail, if ‘y’ was something like a variable name.)

It is possible for a ‘!!!’ to refer to meta-variables bound elsewhere in the pattern. For example,

f(a, !!!a)  :=  g(a)
matches any call to f with different arguments, changing this to g with only the first argument.

If a function call is to be matched and one of the argument patterns contains a ‘!!!’ somewhere inside it, that argument will be matched last. Thus

f(!!!a, a)  :=  g(a)
will be careful to bind ‘a’ to the second argument of f before testing the first argument. If Calc had tried to match the first argument of f first, the results would have been disastrous: since a was unbound so far, the pattern ‘a’ would have matched anything at all, and the pattern ‘!!!a’ therefore would not have matched anything at all!


**** Nested Formulas with Rewrite Rules

When a r (calc-rewrite) is used, it takes an expression from the top of the stack and attempts to match any of the specified rules to any part of the expression, starting with the whole expression and then, if that fails, trying deeper and deeper sub-expressions. For each part of the expression, the rules are tried in the order they appear in the rules vector. The first rule to match the first sub-expression wins; it replaces the matched sub-expression according to the new part of the rule.

Often, the rule set will match and change the formula several times. The top-level formula is first matched and substituted repeatedly until it no longer matches the pattern; then, sub-formulas are tried, and so on. Once every part of the formula has gotten its chance, the rewrite mechanism starts over again with the top-level formula (in case a substitution of one of its arguments has caused it again to match). This continues until no further matches can be made anywhere in the formula.

It is possible for a rule set to get into an infinite loop. The most obvious case, replacing a formula with itself, is not a problem because a rule is not considered to “succeed” unless the righthand side actually comes out to something different from the original formula or sub-formula that was matched. But if you accidentally had both ‘ln(a b) := ln(a) + ln(b)’ and the reverse ‘ln(a) + ln(b) := ln(a b)’ in your rule set, Calc would run forever switching a formula back and forth between the two forms.

To avoid disaster, Calc normally stops after 100 changes have been made to the formula. This will be enough for most multiple rewrites, but it will keep an endless loop of rewrites from locking up the computer forever. (On most systems, you can also type C-g to halt any Emacs command prematurely.)

To change this limit, give a positive numeric prefix argument. In particular, M-1 a r applies only one rewrite at a time, useful when you are first testing your rule (or just if repeated rewriting is not what is called for by your application).

You can also put a “function call” ‘iterations(n)’ in place of a rule anywhere in your rules vector (but usually at the top). Then, n will be used instead of 100 as the default number of iterations for this rule set. You can use ‘iterations(inf)’ if you want no iteration limit by default. A prefix argument will override the iterations limit in the rule set.

[ iterations(1),
  f(x) := f(x+1) ]
More precisely, the limit controls the number of “iterations,” where each iteration is a successful matching of a rule pattern whose righthand side, after substituting meta-variables and applying the default simplifications, is different from the original sub-formula that was matched.

A prefix argument of zero sets the limit to infinity. Use with caution!

Given a negative numeric prefix argument, a r will match and substitute the top-level expression up to that many times, but will not attempt to match the rules to any sub-expressions.

In a formula, rewrite(expr, rules, n) does a rewriting operation. Here expr is the expression being rewritten, rules is the rule, vector of rules, or variable containing the rules, and n is the optional iteration limit, which may be a positive integer, a negative integer, or ‘inf’ or ‘-inf’. If n is omitted the iterations value from the rule set is used; if both are omitted, 100 is used.


**** Multi-Phase Rewrite Rules

It is possible to separate a rewrite rule set into several phases. During each phase, certain rules will be enabled while certain others will be disabled. A phase schedule controls the order in which phases occur during the rewriting process.

If a call to the marker function phase appears in the rules vector in place of a rule, all rules following that point will be members of the phase(s) identified in the arguments to phase. Phases are given integer numbers. The markers ‘phase()’ and ‘phase(all)’ both mean the following rules belong to all phases; this is the default at the start of the rule set.

If you do not explicitly schedule the phases, Calc sorts all phase numbers that appear in the rule set and executes the phases in ascending order. For example, the rule set

[ f0(x) := g0(x),
  phase(1),
  f1(x) := g1(x),
  phase(2),
  f2(x) := g2(x),
  phase(3),
  f3(x) := g3(x),
  phase(1,2),
  f4(x) := g4(x) ]
has three phases, 1 through 3. Phase 1 consists of the f0, f1, and f4 rules (in that order). Phase 2 consists of f0, f2, and f4. Phase 3 consists of f0 and f3.

When Calc rewrites a formula using this rule set, it first rewrites the formula using only the phase 1 rules until no further changes are possible. Then it switches to the phase 2 rule set and continues until no further changes occur, then finally rewrites with phase 3. When no more phase 3 rules apply, rewriting finishes. (This is assuming a r with a large enough prefix argument to allow the rewriting to run to completion; the sequence just described stops early if the number of iterations specified in the prefix argument, 100 by default, is reached.)

During each phase, Calc descends through the nested levels of the formula as described previously. (See Nested Formulas with Rewrite Rules.) Rewriting starts at the top of the formula, then works its way down to the parts, then goes back to the top and works down again. The phase 2 rules do not begin until no phase 1 rules apply anywhere in the formula.

A schedule marker appearing in the rule set (anywhere, but conventionally at the top) changes the default schedule of phases. In the simplest case, schedule has a sequence of phase numbers for arguments; each phase number is invoked in turn until the arguments to schedule are exhausted. Thus adding ‘schedule(3,2,1)’ at the top of the above rule set would reverse the order of the phases; ‘schedule(1,2,3)’ would have no effect since this is the default schedule; and ‘schedule(1,2,1,3)’ would give phase 1 a second chance after phase 2 has completed, before moving on to phase 3.

Any argument to schedule can instead be a vector of phase numbers (or even of sub-vectors). Then the sub-sequence of phases described by the vector are tried repeatedly until no change occurs in any phase in the sequence. For example, ‘schedule([1, 2], 3)’ tries phase 1, then phase 2, then, if either phase made any changes to the formula, repeats these two phases until they can make no further progress. Finally, it goes on to phase 3 for finishing touches.

Also, items in schedule can be variable names as well as numbers. A variable name is interpreted as the name of a function to call on the whole formula. For example, ‘schedule(1, simplify)’ says to apply the phase-1 rules (presumably, all of them), then to call simplify which is the function name equivalent of a s. Likewise, ‘schedule([1, simplify])’ says to alternate between phase 1 and a s until no further changes occur.

Phases can be used purely to improve efficiency; if it is known that a certain group of rules will apply only at the beginning of rewriting, and a certain other group will apply only at the end, then rewriting will be faster if these groups are identified as separate phases. Once the phase 1 rules are done, Calc can put them aside and no longer spend any time on them while it works on phase 2.

There are also some problems that can only be solved with several rewrite phases. For a real-world example of a multi-phase rule set, examine the set FitRules, which is used by the curve-fitting command to convert a model expression to linear form. See Curve Fitting Details. This set is divided into four phases. The first phase rewrites certain kinds of expressions to be more easily linearizable, but less computationally efficient. After the linear components have been picked out, the final phase includes the opposite rewrites to put each component back into an efficient form. If both sets of rules were included in one big phase, Calc could get into an infinite loop going back and forth between the two forms.

Elsewhere in FitRules, the components are first isolated, then recombined where possible to reduce the complexity of the linear fit, then finally packaged one component at a time into vectors. If the packaging rules were allowed to begin before the recombining rules were finished, some components might be put away into vectors before they had a chance to recombine. By putting these rules in two separate phases, this problem is neatly avoided.


**** Selections with Rewrite Rules

If a sub-formula of the current formula is selected (as by j s; see Selecting Sub-Formulas), the a r (calc-rewrite) command applies only to that sub-formula. Together with a negative prefix argument, you can use this fact to apply a rewrite to one specific part of a formula without affecting any other parts.

The j r (calc-rewrite-selection) command allows more sophisticated operations on selections. This command prompts for the rules in the same way as a r, but it then applies those rules to the whole formula in question even though a sub-formula of it has been selected. However, the selected sub-formula will first have been surrounded by a ‘select( )’ function call. (Calc’s evaluator does not understand the function name select; this is only a tag used by the j r command.)

For example, suppose the formula on the stack is ‘2 (a + b)^2’ and the sub-formula ‘a + b’ is selected. This formula will be rewritten to ‘2 select(a + b)^2’ and then the rewrite rules will be applied in the usual way. The rewrite rules can include references to select to tell where in the pattern the selected sub-formula should appear.

If there is still exactly one ‘select( )’ function call in the formula after rewriting is done, it indicates which part of the formula should be selected afterwards. Otherwise, the formula will be unselected.

You can make j r act much like a r by enclosing both parts of the rewrite rule with ‘select()’. However, j r allows you to use the current selection in more flexible ways. Suppose you wished to make a rule which removed the exponent from the selected term; the rule ‘select(a)^x := select(a)’ would work. In the above example, it would rewrite ‘2 select(a + b)^2’ to ‘2 select(a + b)’. This would then be returned to the stack as ‘2 (a + b)’ with the ‘a + b’ selected.

The j r command uses one iteration by default, unlike a r which defaults to 100 iterations. A numeric prefix argument affects j r in the same way as a r. See Nested Formulas with Rewrite Rules.

As with other selection commands, j r operates on the stack entry that contains the cursor. (If the cursor is on the top-of-stack ‘.’ marker, it works as if the cursor were on the formula at stack level 1.)

If you don’t specify a set of rules, the rules are taken from the top of the stack, just as with a r. In this case, the cursor must indicate stack entry 2 or above as the formula to be rewritten (otherwise the same formula would be used as both the target and the rewrite rules).

If the indicated formula has no selection, the cursor position within the formula temporarily selects a sub-formula for the purposes of this command. If the cursor is not on any sub-formula (e.g., it is in the line-number area to the left of the formula), the ‘select( )’ markers are ignored by the rewrite mechanism and the rules are allowed to apply anywhere in the formula.

As a special feature, the normal a r command also ignores ‘select( )’ calls in rewrite rules. For example, if you used the above rule ‘select(a)^x := select(a)’ with a r, it would apply the rule as if it were ‘a^x := a’. Thus, you can write general purpose rules with ‘select( )’ hints inside them so that they will “do the right thing” in both a r and j r, both with and without selections.


**** Matching Commands

The a m (calc-match) [match] function takes a vector of formulas and a rewrite-rule-style pattern, and produces a vector of all formulas which match the pattern. The command prompts you to enter the pattern; as for a r, you can enter a single pattern (i.e., a formula with meta-variables), or a vector of patterns, or a variable which contains patterns, or you can give a blank response in which case the patterns are taken from the top of the stack. The pattern set will be compiled once and saved if it is stored in a variable. If there are several patterns in the set, vector elements are kept if they match any of the patterns.

For example, ‘match(a+b, [x, x+y, x-y, 7, x+y+z])’ will return ‘[x+y, x-y, x+y+z]’.

The import mechanism is not available for pattern sets.

The a m command can also be used to extract all vector elements which satisfy any condition: The pattern ‘x :: x>0’ will select all the positive vector elements.

With the Inverse flag [matchnot], this command extracts all vector elements which do not match the given pattern.

There is also a function ‘matches(x, p)’ which evaluates to 1 if expression x matches pattern p, or to 0 otherwise. This is sometimes useful for including into the conditional clauses of other rewrite rules.

The function vmatches is just like matches, except that if the match succeeds it returns a vector of assignments to the meta-variables instead of the number 1. For example, ‘vmatches(f(1,2), f(a,b))’ returns ‘[a := 1, b := 2]’. If the match fails, the function returns the number 0.


**** Automatic Rewrites

It is possible to get Calc to apply a set of rewrite rules on all results, effectively adding to the built-in set of default simplifications. To do this, simply store your rule set in the variable EvalRules. There is a convenient s E command for editing EvalRules; see Other Operations on Variables.

For example, suppose you want ‘sin(a + b)’ to be expanded out to ‘sin(b) cos(a) + cos(b) sin(a)’ wherever it appears, and similarly for ‘cos(a + b)’. The corresponding rewrite rule set would be,

[ sin(a + b)  :=  cos(a) sin(b) + sin(a) cos(b),
  cos(a + b)  :=  cos(a) cos(b) - sin(a) sin(b) ]
To apply these manually, you could put them in a variable called trigexp and then use a r trigexp every time you wanted to expand trig functions. But if instead you store them in the variable EvalRules, they will automatically be applied to all sines and cosines of sums. Then, with ‘2 x’ and ‘45’ on the stack, typing + S will (assuming Degrees mode) result in ‘0.7071 sin(2 x) + 0.7071 cos(2 x)’ automatically.

As each level of a formula is evaluated, the rules from EvalRules are applied before the default simplifications. Rewriting continues until no further EvalRules apply. Note that this is different from the usual order of application of rewrite rules: EvalRules works from the bottom up, simplifying the arguments to a function before the function itself, while a r applies rules from the top down.

Because the EvalRules are tried first, you can use them to override the normal behavior of any built-in Calc function.

It is important not to write a rule that will get into an infinite loop. For example, the rule set ‘[f(0) := 1, f(n) := n f(n-1)]’ appears to be a good definition of a factorial function, but it is unsafe. Imagine what happens if ‘f(2.5)’ is simplified. Calc will continue to subtract 1 from this argument forever without reaching zero. A safer second rule would be ‘f(n) := n f(n-1) :: n>0’. Another dangerous rule is ‘g(x, y) := g(y, x)’. Rewriting ‘g(2, 4)’, this would bounce back and forth between that and ‘g(4, 2)’ forever. If an infinite loop in EvalRules occurs, Emacs will eventually stop with a “Computation got stuck or ran too long” message.

Another subtle difference between EvalRules and regular rewrites concerns rules that rewrite a formula into an identical formula. For example, ‘f(n) := f(floor(n))’ “fails to match” when ‘n’ is already an integer. But in EvalRules this case is detected only if the righthand side literally becomes the original formula before any further simplification. This means that ‘f(n) := f(floor(n))’ will get into an infinite loop if it occurs in EvalRules. Calc will replace ‘f(6)’ with ‘f(floor(6))’, which is different from ‘f(6)’, so it will consider the rule to have matched and will continue simplifying that formula; first the argument is simplified to get ‘f(6)’, then the rule matches again to get ‘f(floor(6))’ again, ad infinitum. A much safer rule would check its argument first, say, with ‘f(n) := f(floor(n)) :: !dint(n)’.

(What really happens is that the rewrite mechanism substitutes the meta-variables in the righthand side of a rule, compares to see if the result is the same as the original formula and fails if so, then uses the default simplifications to simplify the result and compares again (and again fails if the formula has simplified back to its original form). The only special wrinkle for the EvalRules is that the same rules will come back into play when the default simplifications are used. What Calc wants to do is build ‘f(floor(6))’, see that this is different from the original formula, simplify to ‘f(6)’, see that this is the same as the original formula, and thus halt the rewriting. But while simplifying, ‘f(6)’ will again trigger the same EvalRules rule and Calc will get into a loop inside the rewrite mechanism itself.)

The phase, schedule, and iterations markers do not work in EvalRules. If the rule set is divided into phases, only the phase 1 rules are applied, and the schedule is ignored. The rules are always repeated as many times as possible.

The EvalRules are applied to all function calls in a formula, but not to numbers (and other number-like objects like error forms), nor to vectors or individual variable names. (Though they will apply to components of vectors and error forms when appropriate.) You might try to make a variable phihat which automatically expands to its definition without the need to press = by writing the rule ‘quote(phihat) := (1-sqrt(5))/2’, but unfortunately this rule will not work as part of EvalRules.

Finally, another limitation is that Calc sometimes calls its built-in functions directly rather than going through the default simplifications. When it does this, EvalRules will not be able to override those functions. For example, when you take the absolute value of the complex number ‘(2, 3)’, Calc computes ‘sqrt(2*2 + 3*3)’ by calling the multiplication, addition, and square root functions directly rather than applying the default simplifications to this formula. So an EvalRules rule that (perversely) rewrites ‘sqrt(13) := 6’ would not apply. (However, if you put Calc into Symbolic mode so that ‘sqrt(13)’ will be left in symbolic form by the built-in square root function, your rule will be able to apply. But if the complex number were ‘(3,4)’, so that ‘sqrt(25)’ must be calculated, then Symbolic mode will not help because ‘sqrt(25)’ can be evaluated exactly to 5.)

One subtle restriction that normally only manifests itself with EvalRules is that while a given rewrite rule is in the process of being checked, that same rule cannot be recursively applied. Calc effectively removes the rule from its rule set while checking the rule, then puts it back once the match succeeds or fails. (The technical reason for this is that compiled pattern programs are not reentrant.) For example, consider the rule ‘foo(x) := x :: foo(x/2) > 0’ attempting to match ‘foo(8)’. This rule will be inactive while the condition ‘foo(4) > 0’ is checked, even though it might be an integral part of evaluating that condition. Note that this is not a problem for the more usual recursive type of rule, such as ‘foo(x) := foo(x/2)’, because there the rule has succeeded and been reactivated by the time the righthand side is evaluated.

If EvalRules has no stored value (its default state), or if anything but a vector is stored in it, then it is ignored.

Even though Calc’s rewrite mechanism is designed to compare rewrite rules to formulas as quickly as possible, storing rules in EvalRules may make Calc run substantially slower. This is particularly true of rules where the top-level call is a commonly used function, or is not fixed. The rule ‘f(n) := n f(n-1) :: n>0’ will only activate the rewrite mechanism for calls to the function f, but ‘lg(n) + lg(m) := lg(n m)’ will check every ‘+’ operator.

apply(f, [a*b]) := apply(f, [a]) + apply(f, [b]) :: in(f, [ln, log10])
may seem more “efficient” than two separate rules for ln and log10, but actually it is vastly less efficient because rules with apply as the top-level pattern must be tested against every function call that is simplified.

Suppose you want ‘sin(a + b)’ to be expanded out not all the time, but only when algebraic simplifications are used to simplify the formula. The variable AlgSimpRules holds rules for this purpose. The a s command will apply EvalRules and AlgSimpRules to the formula, as well as all of its built-in simplifications.

Most of the special limitations for EvalRules don’t apply to AlgSimpRules. Calc simply does an a r AlgSimpRules command with an infinite repeat count as the first step of algebraic simplifications. It then applies its own built-in simplifications throughout the formula, and then repeats these two steps (along with applying the default simplifications) until no further changes are possible.

There are also ExtSimpRules and UnitSimpRules variables that are used by a e and u s, respectively; these commands also apply EvalRules and AlgSimpRules. The variable IntegSimpRules contains simplification rules that are used only during integration by a i.


**** Debugging Rewrites

If a buffer named *Trace* exists, the rewrite mechanism will record some useful information there as it operates. The original formula is written there, as is the result of each successful rewrite, and the final result of the rewriting. All phase changes are also noted.

Calc always appends to *Trace*. You must empty this buffer yourself periodically if it is in danger of growing unwieldy.

Note that the rewriting mechanism is substantially slower when the *Trace* buffer exists, even if the buffer is not visible on the screen. Once you are done, you will probably want to kill this buffer (with C-x k *Trace* RET). If you leave it in existence and forget about it, all your future rewrite commands will be needlessly slow.


**** Examples of Rewrite Rules

Returning to the example of substituting the pattern ‘sin(x)^2 + cos(x)^2’ with 1, we saw that the rule ‘opt(a) sin(x)^2 + opt(a) cos(x)^2 := a’ does a good job of finding suitable cases. Another solution would be to use the rule ‘cos(x)^2 := 1 - sin(x)^2’, followed by algebraic simplification if necessary. This rule will be the most effective way to do the job, but at the expense of making some changes that you might not desire.

Another algebraic rewrite rule is ‘exp(x+y) := exp(x) exp(y)’. To make this work with the j r command so that it can be easily targeted to a particular exponential in a large formula, you might wish to write the rule as ‘select(exp(x+y)) := select(exp(x) exp(y))’. The ‘select’ markers will be ignored by the regular a r command (see Selections with Rewrite Rules).

A surprisingly useful rewrite rule is ‘a/(b-c) := a*(b+c)/(b^2-c^2)’. This will simplify the formula whenever ‘b’ and/or ‘c’ can be made simpler by squaring. For example, applying this rule to ‘2 / (sqrt(2) + 3)’ yields ‘6:7 - 2:7 sqrt(2)’ (assuming Symbolic mode has been enabled to keep the square root from being evaluated to a floating-point approximation). This rule is also useful when working with symbolic complex numbers, e.g., ‘(a + b i) / (c + d i)’.

As another example, we could define our own “triangular numbers” function with the rules ‘[tri(0) := 0, tri(n) := n + tri(n-1) :: n>0]’. Enter this vector and store it in a variable: s t trirules. Now, given a suitable formula like ‘tri(5)’ on the stack, type ‘a r trirules’ to apply these rules repeatedly. After six applications, a r will stop with 15 on the stack. Once these rules are debugged, it would probably be most useful to add them to EvalRules so that Calc will evaluate the new tri function automatically. We could then use Z K on the keyboard macro ' tri($) RET to make a command that applies tri to the value on the top of the stack. See Programming.

The following rule set, contributed by François Pinard, implements quaternions, a generalization of the concept of complex numbers. Quaternions have four components, and are here represented by function calls ‘quat(w, [x, y, z])’ with “real part” w and the three “imaginary” parts collected into a vector. Various arithmetical operations on quaternions are supported. To use these rules, either add them to EvalRules, or create a command based on a r for simplifying quaternion formulas. A convenient way to enter quaternions would be a command defined by a keyboard macro containing: ' quat($$$$, [$$$, $$, $]) RET.

[ quat(w, x, y, z) := quat(w, [x, y, z]),
  quat(w, [0, 0, 0]) := w,
  abs(quat(w, v)) := hypot(w, v),
  -quat(w, v) := quat(-w, -v),
  r + quat(w, v) := quat(r + w, v) :: real(r),
  r - quat(w, v) := quat(r - w, -v) :: real(r),
  quat(w1, v1) + quat(w2, v2) := quat(w1 + w2, v1 + v2),
  r * quat(w, v) := quat(r * w, r * v) :: real(r),
  plain(quat(w1, v1) * quat(w2, v2))
     := quat(w1 * w2 - v1 * v2, w1 * v2 + w2 * v1 + cross(v1, v2)),
  quat(w1, v1) / r := quat(w1 / r, v1 / r) :: real(r),
  z / quat(w, v) := z * quatinv(quat(w, v)),
  quatinv(quat(w, v)) := quat(w, -v) / (w^2 + v^2),
  quatsqr(quat(w, v)) := quat(w^2 - v^2, 2 * w * v),
  quat(w, v)^k := quatsqr(quat(w, v)^(k / 2))
               :: integer(k) :: k > 0 :: k % 2 = 0,
  quat(w, v)^k := quatsqr(quat(w, v)^((k - 1) / 2)) * quat(w, v)
               :: integer(k) :: k > 2,
  quat(w, v)^-k := quatinv(quat(w, v)^k) :: integer(k) :: k > 0 ]
Quaternions, like matrices, have non-commutative multiplication. In other words, ‘q1 * q2 = q2 * q1’ is not necessarily true if ‘q1’ and ‘q2’ are quat forms. The ‘quat*quat’ rule above uses plain to prevent Calc from rearranging the product. It may also be wise to add the line ‘[quat(), matrix]’ to the Decls matrix, to ensure that Calc’s other algebraic operations will not rearrange a quaternion product. See Declarations.

These rules also accept a four-argument quat form, converting it to the preferred form in the first rule. If you would rather see results in the four-argument form, just append the two items ‘phase(2), quat(w, [x, y, z]) := quat(w, x, y, z)’ to the end of the rule set. (But remember that multi-phase rule sets don’t work in EvalRules.)


** Operating on Units

One special interpretation of algebraic formulas is as numbers with units. For example, the formula ‘5 m / s^2’ can be read “five meters per second squared.” The commands in this chapter help you manipulate units expressions in this form. Units-related commands begin with the u prefix key.

*** Basic Operations on Units

A units expression is a formula which is basically a number multiplied and/or divided by one or more unit names, which may optionally be raised to integer powers. Actually, the value part need not be a number; any product or quotient involving unit names is a units expression. Many of the units commands will also accept any formula, where the command applies to all units expressions which appear in the formula.

A unit name is a variable whose name appears in the unit table, or a variable whose name is a prefix character like ‘k’ (for “kilo”) or ‘u’ (for “micro”) followed by a name in the unit table. A substantial table of built-in units is provided with Calc; see Predefined Units. You can also define your own unit names; see User-Defined Units.

Note that if the value part of a units expression is exactly ‘1’, it will be removed by the Calculator’s automatic algebra routines: The formula ‘1 mm’ is “simplified” to ‘mm’. This is only a display anomaly, however; ‘mm’ will work just fine as a representation of one millimeter.

You may find that Algebraic mode (see Algebraic Entry) makes working with units expressions easier. Otherwise, you will have to remember to hit the apostrophe key every time you wish to enter units.

The u s (calc-simplify-units) [usimplify] command simplifies a units expression. It uses Calc’s algebraic simplifications to simplify the expression first as a regular algebraic formula; it then looks for features that can be further simplified by converting one object’s units to be compatible with another’s. For example, ‘5 m + 23 mm’ will simplify to ‘5.023 m’. When different but compatible units are added, the righthand term’s units are converted to match those of the lefthand term. See Simplification Modes, for a way to have this done automatically at all times.

Units simplification also handles quotients of two units with the same dimensionality, as in ‘2 in s/L cm’ to ‘5.08 s/L’; fractional powers of unit expressions, as in ‘sqrt(9 mm^2)’ to ‘3 mm’ and ‘sqrt(9 acre)’ to a quantity in meters; and floor, ceil, round, rounde, roundu, trunc, float, frac, abs, and clean applied to units expressions, in which case the operation in question is applied only to the numeric part of the expression. Finally, trigonometric functions of quantities with units of angle are evaluated, regardless of the current angular mode.

The u c (calc-convert-units) command converts a units expression to new, compatible units. For example, given the units expression ‘55 mph’, typing u c m/s RET produces ‘24.5872 m/s’. If you have previously converted a units expression with the same type of units (in this case, distance over time), you will be offered the previous choice of new units as a default. Continuing the above example, entering the units expression ‘100 km/hr’ and typing u c RET (without specifying new units) produces ‘27.7777777778 m/s’.

The u c command treats temperature units (like ‘degC’ and ‘K’) as relative temperatures. For example, u c converts ‘10 degC’ to ‘18 degF’: A change of 10 degrees Celsius corresponds to a change of 18 degrees Fahrenheit. To convert absolute temperatures, you can use the u t (calc-convert-temperature) command. The value on the stack must be a simple units expression with units of temperature only. This command would convert ‘10 degC’ to ‘50 degF’, the equivalent temperature on the Fahrenheit scale.

While many of Calc’s conversion factors are exact, some are necessarily approximate. If Calc is in fraction mode (see Fraction Mode), then unit conversions will try to give exact, rational conversions, but it isn’t always possible. Given ‘55 mph’ in fraction mode, typing u c m/s RET produces ‘15367:625 m/s’, for example, while typing u c au/yr RET produces ‘5.18665819999e-3 au/yr’.

If the units you request are inconsistent with the original units, the number will be converted into your units times whatever “remainder” units are left over. For example, converting ‘55 mph’ into acres produces ‘6.08e-3 acre / (m s)’. Remainder units are expressed in terms of “fundamental” units like ‘m’ and ‘s’, regardless of the input units.

If you intend that your new units be consistent with the original units, the u n (calc-convert-exact-units) command will check the units before the conversion. For example, to change ‘mi/hr’ to ‘km/hr’, you could type u c km RET, but u n km RET would signal an error. You would need to type u n km/hr RET.

One special exception is that if you specify a single unit name, and a compatible unit appears somewhere in the units expression, then that compatible unit will be converted to the new unit and the remaining units in the expression will be left alone. For example, given the input ‘980 cm/s^2’, the command u c ms will change the ‘s’ to ‘ms’ to get ‘9.8e-4 cm/ms^2’. The “remainder unit” ‘cm’ is left alone rather than being changed to the base unit ‘m’.

You can use explicit unit conversion instead of the u s command to gain more control over the units of the result of an expression. For example, given ‘5 m + 23 mm’, you can type u c m or u c mm to express the result in either meters or millimeters. (For that matter, you could type u c fath to express the result in fathoms, if you preferred!)

In place of a specific set of units, you can also enter one of the units system names si, mks (equivalent), or cgs. For example, u c si RET converts the expression into International System of Units (SI) base units. Also, u c base converts to Calc’s base units, which are the same as si units except that base uses ‘g’ as the fundamental unit of mass whereas si uses ‘kg’.

The u c command also accepts composite units, which are expressed as the sum of several compatible unit names. For example, converting ‘30.5 in’ to units ‘mi+ft+in’ (miles, feet, and inches) produces ‘2 ft + 6.5 in’. Calc first sorts the unit names into order of decreasing relative size. It then accounts for as much of the input quantity as it can using an integer number times the largest unit, then moves on to the next smaller unit, and so on. Only the smallest unit may have a non-integer amount attached in the result. A few standard unit names exist for common combinations, such as mfi for ‘mi+ft+in’, and tpo for ‘ton+lb+oz’. Composite units are expanded as if by a x, so that ‘(ft+in)/hr’ is first converted to ‘ft/hr+in/hr’.

If the value on the stack does not contain any units, u c will prompt first for the old units which this value should be considered to have, then for the new units. (If the value on the stack can be simplified so that it doesn’t contain any units, like ‘ft/in’ can be simplified to 12, then u c will still prompt for both old units and new units. Assuming the old and new units you give are consistent with each other, the result also will not contain any units. For example, u c cm RET in RET converts the number 2 on the stack to 5.08.

The u b (calc-base-units) command is shorthand for u c base; it converts the units expression on the top of the stack into base units. If u s does not simplify a units expression as far as you would like, try u b.

Like the u c command, the u b command treats temperature units as relative temperatures.

The u r (calc-remove-units) command removes units from the formula at the top of the stack. The u x (calc-extract-units) command extracts only the units portion of a formula. These commands essentially replace every term of the formula that does or doesn’t (respectively) look like a unit name by the constant 1, then resimplify the formula.

The u a (calc-autorange-units) command turns on and off a mode in which unit prefixes like k (“kilo”) are automatically applied to keep the numeric part of a units expression in a reasonable range. This mode affects u s and all units conversion commands except u b. For example, with autoranging on, ‘12345 Hz’ will be simplified to ‘12.345 kHz’. Autoranging is useful for some kinds of units (like Hz and m), but is probably undesirable for non-metric units like ft and tbsp. (Composite units are more appropriate for those; see above.)

Autoranging always applies the prefix to the leftmost unit name. Calc chooses the largest prefix that causes the number to be greater than or equal to 1.0. Thus an increasing sequence of adjusted times would be ‘1 ms, 10 ms, 100 ms, 1 s, 10 s, 100 s, 1 ks’. Generally the rule of thumb is that the number will be adjusted to be in the interval ‘[1 .. 1000)’, although there are several exceptions to this rule. First, if the unit has a power then this is not possible; ‘0.1 s^2’ simplifies to ‘100000 ms^2’. Second, the “centi-” prefix is allowed to form cm (centimeters), but will not apply to other units. The “deci-,” “deka-,” and “hecto-” prefixes are never used. Thus the allowable interval is ‘[1 .. 10)’ for millimeters and ‘[1 .. 100)’ for centimeters. Finally, a prefix will not be added to a unit if the resulting name is also the actual name of another unit; ‘1e-15 t’ would normally be considered a “femto-ton,” but it is written as ‘1000 at’ (1000 atto-tons) instead because ft would be confused with feet.


*** The Units Table

The u v (calc-enter-units-table) command displays the units table in another buffer called *Units Table*. Each entry in this table gives the unit name as it would appear in an expression, the definition of the unit in terms of simpler units, and a full name or description of the unit. Fundamental units are defined as themselves; these are the units produced by the u b command. The fundamental units are meters, seconds, grams, kelvins, amperes, candelas, moles, radians, and steradians.

The Units Table buffer also displays the Unit Prefix Table. Note that two prefixes, “kilo” and “hecto,” accept either upper- or lower-case prefix letters. ‘Meg’ is also accepted as a synonym for the ‘M’ prefix. Whenever a unit name can be interpreted as either a built-in name or a prefix followed by another built-in name, the former interpretation wins. For example, ‘2 pt’ means two pints, not two pico-tons.

The Units Table buffer, once created, is not rebuilt unless you define new units. To force the buffer to be rebuilt, give any numeric prefix argument to u v.

The u V (calc-view-units-table) command is like u v except that the cursor is not moved into the Units Table buffer. You can type u V again to remove the Units Table from the display. To return from the Units Table buffer after a u v, type C-x * c again or use the regular Emacs C-x o (other-window) command. You can also kill the buffer with C-x k if you wish; the actual units table is safely stored inside the Calculator.

The u g (calc-get-unit-definition) command retrieves a unit’s defining expression and pushes it onto the Calculator stack. For example, u g in will produce the expression ‘2.54 cm’. This is the same definition for the unit that would appear in the Units Table buffer. Note that this command works only for actual unit names; u g km will report that no such unit exists, for example, because km is really the unit m with a k (“kilo”) prefix. To see a definition of a unit in terms of base units, it is easier to push the unit name on the stack and then reduce it to base units with u b.

The u e (calc-explain-units) command displays an English description of the units of the expression on the stack. For example, for the expression ‘62 km^2 g / s^2 mol K’, the description is “Square-Kilometer Gram per (Second-squared Mole Degree-Kelvin).” This command uses the English descriptions that appear in the righthand column of the Units Table.


*** Predefined Units

The definitions of many units have changed over the years. For example, the meter was originally defined in 1791 as one ten-millionth of the distance from the Equator to the North Pole. In order to be more precise, the definition was adjusted several times, and now a meter is defined as the distance that light will travel in a vacuum in 1/299792458 of a second; consequently, the speed of light in a vacuum is exactly 299792458 m/s. Many other units have been redefined in terms of fundamental physical processes; a second, for example, is currently defined as 9192631770 periods of a certain radiation related to the cesium-133 atom. The British imperial units, once defined in terms of physical objects, were redefined in 1963 in terms of SI units. The US customary units, which were the same as British units until the British imperial system was created in 1824, were also defined in terms of the SI units in 1893. Because of these redefinitions, conversions between metric, British Imperial, and US customary units can often be done precisely.

Since the exact definitions of many kinds of units have evolved over the years, and since certain countries sometimes have local differences in their definitions, it is a good idea to examine Calc’s definition of a unit before depending on its exact value. For example, there are three different units for gallons, corresponding to the US (gal), Canadian (galC), and British (galUK) definitions. Also, note that oz is a standard ounce of mass, ozt is a Troy ounce, and ozfl is a fluid ounce.

The temperature units corresponding to degrees Kelvin and Centigrade (Celsius) are the same in this table, since most units commands treat temperatures as being relative. The calc-convert-temperature command has special rules for handling the different absolute magnitudes of the various temperature scales.

The unit of volume “liters” can be referred to by either the lower-case l or the upper-case L.

The unit A stands for amperes; the name Ang is used for angstroms.

The unit pt stands for pints; the name point stands for a typographical point, defined by ‘72 point = 1 in’. This is slightly different from the point defined by the American Typefounder’s Association in 1886, but the point used by Calc has become standard largely due to its use by the PostScript page description language. There is also texpt, which stands for a printer’s point as defined by the TeX typesetting system: ‘72.27 texpt = 1 in’. Other units used by TeX are available; they are texpc (a pica), texbp (a “big point”, equal to a standard point which is larger than the point used by TeX), texdd (a Didot point), texcc (a Cicero) and texsp (a scaled TeX point, all dimensions representable in TeX are multiples of this value).

When Calc is using the TeX or LaTeX language mode (see TeX and LaTeX Language Modes), the TeX specific unit names will not use the ‘tex’ prefix; the unit name for a TeX point will be ‘pt’ instead of ‘texpt’, for example. To avoid conflicts, the unit names for pint and parsec will simply be ‘pint’ and ‘parsec’ instead of ‘pt’ and ‘pc’.

The unit e stands for the elementary (electron) unit of charge; because algebra command could mistake this for the special constant ‘e’, Calc provides the alternate unit name ech which is preferable to e.

The name g stands for one gram of mass; there is also gf, one gram of force. (Likewise for lb, pounds, and lbf.) Meanwhile, one “‘g’” of acceleration is denoted ga.

The unit ton is a U.S. ton of ‘2000 lb’, and t is a metric ton of ‘1000 kg’.

The names s (or sec) and min refer to units of time; arcsec and arcmin are units of angle.

Some “units” are really physical constants; for example, c represents the speed of light, and h represents Planck’s constant. You can use these just like other units: converting ‘.5 c’ to ‘m/s’ expresses one-half the speed of light in meters per second. You can also use this merely as a handy reference; the u g command gets the definition of one of these constants in its normal terms, and u b expresses the definition in base units.

Two units, pi and alpha (the fine structure constant, approximately 1/137) are dimensionless. The units simplification commands simply treat these names as equivalent to their corresponding values. However you can, for example, use u c to convert a pure number into multiples of the fine structure constant, or u b to convert this back into a pure number. (When u c prompts for the “old units,” just enter a blank line to signify that the value really is unitless.)


*** User-Defined Units

Calc provides ways to get quick access to your selected “favorite” units, as well as ways to define your own new units.

To select your favorite units, store a vector of unit names or expressions in the Calc variable Units. The u 1 through u 9 commands (calc-quick-units) provide access to these units. If the value on the top of the stack is a plain number (with no units attached), then u 1 gives it the specified units. (Basically, it multiplies the number by the first item in the Units vector.) If the number on the stack does have units, then u 1 converts that number to the new units. For example, suppose the vector ‘[in, ft]’ is stored in Units. Then 30 u 1 will create the expression ‘30 in’, and u 2 will convert that expression to ‘2.5 ft’.

The u 0 command accesses the tenth element of Units. Only ten quick units may be defined at a time. If the Units variable has no stored value (the default), or if its value is not a vector, then the quick-units commands will not function. The s U command is a convenient way to edit the Units variable; see Other Operations on Variables.

The u d (calc-define-unit) command records the units expression on the top of the stack as the definition for a new, user-defined unit. For example, putting ‘16.5 ft’ on the stack and typing u d rod defines the new unit ‘rod’ to be equivalent to 16.5 feet. The unit conversion and simplification commands will now treat rod just like any other unit of length. You will also be prompted for an optional English description of the unit, which will appear in the Units Table. If you wish the definition of this unit to be displayed in a special way in the Units Table buffer (such as with an asterisk to indicate an approximate value), then you can call this command with an argument, C-u u d; you will then also be prompted for a string that will be used to display the definition.

The u u (calc-undefine-unit) command removes a user-defined unit. It is not possible to remove one of the predefined units, however.

If you define a unit with an existing unit name, your new definition will replace the original definition of that unit. If the unit was a predefined unit, the old definition will not be replaced, only “shadowed.” The built-in definition will reappear if you later use u u to remove the shadowing definition.

To create a new fundamental unit, use either 1 or the unit name itself as the defining expression. Otherwise the expression can involve any other units that you like (except for composite units like ‘mfi’). You can create a new composite unit with a sum of other units as the defining expression. The next unit operation like u c or u v will rebuild the internal unit table incorporating your modifications. Note that erroneous definitions (such as two units defined in terms of each other) will not be detected until the unit table is next rebuilt; u v is a convenient way to force this to happen.

Temperature units are treated specially inside the Calculator; it is not possible to create user-defined temperature units.

The u p (calc-permanent-units) command stores the user-defined units in your Calc init file (the file given by the variable calc-settings-file, typically ~/.emacs.d/calc.el), so that the units will still be available in subsequent Emacs sessions. If there was already a set of user-defined units in your Calc init file, it is replaced by the new set. (See General Mode Commands, for a way to tell Calc to use a different file for the Calc init file.)


*** Logarithmic Units

The units dB (decibels) and Np (nepers) are logarithmic units which are manipulated differently than standard units. Calc provides commands to work with these logarithmic units.

Decibels and nepers are used to measure power quantities as well as field quantities (quantities whose squares are proportional to power); these two types of quantities are handled slightly different from each other. By default the Calc commands work as if power quantities are being used; with the H prefix the Calc commands work as if field quantities are being used.

The decibel level of a power P1, relative to a reference power P0, is defined to be 10 log10(P1/P0) dB. (The factor of 10 is because a decibel, as its name implies, is one-tenth of a bel. The bel, named after Alexander Graham Bell, was considered to be too large of a unit and was effectively replaced by the decibel.) If F is a field quantity with power P=k F^2, then a reference quantity of F0 would correspond to a power of P0=k F0^2. If P1=k F1^2, then

10 log10(P1/P0) = 10 log10(F1^2/F0^2) = 20 log10(F1/F0).
In order to get the same decibel level regardless of whether a field quantity or the corresponding power quantity is used, the decibel level of a field quantity F1, relative to a reference F0, is defined as 20 log10(F1/F0) dB. For example, the decibel value of a sound pressure level of 60 uPa relative to 20 uPa (the threshold of human hearing) is 20 log10(60 uPa/ 20 uPa) dB = 20 log10(3) dB, which is about 9.54 dB. Note that in taking the ratio, the original units cancel and so these logarithmic units are dimensionless.

Nepers (named after John Napier, who is credited with inventing the logarithm) are similar to bels except they use natural logarithms instead of common logarithms. The neper level of a power P1, relative to a reference power P0, is (1/2) ln(P1/P0) Np. The neper level of a field F1, relative to a reference field F0, is ln(F1/F0) Np.

For power quantities, Calc uses 1 mW as the default reference quantity; this default can be changed by changing the value of the customizable variable calc-lu-power-reference (see Customizing Calc). For field quantities, Calc uses 20 uPa as the default reference quantity; this is the value used in acoustics which is where decibels are commonly encountered. This default can be changed by changing the value of the customizable variable calc-lu-field-reference (see Customizing Calc). A non-default reference quantity will be read from the stack if the capital O prefix is used.

The l q (calc-lu-quant) [lupquant] command computes the power quantity corresponding to a given number of logarithmic units. With the capital O prefix, O l q, the reference level will be read from the top of the stack. (In an algebraic formula, lupquant can be given an optional second argument which will be used for the reference level.) For example, 20 dB RET l q will return 100 mW; 20 dB RET 4 W RET O l q will return 400 W. The H l q [lufquant] command behaves like l q but computes field quantities instead of power quantities.

The l d (calc-db) [dbpower] command will compute the decibel level of a power quantity using the default reference level; H l d [dbfield] will compute the decibel level of a field quantity. The commands l n (calc-np) [nppower] and H l n [npfield] will similarly compute neper levels. With the capital O prefix these commands will read a reference level from the stack; in an algebraic formula the reference level can be given as an optional second argument.

The sum of two power or field quantities doesn’t correspond to the sum of the corresponding decibel or neper levels. If the powers corresponding to decibel levels D1 and D2 are added, the corresponding decibel level “sum” will be

  10 log10(10^(D1/10) + 10^(D2/10)) dB.
When field quantities are combined, it often means the corresponding powers are added and so the above formula might be used. In acoustics, for example, the sound pressure level is a field quantity and so the decibels are often defined using the field formula, but the sound pressure levels are combined as the sound power levels, and so the above formula should be used. If two field quantities themselves are added, the new decibel level will be

  20 log10(10^(D1/20) + 10^(D2/20)) dB.
If the power corresponding to D dB is multiplied by a number N, then the corresponding decibel level will be

  D + 10 log10(N) dB,
if a field quantity is multiplied by N the corresponding decibel level will be

  D + 20 log10(N) dB.
There are similar formulas for combining nepers. The l + (calc-lu-plus) [lupadd] command will “add” two logarithmic unit power levels this way; with the H prefix, H l + [lufadd] will add logarithmic unit field levels. Similarly, logarithmic units can be “subtracted” with l - (calc-lu-minus) [lupsub] or H l - [lufsub]. The l * (calc-lu-times) [lupmul] and H l * [lufmul] commands will “multiply” a logarithmic unit by a number; the l / (calc-lu-divide) [lupdiv] and H l / [lufdiv] commands will “divide” a logarithmic unit by a number. Note that the reference quantities don’t play a role in this arithmetic.


*** Musical Notes

Calc can convert between musical notes and their associated frequencies. Notes can be given using either scientific pitch notation or midi numbers. Since these note systems are basically logarithmic scales, Calc uses the l prefix for functions operating on notes.

Scientific pitch notation refers to a note by giving a letter A through G, possibly followed by a flat or sharp) with a subscript indicating an octave number. Each octave starts with C and ends with B and the octave numbered 0 was chosen to correspond to the lowest audible frequency. Using this system, middle C (about 261.625 Hz) corresponds to the note C in octave 4 and is denoted C4. Any frequency can be described by giving a note plus an offset in cents (where a cent is a ratio of frequencies so that a semitone consists of 100 cents).

The midi note number system assigns numbers to notes so that C-1 corresponds to the midi note number 0 and G9 corresponds to the midi note number 127. A midi controller can have up to 128 keys and each midi note number from 0 to 127 corresponds to a possible key.

The l s (calc-spn) [spn] command converts either a frequency or a midi number to scientific pitch notation. For example, 500 Hz gets converted to B_4 + 21.3094853649 cents and 84 to C_6.

The l m (calc-midi) [midi] command converts either a frequency or a note given in scientific pitch notation to the corresponding midi number. For example, C_6 gets converted to 84 and 440 Hz to 69.

The l f (calc-freq) [freq] command converts either either a midi number or a note given in scientific pitch notation to the corresponding frequency. For example, Asharp_2 + 30 cents gets converted to 118.578040134 Hz and 55 to 195.99771799 Hz.

Since the frequencies of notes are not usually given exactly (and are typically irrational), the customizable variable calc-note-threshold determines how close (in cents) a frequency needs to be to a note to be recognized as that note (see Customizing Calc). This variable has a default value of 1. For example, middle C is approximately ‘261.625565302 Hz’; this frequency is often shortened to ‘261.625 Hz’. Without calc-note-threshold (or a value of ‘0’), Calc would convert 261.625 Hz to scientific pitch notation B_3 + 99.9962592773 cents; with the default value of 1, Calc converts 261.625 Hz to C_4.


** Storing and Recalling

Calculator variables are really just Lisp variables that contain numbers or formulas in a form that Calc can understand. The commands in this section allow you to manipulate variables conveniently. Commands related to variables use the s prefix key.

*** Storing Variables

The s s (calc-store) command stores the value at the top of the stack into a specified variable. It prompts you to enter the name of the variable. If you press a single digit, the value is stored immediately in one of the “quick” variables q0 through q9. Or you can enter any variable name.

The s s command leaves the stored value on the stack. There is also an s t (calc-store-into) command, which removes a value from the stack and stores it in a variable.

If the top of stack value is an equation ‘a = 7’ or assignment ‘a := 7’ with a variable on the lefthand side, then Calc will assign that variable with that value by default, i.e., if you type s s RET or s t RET. In this example, the value 7 would be stored in the variable ‘a’. (If you do type a variable name at the prompt, the top-of-stack value is stored in its entirety, even if it is an equation: ‘s s b RET’ with ‘a := 7’ on the stack stores ‘a := 7’ in b.)

In fact, the top of stack value can be a vector of equations or assignments with different variables on their lefthand sides; the default will be to store all the variables with their corresponding righthand sides simultaneously.

It is also possible to type an equation or assignment directly at the prompt for the s s or s t command: s s foo = 7. In this case the expression to the right of the = or := symbol is evaluated as if by the = command, and that value is stored in the variable. No value is taken from the stack; s s and s t are equivalent when used in this way.

The prefix keys s and t may be followed immediately by a digit; s 9 is equivalent to s s 9, and t 9 is equivalent to s t 9. (The t prefix is otherwise used for trail and time/date commands.)

There are also several “arithmetic store” commands. For example, s + removes a value from the stack and adds it to the specified variable. The other arithmetic stores are s -, s *, s /, s ^, and s | (vector concatenation), plus s n and s & which negate or invert the value in a variable, and s [ and s ] which decrease or increase a variable by one.

All the arithmetic stores accept the Inverse prefix to reverse the order of the operands. If ‘v’ represents the contents of the variable, and ‘a’ is the value drawn from the stack, then regular s - assigns ‘v := v - a’, but I s - assigns ‘v := a - v’. While I s * might seem pointless, it is useful if matrix multiplication is involved. Actually, all the arithmetic stores use formulas designed to behave usefully both forwards and backwards:

s +        v := v + a          v := a + v
s -        v := v - a          v := a - v
s *        v := v * a          v := a * v
s /        v := v / a          v := a / v
s ^        v := v ^ a          v := a ^ v
s |        v := v | a          v := a | v
s n        v := v / (-1)       v := (-1) / v
s &        v := v ^ (-1)       v := (-1) ^ v
s [        v := v - 1          v := 1 - v
s ]        v := v - (-1)       v := (-1) - v
In the last four cases, a numeric prefix argument will be used in place of the number one. (For example, M-2 s ] increases a variable by 2, and M-2 I s ] replaces a variable by minus-two minus the variable.

The first six arithmetic stores can also be typed s t +, s t -, etc. The commands s s +, s s -, and so on are analogous arithmetic stores that don’t remove the value ‘a’ from the stack.

All arithmetic stores report the new value of the variable in the Trail for your information. They signal an error if the variable previously had no stored value. If default simplifications have been turned off, the arithmetic stores temporarily turn them on for numeric arguments only (i.e., they temporarily do an m N command). See Simplification Modes. Large vectors put in the trail by these commands always use abbreviated (t .) mode.

The s m command is a general way to adjust a variable’s value using any Calc function. It is a “mapping” command analogous to V M, V R, etc. See Reducing and Mapping Vectors, to see how to specify a function for a mapping command. Basically, all you do is type the Calc command key that would invoke that function normally. For example, s m n applies the n key to negate the contents of the variable, so s m n is equivalent to s n. Also, s m Q takes the square root of the value stored in a variable, s m v v uses v v to reverse the vector stored in the variable, and s m H I S takes the hyperbolic arcsine of the variable contents.

If the mapping function takes two or more arguments, the additional arguments are taken from the stack; the old value of the variable is provided as the first argument. Thus s m - with ‘a’ on the stack computes ‘v - a’, just like s -. With the Inverse prefix, the variable’s original value becomes the last argument instead of the first. Thus I s m - is also equivalent to I s -.

The s x (calc-store-exchange) command exchanges the value of a variable with the value on the top of the stack. Naturally, the variable must already have a stored value for this to work.

You can type an equation or assignment at the s x prompt. The command s x a=6 takes no values from the stack; instead, it pushes the old value of ‘a’ on the stack and stores ‘a = 6’.

Until you store something in them, most variables are “void,” that is, they contain no value at all. If they appear in an algebraic formula they will be left alone even if you press = (calc-evaluate). The s u (calc-unstore) command returns a variable to the void state.

The s c (calc-copy-variable) command copies the stored value of one variable to another. One way it differs from a simple s r followed by an s t (aside from saving keystrokes) is that the value never goes on the stack and thus is never rounded, evaluated, or simplified in any way; it is not even rounded down to the current precision.

The only variables with predefined values are the “special constants” pi, e, i, phi, and gamma. You are free to unstore these variables or to store new values into them if you like, although some of the algebraic-manipulation functions may assume these variables represent their standard values. Calc displays a warning if you change the value of one of these variables, or of one of the other special variables inf, uinf, and nan (which are normally void).

Note that pi doesn’t actually have 3.14159265359 stored in it, but rather a special magic value that evaluates to ‘pi’ at the current precision. Likewise e, i, and phi evaluate according to the current precision or polar mode. If you recall a value from pi and store it back, this magic property will be lost. The magic property is preserved, however, when a variable is copied with s c.

If one of the “special constants” is redefined (or undefined) so that it no longer has its magic property, the property can be restored with s k (calc-copy-special-constant). This command will prompt for a special constant and a variable to store it in, and so a special constant can be stored in any variable. Here, the special constant that you enter doesn’t depend on the value of the corresponding variable; pi will represent 3.14159… regardless of what is currently stored in the Calc variable pi. If one of the other special variables, inf, uinf or nan, is given a value, its original behavior can be restored by voiding it with s u.


*** Recalling Variables

The most straightforward way to extract the stored value from a variable is to use the s r (calc-recall) command. This command prompts for a variable name (similarly to calc-store), looks up the value of the specified variable, and pushes that value onto the stack. It is an error to try to recall a void variable.

It is also possible to recall the value from a variable by evaluating a formula containing that variable. For example, ' a RET = is the same as s r a RET except that if the variable is void, the former will simply leave the formula ‘a’ on the stack whereas the latter will produce an error message.

The r prefix may be followed by a digit, so that r 9 is equivalent to s r 9.


*** Other Operations on Variables

The s e (calc-edit-variable) command edits the stored value of a variable without ever putting that value on the stack or simplifying or evaluating the value. It prompts for the name of the variable to edit. If the variable has no stored value, the editing buffer will start out empty. If the editing buffer is empty when you press C-c C-c to finish, the variable will be made void. See Editing Stack Entries, for a general description of editing.

The s e command is especially useful for creating and editing rewrite rules which are stored in variables. Sometimes these rules contain formulas which must not be evaluated until the rules are actually used. (For example, they may refer to ‘deriv(x,y)’, where x will someday become some expression involving y; if you let Calc evaluate the rule while you are defining it, Calc will replace ‘deriv(x,y)’ with 0 because the formula x does not itself refer to y.) By contrast, recalling the variable, editing with `, and storing will evaluate the variable’s value as a side effect of putting the value on the stack.

There are several special-purpose variable-editing commands that use the s prefix followed by a shifted letter:

s A
Edit AlgSimpRules. See Algebraic Simplifications.

s D
Edit Decls. See Declarations.

s E
Edit EvalRules. See Basic Simplifications.

s F
Edit FitRules. See Curve Fitting.

s G
Edit GenCount. See Solving Equations.

s H
Edit Holidays. See Business Days.

s I
Edit IntegLimit. See Calculus.

s L
Edit LineStyles. See Graphics.

s P
Edit PointStyles. See Graphics.

s R
Edit PlotRejects. See Graphics.

s T
Edit TimeZone. See Time Zones.

s U
Edit Units. See User-Defined Units.

s X
Edit ExtSimpRules. See “Unsafe” Simplifications.

These commands are just versions of s e that use fixed variable names rather than prompting for the variable name.

The s p (calc-permanent-variable) command saves a variable’s value permanently in your Calc init file (the file given by the variable calc-settings-file, typically ~/.emacs.d/calc.el), so that its value will still be available in future Emacs sessions. You can re-execute s p later on to update the saved value, but the only way to remove a saved variable is to edit your calc init file by hand. (See General Mode Commands, for a way to tell Calc to use a different file for the Calc init file.)

If you do not specify the name of a variable to save (i.e., s p RET), all Calc variables with defined values are saved except for the special constants pi, e, i, phi, and gamma; the variables TimeZone and PlotRejects; FitRules, DistribRules, and other built-in rewrite rules; and PlotDatan variables generated by the graphics commands. (You can still save these variables by explicitly naming them in an s p command.)

The s i (calc-insert-variables) command writes the values of all Calc variables into a specified buffer. The variables are written with the prefix var- in the form of Lisp setq commands which store the values in string form. You can place these commands in your Calc init file (or .emacs) if you wish, though in this case it would be easier to use s p RET. (Note that s i omits the same set of variables as s p RET; the difference is that s i will store the variables in any buffer, and it also stores in a more human-readable format.)


*** The Let Command

If you have an expression like ‘a+b^2’ on the stack and you wish to compute its value where ‘b=3’, you can simply store 3 in ‘b’ and then press = to reevaluate the formula. This has the side-effect of leaving the stored value of 3 in ‘b’ for future operations.

The s l (calc-let) command evaluates a formula under a temporary assignment of a variable. It stores the value on the top of the stack into the specified variable, then evaluates the second-to-top stack entry, then restores the original value (or lack of one) in the variable. Thus after ' a+b^2 RET 3 s l b RET, the stack will contain the formula ‘a + 9’. The subsequent command 5 s l a RET will replace this formula with the number 14. The variables ‘a’ and ‘b’ are not permanently affected in any way by these commands.

The value on the top of the stack may be an equation or assignment, or a vector of equations or assignments, in which case the default will be analogous to the case of s t RET. See Storing Variables.

Also, you can answer the variable-name prompt with an equation or assignment: s l b=3 RET is the same as storing 3 on the stack and typing s l b RET.

The a b (calc-substitute) command is another way to substitute a variable with a value in a formula. It does an actual substitution rather than temporarily assigning the variable and evaluating. For example, letting ‘n=2’ in ‘f(n pi)’ with a b will produce ‘f(2 pi)’, whereas s l would give ‘f(6.28)’ since the evaluation step will also evaluate pi.


*** The Evaluates-To Operator

The special algebraic symbol ‘=>’ is known as the evaluates-to operator. (It will show up as an evalto function call in other language modes like Pascal and LaTeX.) This is a binary operator, that is, it has a lefthand and a righthand argument, although it can be entered with the righthand argument omitted.

A formula like ‘a => b’ is evaluated by Calc as follows: First, a is not simplified or modified in any way. The previous value of argument b is thrown away; the formula a is then copied and evaluated as if by the = command according to all current modes and stored variable values, and the result is installed as the new value of b.

For example, suppose you enter the algebraic formula ‘2 + 3 => 17’. The number 17 is ignored, and the lefthand argument is left in its unevaluated form; the result is the formula ‘2 + 3 => 5’.

You can enter an ‘=>’ formula either directly using algebraic entry (in which case the righthand side may be omitted since it is going to be replaced right away anyhow), or by using the s = (calc-evalto) command, which takes a from the stack and replaces it with ‘a => b’.

Calc keeps track of all ‘=>’ operators on the stack, and recomputes them whenever anything changes that might affect their values, i.e., a mode setting or variable value. This occurs only if the ‘=>’ operator is at the top level of the formula, or if it is part of a top-level vector. In other words, pushing ‘2 + (a => 17)’ will change the 17 to the actual value of ‘a’ when you enter the formula, but the result will not be dynamically updated when ‘a’ is changed later because the ‘=>’ operator is buried inside a sum. However, a vector of ‘=>’ operators will be recomputed, since it is convenient to push a vector like ‘[a =>, b =>, c =>]’ on the stack to make a concise display of all the variables in your problem. (Another way to do this would be to use ‘[a, b, c] =>’, which provides a slightly different format of display. You can use whichever you find easiest to read.)

The m C (calc-auto-recompute) command allows you to turn this automatic recomputation on or off. If you turn recomputation off, you must explicitly recompute an ‘=>’ operator on the stack in one of the usual ways, such as by pressing =. Turning recomputation off temporarily can save a lot of time if you will be changing several modes or variables before you look at the ‘=>’ entries again.

Most commands are not especially useful with ‘=>’ operators as arguments. For example, given ‘x + 2 => 17’, it won’t work to type 1 + to get ‘x + 3 => 18’. If you want to operate on the lefthand side of the ‘=>’ operator on the top of the stack, type j 1 (that’s the digit “one”) to select the lefthand side, execute your commands, then type j u to unselect.

All current modes apply when an ‘=>’ operator is computed, including the current simplification mode. Recall that the formula ‘arcsin(sin(x))’ will not be handled by Calc’s algebraic simplifications, but Calc’s unsafe simplifications will reduce it to ‘x’. If you enter ‘arcsin(sin(x)) =>’ normally, the result will be ‘arcsin(sin(x)) => arcsin(sin(x))’. If you change to Extended Simplification mode, the result will be ‘arcsin(sin(x)) => x’. However, just pressing a e once will have no effect on ‘arcsin(sin(x)) => arcsin(sin(x))’, because the righthand side depends only on the lefthand side and the current mode settings, and the lefthand side is not affected by commands like a e.

The “let” command (s l) has an interesting interaction with the ‘=>’ operator. The s l command evaluates the second-to-top stack entry with the top stack entry supplying a temporary value for a given variable. As you might expect, if that stack entry is an ‘=>’ operator its righthand side will temporarily show this value for the variable. In fact, all ‘=>’s on the stack will be updated if they refer to that variable. But this change is temporary in the sense that the next command that causes Calc to look at those stack entries will make them revert to the old variable value.

2:  a => a             2:  a => 17         2:  a => a
1:  a + 1 => a + 1     1:  a + 1 => 18     1:  a + 1 => a + 1
    .                      .                   .

                           17 s l a RET        p 8 RET
Here the p 8 command changes the current precision, thus causing the ‘=>’ forms to be recomputed after the influence of the “let” is gone. The d SPC command (calc-refresh) is a handy way to force the ‘=>’ operators on the stack to be recomputed without any other side effects.

Embedded mode also uses ‘=>’ operators. In Embedded mode, the lefthand side of an ‘=>’ operator can refer to variables assigned elsewhere in the file by ‘:=’ operators. The assignment operator ‘a := 17’ does not actually do anything by itself. But Embedded mode recognizes it and marks it as a sort of file-local definition of the variable. You can enter ‘:=’ operators in Algebraic mode, or by using the s : (calc-assign) [assign] command which takes a variable and value from the stack and replaces them with an assignment.

See TeX and LaTeX Language Modes, for the way ‘=>’ appears in TeX language output. The eqn mode gives similar treatment to ‘=>’.


** Graphics

The commands for graphing data begin with the g prefix key. Calc uses GNUPLOT 2.0 or later to do graphics. These commands will only work if GNUPLOT is available on your system. (While GNUPLOT sounds like a relative of GNU Emacs, it is actually completely unrelated. However, it is free software. It can be obtained from ‘http://www.gnuplot.info’.)

If you have GNUPLOT installed on your system but Calc is unable to find it, you may need to set the calc-gnuplot-name variable in your Calc init file or .emacs. You may also need to set some Lisp variables to show Calc how to run GNUPLOT on your system; these are described under g D and g O below. If you are using the X window system or MS-Windows, Calc will configure GNUPLOT for you automatically. If you have GNUPLOT 3.0 or later and you are using a Unix or GNU system without X, Calc will configure GNUPLOT to display graphs using simple character graphics that will work on any POSIX-compatible terminal.

*** Basic Graphics

The easiest graphics command is g f (calc-graph-fast). This command takes two vectors of equal length from the stack. The vector at the top of the stack represents the “y” values of the various data points. The vector in the second-to-top position represents the corresponding “x” values. This command runs GNUPLOT (if it has not already been started by previous graphing commands) and displays the set of data points. The points will be connected by lines, and there will also be some kind of symbol to indicate the points themselves.

The “x” entry may instead be an interval form, in which case suitable “x” values are interpolated between the minimum and maximum values of the interval (whether the interval is open or closed is ignored).

The “x” entry may also be a number, in which case Calc uses the sequence of “x” values ‘x’, ‘x+1’, ‘x+2’, etc. (Generally the number 0 or 1 would be used for ‘x’ in this case.)

The “y” entry may be any formula instead of a vector. Calc effectively uses N (calc-eval-num) to evaluate variables in the formula; the result of this must be a formula in a single (unassigned) variable. The formula is plotted with this variable taking on the various “x” values. Graphs of formulas by default use lines without symbols at the computed data points. Note that if neither “x” nor “y” is a vector, Calc guesses at a reasonable number of data points to use. See the g N command below. (The “x” values must be either a vector or an interval if “y” is a formula.)

If “y” is (or evaluates to) a formula of the form ‘xy(x, y)’ then the result is a parametric plot. The two arguments of the fictitious xy function are used as the “x” and “y” coordinates of the curve, respectively. In this case the “x” vector or interval you specified is not directly visible in the graph. For example, if “x” is the interval ‘[0..360]’ and “y” is the formula ‘xy(sin(t), cos(t))’, the resulting graph will be a circle.

Also, “x” and “y” may each be variable names, in which case Calc looks for suitable vectors, intervals, or formulas stored in those variables.

The “x” and “y” values for the data points (as pulled from the vectors, calculated from the formulas, or interpolated from the intervals) should be real numbers (integers, fractions, or floats). One exception to this is that the “y” entry can consist of a vector of numbers combined with error forms, in which case the points will be plotted with the appropriate error bars. Other than this, if either the “x” value or the “y” value of a given data point is not a real number, that data point will be omitted from the graph. The points on either side of the invalid point will not be connected by a line.

See the documentation for g a below for a description of the way numeric prefix arguments affect g f.

If you store an empty vector in the variable PlotRejects (i.e., [ ] s t PlotRejects), Calc will append information to this vector for every data point which was rejected because its “x” or “y” values were not real numbers. The result will be a matrix where each row holds the curve number, data point number, “x” value, and “y” value for a rejected data point. See The Evaluates-To Operator, for a handy way to keep tabs on the current value of PlotRejects. See Other Operations on Variables, for the s R command which is another easy way to examine PlotRejects.

To clear the graphics display, type g c (calc-graph-clear). If the GNUPLOT output device is an X window, the window will go away. Effects on other kinds of output devices will vary. You don’t need to use g c if you don’t want to—if you give another g f or g p command later on, it will reuse the existing graphics window if there is one.


*** Three-Dimensional Graphics

The g F (calc-graph-fast-3d) command makes a three-dimensional graph. It works only if you have GNUPLOT 3.0 or later; with GNUPLOT 2.0, you will see a GNUPLOT error message if you try this command.

The g F command takes three values from the stack, called “x”, “y”, and “z”, respectively. As was the case for 2D graphs, there are several options for these values.

In the first case, “x” and “y” are each vectors (not necessarily of the same length); either or both may instead be interval forms. The “z” value must be a matrix with the same number of rows as elements in “x”, and the same number of columns as elements in “y”. The result is a surface plot where ‘z_ij’ is the height of the point at coordinate ‘(x_i, y_j)’ on the surface. The 3D graph will be displayed from a certain default viewpoint; you can change this viewpoint by adding a ‘set view’ to the *Gnuplot Commands* buffer as described later. See the GNUPLOT documentation for a description of the ‘set view’ command.

Each point in the matrix will be displayed as a dot in the graph, and these points will be connected by a grid of lines (isolines).

In the second case, “x”, “y”, and “z” are all vectors of equal length. The resulting graph displays a 3D line instead of a surface, where the coordinates of points along the line are successive triplets of values from the input vectors.

In the third case, “x” and “y” are vectors or interval forms, and “z” is any formula involving two variables (not counting variables with assigned values). These variables are sorted into alphabetical order; the first takes on values from “x” and the second takes on values from “y” to form a matrix of results that are graphed as a 3D surface.

If the “z” formula evaluates to a call to the fictitious function ‘xyz(x, y, z)’, then the result is a “parametric surface.” In this case, the axes of the graph are taken from the x and y values in these calls, and the “x” and “y” values from the input vectors or intervals are used only to specify the range of inputs to the formula. For example, plotting ‘[0..360], [0..180], xyz(sin(x)*sin(y), cos(x)*sin(y), cos(y))’ will draw a sphere. (Since the default resolution for 3D plots is 5 steps in each of “x” and “y”, this will draw a very crude sphere. You could use the g N command, described below, to increase this resolution, or specify the “x” and “y” values as vectors with more than 5 elements.

It is also possible to have a function in a regular g f plot evaluate to an xyz call. Since g f plots a line, not a surface, the result will be a 3D parametric line. For example, ‘[[0..720], xyz(sin(x), cos(x), x)]’ will plot two turns of a helix (a three-dimensional spiral).

As for g f, each of “x”, “y”, and “z” may instead be variables containing the relevant data.


*** Managing Curves

The g f command is really shorthand for the following commands: C-u g d g a g p. Likewise, g F is shorthand for C-u g d g A g p. You can gain more control over your graph by using these commands directly.

The g a (calc-graph-add) command adds the “curve” represented by the two values on the top of the stack to the current graph. You can have any number of curves in the same graph. When you give the g p command, all the curves will be drawn superimposed on the same axes.

The g a command (and many others that affect the current graph) will cause a special buffer, *Gnuplot Commands*, to be displayed in another window. This buffer is a template of the commands that will be sent to GNUPLOT when it is time to draw the graph. The first g a command adds a plot command to this buffer. Succeeding g a commands add extra curves onto that plot command. Other graph-related commands put other GNUPLOT commands into this buffer. In normal usage you never need to work with this buffer directly, but you can if you wish. The only constraint is that there must be only one plot command, and it must be the last command in the buffer. If you want to save and later restore a complete graph configuration, you can use regular Emacs commands to save and restore the contents of the *Gnuplot Commands* buffer.

If the values on the stack are not variable names, g a will invent variable names for them (of the form ‘PlotDatan’) and store the values in those variables. The “x” and “y” variables are what go into the plot command in the template. If you add a curve that uses a certain variable and then later change that variable, you can replot the graph without having to delete and re-add the curve. That’s because the variable name, not the vector, interval or formula itself, is what was added by g a.

A numeric prefix argument on g a or g f changes the way stack entries are interpreted as curves. With a positive prefix argument ‘n’, the top ‘n’ stack entries are “y” values for ‘n’ different curves which share a common “x” value in the ‘n+1’st stack entry. (Thus g a with no prefix argument is equivalent to C-u 1 g a.)

A prefix of zero or plain C-u means to take two stack entries, “x” and “y” as usual, but to interpret “y” as a vector of “y” values for several curves that share a common “x”.

A negative prefix argument tells Calc to read ‘n’ vectors from the stack; each vector ‘[x, y]’ describes an independent curve. This is the only form of g a that creates several curves at once that don’t have common “x” values. (Of course, the range of “x” values covered by all the curves ought to be roughly the same if they are to look nice on the same graph.)

For example, to plot ‘sin(n x)’ for integers ‘n’ from 1 to 5, you could use v x to create a vector of integers (‘n’), then V M ' or V M $ to map ‘sin(n x)’ across this vector. The resulting vector of formulas is suitable for use as the “y” argument to a C-u g a or C-u g f command.

The g A (calc-graph-add-3d) command adds a 3D curve to the graph. It is not valid to intermix 2D and 3D curves in a single graph. This command takes three arguments, “x”, “y”, and “z”, from the stack. With a positive prefix ‘n’, it takes ‘n+2’ arguments (common “x” and “y”, plus ‘n’ separate “z”s). With a zero prefix, it takes three stack entries but the “z” entry is a vector of curve values. With a negative prefix ‘-n’, it takes ‘n’ vectors of the form ‘[x, y, z]’. The g A command works by adding a splot (surface-plot) command to the *Gnuplot Commands* buffer.

(Although g a adds a 2D plot command to the *Gnuplot Commands* buffer, Calc changes this to splot before sending it to GNUPLOT if it notices that the data points are evaluating to xyz calls. It will not work to mix 2D and 3D g a curves in a single graph, although Calc does not currently check for this.)

The g d (calc-graph-delete) command deletes the most recently added curve from the graph. It has no effect if there are no curves in the graph. With a numeric prefix argument of any kind, it deletes all of the curves from the graph.

The g H (calc-graph-hide) command “hides” or “unhides” the most recently added curve. A hidden curve will not appear in the actual plot, but information about it such as its name and line and point styles will be retained.

The g j (calc-graph-juggle) command moves the curve at the end of the list (the “most recently added curve”) to the front of the list. The next-most-recent curve is thus exposed for g d or similar commands to use. With g j you can work with any curve in the graph even though curve-related commands only affect the last curve in the list.

The g p (calc-graph-plot) command uses GNUPLOT to draw the graph described in the *Gnuplot Commands* buffer. Any GNUPLOT parameters which are not defined by commands in this buffer are reset to their default values. The variables named in the plot command are written to a temporary data file and the variable names are then replaced by the file name in the template. The resulting plotting commands are fed to the GNUPLOT program. See the documentation for the GNUPLOT program for more specific information. All temporary files are removed when Emacs or GNUPLOT exits.

If you give a formula for “y”, Calc will remember all the values that it calculates for the formula so that later plots can reuse these values. Calc throws out these saved values when you change any circumstances that may affect the data, such as switching from Degrees to Radians mode, or changing the value of a parameter in the formula. You can force Calc to recompute the data from scratch by giving a negative numeric prefix argument to g p.

Calc uses a fairly rough step size when graphing formulas over intervals. This is to ensure quick response. You can “refine” a plot by giving a positive numeric prefix argument to g p. Calc goes through the data points it has computed and saved from previous plots of the function, and computes and inserts a new data point midway between each of the existing points. You can refine a plot any number of times, but beware that the amount of calculation involved doubles each time.

Calc does not remember computed values for 3D graphs. This means the numerix prefix argument, if any, to g p is effectively ignored if the current graph is three-dimensional.

The g P (calc-graph-print) command is like g p, except that it sends the output to a printer instead of to the screen. More precisely, g p looks for ‘set terminal’ or ‘set output’ commands in the *Gnuplot Commands* buffer; lacking these it uses the default settings. However, g P ignores ‘set terminal’ and ‘set output’ commands and uses a different set of default values. All of these values are controlled by the g D and g O commands discussed below. Provided everything is set up properly, g p will plot to the screen unless you have specified otherwise and g P will always plot to the printer.


*** Graphics Options

The g g (calc-graph-grid) command turns the “grid” on and off. It is off by default; tick marks appear only at the edges of the graph. With the grid turned on, dotted lines appear across the graph at each tick mark. Note that this command only changes the setting in *Gnuplot Commands*; to see the effects of the change you must give another g p command.

The g b (calc-graph-border) command turns the border (the box that surrounds the graph) on and off. It is on by default. This command will only work with GNUPLOT 3.0 and later versions.

The g k (calc-graph-key) command turns the “key” on and off. The key is a chart in the corner of the graph that shows the correspondence between curves and line styles. It is off by default, and is only really useful if you have several curves on the same graph.

The g N (calc-graph-num-points) command allows you to select the number of data points in the graph. This only affects curves where neither “x” nor “y” is specified as a vector. Enter a blank line to revert to the default value (initially 15). With no prefix argument, this command affects only the current graph. With a positive prefix argument this command changes or, if you enter a blank line, displays the default number of points used for all graphs created by g a that don’t specify the resolution explicitly. With a negative prefix argument, this command changes or displays the default value (initially 5) used for 3D graphs created by g A. Note that a 3D setting of 5 means that a total of ‘5^2 = 25’ points will be computed for the surface.

Data values in the graph of a function are normally computed to a precision of five digits, regardless of the current precision at the time. This is usually more than adequate, but there are cases where it will not be. For example, plotting ‘1 + x’ with ‘x’ in the interval ‘[0 .. 1e-6]’ will round all the data points down to 1.0! Putting the command ‘set precision n’ in the *Gnuplot Commands* buffer will cause the data to be computed at precision n instead of 5. Since this is such a rare case, there is no keystroke-based command to set the precision.

The g h (calc-graph-header) command sets the title for the graph. This will show up centered above the graph. The default title is blank (no title).

The g n (calc-graph-name) command sets the title of an individual curve. Like the other curve-manipulating commands, it affects the most recently added curve, i.e., the last curve on the list in the *Gnuplot Commands* buffer. To set the title of the other curves you must first juggle them to the end of the list with g j, or edit the *Gnuplot Commands* buffer by hand. Curve titles appear in the key; if the key is turned off they are not used.

The g t (calc-graph-title-x) and g T (calc-graph-title-y) commands set the titles on the “x” and “y” axes, respectively. These titles appear next to the tick marks on the left and bottom edges of the graph, respectively. Calc does not have commands to control the tick marks themselves, but you can edit them into the *Gnuplot Commands* buffer if you wish. See the GNUPLOT documentation for details.

The g r (calc-graph-range-x) and g R (calc-graph-range-y) commands set the range of values on the “x” and “y” axes, respectively. You are prompted to enter a suitable range. This should be either a pair of numbers of the form, ‘min:max’, or a blank line to revert to the default behavior of setting the range based on the range of values in the data, or ‘$’ to take the range from the top of the stack. Ranges on the stack can be represented as either interval forms or vectors: ‘[min .. max]’ or ‘[min, max]’.

The g l (calc-graph-log-x) and g L (calc-graph-log-y) commands allow you to set either or both of the axes of the graph to be logarithmic instead of linear.

For 3D plots, g C-t, g C-r, and g C-l (those are letters with the Control key held down) are the corresponding commands for the “z” axis.

The g z (calc-graph-zero-x) and g Z (calc-graph-zero-y) commands control whether a dotted line is drawn to indicate the “x” and/or “y” zero axes. (These are the same dotted lines that would be drawn there anyway if you used g g to turn the “grid” feature on.) Zero-axis lines are on by default, and may be turned off only in GNUPLOT 3.0 and later versions. They are not available for 3D plots.

The g s (calc-graph-line-style) command turns the connecting lines on or off for the most recently added curve, and optionally selects the style of lines to be used for that curve. Plain g s simply toggles the lines on and off. With a numeric prefix argument, g s turns lines on and sets a particular line style. Line style numbers start at one and their meanings vary depending on the output device. GNUPLOT guarantees that there will be at least six different line styles available for any device.

The g S (calc-graph-point-style) command similarly turns the symbols at the data points on or off, or sets the point style. If you turn both lines and points off, the data points will show as tiny dots. If the “y” values being plotted contain error forms and the connecting lines are turned off, then this command will also turn the error bars on or off.

Another way to specify curve styles is with the LineStyles and PointStyles variables. These variables initially have no stored values, but if you store a vector of integers in one of these variables, the g a and g f commands will use those style numbers instead of the defaults for new curves that are added to the graph. An entry should be a positive integer for a specific style, or 0 to let the style be chosen automatically, or -1 to turn off lines or points altogether. If there are more curves than elements in the vector, the last few curves will continue to have the default styles. Of course, you can later use g s and g S to change any of these styles.

For example, '[2 -1 3] RET s t LineStyles causes the first curve to have lines in style number 2, the second curve to have no connecting lines, and the third curve to have lines in style 3. Point styles will still be assigned automatically, but you could store another vector in PointStyles to define them, too.


*** Graphical Devices

The g D (calc-graph-device) command sets the device name (or “terminal name” in GNUPLOT lingo) to be used by g p commands on this graph. It does not affect the permanent default device name. If you enter a blank name, the device name reverts to the default. Enter ‘?’ to see a list of supported devices.

With a positive numeric prefix argument, g D instead sets the default device name, used by all plots in the future which do not override it with a plain g D command. If you enter a blank line this command shows you the current default. The special name default signifies that Calc should choose x11 if the X window system is in use (as indicated by the presence of a DISPLAY environment variable), windows on MS-Windows, or otherwise dumb under GNUPLOT 3.0 and later, or postscript under GNUPLOT 2.0. This is the initial default value.

The dumb device is an interface to “dumb terminals,” i.e., terminals with no special graphics facilities. It writes a crude picture of the graph composed of characters like - and | to a buffer called *Gnuplot Trail*, which Calc then displays. The graph is made the same size as the Emacs screen, which on most dumb terminals will be 80x24 characters. The graph is displayed in an Emacs “recursive edit”; type q or C-c C-c to exit the recursive edit and return to Calc. Note that the dumb device is present only in GNUPLOT 3.0 and later versions.

The word dumb may be followed by two numbers separated by spaces. These are the desired width and height of the graph in characters. Also, the device name big is like dumb but creates a graph four times the width and height of the Emacs screen. You will then have to scroll around to view the entire graph. In the *Gnuplot Trail* buffer, SPC, DEL, <, and > are defined to scroll by one screenful in each of the four directions.

With a negative numeric prefix argument, g D sets or displays the device name used by g P (calc-graph-print). This is initially postscript. If you don’t have a PostScript printer, you may decide once again to use dumb to create a plot on any text-only printer.

The g O (calc-graph-output) command sets the name of the output file used by GNUPLOT. For some devices, notably x11 and windows, there is no output file and this information is not used. Many other “devices” are really file formats like postscript; in these cases the output in the desired format goes into the file you name with g O. Type g O stdout RET to set GNUPLOT to write to its standard output stream, i.e., to *Gnuplot Trail*. This is the default setting.

Another special output name is tty, which means that GNUPLOT is going to write graphics commands directly to its standard output, which you wish Emacs to pass through to your terminal. Tektronix graphics terminals, among other devices, operate this way. Calc does this by telling GNUPLOT to write to a temporary file, then running a sub-shell executing the command ‘cat tempfile >/dev/tty’. On typical Unix systems, this will copy the temporary file directly to the terminal, bypassing Emacs entirely. You will have to type C-l to Emacs afterwards to refresh the screen.

Once again, g O with a positive or negative prefix argument sets the default or printer output file names, respectively. In each case you can specify auto, which causes Calc to invent a temporary file name for each g p (or g P) command. This temporary file will be deleted once it has been displayed or printed. If the output file name is not auto, the file is not automatically deleted.

The default and printer devices and output files can be saved permanently by the m m (calc-save-modes) command. The default number of data points (see g N) and the X geometry (see g X) are also saved. Other graph information is not saved; you can save a graph’s configuration simply by saving the contents of the *Gnuplot Commands* buffer.

You may wish to configure the default and printer devices and output files for the whole system. The relevant Lisp variables are calc-gnuplot-default-device and -output, and calc-gnuplot-print-device and -output. The output file names must be either strings as described above, or Lisp expressions which are evaluated on the fly to get the output file names.

Other important Lisp variables are calc-gnuplot-plot-command and calc-gnuplot-print-command, which give the system commands to display or print the output of GNUPLOT, respectively. These may be nil if no command is necessary, or strings which can include ‘%s’ to signify the name of the file to be displayed or printed. Or, these variables may contain Lisp expressions which are evaluated to display or print the output. These variables are customizable (see Customizing Calc).

The g x (calc-graph-display) command lets you specify on which X window system display your graphs should be drawn. Enter a blank line to see the current display name. This command has no effect unless the current device is x11.

The g X (calc-graph-geometry) command is a similar command for specifying the position and size of the X window. The normal value is default, which generally means your window manager will let you place the window interactively. Entering ‘800x500+0+0’ would create an 800-by-500 pixel window in the upper-left corner of the screen. This command has no effect if the current device is windows.

The buffer called *Gnuplot Trail* holds a transcript of the session with GNUPLOT. This shows the commands Calc has “typed” to GNUPLOT and the responses it has received. Calc tries to notice when an error message has appeared here and display the buffer for you when this happens. You can check this buffer yourself if you suspect something has gone wrong1.

The g C (calc-graph-command) command prompts you to enter any line of text, then simply sends that line to the current GNUPLOT process. The *Gnuplot Trail* buffer looks deceptively like a Shell buffer but you can’t type commands in it yourself. Instead, you must use g C for this purpose.

The g v (calc-graph-view-commands) and g V (calc-graph-view-trail) commands display the *Gnuplot Commands* and *Gnuplot Trail* buffers, respectively, in another window. This happens automatically when Calc thinks there is something you will want to see in either of these buffers. If you type g v or g V when the relevant buffer is already displayed, the buffer is hidden again. (Note that on MS-Windows, the *Gnuplot Trail* buffer will usually show nothing of interest, because GNUPLOT’s responses are not communicated back to Calc.)

One reason to use g v is to add your own commands to the *Gnuplot Commands* buffer. Press g v, then use C-x o to switch into that window. For example, GNUPLOT has ‘set label’ and ‘set arrow’ commands that allow you to annotate your plots. Since Calc doesn’t understand these commands, you have to add them to the *Gnuplot Commands* buffer yourself, then use g p to replot using these new commands. Note that your commands must appear before the plot command. To get help on any GNUPLOT feature, type, e.g., g C help set label. You may have to type g C RET a few times to clear the “press return for more” or “subtopic of …” requests. Note that Calc always sends commands (like ‘set nolabel’) to reset all plotting parameters to the defaults before each plot, so to delete a label all you need to do is delete the ‘set label’ line you added (or comment it out with ‘#’) and then replot with g p.

You can use g q (calc-graph-quit) to kill the GNUPLOT process that is running. The next graphing command you give will start a fresh GNUPLOT process. The word ‘Graph’ appears in the Calc window’s mode line whenever a GNUPLOT process is currently running. The GNUPLOT process is automatically killed when you exit Emacs if you haven’t killed it manually by then.

The g K (calc-graph-kill) command is like g q except that it also views the *Gnuplot Trail* buffer so that you can see the process being killed. This is better if you are killing GNUPLOT because you think it has gotten stuck.

Footnotes
(1)
On MS-Windows, due to the peculiarities of how the Windows version of GNUPLOT (called wgnuplot) works, the GNUPLOT responses are not communicated back to Calc. Instead, you need to look them up in the GNUPLOT command window that is displayed as in normal interactive usage of GNUPLOT.


** Kill and Yank Functions

The commands in this chapter move information between the Calculator and other Emacs editing buffers.

In many cases Embedded mode is an easier and more natural way to work with Calc from a regular editing buffer. See Embedded Mode.

*** Killing from the Stack

Kill commands are Emacs commands that insert text into the “kill ring,” from which it can later be “yanked” by a C-y command. Three common kill commands in normal Emacs are C-k, which kills one line, C-w, which kills the region between mark and point, and M-w, which puts the region into the kill ring without actually deleting it. All of these commands work in the Calculator, too, although in the Calculator they operate on whole stack entries, so they “round up” the specified region to encompass full lines. (To copy only parts of lines, the M-C-w command in the Calculator will copy the region to the kill ring without any “rounding up”, just like the M-w command in normal Emacs.) Also, M-k has been provided to complete the set; it puts the current line into the kill ring without deleting anything.

The kill commands are unusual in that they pay attention to the location of the cursor in the Calculator buffer. If the cursor is on or below the bottom line, the kill commands operate on the top of the stack. Otherwise, they operate on whatever stack element the cursor is on. The text is copied into the kill ring exactly as it appears on the screen, including line numbers if they are enabled.

A numeric prefix argument to C-k or M-k affects the number of lines killed. A positive argument kills the current line and ‘n-1’ lines below it. A negative argument kills the ‘-n’ lines above the current line. Again this mirrors the behavior of the standard Emacs C-k command. Although a whole line is always deleted, C-k with no argument copies only the number itself into the kill ring, whereas C-k with a prefix argument of 1 copies the number with its trailing newline.

You can customize calc-kill-line-numbering to nil to exclude line numbering from kills and copies made by calc-kill and calc-copy-as-kill. This option does not affect calc kill and copy commands which operate on the region, as that would not make sense.


*** Yanking into the Stack

The C-y command yanks the most recently killed text back into the Calculator. It pushes this value onto the top of the stack regardless of the cursor position. In general it re-parses the killed text as a number or formula (or a list of these separated by commas or newlines). However if the thing being yanked is something that was just killed from the Calculator itself, its full internal structure is yanked. For example, if you have set the floating-point display mode to show only four significant digits, then killing and re-yanking 3.14159 (which displays as 3.142) will yank the full 3.14159, even though yanking it into any other buffer would yank the number in its displayed form, 3.142. (Since the default display modes show all objects to their full precision, this feature normally makes no difference.)

The C-y command can be given a prefix, which will interpret the text being yanked with a different radix. If the text being yanked can be interpreted as a binary, octal, hexadecimal, or decimal number, then a prefix of 2, 8, 6 or 0 will have Calc interpret the yanked text as a number in the appropriate base. For example, if ‘111’ has just been killed and is yanked into Calc with a command of C-2 C-y, then the number ‘7’ will be put on the stack. If you use the plain prefix C-u, then you will be prompted for a base to use, which can be any integer from 2 to 36. If Calc doesn’t allow the text being yanked to be read in a different base (such as if the text is an algebraic expression), then the prefix will have no effect.


*** Saving into Registers

An alternative to killing and yanking stack entries is using registers in Calc. Saving stack entries in registers is like saving text in normal Emacs registers; although, like Calc’s kill commands, register commands always operate on whole stack entries.

Registers in Calc are places to store stack entries for later use; each register is indexed by a single character. To store the current region (rounded up, of course, to include full stack entries) into a register, use the command r s (calc-copy-to-register). You will then be prompted for a register to use, the next character you type will be the index for the register. To store the region in register r, the full command will be r s r. With an argument, C-u r s r, the region being copied to the register will be deleted from the Calc buffer.

It is possible to add additional stack entries to a register. The command M-x calc-append-to-register will prompt for a register, then add the stack entries in the region to the end of the register contents. The command M-x calc-prepend-to-register will similarly prompt for a register and add the stack entries in the region to the beginning of the register contents. Both commands take C-u arguments, which will cause the region to be deleted after being added to the register.


*** Inserting from Registers

The command r i (calc-insert-register) will prompt for a register, then insert the contents of that register into the Calculator. If the contents of the register were placed there from within Calc, then the full internal structure of the contents will be inserted into the Calculator, otherwise whatever text is in the register is reparsed and then inserted into the Calculator.


*** Grabbing from Other Buffers

The C-x * g (calc-grab-region) command takes the text between point and mark in the current buffer and attempts to parse it as a vector of values. Basically, it wraps the text in vector brackets ‘[ ]’ unless the text already is enclosed in vector brackets, then reads the text as if it were an algebraic entry. The contents of the vector may be numbers, formulas, or any other Calc objects. If the C-x * g command works successfully, it does an automatic C-x * c to enter the Calculator buffer.

A numeric prefix argument grabs the specified number of lines around point, ignoring the mark. A positive prefix grabs from point to the ‘n’th following newline (so that M-1 C-x * g grabs from point to the end of the current line); a negative prefix grabs from point back to the ‘n+1’st preceding newline. In these cases the text that is grabbed is exactly the same as the text that C-k would delete given that prefix argument.

A prefix of zero grabs the current line; point may be anywhere on the line.

A plain C-u prefix interprets the region between point and mark as a single number or formula rather than a vector. For example, C-x * g on the text ‘2 a b’ produces the vector of three values ‘[2, a, b]’, but C-u C-x * g on the same region reads a formula which is a product of three things: ‘2 a b’. (The text ‘a + b’, on the other hand, will be grabbed as a vector of one element by plain C-x * g because the interpretation ‘[a, +, b]’ would be a syntax error.)

If a different language has been specified (see Language Modes), the grabbed text will be interpreted according to that language.

The C-x * r (calc-grab-rectangle) command takes the text between point and mark and attempts to parse it as a matrix. If point and mark are both in the leftmost column, the lines in between are parsed in their entirety. Otherwise, point and mark define the corners of a rectangle whose contents are parsed.

Each line of the grabbed area becomes a row of the matrix. The result will actually be a vector of vectors, which Calc will treat as a matrix only if every row contains the same number of values.

If a line contains a portion surrounded by square brackets (or curly braces), that portion is interpreted as a vector which becomes a row of the matrix. Any text surrounding the bracketed portion on the line is ignored.

Otherwise, the entire line is interpreted as a row vector as if it were surrounded by square brackets. Leading line numbers (in the format used in the Calc stack buffer) are ignored. If you wish to force this interpretation (even if the line contains bracketed portions), give a negative numeric prefix argument to the C-x * r command.

If you give a numeric prefix argument of zero or plain C-u, each line is instead interpreted as a single formula which is converted into a one-element vector. Thus the result of C-u C-x * r will be a one-column matrix. For example, suppose one line of the data is the expression ‘2 a’. A plain C-x * r will interpret this as ‘[2 a]’, which in turn is read as a two-element vector that forms one row of the matrix. But a C-u C-x * r will interpret this row as ‘[2*a]’.

If you give a positive numeric prefix argument n, then each line will be split up into columns of width n; each column is parsed separately as a matrix element. If a line contained ‘2 +/- 3 4 +/- 5’, then grabbing with a prefix argument of 8 would correctly split the line into two error forms.

See Vector/Matrix Functions, to see how to pull the matrix apart into its constituent rows and columns. (If it is a 1x1 matrix, just hit v u (calc-unpack) twice.)

The C-x * : (calc-grab-sum-down) command is a handy way to grab a rectangle of data and sum its columns. It is equivalent to typing C-x * r, followed by V R : + (the vector reduction command that sums the columns of a matrix; see Reducing). The result of the command will be a vector of numbers, one for each column in the input data. The C-x * _ (calc-grab-sum-across) command similarly grabs a rectangle and sums its rows by executing V R _ +.

As well as being more convenient, C-x * : and C-x * _ are also much faster because they don’t actually place the grabbed vector on the stack. In a C-x * r V R : + sequence, formatting the vector for display on the stack takes a large fraction of the total time (unless you have planned ahead and used v . and t . modes).

For example, suppose we have a column of numbers in a file which we wish to sum. Go to one corner of the column and press C-@ to set the mark; go to the other corner and type C-x * :. Since there is only one column, the result will be a vector of one number, the sum. (You can type v u to unpack this vector into a plain number if you want to do further arithmetic with it.)

To compute the product of the column of numbers, we would have to do it “by hand” since there’s no special grab-and-multiply command. Use C-x * r to grab the column of numbers into the calculator in the form of a column matrix. The statistics command u * is a handy way to find the product of a vector or matrix of numbers. See Statistical Operations on Vectors. Another approach would be to use an explicit column reduction command, V R : *.


*** Yanking into Other Buffers

The plain y (calc-copy-to-buffer) command inserts the number at the top of the stack into the most recently used normal editing buffer. (More specifically, this is the most recently used buffer which is displayed in a window and whose name does not begin with ‘*’. If there is no such buffer, this is the most recently used buffer except for Calculator and Calc Trail buffers.) The number is inserted exactly as it appears and without a newline. (If line-numbering is enabled, the line number is normally not included.) The number is not removed from the stack.

With a prefix argument, y inserts several numbers, one per line. A positive argument inserts the specified number of values from the top of the stack. A negative argument inserts the ‘n’th value from the top of the stack. An argument of zero inserts the entire stack. Note that y with an argument of 1 is slightly different from y with no argument; the former always copies full lines, whereas the latter strips off the trailing newline.

With a lone C-u as a prefix argument, y replaces the region in the other buffer with the yanked text, then quits the Calculator, leaving you in that buffer. A typical use would be to use C-x * g to read a region of data into the Calculator, operate on the data to produce a new matrix, then type C-u y to replace the original data with the new data. One might wish to alter the matrix display style (see Vector and Matrix Display Formats) or change the current display language (see Language Modes) before doing this. Also, note that this command replaces a linear region of text (as grabbed by C-x * g), not a rectangle (as grabbed by C-x * r).

If the editing buffer is in overwrite (as opposed to insert) mode, and the C-u prefix was not used, then the yanked number will overwrite the characters following point rather than being inserted before those characters. The usual conventions of overwrite mode are observed; for example, characters will be inserted at the end of a line rather than overflowing onto the next line. Yanking a multi-line object such as a matrix in overwrite mode overwrites the next n lines in the buffer, lengthening or shortening each line as necessary. Finally, if the thing being yanked is a simple integer or floating-point number (like ‘-1.2345e-3’) and the characters following point also make up such a number, then Calc will replace that number with the new number, lengthening or shortening as necessary. The concept of “overwrite mode” has thus been generalized from overwriting characters to overwriting one complete number with another.

The C-x * y key sequence is equivalent to y except that it can be typed anywhere, not just in Calc. This provides an easy way to guarantee that Calc knows which editing buffer you want to use!


*** X Cut and Paste

If you are using Emacs with the X window system, there is an easier way to move small amounts of data into and out of the calculator: Use the mouse-oriented cut and paste facilities of X.

The default bindings for a three-button mouse cause the left button to move the Emacs cursor to the given place, the right button to select the text between the cursor and the clicked location, and the middle button to yank the selection into the buffer at the clicked location. So, if you have a Calc window and an editing window on your Emacs screen, you can use left-click/right-click to select a number, vector, or formula from one window, then middle-click to paste that value into the other window. When you paste text into the Calc window, Calc interprets it as an algebraic entry. It doesn’t matter where you click in the Calc window; the new value is always pushed onto the top of the stack.

The xterm program that is typically used for general-purpose shell windows in X interprets the mouse buttons in the same way. So you can use the mouse to move data between Calc and any other Unix program. One nice feature of xterm is that a double left-click selects one word, and a triple left-click selects a whole line. So you can usually transfer a single number into Calc just by double-clicking on it in the shell, then middle-clicking in the Calc window.


** Keypad Mode

The C-x * k (calc-keypad) command starts the Calculator and displays a picture of a calculator-style keypad. If you are using the X window system, you can click on any of the “keys” in the keypad using the left mouse button to operate the calculator. The original window remains the selected window; in Keypad mode you can type in your file while simultaneously performing calculations with the mouse.

If you have used C-x * b first, C-x * k instead invokes the full-calc-keypad command, which takes over the whole Emacs screen and displays the keypad, the Calc stack, and the Calc trail all at once. This mode would normally be used when running Calc standalone (see Standalone Operation).

If you aren’t using the X window system, you must switch into the *Calc Keypad* window, place the cursor on the desired “key,” and type SPC or RET. If you think this is easier than using Calc normally, go right ahead.

Calc commands are more or less the same in Keypad mode. Certain keypad keys differ slightly from the corresponding normal Calc keystrokes; all such deviations are described below.

Keypad mode includes many more commands than will fit on the keypad at once. Click the right mouse button [calc-keypad-menu] to switch to the next menu. The bottom five rows of the keypad stay the same; the top three rows change to a new set of commands. To return to earlier menus, click the middle mouse button [calc-keypad-menu-back] or simply advance through the menus until you wrap around. Typing TAB inside the keypad window is equivalent to clicking the right mouse button there.

You can always click the EXEC button and type any normal Calc key sequence. This is equivalent to switching into the Calc buffer, typing the keys, then switching back to your original buffer.

*** Main Menu

|----+----+--Calc---+----+----1
|FLR |CEIL|RND |TRNC|CLN2|FLT |
|----+----+----+----+----+----|
| LN |EXP |    |ABS |IDIV|MOD |
|----+----+----+----+----+----|
|SIN |COS |TAN |SQRT|y^x |1/x |
|----+----+----+----+----+----|
|  ENTER  |+/- |EEX |UNDO| <- |
|-----+---+-+--+--+-+---++----|
| INV |  7  |  8  |  9  |  /  |
|-----+-----+-----+-----+-----|
| HYP |  4  |  5  |  6  |  *  |
|-----+-----+-----+-----+-----|
|EXEC |  1  |  2  |  3  |  -  |
|-----+-----+-----+-----+-----|
| OFF |  0  |  .  | PI  |  +  |
|-----+-----+-----+-----+-----+
This is the menu that appears the first time you start Keypad mode. It will show up in a vertical window on the right side of your screen. Above this menu is the traditional Calc stack display. On a 24-line screen you will be able to see the top three stack entries.

The ten digit keys, decimal point, and EEX key are used for entering numbers in the obvious way. EEX begins entry of an exponent in scientific notation. Just as with regular Calc, the number is pushed onto the stack as soon as you press ENTER or any other function key.

The +/- key corresponds to normal Calc’s n key. During numeric entry it changes the sign of the number or of the exponent. At other times it changes the sign of the number on the top of the stack.

The INV and HYP keys modify other keys. As well as having the effects described elsewhere in this manual, Keypad mode defines several other “inverse” operations. These are described below and in the following sections.

The ENTER key finishes the current numeric entry, or otherwise duplicates the top entry on the stack.

The UNDO key undoes the most recent Calc operation. INV UNDO is the “redo” command, and HYP UNDO is “last arguments” (M-RET).

The <- key acts as a “backspace” during numeric entry. At other times it removes the top stack entry. INV <- clears the entire stack. HYP <- takes an integer from the stack, then removes that many additional stack elements.

The EXEC key prompts you to enter any keystroke sequence that would normally work in Calc mode. This can include a numeric prefix if you wish. It is also possible simply to switch into the Calc window and type commands in it; there is nothing “magic” about this window when Keypad mode is active.

The other keys in this display perform their obvious calculator functions. CLN2 rounds the top-of-stack by temporarily reducing the precision by 2 digits. FLT converts an integer or fraction on the top of the stack to floating-point.

The INV and HYP keys combined with several of these keys give you access to some common functions even if the appropriate menu is not displayed. Obviously you don’t need to learn these keys unless you find yourself wasting time switching among the menus.

INV +/-
is the same as 1/x.

INV +
is the same as SQRT.

INV -
is the same as CONJ.

INV *
is the same as y^x.

INV /
is the same as INV y^x (the ‘x’th root of ‘y’).

HYP/INV 1
are the same as SIN / INV SIN.

HYP/INV 2
are the same as COS / INV COS.

HYP/INV 3
are the same as TAN / INV TAN.

INV/HYP 4
are the same as LN / HYP LN.

INV/HYP 5
are the same as EXP / HYP EXP.

INV 6
is the same as ABS.

INV 7
is the same as RND (calc-round).

INV 8
is the same as CLN2.

INV 9
is the same as FLT (calc-float).

INV 0
is the same as IMAG.

INV .
is the same as PREC.

INV ENTER
is the same as SWAP.

HYP ENTER
is the same as RLL3.

INV HYP ENTER
is the same as OVER.

HYP +/-
packs the top two stack entries as an error form.

HYP EEX
packs the top two stack entries as a modulo form.

INV EEX
creates an interval form; this removes an integer which is one of 0 ‘[]’, 1 ‘[)’, 2 ‘(]’ or 3 ‘()’, followed by the two limits of the interval.

The OFF key turns Calc off; typing C-x * k or C-x * * again has the same effect. This is analogous to typing q or hitting C-x * c again in the normal calculator. If Calc is running standalone (the full-calc-keypad command appeared in the command line that started Emacs), then OFF is replaced with EXIT; clicking on this actually exits Emacs itself.


*** Functions Menu

|----+----+----+----+----+----2
|IGAM|BETA|IBET|ERF |BESJ|BESY|
|----+----+----+----+----+----|
|IMAG|CONJ| RE |ATN2|RAND|RAGN|
|----+----+----+----+----+----|
|GCD |FACT|DFCT|BNOM|PERM|NXTP|
|----+----+----+----+----+----|
This menu provides various operations from the f and k prefix keys.

IMAG multiplies the number on the stack by the imaginary number ‘i = (0, 1)’.

RE extracts the real part a complex number. INV RE extracts the imaginary part.

RAND takes a number from the top of the stack and computes a random number greater than or equal to zero but less than that number. (See Random Numbers.) RAGN is the “random again” command; it computes another random number using the same limit as last time.

INV GCD computes the LCM (least common multiple) function.

INV FACT is the gamma function. ‘gamma(x) = (x-1)!’.

PERM is the number-of-permutations function, which is on the H k c key in normal Calc.

NXTP finds the next prime after a number. INV NXTP finds the previous prime.


*** Binary Menu

|----+----+----+----+----+----3
|AND | OR |XOR |NOT |LSH |RSH |
|----+----+----+----+----+----|
|DEC |HEX |OCT |BIN |WSIZ|ARSH|
|----+----+----+----+----+----|
| A  | B  | C  | D  | E  | F  |
|----+----+----+----+----+----|
The keys in this menu perform operations on binary integers. Note that both logical and arithmetic right-shifts are provided. INV LSH rotates one bit to the left.

The “difference” function (normally on b d) is on INV AND. The “clip” function (normally on b c) is on INV NOT.

The DEC, HEX, OCT, and BIN keys select the current radix for display and entry of numbers: Decimal, hexadecimal, octal, or binary. The six letter keys A through F are used for entering hexadecimal numbers.

The WSIZ key displays the current word size for binary operations and allows you to enter a new word size. You can respond to the prompt using either the keyboard or the digits and ENTER from the keypad. The initial word size is 32 bits.


*** Vectors Menu

|----+----+----+----+----+----4
|SUM |PROD|MAX |MAP*|MAP^|MAP$|
|----+----+----+----+----+----|
|MINV|MDET|MTRN|IDNT|CRSS|"x" |
|----+----+----+----+----+----|
|PACK|UNPK|INDX|BLD |LEN |... |
|----+----+----+----+----+----|
The keys in this menu operate on vectors and matrices.

PACK removes an integer n from the top of the stack; the next n stack elements are removed and packed into a vector, which is replaced onto the stack. Thus the sequence 1 ENTER 3 ENTER 5 ENTER 3 PACK enters the vector ‘[1, 3, 5]’ onto the stack. To enter a matrix, build each row on the stack as a vector, then use a final PACK to collect the rows into a matrix.

UNPK unpacks the vector on the stack, pushing each of its components separately.

INDX removes an integer n, then builds a vector of integers from 1 to n. INV INDX takes three numbers from the stack: The vector size n, the starting number, and the increment. BLD takes an integer n and any value x and builds a vector of n copies of x.

IDNT removes an integer n, then builds an n-by-n identity matrix.

LEN replaces a vector by its length, an integer.

... turns on or off “abbreviated” display mode for large vectors.

MINV, MDET, MTRN, and CROSS are the matrix inverse, determinant, and transpose, and vector cross product.

SUM replaces a vector by the sum of its elements. It is equivalent to u + in normal Calc (see Statistical Operations on Vectors). PROD computes the product of the elements of a vector, and MAX computes the maximum of all the elements of a vector.

INV SUM computes the alternating sum of the first element minus the second, plus the third, minus the fourth, and so on. INV MAX computes the minimum of the vector elements.

HYP SUM computes the mean of the vector elements. HYP PROD computes the sample standard deviation. HYP MAX computes the median.

MAP* multiplies two vectors elementwise. It is equivalent to the V M * command. MAP^ computes powers elementwise. The arguments must be vectors of equal length, or one must be a vector and the other must be a plain number. For example, 2 MAP^ squares all the elements of a vector.

MAP$ maps the formula on the top of the stack across the vector in the second-to-top position. If the formula contains several variables, Calc takes that many vectors starting at the second-to-top position and matches them to the variables in alphabetical order. The result is a vector of the same size as the input vectors, whose elements are the formula evaluated with the variables set to the various sets of numbers in those vectors. For example, you could simulate MAP^ using MAP$ with the formula ‘x^y’.

The "x" key pushes the variable name ‘x’ onto the stack. To build the formula ‘x^2 + 6’, you would use the key sequence "x" 2 y^x 6 +. This formula would then be suitable for use with the MAP$ key described above. With INV, HYP, or INV and HYP, the "x" key pushes the variable names ‘y’, ‘z’, and ‘t’, respectively.


*** Modes Menu

|----+----+----+----+----+----5
|FLT |FIX |SCI |ENG |GRP |    |
|----+----+----+----+----+----|
|RAD |DEG |FRAC|POLR|SYMB|PREC|
|----+----+----+----+----+----|
|SWAP|RLL3|RLL4|OVER|STO |RCL |
|----+----+----+----+----+----|
The keys in this menu manipulate modes, variables, and the stack.

The FLT, FIX, SCI, and ENG keys select floating-point, fixed-point, scientific, or engineering notation. FIX displays two digits after the decimal by default; the others display full precision. With the INV prefix, these keys pop a number-of-digits argument from the stack.

The GRP key turns grouping of digits with commas on or off. INV GRP enables grouping to the right of the decimal point as well as to the left.

The RAD and DEG keys switch between radians and degrees for trigonometric functions.

The FRAC key turns Fraction mode on or off. This affects whether commands like / with integer arguments produce fractional or floating-point results.

The POLR key turns Polar mode on or off, determining whether polar or rectangular complex numbers are used by default.

The SYMB key turns Symbolic mode on or off, in which operations that would produce inexact floating-point results are left unevaluated as algebraic formulas.

The PREC key selects the current precision. Answer with the keyboard or with the keypad digit and ENTER keys.

The SWAP key exchanges the top two stack elements. The RLL3 key rotates the top three stack elements upwards. The RLL4 key rotates the top four stack elements upwards. The OVER key duplicates the second-to-top stack element.

The STO and RCL keys are analogous to s t and s r in regular Calc. See Storing and Recalling. Click the STO or RCL key, then one of the ten digits. (Named variables are not available in Keypad mode.) You can also use, for example, STO + 3 to add to register 3.


** Embedded Mode

Embedded mode in Calc provides an alternative to copying numbers and formulas back and forth between editing buffers and the Calc stack. In Embedded mode, your editing buffer becomes temporarily linked to the stack and this copying is taken care of automatically.

*** Basic Embedded Mode

To enter Embedded mode, position the Emacs point (cursor) on a formula in any buffer and press C-x * e (calc-embedded). Note that C-x * e is not to be used in the Calc stack buffer like most Calc commands, but rather in regular editing buffers that are visiting your own files.

Calc will try to guess an appropriate language based on the major mode of the editing buffer. (See Language Modes.) If the current buffer is in latex-mode, for example, Calc will set its language to LaTeX. Similarly, Calc will use TeX language for tex-mode, plain-tex-mode and context-mode, C language for c-mode and c++-mode, FORTRAN language for fortran-mode and f90-mode, Pascal for pascal-mode, and eqn for nroff-mode (see Customizing Calc). These can be overridden with Calc’s mode changing commands (see Mode Settings in Embedded Mode). If no suitable language is available, Calc will continue with its current language.

Calc normally scans backward and forward in the buffer for the nearest opening and closing formula delimiters. The simplest delimiters are blank lines. Other delimiters that Embedded mode understands are:

The TeX and LaTeX math delimiters ‘$ $’, ‘$$ $$’, ‘\[ \]’, and ‘\( \)’;
Lines beginning with ‘\begin’ and ‘\end’ (except matrix delimiters);
Lines beginning with ‘@’ (Texinfo delimiters).
Lines beginning with ‘.EQ’ and ‘.EN’ (eqn delimiters);
Lines containing a single ‘%’ or ‘.\"’ symbol and nothing else.
See Customizing Embedded Mode, to see how to make Calc recognize your own favorite delimiters. Delimiters like ‘$ $’ can appear on their own separate lines or in-line with the formula.

If you give a positive or negative numeric prefix argument, Calc instead uses the current point as one end of the formula, and includes that many lines forward or backward (respectively, including the current line). Explicit delimiters are not necessary in this case.

With a prefix argument of zero, Calc uses the current region (delimited by point and mark) instead of formula delimiters. With a prefix argument of C-u only, Calc uses the current line as the formula.

The C-x * w (calc-embedded-word) command will start Embedded mode on the current “word”; in this case Calc will scan for the first non-numeric character (i.e., the first character that is not a digit, sign, decimal point, or upper- or lower-case ‘e’) forward and backward to delimit the formula.

When you enable Embedded mode for a formula, Calc reads the text between the delimiters and tries to interpret it as a Calc formula. Calc can generally identify TeX formulas and Big-style formulas even if the language mode is wrong. If Calc can’t make sense of the formula, it beeps and refuses to enter Embedded mode. But if the current language is wrong, Calc can sometimes parse the formula successfully (but incorrectly); for example, the C expression ‘atan(a[1])’ can be parsed in Normal language mode, but the atan won’t correspond to the built-in arctan function, and the ‘a[1]’ will be interpreted as ‘a’ times the vector ‘[1]’!

If you press C-x * e or C-x * w to activate an embedded formula which is blank, say with the cursor on the space between the two delimiters ‘$ $’, Calc will immediately prompt for an algebraic entry.

Only one formula in one buffer can be enabled at a time. If you move to another area of the current buffer and give Calc commands, Calc turns Embedded mode off for the old formula and then tries to restart Embedded mode at the new position. Other buffers are not affected by Embedded mode.

When Embedded mode begins, Calc pushes the current formula onto the stack. No Calc stack window is created; however, Calc copies the top-of-stack position into the original buffer at all times. You can create a Calc window by hand with C-x * o if you find you need to see the entire stack.

For example, typing C-x * e while somewhere in the formula ‘n>2’ in the following line enables Embedded mode on that inequality:

We define $F_n = F_(n-1)+F_(n-2)$ for all $n>2$.
The formula ‘n>2’ will be pushed onto the Calc stack, and the top of stack will be copied back into the editing buffer. This means that spaces will appear around the ‘>’ symbol to match Calc’s usual display style:

We define $F_n = F_(n-1)+F_(n-2)$ for all $n > 2$.
No spaces have appeared around the ‘+’ sign because it’s in a different formula, one which we have not yet touched with Embedded mode.

Now that Embedded mode is enabled, keys you type in this buffer are interpreted as Calc commands. At this point we might use the “commute” command j C to reverse the inequality. This is a selection-based command for which we first need to move the cursor onto the operator (‘>’ in this case) that needs to be commuted.

We define $F_n = F_(n-1)+F_(n-2)$ for all $2 < n$.
The C-x * o command is a useful way to open a Calc window without actually selecting that window. Giving this command verifies that ‘2 < n’ is also on the Calc stack. Typing 17 RET would produce:

We define $F_n = F_(n-1)+F_(n-2)$ for all $17$.
with ‘2 < n’ and ‘17’ on the stack; typing TAB at this point will exchange the two stack values and restore ‘2 < n’ to the embedded formula. Even though you can’t normally see the stack in Embedded mode, it is still there and it still operates in the same way. But, as with old-fashioned RPN calculators, you can only see the value at the top of the stack at any given time (unless you use C-x * o).

Typing C-x * e again turns Embedded mode off. The Calc window reveals that the formula ‘2 < n’ is automatically removed from the stack, but the ‘17’ is not. Entering Embedded mode always pushes one thing onto the stack, and leaving Embedded mode always removes one thing. Anything else that happens on the stack is entirely your business as far as Embedded mode is concerned.

If you press C-x * e in the wrong place by accident, it is possible that Calc will be able to parse the nearby text as a formula and will mangle that text in an attempt to redisplay it “properly” in the current language mode. If this happens, press C-x * e again to exit Embedded mode, then give the regular Emacs “undo” command (C-_ or C-x u) to put the text back the way it was before Calc edited it. Note that Calc’s own Undo command (typed before you turn Embedded mode back off) will not do you any good, because as far as Calc is concerned you haven’t done anything with this formula yet.


*** More About Embedded Mode

When Embedded mode “activates” a formula, i.e., when it examines the formula for the first time since the buffer was created or loaded, Calc tries to sense the language in which the formula was written. If the formula contains any LaTeX-like ‘\’ sequences, it is parsed (i.e., read) in LaTeX mode. If the formula appears to be written in multi-line Big mode, it is parsed in Big mode. Otherwise, it is parsed according to the current language mode.

Note that Calc does not change the current language mode according the formula it reads in. Even though it can read a LaTeX formula when not in LaTeX mode, it will immediately rewrite this formula using whatever language mode is in effect.

Calc’s parser is unable to read certain kinds of formulas. For example, with v ] (calc-matrix-brackets) you can specify matrix display styles which the parser is unable to recognize as matrices. The d p (calc-show-plain) command turns on a mode in which a “plain” version of a formula is placed in front of the fully-formatted version. When Calc reads a formula that has such a plain version in front, it reads the plain version and ignores the formatted version.

Plain formulas are preceded and followed by ‘%%%’ signs by default. This notation has the advantage that the ‘%’ character begins a comment in TeX and LaTeX, so if your formula is embedded in a TeX or LaTeX document its plain version will be invisible in the final printed copy. Certain major modes have different delimiters to ensure that the “plain” version will be in a comment for those modes, also. See Customizing Embedded Mode to see how to change the “plain” formula delimiters.

There are several notations which Calc’s parser for “big” formatted formulas can’t yet recognize. In particular, it can’t read the large symbols for sum, prod, and integ, and it can’t handle ‘=>’ with the righthand argument omitted. Also, Calc won’t recognize special formats you have defined with the Z C command (see User-Defined Compositions). In these cases it is important to use “plain” mode to make sure Calc will be able to read your formula later.

Another example where “plain” mode is important is if you have specified a float mode with few digits of precision. Normally any digits that are computed but not displayed will simply be lost when you save and re-load your embedded buffer, but “plain” mode allows you to make sure that the complete number is present in the file as well as the rounded-down number.

Embedded buffers remember active formulas for as long as they exist in Emacs memory. Suppose you have an embedded formula which is ‘pi’ to the normal 12 decimal places, and then type C-u 5 d n to display only five decimal places. If you then type d n, all 12 places reappear because the full number is still there on the Calc stack. More surprisingly, even if you exit Embedded mode and later re-enter it for that formula, typing d n will restore all 12 places because each buffer remembers all its active formulas. However, if you save the buffer in a file and reload it in a new Emacs session, all non-displayed digits will have been lost unless you used “plain” mode.

In some applications of Embedded mode, you will want to have a sequence of copies of a formula that show its evolution as you work on it. For example, you might want to have a sequence like this in your file (elaborating here on the example from the “Getting Started” chapter):

The derivative of

                              ln(ln(x))

is

                  (the derivative of ln(ln(x)))

whose value at x = 2 is

                            (the value)

and at x = 3 is

                            (the value)
The C-x * d (calc-embedded-duplicate) command is a handy way to make sequences like this. If you type C-x * d, the formula under the cursor (which may or may not have Embedded mode enabled for it at the time) is copied immediately below and Embedded mode is then enabled for that copy.

For this example, you would start with just

The derivative of

                              ln(ln(x))
and press C-x * d with the cursor on this formula. The result is

The derivative of

                              ln(ln(x))


                              ln(ln(x))
with the second copy of the formula enabled in Embedded mode. You can now press a d x RET to take the derivative, and C-x * d C-x * d to make two more copies of the derivative. To complete the computations, type 3 s l x RET to evaluate the last formula, then move up to the second-to-last formula and type 2 s l x RET.

Finally, you would want to press C-x * e to exit Embedded mode, then go up and insert the necessary text in between the various formulas and numbers.

The C-x * f (calc-embedded-new-formula) command creates a new embedded formula at the current point. It inserts some default delimiters, which are usually just blank lines, and then does an algebraic entry to get the formula (which is then enabled for Embedded mode). This is just shorthand for typing the delimiters yourself, positioning the cursor between the new delimiters, and pressing C-x * e. The key sequence C-x * ' is equivalent to C-x * f.

The C-x * n (calc-embedded-next) and C-x * p (calc-embedded-previous) commands move the cursor to the next or previous active embedded formula in the buffer. They can take positive or negative prefix arguments to move by several formulas. Note that these commands do not actually examine the text of the buffer looking for formulas; they only see formulas which have previously been activated in Embedded mode. In fact, C-x * n and C-x * p are a useful way to tell which embedded formulas are currently active. Also, note that these commands do not enable Embedded mode on the next or previous formula, they just move the cursor.

The C-x * ` (calc-embedded-edit) command edits the embedded formula at the current point as if by ` (calc-edit). Embedded mode does not have to be enabled for this to work. Press C-c C-c to finish the edit, or C-x k to cancel.


*** Assignments in Embedded Mode

The ‘:=’ (assignment) and ‘=>’ (“evaluates-to”) operators are especially useful in Embedded mode. They allow you to make a definition in one formula, then refer to that definition in other formulas embedded in the same buffer.

An embedded formula which is an assignment to a variable, as in

foo := 5
records ‘5’ as the stored value of foo for the purposes of Embedded mode operations in the current buffer. It does not actually store ‘5’ as the “global” value of foo, however. Regular Calc operations, and Embedded formulas in other buffers, will not see this assignment.

One way to use this assigned value is simply to create an Embedded formula elsewhere that refers to foo, and to press = in that formula. However, this permanently replaces the foo in the formula with its current value. More interesting is to use ‘=>’ elsewhere:

foo + 7 => 12
See The Evaluates-To Operator, for a general discussion of ‘=>’.

If you move back and change the assignment to foo, any ‘=>’ formulas which refer to it are automatically updated.

foo := 17

foo + 7 => 24
The obvious question then is, how can one easily change the assignment to foo? If you simply select the formula in Embedded mode and type 17, the assignment itself will be replaced by the 17. The effect on the other formula will be that the variable foo becomes unassigned:

17

foo + 7 => foo + 7
The right thing to do is first to use a selection command (j 2 will do the trick) to select the righthand side of the assignment. Then, 17 TAB DEL will swap the 17 into place (see Selecting Sub-Formulas, to see how this works).

The C-x * j (calc-embedded-select) command provides an easy way to operate on assignments. It is just like C-x * e, except that if the enabled formula is an assignment, it uses j 2 to select the righthand side. If the enabled formula is an evaluates-to, it uses j 1 to select the lefthand side. A formula can also be a combination of both:

bar := foo + 3 => 20
in which case C-x * j will select the middle part (‘foo + 3’).

The formula is automatically deselected when you leave Embedded mode.

Another way to change the assignment to foo would simply be to edit the number using regular Emacs editing rather than Embedded mode. Then, we have to find a way to get Embedded mode to notice the change. The C-x * u (calc-embedded-update-formula) command is a convenient way to do this.

foo := 6

foo + 7 => 13
Pressing C-x * u is much like pressing C-x * e = C-x * e, that is, temporarily enabling Embedded mode for the formula under the cursor and then evaluating it with =. But C-x * u does not actually use C-x * e, and in fact another formula somewhere else can be enabled in Embedded mode while you use C-x * u and that formula will not be disturbed.

With a numeric prefix argument, C-x * u updates all active ‘=>’ formulas in the buffer. Formulas which have not yet been activated in Embedded mode, and formulas which do not have ‘=>’ as their top-level operator, are not affected by this. (This is useful only if you have used m C; see below.)

With a plain C-u prefix, C-u C-x * u updates only in the region between mark and point rather than in the whole buffer.

C-x * u is also a handy way to activate a formula, such as an ‘=>’ formula that has freshly been typed in or loaded from a file.

The C-x * a (calc-embedded-activate) command scans through the current buffer and activates all embedded formulas that contain ‘:=’ or ‘=>’ symbols. This does not mean that Embedded mode is actually turned on, but only that the formulas’ positions are registered with Embedded mode so that the ‘=>’ values can be properly updated as assignments are changed.

It is a good idea to type C-x * a right after loading a file that uses embedded ‘=>’ operators. Emacs includes a nifty “buffer-local variables” feature that you can use to do this automatically. The idea is to place near the end of your file a few lines that look like this:

--- Local Variables: ---
--- eval:(calc-embedded-activate) ---
--- End: ---
where the leading and trailing ‘---’ can be replaced by any suitable strings (which must be the same on all three lines) or omitted altogether; in a TeX or LaTeX file, ‘%’ would be a good leading string and no trailing string would be necessary. In a C program, ‘/*’ and ‘*/’ would be good leading and trailing strings.

When Emacs loads a file into memory, it checks for a Local Variables section like this one at the end of the file. If it finds this section, it does the specified things (in this case, running C-x * a automatically) before editing of the file begins. The Local Variables section must be within 3000 characters of the end of the file for Emacs to find it, and it must be in the last page of the file if the file has any page separators. See Local Variables in Files in the Emacs manual.

Note that C-x * a does not update the formulas it finds. To do this, type, say, M-1 C-x * u after C-x * a. Generally this should not be a problem, though, because the formulas will have been up-to-date already when the file was saved.

Normally, C-x * a activates all the formulas it finds, but any previous active formulas remain active as well. With a positive numeric prefix argument, C-x * a first deactivates all current active formulas, then actives the ones it finds in its scan of the buffer. With a negative prefix argument, C-x * a simply deactivates all formulas.

Embedded mode has two symbols, ‘Active’ and ‘~Active’, which it puts next to the major mode name in a buffer’s mode line. It puts ‘Active’ if it has reason to believe that all formulas in the buffer are active, because you have typed C-x * a and Calc has not since had to deactivate any formulas (which can happen if Calc goes to update an ‘=>’ formula somewhere because a variable changed, and finds that the formula is no longer there due to some kind of editing outside of Embedded mode). Calc puts ‘~Active’ in the mode line if some, but probably not all, formulas in the buffer are active. This happens if you activate a few formulas one at a time but never use C-x * a, or if you used C-x * a but then Calc had to deactivate a formula because it lost track of it. If neither of these symbols appears in the mode line, no embedded formulas are active in the buffer (e.g., before Embedded mode has been used, or after a M-- C-x * a).

Embedded formulas can refer to assignments both before and after them in the buffer. If there are several assignments to a variable, the nearest preceding assignment is used if there is one, otherwise the following assignment is used.

x => 1

x := 1

x => 1

x := 2

x => 2
As well as simple variables, you can also assign to subscript expressions of the form ‘var_number’ (as in x_0), or ‘var_var’ (as in x_max). Assignments to other kinds of objects can be represented by Calc, but the automatic linkage between assignments and references works only for plain variables and these two kinds of subscript expressions.

If there are no assignments to a given variable, the global stored value for the variable is used (see Storing Variables), or, if no value is stored, the variable is left in symbolic form. Note that global stored values will be lost when the file is saved and loaded in a later Emacs session, unless you have used the s p (calc-permanent-variable) command to save them; see Other Operations on Variables.

The m C (calc-auto-recompute) command turns automatic recomputation of ‘=>’ forms on and off. If you turn automatic recomputation off, you will have to use C-x * u to update these formulas manually after an assignment has been changed. If you plan to change several assignments at once, it may be more efficient to type m C, change all the assignments, then use M-1 C-x * u to update the entire buffer afterwards. The m C command also controls ‘=>’ formulas on the stack; see The Evaluates-To Operator. When you turn automatic recomputation back on, the stack will be updated but the Embedded buffer will not; you must use C-x * u to update the buffer by hand.


*** Mode Settings in Embedded Mode

The mode settings can be changed while Calc is in embedded mode, but by default they will revert to their original values when embedded mode is ended. However, the modes saved when the mode-recording mode is Save (see below) and the modes in effect when the m e (calc-embedded-preserve-modes) command is given will be preserved when embedded mode is ended.

Embedded mode has a rather complicated mechanism for handling mode settings in Embedded formulas. It is possible to put annotations in the file that specify mode settings either global to the entire file or local to a particular formula or formulas. In the latter case, different modes can be specified for use when a formula is the enabled Embedded mode formula.

When you give any mode-setting command, like m f (for Fraction mode) or d s (for scientific notation), Embedded mode adds a line like the following one to the file just before the opening delimiter of the formula.

% [calc-mode: fractions: t]
% [calc-mode: float-format: (sci 0)]
When Calc interprets an embedded formula, it scans the text before the formula for mode-setting annotations like these and sets the Calc buffer to match these modes. Modes not explicitly described in the file are not changed. Calc scans all the way to the top of the file, or up to a line of the form

% [calc-defaults]
which you can insert at strategic places in the file if this backward scan is getting too slow, or just to provide a barrier between one “zone” of mode settings and another.

If the file contains several annotations for the same mode, the closest one before the formula is used. Annotations after the formula are never used (except for global annotations, described below).

The scan does not look for the leading ‘% ’, only for the square brackets and the text they enclose. In fact, the leading characters are different for different major modes. You can edit the mode annotations to a style that works better in context if you wish. See Customizing Embedded Mode, to see how to change the style that Calc uses when it generates the annotations. You can write mode annotations into the file yourself if you know the syntax; the easiest way to find the syntax for a given mode is to let Calc write the annotation for it once and see what it does.

If you give a mode-changing command for a mode that already has a suitable annotation just above the current formula, Calc will modify that annotation rather than generating a new, conflicting one.

Mode annotations have three parts, separated by colons. (Spaces after the colons are optional.) The first identifies the kind of mode setting, the second is a name for the mode itself, and the third is the value in the form of a Lisp symbol, number, or list. Annotations with unrecognizable text in the first or second parts are ignored. The third part is not checked to make sure the value is of a valid type or range; if you write an annotation by hand, be sure to give a proper value or results will be unpredictable. Mode-setting annotations are case-sensitive.

While Embedded mode is enabled, the word Local appears in the mode line. This is to show that mode setting commands generate annotations that are “local” to the current formula or set of formulas. The m R (calc-mode-record-mode) command causes Calc to generate different kinds of annotations. Pressing m R repeatedly cycles through the possible modes.

LocEdit and LocPerm modes generate annotations that look like this, respectively:

% [calc-edit-mode: float-format: (sci 0)]
% [calc-perm-mode: float-format: (sci 5)]
The first kind of annotation will be used only while a formula is enabled in Embedded mode. The second kind will be used only when the formula is not enabled. (Whether the formula is “active” or not, i.e., whether Calc has seen this formula yet, is not relevant here.)

Global mode generates an annotation like this at the end of the file:

% [calc-global-mode: fractions t]
Global mode annotations affect all formulas throughout the file, and may appear anywhere in the file. This allows you to tuck your mode annotations somewhere out of the way, say, on a new page of the file, as long as those mode settings are suitable for all formulas in the file.

Enabling a formula with C-x * e causes a fresh scan for local mode annotations; you will have to use this after adding annotations above a formula by hand to get the formula to notice them. Updating a formula with C-x * u will also re-scan the local modes, but global modes are only re-scanned by C-x * a.

Another way that modes can get out of date is if you add a local mode annotation to a formula that has another formula after it. In this example, we have used the d s command while the first of the two embedded formulas is active. But the second formula has not changed its style to match, even though by the rules of reading annotations the ‘(sci 0)’ applies to it, too.

% [calc-mode: float-format: (sci 0)]
1.23e2

456.
We would have to go down to the other formula and press C-x * u on it in order to get it to notice the new annotation.

Two more mode-recording modes selectable by m R are available which are also available outside of Embedded mode. (see General Mode Commands.) They are Save, in which mode settings are recorded permanently in your Calc init file (the file given by the variable calc-settings-file, typically ~/.emacs.d/calc.el) rather than by annotating the current document, and no-recording mode (where there is no symbol like Save or Local in the mode line), in which mode-changing commands do not leave any annotations at all.

When Embedded mode is not enabled, mode-recording modes except for Save have no effect.


*** Customizing Embedded Mode

You can modify Embedded mode’s behavior by setting various Lisp variables described here. These variables are customizable (see Customizing Calc), or you can use M-x set-variable to adjust a variable on the fly. (Another possibility would be to use a file-local variable annotation at the end of the file; see Local Variables in Files in the Emacs manual.) Many of the variables given mentioned here can be set to depend on the major mode of the editing buffer (see Customizing Calc).

The calc-embedded-open-formula variable holds a regular expression for the opening delimiter of a formula. See Regular Expression Search in the Emacs manual, to see how regular expressions work. Basically, a regular expression is a pattern that Calc can search for. A regular expression that considers blank lines, ‘$’, and ‘$$’ to be opening delimiters is "\\`\\|^\n\\|\\$\\$?". Just in case the meaning of this regular expression is not completely plain, let’s go through it in detail.

The surrounding ‘" "’ marks quote the text between them as a Lisp string. If you left them off, set-variable (for example) would try to read the regular expression as a Lisp program.

The most obvious property of this regular expression is that it contains indecently many backslashes. There are actually two levels of backslash usage going on here. First, when Lisp reads a quoted string, all pairs of characters beginning with a backslash are interpreted as special characters. Here, \n changes to a new-line character, and \\ changes to a single backslash. So the actual regular expression seen by Calc is ‘\`\|^ (newline) \|\$\$?’.

Regular expressions also consider pairs beginning with backslash to have special meanings. Sometimes the backslash is used to quote a character that otherwise would have a special meaning in a regular expression, like ‘$’, which normally means “end-of-line,” or ‘?’, which means that the preceding item is optional. So ‘\$\$?’ matches either one or two dollar signs.

The other codes in this regular expression are ‘^’, which matches “beginning-of-line,” ‘\|’, which means “or,” and ‘\`’, which matches “beginning-of-buffer.” So the whole pattern means that a formula begins at the beginning of the buffer, or on a newline that occurs at the beginning of a line (i.e., a blank line), or at one or two dollar signs.

The default value of calc-embedded-open-formula looks just like this example, with several more alternatives added on to recognize various other common kinds of delimiters.

By the way, the reason to use ‘^\n’ rather than ‘^$’ or ‘\n\n’, which also would appear to match blank lines, is that the former expression actually “consumes” only one newline character as part of the delimiter, whereas the latter expressions consume zero or two newlines, respectively. The former choice gives the most natural behavior when Calc must operate on a whole formula including its delimiters.

See the Emacs manual for complete details on regular expressions. But just for your convenience, here is a list of all characters which must be quoted with backslash (like ‘\$’) to avoid some special interpretation: ‘. * + ? [ ] ^ $ \’. (Note the backslash in this list; for example, to match ‘\[’ you must use "\\\\\\[". An exercise for the reader is to account for each of these six backslashes!)

The calc-embedded-close-formula variable holds a regular expression for the closing delimiter of a formula. A closing regular expression to match the above example would be "\\'\\|\n$\\|\\$\\$?". This is almost the same as the other one, except it now uses ‘\'’ (“end-of-buffer”) and ‘\n$’ (newline occurring at end of line, yet another way of describing a blank line that is more appropriate for this case).

The calc-embedded-word-regexp variable holds a regular expression used to define an expression to look for (a “word”) when you type C-x * w to enable Embedded mode.

The calc-embedded-open-plain variable is a string which begins a “plain” formula written in front of the formatted formula when d p mode is turned on. Note that this is an actual string, not a regular expression, because Calc must be able to write this string into a buffer as well as to recognize it. The default string is "%%% " (note the trailing space), but may be different for certain major modes.

The calc-embedded-close-plain variable is a string which ends a “plain” formula. The default is " %%%\n", but may be different for different major modes. Without the trailing newline here, the first line of a Big mode formula that followed might be shifted over with respect to the other lines.

The calc-embedded-open-new-formula variable is a string which is inserted at the front of a new formula when you type C-x * f. Its default value is "\n\n". If this string begins with a newline character and the C-x * f is typed at the beginning of a line, C-x * f will skip this first newline to avoid introducing unnecessary blank lines in the file.

The calc-embedded-close-new-formula variable is the corresponding string which is inserted at the end of a new formula. Its default value is also "\n\n". The final newline is omitted by C-x * f if typed at the end of a line. (It follows that if C-x * f is typed on a blank line, both a leading opening newline and a trailing closing newline are omitted.)

The calc-embedded-announce-formula variable is a regular expression which is sure to be followed by an embedded formula. The C-x * a command searches for this pattern as well as for ‘=>’ and ‘:=’ operators. Note that C-x * a will not activate just anything surrounded by formula delimiters; after all, blank lines are considered formula delimiters by default! But if your language includes a delimiter which can only occur actually in front of a formula, you can take advantage of it here. The default pattern is "%Embed\n\\(% .*\n\\)*", but may be different for different major modes. This pattern will check for ‘%Embed’ followed by any number of lines beginning with ‘%’ and a space. This last is important to make Calc consider mode annotations part of the pattern, so that the formula’s opening delimiter really is sure to follow the pattern.

The calc-embedded-open-mode variable is a string (not a regular expression) which should precede a mode annotation. Calc never scans for this string; Calc always looks for the annotation itself. But this is the string that is inserted before the opening bracket when Calc adds an annotation on its own. The default is "% ", but may be different for different major modes.

The calc-embedded-close-mode variable is a string which follows a mode annotation written by Calc. Its default value is simply a newline, "\n", but may be different for different major modes. If you change this, it is a good idea still to end with a newline so that mode annotations will appear on lines by themselves.


** Programming

There are several ways to “program” the Emacs Calculator, depending on the nature of the problem you need to solve.

Keyboard macros allow you to record a sequence of keystrokes and play them back at a later time. This is just the standard Emacs keyboard macro mechanism, dressed up with a few more features such as loops and conditionals.
Algebraic definitions allow you to use any formula to define a new function. This function can then be used in algebraic formulas or as an interactive command.
Rewrite rules are discussed in the section on algebra commands. See Rewrite Rules. If you put your rewrite rules in the variable EvalRules, they will be applied automatically to all Calc results in just the same way as an internal “rule” is applied to evaluate ‘sqrt(9)’ to 3 and so on. See Automatic Rewrites.
Lisp is the programming language that Calc (and most of Emacs) is written in. If the above techniques aren’t powerful enough, you can write Lisp functions to do anything that built-in Calc commands can do. Lisp code is also somewhat faster than keyboard macros or rewrite rules.
Programming features are available through the z and Z prefix keys. New commands that you define are two-key sequences beginning with z. Commands for managing these definitions use the shift-Z prefix. (The Z T (calc-timing) command is described elsewhere; see Troubleshooting Commands. The Z C (calc-user-define-composition) command is also described elsewhere; see User-Defined Compositions.)

*** Creating User Keys

Any Calculator command may be bound to a key using the Z D (calc-user-define) command. Actually, it is bound to a two-key sequence beginning with the lower-case z prefix.

The Z D command first prompts for the key to define. For example, press Z D a to define the new key sequence z a. You are then prompted for the name of the Calculator command that this key should run. For example, the calc-sincos command is not normally available on a key. Typing Z D s sincos RET programs the z s key sequence to run calc-sincos. This definition will remain in effect for the rest of this Emacs session, or until you redefine z s to be something else.

You can actually bind any Emacs command to a z key sequence by backspacing over the ‘calc-’ when you are prompted for the command name.

As with any other prefix key, you can type z ? to see a list of all the two-key sequences you have defined that start with z. Initially, no z sequences (except z ? itself) are defined.

User keys are typically letters, but may in fact be any key. (META-keys are not permitted, nor are a terminal’s special function keys which generate multi-character sequences when pressed.) You can define different commands on the shifted and unshifted versions of a letter if you wish.

The Z U (calc-user-undefine) command unbinds a user key. For example, the key sequence Z U s will undefine the sincos key we defined above.

The Z P (calc-user-define-permanent) command makes a key binding permanent so that it will remain in effect even in future Emacs sessions. (It does this by adding a suitable bit of Lisp code into your Calc init file; that is, the file given by the variable calc-settings-file, typically ~/.emacs.d/calc.el.) For example, Z P s would register our sincos command permanently. If you later wish to unregister this command you must edit your Calc init file by hand. (See General Mode Commands, for a way to tell Calc to use a different file for the Calc init file.)

The Z P command also saves the user definition, if any, for the command bound to the key. After Z F and Z C, a given user key could invoke a command, which in turn calls an algebraic function, which might have one or more special display formats. A single Z P command will save all of these definitions. To save an algebraic function, type ' (the apostrophe) when prompted for a key, and type the function name. To save a command without its key binding, type M-x and enter a function name. (The ‘calc-’ prefix will automatically be inserted for you.) (If the command you give implies a function, the function will be saved, and if the function has any display formats, those will be saved, but not the other way around: Saving a function will not save any commands or key bindings associated with the function.)

The Z E (calc-user-define-edit) command edits the definition of a user key. This works for keys that have been defined by either keyboard macros or formulas; further details are contained in the relevant following sections.


*** Programming with Keyboard Macros

The easiest way to “program” the Emacs Calculator is to use standard keyboard macros. Press C-x ( to begin recording a macro. From this point on, keystrokes you type will be saved away as well as performing their usual functions. Press C-x ) to end recording. Press shift-X (or the standard Emacs key sequence C-x e) to execute your keyboard macro by replaying the recorded keystrokes. See Keyboard Macros in the Emacs Manual, for further information.

When you use X to invoke a keyboard macro, the entire macro is treated as a single command by the undo and trail features. The stack display buffer is not updated during macro execution, but is instead fixed up once the macro completes. Thus, commands defined with keyboard macros are convenient and efficient. The C-x e command, on the other hand, invokes the keyboard macro with no special treatment: Each command in the macro will record its own undo information and trail entry, and update the stack buffer accordingly. If your macro uses features outside of Calc’s control to operate on the contents of the Calc stack buffer, or if it includes Undo, Redo, or last-arguments commands, you must use C-x e to make sure the buffer and undo list are up-to-date at all times. You could also consider using K (calc-keep-args) instead of M-RET (calc-last-args).

Calc extends the standard Emacs keyboard macros in several ways. Keyboard macros can be used to create user-defined commands. Keyboard macros can include conditional and iteration structures, somewhat analogous to those provided by a traditional programmable calculator.

**** Naming Keyboard Macros

Once you have defined a keyboard macro, you can bind it to a z key sequence with the Z K (calc-user-define-kbd-macro) command. This command prompts first for a key, then for a command name. For example, if you type C-x ( n TAB n TAB C-x ) you will define a keyboard macro which negates the top two numbers on the stack (TAB swaps the top two stack elements). Now you can type Z K n RET to define this keyboard macro onto the z n key sequence. The default command name (if you answer the second prompt with just the RET key as in this example) will be something like ‘calc-User-n’. The keyboard macro will now be available as both z n and M-x calc-User-n. You can backspace and enter a more descriptive command name if you wish.

Macros defined by Z K act like single commands; they are executed in the same way as by the X key. If you wish to define the macro as a standard no-frills Emacs macro (to be executed as if by C-x e), give a negative prefix argument to Z K.

Once you have bound your keyboard macro to a key, you can use Z P to register it permanently with Emacs. See Creating User Keys.

The Z E (calc-user-define-edit) command on a key that has been defined by a keyboard macro tries to use the edmacro package edit the macro. Type C-c C-c to finish editing and update the definition stored on the key, or, to cancel the edit, kill the buffer with C-x k. The special characters RET, LFD, TAB, SPC, DEL, and NUL must be entered as these three character sequences, written in all uppercase, as must the prefixes C- and M-. Spaces and line breaks are ignored. Other characters are copied verbatim into the keyboard macro. Basically, the notation is the same as is used in all of this manual’s examples, except that the manual takes some liberties with spaces: When we say ' [1 2 3] RET, we take it for granted that it is clear we really mean ' [1 SPC 2 SPC 3] RET.

The C-x * m (read-kbd-macro) command reads an Emacs “region” of spelled-out keystrokes and defines it as the current keyboard macro. It is a convenient way to define a keyboard macro that has been stored in a file, or to define a macro without executing it at the same time.


**** Conditionals in Keyboard Macros

The Z [ (calc-kbd-if) and Z ] (calc-kbd-end-if) commands allow you to put simple tests in a keyboard macro. When Calc sees the Z [, it pops an object from the stack and, if the object is a non-zero value, continues executing keystrokes. But if the object is zero, or if it is not provably nonzero, Calc skips ahead to the matching Z ] keystroke. See Logical Operations, for a set of commands for performing tests which conveniently produce 1 for true and 0 for false.

For example, RET 0 a < Z [ n Z ] implements an absolute-value function in the form of a keyboard macro. This macro duplicates the number on the top of the stack, pushes zero and compares using a < (calc-less-than), then, if the number was less than zero, executes n (calc-change-sign). Otherwise, the change-sign command is skipped.

To program this macro, type C-x (, type the above sequence of keystrokes, then type C-x ). Note that the keystrokes will be executed while you are making the definition as well as when you later re-execute the macro by typing X. Thus you should make sure a suitable number is on the stack before defining the macro so that you don’t get a stack-underflow error during the definition process.

Conditionals can be nested arbitrarily. However, there should be exactly one Z ] for each Z [ in a keyboard macro.

The Z : (calc-kbd-else) command allows you to choose between two keystroke sequences. The general format is cond Z [ then-part Z : else-part Z ]. If cond is true (i.e., if the top of stack contains a non-zero number after cond has been executed), the then-part will be executed and the else-part will be skipped. Otherwise, the then-part will be skipped and the else-part will be executed.

The Z | (calc-kbd-else-if) command allows you to choose between any number of alternatives. For example, cond1 Z [ part1 Z : cond2 Z | part2 Z : part3 Z ] will execute part1 if cond1 is true, otherwise it will execute part2 if cond2 is true, otherwise it will execute part3.

More precisely, Z [ pops a number and conditionally skips to the next matching Z : or Z ] key. Z ] has no effect when actually executed. Z : skips to the next matching Z ]. Z | pops a number and conditionally skips to the next matching Z : or Z ]; thus, Z [ and Z | are functionally equivalent except that Z [ participates in nesting but Z | does not.

Calc’s conditional and looping constructs work by scanning the keyboard macro for occurrences of character sequences like ‘Z:’ and ‘Z]’. One side-effect of this is that if you use these constructs you must be careful that these character pairs do not occur by accident in other parts of the macros. Since Calc rarely uses shift-Z for any purpose except as a prefix character, this is not likely to be a problem. Another side-effect is that it will not work to define your own custom key bindings for these commands. Only the standard shift-Z bindings will work correctly.

If Calc gets stuck while skipping characters during the definition of a macro, type Z C-g to cancel the definition. (Typing plain C-g actually adds a C-g keystroke to the macro.)


**** Loops in Keyboard Macros

The Z < (calc-kbd-repeat) and Z > (calc-kbd-end-repeat) commands pop a number from the stack, which must be an integer, then repeat the keystrokes between the brackets the specified number of times. If the integer is zero or negative, the body is skipped altogether. For example, 1 TAB Z < 2 * Z > computes two to a nonnegative integer power. First, we push 1 on the stack and then swap the integer argument back to the top. The Z < pops that argument leaving the 1 back on top of the stack. Then, we repeat a multiply-by-two step however many times.

Once again, the keyboard macro is executed as it is being entered. In this case it is especially important to set up reasonable initial conditions before making the definition: Suppose the integer 1000 just happened to be sitting on the stack before we typed the above definition! Another approach is to enter a harmless dummy definition for the macro, then go back and edit in the real one with a Z E command. Yet another approach is to type the macro as written-out keystroke names in a buffer, then use C-x * m (read-kbd-macro) to read the macro.

The Z / (calc-kbd-break) command allows you to break out of a keyboard macro loop prematurely. It pops an object from the stack; if that object is true (a non-zero number), control jumps out of the innermost enclosing Z < … Z > loop and continues after the Z >. If the object is false, the Z / has no effect. Thus cond Z / is similar to ‘if (cond) break;’ in the C language.

The Z ( (calc-kbd-for) and Z ) (calc-kbd-end-for) commands are similar to Z < and Z >, except that they make the value of the counter available inside the loop. The general layout is init final Z ( body step Z ). The Z ( command pops initial and final values from the stack. It then creates a temporary internal counter and initializes it with the value init. The Z ( command then repeatedly pushes the counter value onto the stack and executes body and step, adding step to the counter each time until the loop finishes.

By default, the loop finishes when the counter becomes greater than (or less than) final, assuming initial is less than (greater than) final. If initial is equal to final, the body executes exactly once. The body of the loop always executes at least once. For example, 0 1 10 Z ( 2 ^ + 1 Z ) computes the sum of the squares of the integers from 1 to 10, in steps of 1.

If you give a numeric prefix argument of 1 to Z (, the loop is forced to use upward-counting conventions. In this case, if initial is greater than final the body will not be executed at all. Note that step may still be negative in this loop; the prefix argument merely constrains the loop-finished test. Likewise, a prefix argument of -1 forces downward-counting conventions.

The Z { (calc-kbd-loop) and Z } (calc-kbd-end-loop) commands are similar to Z < and Z >, except that they do not pop a count from the stack—they effectively create an infinite loop. Every Z { … Z } loop ought to include at least one Z / to make sure the loop doesn’t run forever. (If any error message occurs which causes Emacs to beep, the keyboard macro will also be halted; this is a standard feature of Emacs. You can also generally press C-g to halt a running keyboard macro, although not all versions of Unix support this feature.)

The conditional and looping constructs are not actually tied to keyboard macros, but they are most often used in that context. For example, the keystrokes 10 Z < 23 RET Z > push ten copies of 23 onto the stack. This can be typed “live” just as easily as in a macro definition.

See Conditionals in Keyboard Macros, for some additional notes about conditional and looping commands.


**** Local Values in Macros

Keyboard macros sometimes want to operate under known conditions without affecting surrounding conditions. For example, a keyboard macro may wish to turn on Fraction mode, or set a particular precision, independent of the user’s normal setting for those modes.

Macros also sometimes need to use local variables. Assignments to local variables inside the macro should not affect any variables outside the macro. The Z ` (calc-kbd-push) and Z ' (calc-kbd-pop) commands give you both of these capabilities.

When you type Z ` (with a grave accent), the values of various mode settings are saved away. The ten “quick” variables q0 through q9 are also saved. When you type Z ' (with an apostrophe), these values are restored. Pairs of Z ` and Z ' commands may be nested.

If a keyboard macro halts due to an error in between a Z ` and a Z ', the saved values will be restored correctly even though the macro never reaches the Z ' command. Thus you can use Z ` and Z ' without having to worry about what happens in exceptional conditions.

If you type Z ` “live” (not in a keyboard macro), Calc puts you into a “recursive edit.” You can tell you are in a recursive edit because there will be extra square brackets in the mode line, as in ‘[(Calculator)]’. These brackets will go away when you type the matching Z ' command. The modes and quick variables will be saved and restored in just the same way as if actual keyboard macros were involved.

The modes saved by Z ` and Z ' are the current precision and binary word size, the angular mode (Deg, Rad, or HMS), the simplification mode, Algebraic mode, Symbolic mode, Infinite mode, Matrix or Scalar mode, Fraction mode, and the current complex mode (Polar or Rectangular). The ten “quick” variables’ values (or lack thereof) are also saved.

Most mode-setting commands act as toggles, but with a numeric prefix they force the mode either on (positive prefix) or off (negative or zero prefix). Since you don’t know what the environment might be when you invoke your macro, it’s best to use prefix arguments for all mode-setting commands inside the macro.

In fact, C-u Z ` is like Z ` except that it sets the modes listed above to their default values. As usual, the matching Z ' will restore the modes to their settings from before the C-u Z `. Also, Z ` with a negative prefix argument resets the algebraic mode to its default (off) but leaves the other modes the same as they were outside the construct.

The contents of the stack and trail, values of non-quick variables, and other settings such as the language mode and the various display modes, are not affected by Z ` and Z '.


**** Queries in Keyboard Macros

The Z # (calc-kbd-query) command prompts for an algebraic entry which takes its input from the keyboard, even during macro execution. All the normal conventions of algebraic input, including the use of $ characters, are supported. The prompt message itself is taken from the top of the stack, and so must be entered (as a string) before the Z # command. (Recall, as a string it can be entered by pressing the " key and will appear as a vector when it is put on the stack. The prompt message is only put on the stack to provide a prompt for the Z # command; it will not play any role in any subsequent calculations.) This command allows your keyboard macros to accept numbers or formulas as interactive input.

As an example, 2 RET "Power: " RET Z # 3 RET ^ will prompt for input with “Power: ” in the minibuffer, then return 2 to the provided power. (The response to the prompt that’s given, 3 in this example, will not be part of the macro.)

See Keyboard Macro Query in the Emacs Manual, for a description of C-x q (kbd-macro-query), the standard Emacs way to accept keyboard input during a keyboard macro. In particular, you can use C-x q to enter a recursive edit, which allows the user to perform any Calculator operations interactively before pressing C-M-c to return control to the keyboard macro.


*** Invocation Macros

Calc provides one special keyboard macro, called up by C-x * z (calc-user-invocation), that is intended to allow you to define your own special way of starting Calc. To define this “invocation macro,” create the macro in the usual way with C-x ( and C-x ), then type Z I (calc-user-define-invocation). There is only one invocation macro, so you don’t need to type any additional letters after Z I. From now on, you can type C-x * z at any time to execute your invocation macro.

For example, suppose you find yourself often grabbing rectangles of numbers into Calc and multiplying their columns. You can do this by typing C-x * r to grab, and V R : * to multiply columns. To make this into an invocation macro, just type C-x ( C-x * r V R : * C-x ), then Z I. Then, to multiply a rectangle of data, just mark the data in its buffer in the usual way and type C-x * z.

Invocation macros are treated like regular Emacs keyboard macros; all the special features described above for Z K-style macros do not apply. C-x * z is just like C-x e, except that it uses the macro that was last stored by Z I. (In fact, the macro does not even have to have anything to do with Calc!)

The m m command saves the last invocation macro defined by Z I along with all the other Calc mode settings. See General Mode Commands.


*** Programming with Formulas

Another way to create a new Calculator command uses algebraic formulas. The Z F (calc-user-define-formula) command stores the formula at the top of the stack as the definition for a key. This command prompts for five things: The key, the command name, the function name, the argument list, and the behavior of the command when given non-numeric arguments.

For example, suppose we type ' a+2b RET to push the formula ‘a + 2*b’ onto the stack. We now type Z F m to define this formula on the z m key sequence. The next prompt is for a command name, beginning with ‘calc-’, which should be the long (M-x) form for the new command. If you simply press RET, a default name like calc-User-m will be constructed. In our example, suppose we enter spam RET to define the new command as calc-spam.

If you want to give the formula a long-style name only, you can press SPC or RET when asked which single key to use. For example Z F RET spam RET defines the new command as M-x calc-spam, with no keyboard equivalent.

The third prompt is for an algebraic function name. The default is to use the same name as the command name but without the ‘calc-’ prefix. (If this is of the form ‘User-m’, the hyphen is removed so it won’t be taken for a minus sign in algebraic formulas.) This is the name you will use if you want to enter your new function in an algebraic formula. Suppose we enter yow RET. Then the new function can be invoked by pushing two numbers on the stack and typing z m or x spam, or by entering the algebraic formula ‘yow(x,y)’.

The fourth prompt is for the function’s argument list. This is used to associate values on the stack with the variables that appear in the formula. The default is a list of all variables which appear in the formula, sorted into alphabetical order. In our case, the default would be ‘(a b)’. This means that, when the user types z m, the Calculator will remove two numbers from the stack, substitute these numbers for ‘a’ and ‘b’ (respectively) in the formula, then simplify the formula and push the result on the stack. In other words, 10 RET 100 z m would replace the 10 and 100 on the stack with the number 210, which is ‘a + 2 b’ with ‘a=10’ and ‘b=100’. Likewise, the formula ‘yow(10, 100)’ will be evaluated by substituting ‘a=10’ and ‘b=100’ in the definition.

You can rearrange the order of the names before pressing RET to control which stack positions go to which variables in the formula. If you remove a variable from the argument list, that variable will be left in symbolic form by the command. Thus using an argument list of ‘(b)’ for our function would cause 10 z m to replace the 10 on the stack with the formula ‘a + 20’. If we had used an argument list of ‘(b a)’, the result with inputs 10 and 100 would have been 120.

You can also put a nameless function on the stack instead of just a formula, as in ‘<a, b : a + 2 b>’. See Specifying Operators. In this example, the command will be defined by the formula ‘a + 2 b’ using the argument list ‘(a b)’.

The final prompt is a y-or-n question concerning what to do if symbolic arguments are given to your function. If you answer y, then executing z m (using the original argument list ‘(a b)’) with arguments ‘10’ and ‘x’ will leave the function in symbolic form, i.e., ‘yow(10,x)’. On the other hand, if you answer n, then the formula will always be expanded, even for non-constant arguments: ‘10 + 2 x’. If you never plan to feed algebraic formulas to your new function, it doesn’t matter how you answer this question.

If you answered y to this question you can still cause a function call to be expanded by typing a " (calc-expand-formula). Also, Calc will expand the function if necessary when you take a derivative or integral or solve an equation involving the function.

Once you have defined a formula on a key, you can retrieve this formula with the Z G (calc-user-define-get-defn) command. Press a key, and this command pushes the formula that was used to define that key onto the stack. Actually, it pushes a nameless function that specifies both the argument list and the defining formula. You will get an error message if the key is undefined, or if the key was not defined by a Z F command.

The Z E (calc-user-define-edit) command on a key that has been defined by a formula uses a variant of the calc-edit command to edit the defining formula. Press C-c C-c to finish editing and store the new formula back in the definition, or kill the buffer with C-x k to cancel the edit. (The argument list and other properties of the definition are unchanged; to adjust the argument list, you can use Z G to grab the function onto the stack, edit with `, and then re-execute the Z F command.)

As usual, the Z P command records your definition permanently. In this case it will permanently record all three of the relevant definitions: the key, the command, and the function.

You may find it useful to turn off the default simplifications with m O (calc-no-simplify-mode) when entering a formula to be used as a function definition. For example, the formula ‘deriv(a^2,v)’ which might be used to define a new function ‘dsqr(a,v)’ will be “simplified” to 0 immediately upon entry since deriv considers ‘a’ to be constant with respect to ‘v’. Turning off default simplifications cures this problem: The definition will be stored in symbolic form without ever activating the deriv function. Press m D to turn the default simplifications back on afterwards.


*** Programming Calc, with Lisp

The Calculator can be programmed quite extensively in Lisp. All you do is write a normal Lisp function definition, but with defmath in place of defun. This has the same form as defun, but it automagically replaces calls to standard Lisp functions like + and zerop with calls to the corresponding functions in Calc’s own library. Thus you can write natural-looking Lisp code which operates on all of the standard Calculator data types. You can then use Z D if you wish to bind your new command to a z-prefix key sequence. The Z E command will not edit a Lisp-based definition.

Emacs Lisp is described in the GNU Emacs Lisp Reference Manual. This section assumes a familiarity with Lisp programming concepts; if you do not know Lisp, you may find keyboard macros or rewrite rules to be an easier way to program the Calculator.

This section first discusses ways to write commands, functions, or small programs to be executed inside of Calc. Then it discusses how your own separate programs are able to call Calc from the outside. Finally, there is a list of internal Calc functions and data structures for the true Lisp enthusiast.

**** Defining New Functions

The defmath function (actually a Lisp macro) is like defun except that code in the body of the definition can make use of the full range of Calculator data types. The prefix ‘calcFunc-’ is added to the specified name to get the actual Lisp function name. As a simple example,

(defmath myfact (n)
  (if (> n 0)
      (* n (myfact (1- n)))
    1))
This actually expands to the code,

(defun calcFunc-myfact (n)
  (if (math-posp n)
      (math-mul n (calcFunc-myfact (math-add n -1)))
    1))
This function can be used in algebraic expressions, e.g., ‘myfact(5)’.

The ‘myfact’ function as it is defined above has the bug that an expression ‘myfact(a+b)’ will be simplified to 1 because the formula ‘a+b’ is not considered to be posp. A robust factorial function would be written along the following lines:

(defmath myfact (n)
  (if (> n 0)
      (* n (myfact (1- n)))
    (if (= n 0)
        1
      nil)))    ; this could be simplified as: (and (= n 0) 1)
If a function returns nil, it is left unsimplified by the Calculator (except that its arguments will be simplified). Thus, ‘myfact(a+1+2)’ will be simplified to ‘myfact(a+3)’ but no further. Beware that every time the Calculator reexamines this formula it will attempt to resimplify it, so your function ought to detect the returning-nil case as efficiently as possible.

The following standard Lisp functions are treated by defmath: +, -, *, /, %, ^ or expt, =, <, >, <=, >=, /=, 1+, 1-, logand, logior, logxor, logandc2, lognot. Also, ~= is an abbreviation for math-nearly-equal, which is useful in implementing Taylor series.

For other functions func, if a function by the name ‘calcFunc-func’ exists it is used, otherwise if a function by the name ‘math-func’ exists it is used, otherwise if func itself is defined as a function it is used, otherwise ‘calcFunc-func’ is used on the assumption that this is a to-be-defined math function. Also, if the function name is quoted as in ‘('integerp a)’ the function name is always used exactly as written (but not quoted).

Variable names have ‘var-’ prepended to them unless they appear in the function’s argument list or in an enclosing let, let*, for, or foreach form, or their names already contain a ‘-’ character. Thus a reference to ‘foo’ is the same as a reference to ‘var-foo’.

A few other Lisp extensions are available in defmath definitions:

The elt function accepts any number of index variables. Note that Calc vectors are stored as Lisp lists whose first element is the symbol vec; thus, ‘(elt v 2)’ yields the second element of vector v, and ‘(elt m i j)’ yields one element of a Calc matrix.
The setq function has been extended to act like the Common Lisp setf function. (The name setf is recognized as a synonym of setq.) Specifically, the first argument of setq can be an nth, elt, car, or cdr form, in which case the effect is to store into the specified element of a list. Thus, ‘(setq (elt m i j) x)’ stores ‘x’ into one element of a matrix.
A for looping construct is available. For example, ‘(for ((i 0 10)) body)’ executes body once for each binding of ‘i’ from zero to 10. This is like a let form in that ‘i’ is temporarily bound to the loop count without disturbing its value outside the for construct. Nested loops, as in ‘(for ((i 0 10) (j 0 (1- i) 2)) body)’, are also available. For each value of ‘i’ from zero to 10, ‘j’ counts from 0 to ‘i-1’ in steps of two. Note that for has the same general outline as let*, except that each element of the header is a list of three or four things, not just two.
The foreach construct loops over elements of a list. For example, ‘(foreach ((x (cdr v))) body)’ executes body with ‘x’ bound to each element of Calc vector ‘v’ in turn. The purpose of cdr here is to skip over the initial vec symbol in the vector.
The break function breaks out of the innermost enclosing while, for, or foreach loop. If given a value, as in ‘(break x)’, this value is returned by the loop. (Lisp loops otherwise always return nil.)
The return function prematurely returns from the enclosing function. For example, ‘(return (+ x y))’ returns ‘x+y’ as the value of a function. You can use return anywhere inside the body of the function.
Non-integer numbers cannot be included directly into a defmath definition. This is because the Lisp reader will fail to parse them long before defmath ever gets control. Instead, use the notation, ‘:"3.1415"’. In fact, any algebraic formula can go between the quotes. For example,

(defmath sqexp (x)     ; sqexp(x) == sqrt(exp(x)) == exp(x*0.5)
  (and (numberp x)
       (exp :"x * 0.5")))
expands to

(defun calcFunc-sqexp (x)
  (and (math-numberp x)
       (calcFunc-exp (math-mul x '(float 5 -1)))))
Note the use of numberp as a guard to ensure that the argument is a number first, returning nil if not. The exponential function could itself have been included in the expression, if we had preferred: ‘:"exp(x * 0.5)"’. As another example, the multiplication-and-recursion step of myfact could have been written

:"n * myfact(n-1)"
A good place to put your defmath commands is your Calc init file (the file given by calc-settings-file, typically ~/.emacs.d/calc.el), which will not be loaded until Calc starts. If a file named .emacs exists in your home directory, Emacs reads and executes the Lisp forms in this file as it starts up. While it may seem reasonable to put your favorite defmath commands there, this has the unfortunate side-effect that parts of the Calculator must be loaded in to process the defmath commands whether or not you will actually use the Calculator! If you want to put the defmath commands there (for example, if you redefine calc-settings-file to be .emacs), a better effect can be had by writing

(put 'calc-define 'thing '(progn
 (defmath ... )
 (defmath ... )
))
The put function adds a property to a symbol. Each Lisp symbol has a list of properties associated with it. Here we add a property with a name of thing and a ‘(progn ...)’ form as its value. When Calc starts up, and at the start of every Calc command, the property list for the symbol calc-define is checked and the values of any properties found are evaluated as Lisp forms. The properties are removed as they are evaluated. The property names (like thing) are not used; you should choose something like the name of your project so as not to conflict with other properties.

The net effect is that you can put the above code in your .emacs file and it will not be executed until Calc is loaded. Or, you can put that same code in another file which you load by hand either before or after Calc itself is loaded.

The properties of calc-define are evaluated in the same order that they were added. They can assume that the Calc modules calc.el, calc-ext.el, and calc-macs.el have been fully loaded, and that the *Calculator* buffer will be the current buffer.

If your calc-define property only defines algebraic functions, you can be sure that it will have been evaluated before Calc tries to call your function, even if the file defining the property is loaded after Calc is loaded. But if the property defines commands or key sequences, it may not be evaluated soon enough. (Suppose it defines the new command tweak-calc; the user can load your file, then type M-x tweak-calc before Calc has had chance to do anything.) To protect against this situation, you can put

(run-hooks 'calc-check-defines)
at the end of your file. The calc-check-defines function is what looks for and evaluates properties on calc-define; run-hooks has the advantage that it is quietly ignored if calc-check-defines is not yet defined because Calc has not yet been loaded.

Examples of things that ought to be enclosed in a calc-define property are defmath calls, define-key calls that modify the Calc key map, and any calls that redefine things defined inside Calc. Ordinary defuns need not be enclosed with calc-define.


**** Defining New Simple Commands

If a defmath form contains an interactive clause, it defines a Calculator command. Actually such a defmath results in two function definitions: One, a ‘calcFunc-’ function as was just described, with the interactive clause removed. Two, a ‘calc-’ function with a suitable interactive clause and some sort of wrapper to make the command work in the Calc environment.

In the simple case, the interactive clause has the same form as for normal Emacs Lisp commands:

(defmath increase-precision (delta)
  "Increase precision by DELTA."     ; This is the "documentation string"
  (interactive "p")                  ; Register this as a M-x-able command
  (setq calc-internal-prec (+ calc-internal-prec delta)))
This expands to the pair of definitions,

(defun calc-increase-precision (delta)
  "Increase precision by DELTA."
  (interactive "p")
  (calc-wrapper
   (setq calc-internal-prec (math-add calc-internal-prec delta))))

(defun calcFunc-increase-precision (delta)
  "Increase precision by DELTA."
  (setq calc-internal-prec (math-add calc-internal-prec delta)))
where in this case the latter function would never really be used! Note that since the Calculator stores integers as plain Lisp integers, the math-add function will work just as well as the native + even when the intent is to operate on native Lisp integers.

The ‘calc-wrapper’ call invokes a macro which surrounds the body of the function with code that looks roughly like this:

(let ((calc-command-flags nil))
  (unwind-protect
      (save-current-buffer
        (calc-select-buffer)
        body of function
        renumber stack
        clear Working message)
    realign cursor and window
    clear Inverse, Hyperbolic, and Keep Args flags
    update Emacs mode line))
The calc-select-buffer function selects the *Calculator* buffer if necessary, say, because the command was invoked from inside the *Calc Trail* window.

You can call, for example, (calc-set-command-flag 'no-align) to set the above-mentioned command flags. Calc routines recognize the following command flags:

renum-stack
Stack line numbers ‘1:’, ‘2:’, and so on must be renumbered after this command completes. This is set by routines like calc-push.

clear-message
Calc should call ‘(message "")’ if this command completes normally (to clear a “Working…” message out of the echo area).

no-align
Do not move the cursor back to the ‘.’ top-of-stack marker.

position-point
Use the variables calc-position-point-line and calc-position-point-column to position the cursor after this command finishes.

keep-flags
Do not clear calc-inverse-flag, calc-hyperbolic-flag, and calc-keep-args-flag at the end of this command.

do-edit
Switch to buffer *Calc Edit* after this command.

hold-trail
Do not move trail pointer to end of trail when something is recorded there.

Calc reserves a special prefix key, shift-Y, for user-written extensions to Calc. There are no built-in commands that work with this prefix key; you must call define-key from Lisp (probably from inside a calc-define property) to add to it. Initially only Y ? is defined; it takes help messages from a list of strings (initially nil) in the variable calc-Y-help-msgs. All other undefined keys except for Y are reserved for use by future versions of Calc.

If you are writing a Calc enhancement which you expect to give to others, it is best to minimize the number of Y-key sequences you use. In fact, if you have more than one key sequence you should consider defining three-key sequences with a Y, then a key that stands for your package, then a third key for the particular command within your package.

Users may wish to install several Calc enhancements, and it is possible that several enhancements will choose to use the same key. In the example below, a variable inc-prec-base-key has been defined to contain the key that identifies the inc-prec package. Its value is initially "P", but a user can change this variable if necessary without having to modify the file.

Here is a complete file, inc-prec.el, which makes a Y P I command that increases the precision, and a Y P D command that decreases the precision.

;;; Increase and decrease Calc precision.  Dave Gillespie, 5/31/91.
;; (Include copyright or copyleft stuff here.)

(defvar inc-prec-base-key "P"
  "Base key for inc-prec.el commands.")

(put 'calc-define 'inc-prec '(progn

(define-key calc-mode-map (format "Y%sI" inc-prec-base-key)
            'calc-increase-precision)
(define-key calc-mode-map (format "Y%sD" inc-prec-base-key)
            'calc-decrease-precision)

(setq calc-Y-help-msgs
      (cons (format "%s + Inc-prec, Dec-prec" inc-prec-base-key)
            calc-Y-help-msgs))

(defmath increase-precision (delta)
  "Increase precision by DELTA."
  (interactive "p")
  (setq calc-internal-prec (+ calc-internal-prec delta)))

(defmath decrease-precision (delta)
  "Decrease precision by DELTA."
  (interactive "p")
  (setq calc-internal-prec (- calc-internal-prec delta)))

))  ; end of calc-define property

(run-hooks 'calc-check-defines)


**** Defining New Stack-Based Commands

To define a new computational command which takes and/or leaves arguments on the stack, a special form of interactive clause is used.

(interactive num tag)
where num is an integer, and tag is a string. The effect is to pop num values off the stack, resimplify them by calling calc-normalize, and hand them to your function according to the function’s argument list. Your function may include &optional and &rest parameters, so long as calling the function with num parameters is valid.

Your function must return either a number or a formula in a form acceptable to Calc, or a list of such numbers or formulas. These value(s) are pushed onto the stack when the function completes. They are also recorded in the Calc Trail buffer on a line beginning with tag, a string of (normally) four characters or less. If you omit tag or use nil as a tag, the result is not recorded in the trail.

As an example, the definition

(defmath myfact (n)
  "Compute the factorial of the integer at the top of the stack."
  (interactive 1 "fact")
  (if (> n 0)
      (* n (myfact (1- n)))
    (and (= n 0) 1)))
is a version of the factorial function shown previously which can be used as a command as well as an algebraic function. It expands to

(defun calc-myfact ()
  "Compute the factorial of the integer at the top of the stack."
  (interactive)
  (calc-slow-wrapper
   (calc-enter-result 1 "fact"
     (cons 'calcFunc-myfact (calc-top-list-n 1)))))

(defun calcFunc-myfact (n)
  "Compute the factorial of the integer at the top of the stack."
  (if (math-posp n)
      (math-mul n (calcFunc-myfact (math-add n -1)))
    (and (math-zerop n) 1)))
The calc-slow-wrapper function is a version of calc-wrapper that automatically puts up a ‘Working...’ message before the computation begins. (This message can be turned off by the user with an m w (calc-working) command.)

The calc-top-list-n function returns a list of the specified number of values from the top of the stack. It resimplifies each value by calling calc-normalize. If its argument is zero it returns an empty list. It does not actually remove these values from the stack.

The calc-enter-result function takes an integer num and string tag as described above, plus a third argument which is either a Calculator data object or a list of such objects. These objects are resimplified and pushed onto the stack after popping the specified number of values from the stack. If tag is non-nil, the values being pushed are also recorded in the trail.

Note that if calcFunc-myfact returns nil this represents “leave the function in symbolic form.” To return an actual empty list, in the sense that calc-enter-result will push zero elements back onto the stack, you should return the special value ‘'(nil)’, a list containing the single symbol nil.

The interactive declaration can actually contain a limited Emacs-style code string as well which comes just before num and tag. Currently the only Emacs code supported is ‘"p"’, as in

(defmath foo (a b &optional c)
  (interactive "p" 2 "foo")
  body)
In this example, the command calc-foo will evaluate the expression ‘foo(a,b)’ if executed with no argument, or ‘foo(a,b,n)’ if executed with a numeric prefix argument of ‘n’.

The other code string allowed is ‘"m"’ (unrelated to the usual ‘"m"’ code as used with defun). It uses the numeric prefix argument as the number of objects to remove from the stack and pass to the function. In this case, the integer num serves as a default number of arguments to be used when no prefix is


**** Argument Qualifiers

Anywhere a parameter name can appear in the parameter list you can also use an argument qualifier. Thus the general form of a definition is:

(defmath name (param param...
               &optional param param...
               &rest param)
  body)
where each param is either a symbol or a list of the form

(qual param)
The following qualifiers are recognized:

‘complete’ ¶
The argument must not be an incomplete vector, interval, or complex number. (This is rarely needed since the Calculator itself will never call your function with an incomplete argument. But there is nothing stopping your own Lisp code from calling your function with an incomplete argument.)

‘integer’ ¶
The argument must be an integer. If it is an integer-valued float it will be accepted but converted to integer form. Non-integers and formulas are rejected.

‘natnum’ ¶
Like ‘integer’, but the argument must be non-negative.

‘fixnum’ ¶
Like ‘integer’, but the argument must fit into a native Lisp fixnum, which on most systems means less than 2^61 in absolute value. The argument is converted into Lisp-integer form if necessary.

‘float’ ¶
The argument is converted to floating-point format if it is a number or vector. If it is a formula it is left alone. (The argument is never actually rejected by this qualifier.)

‘pred’
The argument must satisfy predicate pred, which is one of the standard Calculator predicates. See Predicates.

‘not-pred’
The argument must not satisfy predicate pred.

For example,

(defmath foo (a (constp (not-matrixp b)) &optional (float c)
              &rest (integer d))
  body)
expands to

(defun calcFunc-foo (a b &optional c &rest d)
  (and (math-matrixp b)
       (math-reject-arg b 'not-matrixp))
  (or (math-constp b)
      (math-reject-arg b 'constp))
  (and c (setq c (math-check-float c)))
  (setq d (mapcar 'math-check-integer d))
  body)
which performs the necessary checks and conversions before executing the body of the function.


**** Example Definitions

This section includes some Lisp programming examples on a larger scale. These programs make use of some of the Calculator’s internal functions; see Calculator Internals.

***** Bit-Counting

Calc does not include a built-in function for counting the number of “one” bits in a binary integer. It’s easy to invent one using b u to convert the integer to a set, and V # to count the elements of that set; let’s write a function that counts the bits without having to create an intermediate set.

(defmath bcount ((natnum n))
  (interactive 1 "bcnt")
  (let ((count 0))
    (while (> n 0)
      (if (oddp n)
          (setq count (1+ count)))
      (setq n (ash n -1)))
    count))
When this is expanded by defmath, it will become the following Emacs Lisp function:

(defun calcFunc-bcount (n)
  (setq n (math-check-natnum n))
  (let ((count 0))
    (while (math-posp n)
      (if (math-oddp n)
          (setq count (math-add count 1)))
      (setq n (calcFunc-lsh n -1)))
    count))

***** The Sine Function

A somewhat limited sine function could be defined as follows, using the well-known Taylor series expansion for ‘sin(x)’:

(defmath mysin ((float (anglep x)))
  (interactive 1 "mysn")
  (setq x (to-radians x))    ; Convert from current angular mode.
  (let ((sum x)              ; Initial term of Taylor expansion of sin.
        newsum
        (nfact 1)            ; "nfact" equals "n" factorial at all times.
        (xnegsqr :"-(x^2)")) ; "xnegsqr" equals -x^2.
    (for ((n 3 100 2))       ; Upper limit of 100 is a good precaution.
      (working "mysin" sum)  ; Display "Working" message, if enabled.
      (setq nfact (* nfact (1- n) n)
            x (* x xnegsqr)
            newsum (+ sum (/ x nfact)))
      (if (~= newsum sum)    ; If newsum is "nearly equal to" sum,
          (break))           ;  then we are done.
      (setq sum newsum))
    sum))
The actual sin function in Calc works by first reducing the problem to a sine or cosine of a nonnegative number less than ‘pi/4’. This ensures that the Taylor series will converge quickly. Also, the calculation is carried out with two extra digits of precision to guard against cumulative round-off in ‘sum’. Finally, complex arguments are allowed and handled by a separate algorithm.

(defmath mysin ((float (scalarp x)))
  (interactive 1 "mysn")
  (setq x (to-radians x))    ; Convert from current angular mode.
  (with-extra-prec 2         ; Evaluate with extra precision.
    (cond ((complexp x)
           (mysin-complex x))
          ((< x 0)
           (- (mysin-raw (- x)))    ; Always call mysin-raw with x >= 0.
          (t (mysin-raw x))))))

(defmath mysin-raw (x)
  (cond ((>= x 7)
         (mysin-raw (% x (two-pi))))     ; Now x < 7.
        ((> x (pi-over-2))
         (- (mysin-raw (- x (pi)))))     ; Now -pi/2 <= x <= pi/2.
        ((> x (pi-over-4))
         (mycos-raw (- x (pi-over-2))))  ; Now -pi/2 <= x <= pi/4.
        ((< x (- (pi-over-4)))
         (- (mycos-raw (+ x (pi-over-2)))))  ; Now -pi/4 <= x <= pi/4,
        (t (mysin-series x))))           ; so the series will be efficient.
where mysin-complex is an appropriate function to handle complex numbers, mysin-series is the routine to compute the sine Taylor series as before, and mycos-raw is a function analogous to mysin-raw for cosines.

The strategy is to ensure that ‘x’ is nonnegative before calling mysin-raw. This function then recursively reduces its argument to a suitable range, namely, plus-or-minus ‘pi/4’. Note that each test, and particularly the first comparison against 7, is designed so that small roundoff errors cannot produce an infinite loop. (Suppose we compared with ‘(two-pi)’ instead; if due to roundoff problems the modulo operator ever returned ‘(two-pi)’ exactly, an infinite recursion could result!) We use modulo only for arguments that will clearly get reduced, knowing that the next rule will catch any reductions that this rule misses.

If a program is being written for general use, it is important to code it carefully as shown in this second example. For quick-and-dirty programs, when you know that your own use of the sine function will never encounter a large argument, a simpler program like the first one shown is fine.


**** Calling Calc from Your Lisp Programs

A later section (see Calculator Internals) gives a full description of Calc’s internal Lisp functions. It’s not hard to call Calc from inside your programs, but the number of these functions can be daunting. So Calc provides one special “programmer-friendly” function called calc-eval that can be made to do just about everything you need. It’s not as fast as the low-level Calc functions, but it’s much simpler to use!

It may seem that calc-eval itself has a daunting number of options, but they all stem from one simple operation.

In its simplest manifestation, ‘(calc-eval "1+2")’ parses the string "1+2" as if it were a Calc algebraic entry and returns the result formatted as a string: "3".

Since calc-eval is on the list of recommended autoload functions, you don’t need to make any special preparations to load Calc before calling calc-eval the first time. Calc will be loaded and initialized for you.

All the Calc modes that are currently in effect will be used when evaluating the expression and formatting the result.

***** Additional Arguments to calc-eval

If the input string parses to a list of expressions, Calc returns the results separated by ", ". You can specify a different separator by giving a second string argument to calc-eval: ‘(calc-eval "1+2,3+4" ";")’ returns "3;7".

The “separator” can also be any of several Lisp symbols which request other behaviors from calc-eval. These are discussed one by one below.

You can give additional arguments to be substituted for ‘$’, ‘$$’, and so on in the main expression. For example, ‘(calc-eval "$/$$" nil "7" "1+1")’ evaluates the expression "7/(1+1)" to yield the result "3.5" (assuming Fraction mode is not in effect). Note the nil used as a placeholder for the item-separator argument.

***** Error Handling

If calc-eval encounters an error, it returns a list containing the character position of the error, plus a suitable message as a string. Note that ‘1 / 0’ is not an error by Calc’s standards; it simply returns the string "1 / 0" which is the division left in symbolic form. But ‘(calc-eval "1/")’ will return the list ‘(2 "Expected a number")’.

If you bind the variable calc-eval-error to t using a let form surrounding the call to calc-eval, errors instead call the Emacs error function which aborts to the Emacs command loop with a beep and an error message.

If you bind this variable to the symbol string, error messages are returned as strings instead of lists. The character position is ignored.

As a courtesy to other Lisp code which may be using Calc, be sure to bind calc-eval-error using let rather than changing it permanently with setq.

***** Numbers Only

Sometimes it is preferable to treat ‘1 / 0’ as an error rather than returning a symbolic result. If you pass the symbol num as the second argument to calc-eval, results that are not constants are treated as errors. The error message reported is the first calc-why message if there is one, or otherwise “Number expected.”

A result is “constant” if it is a number, vector, or other object that does not include variables or function calls. If it is a vector, the components must themselves be constants.

***** Default Modes

If the first argument to calc-eval is a list whose first element is a formula string, then calc-eval sets all the various Calc modes to their default values while the formula is evaluated and formatted. For example, the precision is set to 12 digits, digit grouping is turned off, and the Normal language mode is used.

This same principle applies to the other options discussed below. If the first argument would normally be x, then it can also be the list ‘(x)’ to use the default mode settings.

If there are other elements in the list, they are taken as variable-name/value pairs which override the default mode settings. Look at the documentation at the front of the calc.el file to find the names of the Lisp variables for the various modes. The mode settings are restored to their original values when calc-eval is done.

For example, ‘(calc-eval '("$+$$" calc-internal-prec 8) 'num a b)’ computes the sum of two numbers, requiring a numeric result, and using default mode settings except that the precision is 8 instead of the default of 12.

It’s usually best to use this form of calc-eval unless your program actually considers the interaction with Calc’s mode settings to be a feature. This will avoid all sorts of potential “gotchas”; consider what happens with ‘(calc-eval "sqrt(2)" 'num)’ when the user has left Calc in Symbolic mode or No-Simplify mode.

As another example, ‘(equal (calc-eval '("$<$$") nil a b) "1")’ checks if the number in string ‘a’ is less than the one in string ‘b’. Without using a list, the integer 1 might come out in a variety of formats which would be hard to test for conveniently: "1", "8#1", "00001". (But see “Predicates” mode, below.)

***** Raw Numbers

Normally all input and output for calc-eval is done with strings. You can do arithmetic with, say, ‘(calc-eval "$+$$" nil a b)’ in place of ‘(+ a b)’, but this is very inefficient since the numbers must be converted to and from string format as they are passed from one calc-eval to the next.

If the separator is the symbol raw, the result will be returned as a raw Calc data structure rather than a string. You can read about how these objects look in the following sections, but usually you can treat them as “black box” objects with no important internal structure.

There is also a rawnum symbol, which is a combination of raw (returning a raw Calc object) and num (signaling an error if that object is not a constant).

You can pass a raw Calc object to calc-eval in place of a string, either as the formula itself or as one of the ‘$’ arguments. Thus ‘(calc-eval "$+$$" 'raw a b)’ is an addition function that operates on raw Calc objects. Of course in this case it would be easier to call the low-level math-add function in Calc, if you can remember its name.

In particular, note that a plain Lisp integer is acceptable to Calc as a raw object.

When it comes time to display the object, just use ‘(calc-eval a)’ to format it as a string.

It is an error if the input expression evaluates to a list of values. The separator symbol list is like raw except that it returns a list of one or more raw Calc objects.

Note that a Lisp string is not a valid Calc object, nor is a list containing a string. Thus you can still safely distinguish all the various kinds of error returns discussed above.

17.6.6.6 Predicates
If the separator symbol is pred, the result of the formula is treated as a true/false value; calc-eval returns t or nil, respectively. A value is considered “true” if it is a non-zero number, or false if it is zero or if it is not a number.

For example, ‘(calc-eval "$<$$" 'pred a b)’ tests whether one value is less than another.

As usual, it is also possible for calc-eval to return one of the error indicators described above. Lisp will interpret such an indicator as “true” if you don’t check for it explicitly. If you wish to have an error register as “false”, use something like ‘(eq (calc-eval ...) t)’.

***** Variable Values

Variables in the formula passed to calc-eval are not normally replaced by their values. If you wish this, you can use the evalv function (see Algebraic Manipulation). For example, if 4 is stored in Calc variable a (i.e., in Lisp variable var-a), then ‘(calc-eval "a+pi")’ will return the formula "a + pi", but ‘(calc-eval "evalv(a+pi)")’ will return "7.14159265359".

To store in a Calc variable, just use setq to store in the corresponding Lisp variable. (This is obtained by prepending ‘var-’ to the Calc variable name.) Calc routines will understand either string or raw form values stored in variables, although raw data objects are much more efficient. For example, to increment the Calc variable a:

(setq var-a (calc-eval "evalv(a+1)" 'raw))
17.6.6.8 Stack Access
If the separator symbol is push, the formula argument is evaluated (with possible ‘$’ expansions, as usual). The result is pushed onto the Calc stack. The return value is nil (unless there is an error from evaluating the formula, in which case the return value depends on calc-eval-error in the usual way).

If the separator symbol is pop, the first argument to calc-eval must be an integer instead of a string. That many values are popped from the stack and thrown away. A negative argument deletes the entry at that stack level. The return value is the number of elements remaining in the stack after popping; ‘(calc-eval 0 'pop)’ is a good way to measure the size of the stack.

If the separator symbol is top, the first argument to calc-eval must again be an integer. The value at that stack level is formatted as a string and returned. Thus ‘(calc-eval 1 'top)’ returns the top-of-stack value. If the integer is out of range, nil is returned.

The separator symbol rawtop is just like top except that the stack entry is returned as a raw Calc object instead of as a string.

In all of these cases the first argument can be made a list in order to force the default mode settings, as described above. Thus ‘(calc-eval '(2 calc-number-radix 16) 'top)’ returns the second-to-top stack entry, formatted as a string using the default instead of current display modes, except that the radix is hexadecimal instead of decimal.

It is, of course, polite to put the Calc stack back the way you found it when you are done, unless the user of your program is actually expecting it to affect the stack.

Note that you do not actually have to switch into the *Calculator* buffer in order to use calc-eval; it temporarily switches into the stack buffer if necessary.

***** Keyboard Macros

If the separator symbol is macro, the first argument must be a string of characters which Calc can execute as a sequence of keystrokes. This switches into the Calc buffer for the duration of the macro. For example, ‘(calc-eval "vx5\rVR+" 'macro)’ pushes the vector ‘[1,2,3,4,5]’ on the stack and then replaces it with the sum of those numbers. Note that ‘\r’ is the Lisp notation for the carriage return, RET, character.

If your keyboard macro wishes to pop the stack, ‘\C-d’ is safer than ‘\177’ (the DEL character) because some installations may have switched the meanings of DEL and C-h. Calc always interprets C-d as a synonym for “pop-stack” regardless of key mapping.

If you provide a third argument to calc-eval, evaluation of the keyboard macro will leave a record in the Trail using that argument as a tag string. Normally the Trail is unaffected.

The return value in this case is always nil.

***** Lisp Evaluation

Finally, if the separator symbol is eval, then the Lisp eval function is called on the first argument, which must be a Lisp expression rather than a Calc formula. Remember to quote the expression so that it is not evaluated until inside calc-eval.

The difference from plain eval is that calc-eval switches to the Calc buffer before evaluating the expression. For example, ‘(calc-eval '(setq calc-internal-prec 17) 'eval)’ will correctly affect the buffer-local Calc precision variable.

An alternative would be ‘(calc-eval '(calc-precision 17) 'eval)’. This is evaluating a call to the function that is normally invoked by the p key, giving it 17 as its “numeric prefix argument.” Note that this function will leave a message in the echo area as a side effect. Also, all Calc functions switch to the Calc buffer automatically if not invoked from there, so the above call is also equivalent to ‘(calc-precision 17)’ by itself. In all cases, Calc uses save-excursion to switch back to your original buffer when it is done.

As usual the first argument can be a list that begins with a Lisp expression to use default instead of current mode settings.

The result of calc-eval in this usage is just the result returned by the evaluated Lisp expression.

***** Example

Here is a sample Emacs command that uses calc-eval. Suppose you have a document with lots of references to temperatures on the Fahrenheit scale, say “98.6 F”, and you wish to convert these references to Centigrade. The following command does this conversion. Place the Emacs cursor right after the letter “F” and invoke the command to change “98.6 F” to “37 C”. Or, if the temperature is already in Centigrade form, the command changes it back to Fahrenheit.

(defun convert-temp ()
  (interactive)
  (save-excursion
    (re-search-backward "[^-.0-9]\\([-.0-9]+\\) *\\([FC]\\)")
    (let* ((top1 (match-beginning 1))
           (bot1 (match-end 1))
           (number (buffer-substring top1 bot1))
           (top2 (match-beginning 2))
           (bot2 (match-end 2))
           (type (buffer-substring top2 bot2)))
      (if (equal type "F")
          (setq type "C"
                number (calc-eval "($ - 32)*5/9" nil number))
        (setq type "F"
              number (calc-eval "$*9/5 + 32" nil number)))
      (goto-char top2)
      (delete-region top2 bot2)
      (insert-before-markers type)
      (goto-char top1)
      (delete-region top1 bot1)
      (if (string-match "\\.$" number)   ; change "37." to "37"
          (setq number (substring number 0 -1)))
      (insert number))))
Note the use of insert-before-markers when changing between “F” and “C”, so that the character winds up before the cursor instead of after it.


**** Calculator Internals

This section describes the Lisp functions defined by the Calculator that may be of use to user-written Calculator programs (as described in the rest of this chapter). These functions are shown by their names as they conventionally appear in defmath. Their full Lisp names are generally gotten by prepending ‘calcFunc-’ or ‘math-’ to their apparent names. (Names that begin with ‘calc-’ are already in their full Lisp form.) You can use the actual full names instead if you prefer them, or if you are calling these functions from regular Lisp.

The functions described here are scattered throughout the various Calc component files. Note that calc.el includes autoloads for only a few component files; to get autoloads of the more advanced function, one needs to load calc-ext.el, which in turn autoloads all the functions in the remaining component files.

Because defmath itself uses the extensions, user-written code generally always executes with the extensions already loaded, so normally you can use any Calc function and be confident that it will be autoloaded for you when necessary. If you are doing something special, check carefully to make sure each function you are using is from calc.el or its components, and use (require 'calc-ext) before using any function based in calc-ext.el if you can’t prove this file will already be loaded.

***** Data Type Formats

Integers are stored as standard Lisp integers. This is the only storage format for Calc data objects which is not a Lisp list.

Fractions are stored as a list of the form, ‘(frac n d)’ where n is an integer numerator, d is an integer denominator greater than one, and n and d are relatively prime. Note that fractions where d is one are automatically converted to plain integers by all math routines; fractions where d is negative are normalized by negating the numerator and denominator.

Floating-point numbers are stored in the form, ‘(float mant exp)’, where mant (the “mantissa”) is an integer less than ‘10^p’ in absolute value (p represents the current precision), and exp (the “exponent”) is an integer. The value of the float is ‘mant * 10^exp’. For example, the number -3.14 is stored as ‘(float -314 -2) = -314*10^-2’. Other constraints are that the number 0.0 is always stored as ‘(float 0 0)’, and, except for the 0.0 case, the rightmost base-10 digit of mant is always nonzero. (If the rightmost digit is zero, the number is rearranged by dividing mant by ten and incrementing exp.)

Rectangular complex numbers are stored in the form ‘(cplx re im)’, where re and im are each real numbers, either integers, fractions, or floats. The value is ‘re + imi’. The im part is nonzero; complex numbers with zero imaginary components are converted to real numbers automatically.

Polar complex numbers are stored in the form ‘(polar r theta)’, where r is a positive real value and theta is a real value or HMS form representing an angle. This angle is usually normalized to lie in the interval ‘(-180 .. 180)’ degrees, or ‘(-pi .. pi)’ radians, according to the current angular mode. If the angle is 0 the value is converted to a real number automatically. (If the angle is 180 degrees, the value is usually also converted to a negative real number.)

Hours-minutes-seconds forms are stored as ‘(hms h m s)’, where h is an integer or an integer-valued float (i.e., a float with ‘exp >= 0’), m is an integer or integer-valued float in the range ‘[0 .. 60)’, and s is any real number in the range ‘[0 .. 60)’.

Date forms are stored as ‘(date n)’, where n is a real number that counts days since midnight on the morning of January 1, 1 AD. If n is an integer, this is a pure date form. If n is a fraction or float, this is a date/time form.

Modulo forms are stored as ‘(mod n m)’, where m is a positive real number or HMS form, and n is a real number or HMS form in the range ‘[0 .. m)’.

Error forms are stored as ‘(sdev x sigma)’, where x is the mean value and sigma is the standard deviation. Each component is either a number, an HMS form, or a symbolic object (a variable or function call). If sigma is zero, the value is converted to a plain real number. If sigma is negative or complex, it is automatically normalized to be a positive real.

Interval forms are stored as ‘(intv mask lo hi)’, where mask is one of the integers 0, 1, 2, or 3, and lo and hi are real numbers, HMS forms, or symbolic objects. The mask is a binary integer where 1 represents the fact that the interval is closed on the high end, and 2 represents the fact that it is closed on the low end. (Thus 3 represents a fully closed interval.) The interval ‘(intv 3 x x)’ is converted to the plain number x; intervals ‘(intv mask x x)’ for any other mask represent empty intervals. If hi is less than lo, the interval is converted to a standard empty interval by replacing hi with lo.

Vectors are stored as ‘(vec v1 v2 …)’, where v1 is the first element of the vector, v2 is the second, and so on. An empty vector is stored as ‘(vec)’. A matrix is simply a vector where all v’s are themselves vectors of equal lengths. Note that Calc vectors are unrelated to the Emacs Lisp “vector” type, which is generally unused by Calc data structures.

Variables are stored as ‘(var name sym)’, where name is a Lisp symbol whose print name is used as the visible name of the variable, and sym is a Lisp symbol in which the variable’s value is actually stored. Thus, ‘(var pi var-pi)’ represents the special constant ‘pi’. Almost always, the form is ‘(var v var-v)’. If the variable name was entered with # signs (which are converted to hyphens internally), the form is ‘(var u v)’, where u is a symbol whose name contains # characters, and v is a symbol that contains - characters instead. The value of a variable is the Calc object stored in its sym symbol’s value cell. If the symbol’s value cell is void or if it contains nil, the variable has no value. Special constants have the form ‘(special-const value)’ stored in their value cell, where value is a formula which is evaluated when the constant’s value is requested. Variables which represent units are not stored in any special way; they are units only because their names appear in the units table. If the value cell contains a string, it is parsed to get the variable’s value when the variable is used.

A Lisp list with any other symbol as the first element is a function call. The symbols +, -, *, /, %, ^, and | represent special binary operators; these lists are always of the form ‘(op lhs rhs)’ where lhs is the sub-formula on the lefthand side and rhs is the sub-formula on the right. The symbol neg represents unary negation; this list is always of the form ‘(neg arg)’. Any other symbol func represents a function that would be displayed in function-call notation; the symbol func is in general always of the form ‘calcFunc-name’. The function cell of the symbol func should contain a Lisp function for evaluating a call to func. This function is passed the remaining elements of the list (themselves already evaluated) as arguments; such functions should return nil or call reject-arg to signify that they should be left in symbolic form, or they should return a Calc object which represents their value, or a list of such objects if they wish to return multiple values. (The latter case is allowed only for functions which are the outer-level call in an expression whose value is about to be pushed on the stack; this feature is considered obsolete and is not used by any built-in Calc functions.)


***** Interactive Functions

The functions described here are used in implementing interactive Calc commands. Note that this list is not exhaustive! If there is an existing command that behaves similarly to the one you want to define, you may find helpful tricks by checking the source code for that command.

Function: calc-set-command-flag flag ¶
Set the command flag flag. This is generally a Lisp symbol, but may in fact be anything. The effect is to add flag to the list stored in the variable calc-command-flags, unless it is already there. See Defining New Simple Commands.

Function: calc-clear-command-flag flag ¶
If flag appears among the list of currently-set command flags, remove it from that list.

Function: calc-record-undo rec ¶
Add the “undo record” rec to the list of steps to take if the current operation should need to be undone. Stack push and pop functions automatically call calc-record-undo, so the kinds of undo records you might need to create take the form ‘(set sym value)’, which says that the Lisp variable sym was changed and had previously contained value; ‘(store var value)’ which says that the Calc variable var (a string which is the name of the symbol that contains the variable’s value) was stored and its previous value was value (either a Calc data object, or nil if the variable was previously void); or ‘(eval undo redo args …)’, which means that to undo requires calling the function ‘(undo args …)’ and, if the undo is later redone, calling ‘(redo args …)’.

Function: calc-record-why msg args ¶
Record the error or warning message msg, which is normally a string. This message will be replayed if the user types w (calc-why); if the message string begins with a ‘*’, it is considered important enough to display even if the user doesn’t type w. If one or more args are present, the displayed message will be of the form, ‘msg: arg1, arg2, …’, where the arguments are formatted on the assumption that they are either strings or Calc objects of some sort. If msg is a symbol, it is the name of a Calc predicate (such as integerp or numvecp) which the arguments did not satisfy; it is expanded to a suitable string such as “Expected an integer.” The reject-arg function calls calc-record-why automatically; see Predicates.

Function: calc-is-inverse ¶
This predicate returns true if the current command is inverse, i.e., if the Inverse (I key) flag was set.

Function: calc-is-hyperbolic ¶
This predicate is the analogous function for the H key.


***** Stack-Oriented Functions

The functions described here perform various operations on the Calc stack and trail. They are to be used in interactive Calc commands.

Function: calc-push-list vals n ¶
Push the Calc objects in list vals onto the stack at stack level n. If n is omitted it defaults to 1, so that the elements are pushed at the top of the stack. If n is greater than 1, the elements will be inserted into the stack so that the last element will end up at level n, the next-to-last at level n+1, etc. The elements of vals are assumed to be valid Calc objects, and are not evaluated, rounded, or renormalized in any way. If vals is an empty list, nothing happens.

The stack elements are pushed without any sub-formula selections. You can give an optional third argument to this function, which must be a list the same size as vals of selections. Each selection must be eq to some sub-formula of the corresponding formula in vals, or nil if that formula should have no selection.

Function: calc-top-list n m ¶
Return a list of the n objects starting at level m of the stack. If m is omitted it defaults to 1, so that the elements are taken from the top of the stack. If n is omitted, it also defaults to 1, so that the top stack element (in the form of a one-element list) is returned. If m is greater than 1, the mth stack element will be at the end of the list, the m+1st element will be next-to-last, etc. If n or m are out of range, the command is aborted with a suitable error message. If n is zero, the function returns an empty list. The stack elements are not evaluated, rounded, or renormalized.

If any stack elements contain selections, and selections have not been disabled by the j e (calc-enable-selections) command, this function returns the selected portions rather than the entire stack elements. It can be given a third “selection-mode” argument which selects other behaviors. If it is the symbol t, then a selection in any of the requested stack elements produces an “invalid operation on selections” error. If it is the symbol full, the whole stack entry is always returned regardless of selections. If it is the symbol sel, the selected portion is always returned, or nil if there is no selection. (This mode ignores the j e command.) If the symbol is entry, the complete stack entry in list form is returned; the first element of this list will be the whole formula, and the third element will be the selection (or nil).

Function: calc-pop-stack n m ¶
Remove the specified elements from the stack. The parameters n and m are defined the same as for calc-top-list. The return value of calc-pop-stack is uninteresting.

If there are any selected sub-formulas among the popped elements, and j e has not been used to disable selections, this produces an error without changing the stack. If you supply an optional third argument of t, the stack elements are popped even if they contain selections.

Function: calc-record-list vals tag ¶
This function records one or more results in the trail. The vals are a list of strings or Calc objects. The tag is the four-character tag string to identify the values. If tag is omitted, a blank tag will be used.

Function: calc-normalize n ¶
This function takes a Calc object and “normalizes” it. At the very least this involves re-rounding floating-point values according to the current precision and other similar jobs. Also, unless the user has selected No-Simplify mode (see Simplification Modes), this involves actually evaluating a formula object by executing the function calls it contains, and possibly also doing algebraic simplification, etc.

Function: calc-top-list-n n m ¶
This function is identical to calc-top-list, except that it calls calc-normalize on the values that it takes from the stack. They are also passed through check-complete, so that incomplete objects will be rejected with an error message. All computational commands should use this in preference to calc-top-list; the only standard Calc commands that operate on the stack without normalizing are stack management commands like calc-enter and calc-roll-up. This function accepts the same optional selection-mode argument as calc-top-list.

Function: calc-top-n m ¶
This function is a convenient form of calc-top-list-n in which only a single element of the stack is taken and returned, rather than a list of elements. This also accepts an optional selection-mode argument.

Function: calc-enter-result n tag vals ¶
This function is a convenient interface to most of the above functions. The vals argument should be either a single Calc object, or a list of Calc objects; the object or objects are normalized, and the top n stack entries are replaced by the normalized objects. If tag is non-nil, the normalized objects are also recorded in the trail. A typical stack-based computational command would take the form,

(calc-enter-result n tag (cons 'calcFunc-func
                               (calc-top-list-n n)))
If any of the n stack elements replaced contain sub-formula selections, and selections have not been disabled by j e, this function takes one of two courses of action. If n is equal to the number of elements in vals, then each element of vals is spliced into the corresponding selection; this is what happens when you use the TAB key, or when you use a unary arithmetic operation like sqrt. If vals has only one element but n is greater than one, there must be only one selection among the top n stack elements; the element from vals is spliced into that selection. This is what happens when you use a binary arithmetic operation like +. Any other combination of n and vals is an error when selections are present.

Function: calc-unary-op tag func arg ¶
This function implements a unary operator that allows a numeric prefix argument to apply the operator over many stack entries. If the prefix argument arg is nil, this uses calc-enter-result as outlined above. Otherwise, it maps the function over several stack elements; see Numeric Prefix Arguments. For example,

(defun calc-zeta (arg)
  (interactive "P")
  (calc-unary-op "zeta" 'calcFunc-zeta arg))
Function: calc-binary-op tag func arg ident unary ¶
This function implements a binary operator, analogously to calc-unary-op. The optional ident and unary arguments specify the behavior when the prefix argument is zero or one, respectively. If the prefix is zero, the value ident is pushed onto the stack, if specified, otherwise an error message is displayed. If the prefix is one, the unary function unary is applied to the top stack element, or, if unary is not specified, nothing happens. When the argument is two or more, the binary function func is reduced across the top arg stack elements; when the argument is negative, the function is mapped between the next-to-top -arg stack elements and the top element.

Function: calc-stack-size ¶
Return the number of elements on the stack as an integer. This count does not include elements that have been temporarily hidden by stack truncation; see Truncating the Stack.

Function: calc-cursor-stack-index n ¶
Move the point to the nth stack entry. If n is zero, this will be the ‘.’ line. If n is from 1 to the current stack size, this will be the beginning of the first line of that stack entry’s display. If line numbers are enabled, this will move to the first character of the line number, not the stack entry itself.

Function: calc-substack-height n ¶
Return the number of lines between the beginning of the nth stack entry and the bottom of the buffer. If n is zero, this will be one (assuming no stack truncation). If all stack entries are one line long (i.e., no matrices are displayed), the return value will be equal n+1 as long as n is in range. (Note that in Big mode, the return value includes the blank lines that separate stack entries.)

Function: calc-refresh ¶
Erase the *Calculator* buffer and reformat its contents from memory. This must be called after changing any parameter, such as the current display radix, which might change the appearance of existing stack entries. (During a keyboard macro invoked by the X key, refreshing is suppressed, but a flag is set so that the entire stack will be refreshed rather than just the top few elements when the macro finishes.)


***** Predicates

The functions described here are predicates, that is, they return a true/false value where nil means false and anything else means true. These predicates are expanded by defmath, for example, from zerop to math-zerop. In many cases they correspond to native Lisp functions by the same name, but are extended to cover the full range of Calc data types.

Function: zerop x ¶
Returns true if x is numerically zero, in any of the Calc data types. (Note that for some types, such as error forms and intervals, it never makes sense to return true.) In defmath, the expression ‘(= x 0)’ will automatically be converted to ‘(math-zerop x)’, and ‘(/= x 0)’ will be converted to ‘(not (math-zerop x))’.

Function: negp x ¶
Returns true if x is negative. This accepts negative real numbers of various types, negative HMS and date forms, and intervals in which all included values are negative. In defmath, the expression ‘(< x 0)’ will automatically be converted to ‘(math-negp x)’, and ‘(>= x 0)’ will be converted to ‘(not (math-negp x))’.

Function: posp x ¶
Returns true if x is positive (and non-zero). For complex numbers, none of these three predicates will return true.

Function: looks-negp x ¶
Returns true if x is “negative-looking.” This returns true if x is a negative number, or a formula with a leading minus sign such as ‘-a/b’. In other words, this is an object which can be made simpler by calling (- x).

Function: integerp x ¶
Returns true if x is an integer of any size.

Function: fixnump x ¶
Returns true if x is a native Lisp fixnum.

Function: natnump x ¶
Returns true if x is a nonnegative integer of any size.

Function: fixnatnump x ¶
Returns true if x is a nonnegative Lisp fixnum.

Function: num-integerp x ¶
Returns true if x is numerically an integer, i.e., either a true integer or a float with no significant digits to the right of the decimal point.

Function: messy-integerp x ¶
Returns true if x is numerically, but not literally, an integer. A value is num-integerp if it is integerp or messy-integerp (but it is never both at once).

Function: num-natnump x ¶
Returns true if x is numerically a nonnegative integer.

Function: evenp x ¶
Returns true if x is an even integer.

Function: looks-evenp x ¶
Returns true if x is an even integer, or a formula with a leading multiplicative coefficient which is an even integer.

Function: oddp x ¶
Returns true if x is an odd integer.

Function: ratp x ¶
Returns true if x is a rational number, i.e., an integer or a fraction.

Function: realp x ¶
Returns true if x is a real number, i.e., an integer, fraction, or floating-point number.

Function: anglep x ¶
Returns true if x is a real number or HMS form.

Function: floatp x ¶
Returns true if x is a float, or a complex number, error form, interval, date form, or modulo form in which at least one component is a float.

Function: complexp x ¶
Returns true if x is a rectangular or polar complex number (but not a real number).

Function: rect-complexp x ¶
Returns true if x is a rectangular complex number.

Function: polar-complexp x ¶
Returns true if x is a polar complex number.

Function: numberp x ¶
Returns true if x is a real number or a complex number.

Function: scalarp x ¶
Returns true if x is a real or complex number or an HMS form.

Function: vectorp x ¶
Returns true if x is a vector (this simply checks if its argument is a list whose first element is the symbol vec).

Function: numvecp x ¶
Returns true if x is a number or vector.

Function: matrixp x ¶
Returns true if x is a matrix, i.e., a vector of one or more vectors, all of the same size.

Function: square-matrixp x ¶
Returns true if x is a square matrix.

Function: objectp x ¶
Returns true if x is any numeric Calc object, including real and complex numbers, HMS forms, date forms, error forms, intervals, and modulo forms. (Note that error forms and intervals may include formulas as their components; see constp below.)

Function: objvecp x ¶
Returns true if x is an object or a vector. This also accepts incomplete objects, but it rejects variables and formulas (except as mentioned above for objectp).

Function: primp x ¶
Returns true if x is a “primitive” or “atomic” Calc object, i.e., one whose components cannot be regarded as sub-formulas. This includes variables, and all objectp types except error forms and intervals.

Function: constp x ¶
Returns true if x is constant, i.e., a real or complex number, HMS form, date form, or error form, interval, or vector all of whose components are constp.

Function: lessp x y ¶
Returns true if x is numerically less than y. Returns false if x is greater than or equal to y, or if the order is undefined or cannot be determined. Generally speaking, this works by checking whether ‘x - y’ is negp. In defmath, the expression ‘(< x y)’ will automatically be converted to ‘(lessp x y)’; expressions involving >, <=, and >= are similarly converted in terms of lessp.

Function: beforep x y ¶
Returns true if x comes before y in a canonical ordering of Calc objects. If x and y are both real numbers, this will be the same as lessp. But whereas lessp considers other types of objects to be unordered, beforep puts any two objects into a definite, consistent order. The beforep function is used by the V S vector-sorting command, and also by Calc’s algebraic simplifications to put the terms of a product into canonical order: This allows ‘x y + y x’ to be simplified easily to ‘2 x y’.

Function: equal x y ¶
This is the standard Lisp equal predicate; it returns true if x and y are structurally identical. This is the usual way to compare numbers for equality, but note that equal will treat 0 and 0.0 as different.

Function: math-equal x y ¶
Returns true if x and y are numerically equal, either because they are equal, or because their difference is zerop. In defmath, the expression ‘(= x y)’ will automatically be converted to ‘(math-equal x y)’.

Function: equal-int x n ¶
Returns true if x and n are numerically equal, where n is an integer which is not a multiple of 10. This will automatically be used by defmath in place of the more general math-equal whenever possible.

Function: nearly-equal x y ¶
Returns true if x and y, as floating-point numbers, are equal except possibly in the last decimal place. For example, 314.159 and 314.166 are considered nearly equal if the current precision is 6 (since they differ by 7 units), but not if the current precision is 7 (since they differ by 70 units). Most functions which use series expansions use with-extra-prec to evaluate the series with 2 extra digits of precision, then use nearly-equal to decide when the series has converged; this guards against cumulative error in the series evaluation without doing extra work which would be lost when the result is rounded back down to the current precision. In defmath, this can be written ‘(~= x y)’. The x and y can be numbers of any kind, including complex.

Function: nearly-zerop x y ¶
Returns true if x is nearly zero, compared to y. This checks whether x plus y would by be nearly-equal to y itself, to within the current precision, in other words, if adding x to y would have a negligible effect on y due to roundoff error. X may be a real or complex number, but y must be real.

Function: is-true x ¶
Return true if the formula x represents a true value in Calc, not Lisp, terms. It tests if x is a non-zero number or a provably non-zero formula.

Function: reject-arg val pred ¶
Abort the current function evaluation due to unacceptable argument values. This calls ‘(calc-record-why pred val)’, then signals a Lisp error which normalize will trap. The net effect is that the function call which led here will be left in symbolic form.

Function: inexact-value ¶
If Symbolic mode is enabled, this will signal an error that causes normalize to leave the formula in symbolic form, with the message “Inexact result.” (This function has no effect when not in Symbolic mode.) Note that if your function calls ‘(sin 5)’ in Symbolic mode, the sin function will call inexact-value, which will cause your function to be left unsimplified. You may instead wish to call ‘(normalize (list 'calcFunc-sin 5))’, which in Symbolic mode will return the formula ‘sin(5)’ to your function.

Function: overflow ¶
This signals an error that will be reported as a floating-point overflow.

Function: underflow ¶
This signals a floating-point underflow.


***** Computational Functions

The functions described here do the actual computational work of the Calculator. In addition to these, note that any function described in the main body of this manual may be called from Lisp; for example, if the documentation refers to the calc-sqrt [sqrt] command, this means calc-sqrt is an interactive stack-based square-root command and sqrt (which defmath expands to calcFunc-sqrt) is the actual Lisp function for taking square roots.

The functions math-add, math-sub, math-mul, math-div, math-mod, and math-neg are not included in this list, since defmath allows you to write native Lisp +, -, *, /, %, and unary -, respectively, instead.

Function: normalize val ¶
(Full form: math-normalize.) Reduce the value val to standard form. Variables are left alone, but function calls are actually evaluated in formulas. For example, normalizing ‘(+ 2 (calcFunc-abs -4))’ will return 6.

If a function call fails, because the function is void or has the wrong number of parameters, or because it returns nil or calls reject-arg or inexact-result, normalize returns the formula still in symbolic form.

If the current simplification mode is “none” or “numeric arguments only,” normalize will act appropriately. However, the more powerful simplification modes (like Algebraic Simplification) are not handled by normalize. They are handled by calc-normalize, which calls normalize and possibly some other routines, such as simplify or simplify-units. Programs generally will never call calc-normalize except when popping or pushing values on the stack.

Function: evaluate-expr expr ¶
Replace all variables in expr that have values with their values, then use normalize to simplify the result. This is what happens when you press the = key interactively.

Macro: with-extra-prec n body ¶
Evaluate the Lisp forms in body with precision increased by n digits. This is a macro which expands to

(math-normalize
  (let ((calc-internal-prec (+ calc-internal-prec n)))
    body))
The surrounding call to math-normalize causes a floating-point result to be rounded down to the original precision afterwards. This is important because some arithmetic operations assume a number’s mantissa contains no more digits than the current precision allows.

Function: make-frac n d ¶
Build a fraction ‘n:d’. This is equivalent to calling ‘(normalize (list 'frac n d))’, but more efficient.

Function: make-float mant exp ¶
Build a floating-point value out of mant and exp, both of which are arbitrary integers. This function will return a properly normalized float value, or signal an overflow or underflow if exp is out of range.

Function: make-sdev x sigma ¶
Build an error form out of x and the absolute value of sigma. If sigma is zero, the result is the number x directly. If sigma is negative or complex, its absolute value is used. If x or sigma is not a valid type of object for use in error forms, this calls reject-arg.

Function: make-intv mask lo hi ¶
Build an interval form out of mask (which is assumed to be an integer from 0 to 3), and the limits lo and hi. If lo is greater than hi, an empty interval form is returned. This calls reject-arg if lo or hi is unsuitable.

Function: sort-intv mask lo hi ¶
Build an interval form, similar to make-intv, except that if lo is less than hi they are simply exchanged, and the bits of mask are swapped accordingly.

Function: make-mod n m ¶
Build a modulo form out of n and the modulus m. Since modulo forms do not allow formulas as their components, if n or m is not a real number or HMS form the result will be a formula which is a call to makemod, the algebraic version of this function.

Function: float x ¶
Convert x to floating-point form. Integers and fractions are converted to numerically equivalent floats; components of complex numbers, vectors, HMS forms, date forms, error forms, intervals, and modulo forms are recursively floated. If the argument is a variable or formula, this calls reject-arg.

Function: compare x y ¶
Compare the numbers x and y, and return -1 if ‘(lessp x y)’, 1 if ‘(lessp y x)’, 0 if ‘(math-equal x y)’, or 2 if the order is undefined or cannot be determined.

Function: numdigs n ¶
Return the number of digits of integer n, effectively ‘ceil(log10(n))’, but much more efficient. Zero is considered to have zero digits.

Function: scale-int x n ¶
Shift integer x left n decimal digits, or right -n digits with truncation toward zero.

Function: scale-rounding x n ¶
Like scale-int, except that a right shift rounds to the nearest integer rather than truncating.

Function: fixnum n ¶
Return the integer n as a fixnum, i.e., a small Lisp integer. If n is outside the permissible range for Lisp fixnums (usually 62 binary bits) the result is undefined.

Function: sqr x ¶
Compute the square of x; short for ‘(* x x)’.

Function: quotient x y ¶
Divide integer x by integer y; return an integer quotient and discard the remainder. If x or y is negative, the direction of rounding is undefined.

Function: idiv x y ¶
Perform an integer division; if x and y are both nonnegative integers, this uses the quotient function, otherwise it computes ‘floor(x/y)’. Thus the result is well-defined but slower than for quotient.

Function: imod x y ¶
Divide integer x by integer y; return the integer remainder and discard the quotient. Like quotient, this works only for integer arguments and is not well-defined for negative arguments. For a more well-defined result, use ‘(% x y)’.

Function: idivmod x y ¶
Divide integer x by integer y; return a cons cell whose car is ‘(quotient x y)’ and whose cdr is ‘(imod x y)’.

Function: pow x y ¶
Compute x to the power y. In defmath code, this can also be written ‘(^ x y)’ or ‘(expt x y)’.

Function: abs-approx x ¶
Compute a fast approximation to the absolute value of x. For example, for a rectangular complex number the result is the sum of the absolute values of the components.

Function: pi ¶
The function ‘(pi)’ computes ‘pi’ to the current precision. Other related constant-generating functions are two-pi, pi-over-2, pi-over-4, pi-over-180, sqrt-two-pi, e, sqrt-e, ln-2, ln-10, phi and gamma-const. Each function returns a floating-point value in the current precision, and each uses caching so that all calls after the first are essentially free.

Macro: math-defcache func initial form ¶
This macro, usually used as a top-level call like defun or defvar, defines a new cached constant analogous to pi, etc. It defines a function func which returns the requested value; if initial is non-nil it must be a ‘(float …)’ form which serves as an initial value for the cache. If func is called when the cache is empty or does not have enough digits to satisfy the current precision, the Lisp expression form is evaluated with the current precision increased by four, and the result minus its two least significant digits is stored in the cache. For example, calling ‘(pi)’ with a precision of 30 computes ‘pi’ to 34 digits, rounds it down to 32 digits for future use, then rounds it again to 30 digits for use in the present request.

Function: full-circle symb ¶
If the current angular mode is Degrees or HMS, this function returns the integer 360. In Radians mode, this function returns either the corresponding value in radians to the current precision, or the formula ‘2*pi’, depending on the Symbolic mode. There are also similar function half-circle and quarter-circle.

Function: power-of-2 n ¶
Compute two to the integer power n, as a (potentially very large) integer. Powers of two are cached, so only the first call for a particular n is expensive.

Function: integer-log2 n ¶
Compute the base-2 logarithm of n, which must be an integer which is a power of two. If n is not a power of two, this function will return nil.

Function: div-mod a b m ¶
Divide a by b, modulo m. This returns nil if there is no solution, or if any of the arguments are not integers.

Function: pow-mod a b m ¶
Compute a to the power b, modulo m. If a, b, and m are integers, this uses an especially efficient algorithm. Otherwise, it simply computes ‘(% (^ a b) m)’.

Function: isqrt n ¶
Compute the integer square root of n. This is the square root of n rounded down toward zero, i.e., ‘floor(sqrt(n))’. If n is itself an integer, the computation is especially efficient.

Function: to-hms a ang ¶
Convert the argument a into an HMS form. If ang is specified, it is the angular mode in which to interpret a, either deg or rad. Otherwise, the current angular mode is used. If a is already an HMS form it is returned as-is.

Function: from-hms a ang ¶
Convert the HMS form a into a real number. If ang is specified, it is the angular mode in which to express the result, otherwise the current angular mode is used. If a is already a real number, it is returned as-is.

Function: to-radians a ¶
Convert the number or HMS form a to radians from the current angular mode.

Function: from-radians a ¶
Convert the number a from radians to the current angular mode. If a is a formula, this returns the formula ‘deg(a)’.

Function: to-radians-2 a ¶
Like to-radians, except that in Symbolic mode a degrees to radians conversion yields a formula like ‘a*pi/180’.

Function: from-radians-2 a ¶
Like from-radians, except that in Symbolic mode a radians to degrees conversion yields a formula like ‘a*180/pi’.

Function: random-digit ¶
Produce a random base-1000 digit in the range 0 to 999.

Function: random-digits n ¶
Produce a random n-digit integer; this will be an integer in the interval ‘[0, 10^n)’.

Function: random-float ¶
Produce a random float in the interval ‘[0, 1)’.

Function: prime-test n iters ¶
Determine whether the integer n is prime. Return a list which has one of these forms: ‘(nil f)’ means the number is non-prime because it was found to be divisible by f; ‘(nil)’ means it was found to be non-prime by table look-up (so no factors are known); ‘(nil unknown)’ means it is definitely non-prime but no factors are known because n was large enough that Fermat’s probabilistic test had to be used; ‘(t)’ means the number is definitely prime; and ‘(maybe i p)’ means that Fermat’s test, after i iterations, is p percent sure that the number is prime. The iters parameter is the number of Fermat iterations to use, in the case that this is necessary. If prime-test returns “maybe,” you can call it again with the same n to get a greater certainty; prime-test remembers where it left off.

Function: to-simple-fraction f ¶
If f is a floating-point number which can be represented exactly as a small rational number, return that number, else return f. For example, 0.75 would be converted to 3:4. This function is very fast.

Function: to-fraction f tol ¶
Find a rational approximation to floating-point number f to within a specified tolerance tol; this corresponds to the algebraic function frac, and can be rather slow.

Function: quarter-integer n ¶
If n is an integer or integer-valued float, this function returns zero. If n is a half-integer (i.e., an integer plus 1:2 or 0.5), it returns 2. If n is a quarter-integer, it returns 1 or 3. If n is anything else, this function returns nil.


***** Vector Functions

The functions described here perform various operations on vectors and matrices.

Function: math-concat x y ¶
Do a vector concatenation; this operation is written ‘x | y’ in a symbolic formula. See Building Vectors.

Function: vec-length v ¶
Return the length of vector v. If v is not a vector, the result is zero. If v is a matrix, this returns the number of rows in the matrix.

Function: mat-dimens m ¶
Determine the dimensions of vector or matrix m. If m is not a vector, the result is an empty list. If m is a plain vector but not a matrix, the result is a one-element list containing the length of the vector. If m is a matrix with r rows and c columns, the result is the list ‘(r c)’. Higher-order tensors produce lists of more than two dimensions. Note that the object ‘[[1, 2, 3], [4, 5]]’ is a vector of vectors not all the same size, and is treated by this and other Calc routines as a plain vector of two elements.

Function: dimension-error ¶
Abort the current function with a message of “Dimension error.” The Calculator will leave the function being evaluated in symbolic form; this is really just a special case of reject-arg.

Function: build-vector args ¶
Return a Calc vector with args as elements. For example, ‘(build-vector 1 2 3)’ returns the Calc vector ‘[1, 2, 3]’, stored internally as the list ‘(vec 1 2 3)’.

Function: make-vec obj dims ¶
Return a Calc vector or matrix all of whose elements are equal to obj. For example, ‘(make-vec 27 3 4)’ returns a 3x4 matrix filled with 27’s.

Function: row-matrix v ¶
If v is a plain vector, convert it into a row matrix, i.e., a matrix whose single row is v. If v is already a matrix, leave it alone.

Function: col-matrix v ¶
If v is a plain vector, convert it into a column matrix, i.e., a matrix with each element of v as a separate row. If v is already a matrix, leave it alone.

Function: map-vec f v ¶
Map the Lisp function f over the Calc vector v. For example, ‘(map-vec 'math-floor v)’ returns a vector of the floored components of vector v.

Function: map-vec-2 f a b ¶
Map the Lisp function f over the two vectors a and b. If a and b are vectors of equal length, the result is a vector of the results of calling ‘(f ai bi)’ for each pair of elements ai and bi. If either a or b is a scalar, it is matched with each value of the other vector. For example, ‘(map-vec-2 'math-add v 1)’ returns the vector v with each element increased by one. Note that using ‘'+’ would not work here, since defmath does not expand function names everywhere, just where they are in the function position of a Lisp expression.

Function: reduce-vec f v ¶
Reduce the function f over the vector v. For example, if v is ‘[10, 20, 30, 40]’, this calls ‘(f (f (f 10 20) 30) 40)’. If v is a matrix, this reduces over the rows of v.

Function: reduce-cols f m ¶
Reduce the function f over the columns of matrix m. For example, if m is ‘[[1, 2], [3, 4], [5, 6]]’, the result is a vector of the two elements ‘(f (f 1 3) 5)’ and ‘(f (f 2 4) 6)’.

Function: mat-row m n ¶
Return the nth row of matrix m. This is equivalent to ‘(elt m n)’. For a slower but safer version, use mrow. (See Extracting Vector Elements.)

Function: mat-col m n ¶
Return the nth column of matrix m, in the form of a vector. The arguments are not checked for correctness.

Function: mat-less-row m n ¶
Return a copy of matrix m with its nth row deleted. The number n must be in range from 1 to the number of rows in m.

Function: mat-less-col m n ¶
Return a copy of matrix m with its nth column deleted.

Function: transpose m ¶
Return the transpose of matrix m.

Function: flatten-vector v ¶
Flatten nested vector v into a vector of scalars. For example, if v is ‘[[1, 2, 3], [4, 5]]’ the result is ‘[1, 2, 3, 4, 5]’.

Function: copy-matrix m ¶
If m is a matrix, return a copy of m. This maps copy-sequence over the rows of m; in Lisp terms, each element of the result matrix will be eq to the corresponding element of m, but none of the cons cells that make up the structure of the matrix will be eq. If m is a plain vector, this is the same as copy-sequence.

Function: swap-rows m r1 r2 ¶
Exchange rows r1 and r2 of matrix m in-place. In other words, unlike most of the other functions described here, this function changes m itself rather than building up a new result matrix. The return value is m, i.e., ‘(eq (swap-rows m 1 2) m)’ is true, with the side effect of exchanging the first two rows of m.


***** Symbolic Functions

The functions described here operate on symbolic formulas in the Calculator.

Function: calc-prepare-selection num ¶
Prepare a stack entry for selection operations. If num is omitted, the stack entry containing the cursor is used; otherwise, it is the number of the stack entry to use. This function stores useful information about the current stack entry into a set of variables. calc-selection-cache-num contains the number of the stack entry involved (equal to num if you specified it); calc-selection-cache-entry contains the stack entry as a list (such as calc-top-list would return with entry as the selection mode); and calc-selection-cache-comp contains a special “tagged” composition (see I/O and Formatting Functions) which allows Calc to relate cursor positions in the buffer with their corresponding sub-formulas.

A slight complication arises in the selection mechanism because formulas may contain small integers. For example, in the vector ‘[1, 2, 1]’ the first and last elements are eq to each other; selections are recorded as the actual Lisp object that appears somewhere in the tree of the whole formula, but storing 1 would falsely select both 1’s in the vector. So calc-prepare-selection also checks the stack entry and replaces any plain integers with “complex number” lists of the form ‘(cplx n 0)’. This list will be displayed the same as a plain n and the change will be completely invisible to the user, but it will guarantee that no two sub-formulas of the stack entry will be eq to each other. Next time the stack entry is involved in a computation, calc-normalize will replace these lists with plain numbers again, again invisibly to the user.

Function: calc-encase-atoms x ¶
This modifies the formula x to ensure that each part of the formula is a unique atom, using the ‘(cplx n 0)’ trick described above. This function may use setcar to modify the formula in-place.

Function: calc-find-selected-part ¶
Find the smallest sub-formula of the current formula that contains the cursor. This assumes calc-prepare-selection has been called already. If the cursor is not actually on any part of the formula, this returns nil.

Function: calc-change-current-selection selection ¶
Change the currently prepared stack element’s selection to selection, which should be eq to some sub-formula of the stack element, or nil to unselect the formula. The stack element’s appearance in the Calc buffer is adjusted to reflect the new selection.

Function: calc-find-nth-part expr n ¶
Return the nth sub-formula of expr. This function is used by the selection commands, and (unless j b has been used) treats sums and products as flat many-element formulas. Thus if expr is ‘((a + b) - c) + d’, calling calc-find-nth-part with n equal to four will return ‘d’.

Function: calc-find-parent-formula expr part ¶
Return the sub-formula of expr which immediately contains part. If expr is ‘a*b + (c+1)*d’ and part is eq to the ‘c+1’ term of expr, then this function will return ‘(c+1)*d’. If part turns out not to be a sub-formula of expr, the function returns nil. If part is eq to expr, the function returns t. This function does not take associativity into account.

Function: calc-find-assoc-parent-formula expr part ¶
This is the same as calc-find-parent-formula, except that (unless j b has been used) it continues widening the selection to contain a complete level of the formula. Given ‘a’ from ‘((a + b) - c) + d’, calc-find-parent-formula will return ‘a + b’ but calc-find-assoc-parent-formula will return the whole expression.

Function: calc-grow-assoc-formula expr part ¶
This expands sub-formula part of expr to encompass a complete level of the formula. If part and its immediate parent are not compatible associative operators, or if j b has been used, this simply returns part.

Function: calc-find-sub-formula expr part ¶
This finds the immediate sub-formula of expr which contains part. It returns an index n such that ‘(calc-find-nth-part expr n)’ would return part. If part is not a sub-formula of expr, it returns nil. If part is eq to expr, it returns t. This function does not take associativity into account.

Function: calc-replace-sub-formula expr old new ¶
This function returns a copy of formula expr, with the sub-formula that is eq to old replaced by new.

Function: simplify expr ¶
Simplify the expression expr by applying Calc’s algebraic simplifications. This always returns a copy of the expression; the structure expr points to remains unchanged in memory.

More precisely, here is what simplify does: The expression is first normalized and evaluated by calling normalize. If any AlgSimpRules have been defined, they are then applied. Then the expression is traversed in a depth-first, bottom-up fashion; at each level, any simplifications that can be made are made until no further changes are possible. Once the entire formula has been traversed in this way, it is compared with the original formula (from before the call to normalize) and, if it has changed, the entire procedure is repeated (starting with normalize) until no further changes occur. Usually only two iterations are needed: one to simplify the formula, and another to verify that no further simplifications were possible.

Function: simplify-extended expr ¶
Simplify the expression expr, with additional rules enabled that help do a more thorough job, while not being entirely “safe” in all circumstances. (For example, this mode will simplify ‘sqrt(x^2)’ to ‘x’, which is only valid when x is positive.) This is implemented by temporarily binding the variable math-living-dangerously to t (using a let form) and calling simplify. Dangerous simplification rules are written to check this variable before taking any action.

Function: simplify-units expr ¶
Simplify the expression expr, treating variable names as units whenever possible. This works by binding the variable math-simplifying-units to t while calling simplify.

Macro: math-defsimplify funcs body ¶
Register a new simplification rule; this is normally called as a top-level form, like defun or defmath. If funcs is a symbol (like + or calcFunc-sqrt), this simplification rule is applied to the formulas which are calls to the specified function. Or, funcs can be a list of such symbols; the rule applies to all functions on the list. The body is written like the body of a function with a single argument called expr. The body will be executed with expr bound to a formula which is a call to one of the functions funcs. If the function body returns nil, or if it returns a result equal to the original expr, it is ignored and Calc goes on to try the next simplification rule that applies. If the function body returns something different, that new formula is substituted for expr in the original formula.

At each point in the formula, rules are tried in the order of the original calls to math-defsimplify; the search stops after the first rule that makes a change. Thus later rules for that same function will not have a chance to trigger until the next iteration of the main simplify loop.

Note that, since defmath is not being used here, body must be written in true Lisp code without the conveniences that defmath provides. If you prefer, you can have body simply call another function (defined with defmath) which does the real work.

The arguments of a function call will already have been simplified before any rules for the call itself are invoked. Since a new argument list is consed up when this happens, this means that the rule’s body is allowed to rearrange the function’s arguments destructively if that is convenient. Here is a typical example of a simplification rule:

(math-defsimplify calcFunc-arcsinh
  (or (and (math-looks-negp (nth 1 expr))
           (math-neg (list 'calcFunc-arcsinh
                           (math-neg (nth 1 expr)))))
      (and (eq (car-safe (nth 1 expr)) 'calcFunc-sinh)
           (or math-living-dangerously
               (math-known-realp (nth 1 (nth 1 expr))))
           (nth 1 (nth 1 expr)))))
This is really a pair of rules written with one math-defsimplify for convenience; the first replaces ‘arcsinh(-x)’ with ‘-arcsinh(x)’, and the second, which is safe only for real ‘x’, replaces ‘arcsinh(sinh(x))’ with ‘x’.

Function: common-constant-factor expr ¶
Check expr to see if it is a sum of terms all multiplied by the same rational value. If so, return this value. If not, return nil. For example, if called on ‘6x + 9y + 12z’, it would return 3, since 3 is a common factor of all the terms.

Function: cancel-common-factor expr factor ¶
Assuming expr is a sum with factor as a common factor, divide each term of the sum by factor. This is done by destructively modifying parts of expr, on the assumption that it is being used by a simplification rule (where such things are allowed; see above). For example, consider this built-in rule for square roots:

(math-defsimplify calcFunc-sqrt
  (let ((fac (math-common-constant-factor (nth 1 expr))))
    (and fac (not (eq fac 1))
         (math-mul (math-normalize (list 'calcFunc-sqrt fac))
                   (math-normalize
                    (list 'calcFunc-sqrt
                          (math-cancel-common-factor
                           (nth 1 expr) fac)))))))
Function: frac-gcd a b ¶
Compute a “rational GCD” of a and b, which must both be rational numbers. This is the fraction composed of the GCD of the numerators of a and b, over the GCD of the denominators. It is used by common-constant-factor. Note that the standard gcd function uses the LCM to combine the denominators.

Function: map-tree func expr many ¶
Try applying Lisp function func to various sub-expressions of expr. Initially, call func with expr itself as an argument. If this returns an expression which is not equal to expr, apply func again until eventually it does return expr with no changes. Then, if expr is a function call, recursively apply func to each of the arguments. This keeps going until no changes occur anywhere in the expression; this final expression is returned by map-tree. Note that, unlike simplification rules, func functions may not make destructive changes to expr. If a third argument many is provided, it is an integer which says how many times func may be applied; the default, as described above, is infinitely many times.

Function: compile-rewrites rules ¶
Compile the rewrite rule set specified by rules, which should be a formula that is either a vector or a variable name. If the latter, the compiled rules are saved so that later compile-rules calls for that same variable can return immediately. If there are problems with the rules, this function calls error with a suitable message.

Function: apply-rewrites expr crules heads ¶
Apply the compiled rewrite rule set crules to the expression expr. This will make only one rewrite and only checks at the top level of the expression. The result nil if no rules matched, or if the only rules that matched did not actually change the expression. The heads argument is optional; if is given, it should be a list of all function names that (may) appear in expr. The rewrite compiler tags each rule with the rarest-looking function name in the rule; if you specify heads, apply-rewrites can use this information to narrow its search down to just a few rules in the rule set.

Function: rewrite-heads expr ¶
Compute a heads list for expr suitable for use with apply-rewrites, as discussed above.

Function: rewrite expr rules many ¶
This is an all-in-one rewrite function. It compiles the rule set specified by rules, then uses map-tree to apply the rules throughout expr up to many (default infinity) times.

Function: match-patterns pat vec not-flag ¶
Given a Calc vector vec and an uncompiled pattern set or pattern set variable pat, this function returns a new vector of all elements of vec which do (or don’t, if not-flag is non-nil) match any of the patterns in pat.

Function: deriv expr var value symb ¶
Compute the derivative of expr with respect to variable var (which may actually be any sub-expression). If value is specified, the derivative is evaluated at the value of var; otherwise, the derivative is left in terms of var. If the expression contains functions for which no derivative formula is known, new derivative functions are invented by adding primes to the names; see Calculus. However, if symb is non-nil, the presence of nondifferentiable functions in expr instead cancels the whole differentiation, and deriv returns nil instead.

Derivatives of an n-argument function can be defined by adding a math-derivative-n property to the property list of the symbol for the function’s derivative, which will be the function name followed by an apostrophe. The value of the property should be a Lisp function; it is called with the same arguments as the original function call that is being differentiated. It should return a formula for the derivative. For example, the derivative of ln is defined by

(put 'calcFunc-ln\' 'math-derivative-1
     (lambda (u) (math-div 1 u)))
The two-argument log function has two derivatives,

(put 'calcFunc-log\' 'math-derivative-2     ; d(log(x,b)) / dx
     (lambda (x b) ... ))
(put 'calcFunc-log\'2 'math-derivative-2    ; d(log(x,b)) / db
     (lambda (x b) ... ))
Function: tderiv expr var value symb ¶
Compute the total derivative of expr. This is the same as deriv, except that variables other than var are not assumed to be constant with respect to var.

Function: integ expr var low high ¶
Compute the integral of expr with respect to var. See Calculus, for further details.

Macro: math-defintegral funcs body ¶
Define a rule for integrating a function or functions of one argument; this macro is very similar in format to math-defsimplify. The main difference is that here body is the body of a function with a single argument u which is bound to the argument to the function being integrated, not the function call itself. Also, the variable of integration is available as math-integ-var. If evaluation of the integral requires doing further integrals, the body should call ‘(math-integral x)’ to find the integral of x with respect to math-integ-var; this function returns nil if the integral could not be done. Some examples:

(math-defintegral calcFunc-conj
  (let ((int (math-integral u)))
    (and int
         (list 'calcFunc-conj int))))

(math-defintegral calcFunc-cos
  (and (equal u math-integ-var)
       (math-from-radians-2 (list 'calcFunc-sin u))))
In the cos example, we define only the integral of ‘cos(x) dx’, relying on the general integration-by-substitution facility to handle cosines of more complicated arguments. An integration rule should return nil if it can’t do the integral; if several rules are defined for the same function, they are tried in order until one returns a non-nil result.

Macro: math-defintegral-2 funcs body ¶
Define a rule for integrating a function or functions of two arguments. This is exactly analogous to math-defintegral, except that body is written as the body of a function with two arguments, u and v.

Function: solve-for lhs rhs var full ¶
Attempt to solve the equation ‘lhs = rhs’ by isolating the variable var on the lefthand side; return the resulting righthand side, or nil if the equation cannot be solved. The variable var must appear at least once in lhs or rhs. Note that the return value is a formula which does not contain var; this is different from the user-level solve and finv functions, which return a rearranged equation or a functional inverse, respectively. If full is non-nil, a full solution including dummy signs and dummy integers will be produced. User-defined inverses are provided as properties in a manner similar to derivatives:

(put 'calcFunc-ln 'math-inverse
     (lambda (x) (list 'calcFunc-exp x)))
This function can call ‘(math-solve-get-sign x)’ to create a new arbitrary sign variable, returning x times that sign, and ‘(math-solve-get-int x)’ to create a new arbitrary integer variable multiplied by x. These functions simply return x if the caller requested a non-“full” solution.

Function: solve-eqn expr var full ¶
This version of solve-for takes an expression which will typically be an equation or inequality. (If it is not, it will be interpreted as the equation ‘expr = 0’.) It returns an equation or inequality, or nil if no solution could be found.

Function: solve-system exprs vars full ¶
This function solves a system of equations. Generally, exprs and vars will be vectors of equal length. See Solving Systems of Equations, for other options.

Function: expr-contains expr var ¶
Returns a non-nil value if var occurs as a subexpression of expr.

This function might seem at first to be identical to calc-find-sub-formula. The key difference is that expr-contains uses equal to test for matches, whereas calc-find-sub-formula uses eq. In the formula ‘f(a, a)’, the two ‘a’s will be equal but not eq to each other.

Function: expr-contains-count expr var ¶
Returns the number of occurrences of var as a subexpression of expr, or nil if there are no occurrences.

Function: expr-depends expr var ¶
Returns true if expr refers to any variable the occurs in var. In other words, it checks if expr and var have any variables in common.

Function: expr-contains-vars expr ¶
Return true if expr contains any variables, or nil if expr contains only constants and functions with constant arguments.

Function: expr-subst expr old new ¶
Returns a copy of expr, with all occurrences of old replaced by new. This treats lambda forms specially with respect to the dummy argument variables, so that the effect is always to return expr evaluated at old = new.

Function: multi-subst expr old new ¶
This is like expr-subst, except that old and new are lists of expressions to be substituted simultaneously. If one list is shorter than the other, trailing elements of the longer list are ignored.

Function: expr-weight expr ¶
Returns the “weight” of expr, basically a count of the total number of objects and function calls that appear in expr. For “primitive” objects, this will be one.

Function: expr-height expr ¶
Returns the “height” of expr, which is the deepest level to which function calls are nested. (Note that ‘a + b’ counts as a function call.) For primitive objects, this returns zero.

Function: polynomial-p expr var ¶
Check if expr is a polynomial in variable (or sub-expression) var. If so, return the degree of the polynomial, that is, the highest power of var that appears in expr. For example, for ‘(x^2 + 3)^3 + 4’ this would return 6. This function returns nil unless expr, when expanded out by a x (calc-expand), would consist of a sum of terms in which var appears only raised to nonnegative integer powers. Note that if var does not occur in expr, then expr is considered a polynomial of degree 0.

Function: is-polynomial expr var degree loose ¶
Check if expr is a polynomial in variable or sub-expression var, and, if so, return a list representation of the polynomial where the elements of the list are coefficients of successive powers of var: ‘a + b x + c x^3’ would produce the list ‘(a b 0 c)’, and ‘(x + 1)^2’ would produce the list ‘(1 2 1)’. The highest element of the list will be non-zero, with the special exception that if expr is the constant zero, the returned value will be ‘(0)’. Return nil if expr is not a polynomial in var. If degree is specified, this will not consider polynomials of degree higher than that value. This is a good precaution because otherwise an input of ‘(x+1)^1000’ will cause a huge coefficient list to be built. If loose is non-nil, then a looser definition of a polynomial is used in which coefficients are no longer required not to depend on var, but are only required not to take the form of polynomials themselves. For example, ‘sin(x) x^2 + cos(x)’ is a loose polynomial with coefficients ‘((calcFunc-cos x) 0 (calcFunc-sin x))’. The result will never be nil in loose mode, since any expression can be interpreted as a “constant” loose polynomial.

Function: polynomial-base expr pred ¶
Check if expr is a polynomial in any variable that occurs in it; if so, return that variable. (If expr is a multivariate polynomial, this chooses one variable arbitrarily.) If pred is specified, it should be a Lisp function which is called as ‘(pred subexpr)’, and which should return true if mpb-top-expr (a global name for the original expr) is a suitable polynomial in subexpr. The default predicate uses ‘(polynomial-p mpb-top-expr subexpr)’; you can use pred to specify additional conditions. Or, you could have pred build up a list of every suitable subexpr that is found.

Function: poly-simplify poly ¶
Simplify polynomial coefficient list poly by (destructively) clipping off trailing zeros.

Function: poly-mix a ac b bc ¶
Mix two polynomial lists a and b (in the form returned by is-polynomial) in a linear combination with coefficient expressions ac and bc. The result is a (not necessarily simplified) polynomial list representing ‘ac a + bc b’.

Function: poly-mul a b ¶
Multiply two polynomial coefficient lists a and b. The result will be in simplified form if the inputs were simplified.

Function: build-polynomial-expr poly var ¶
Construct a Calc formula which represents the polynomial coefficient list poly applied to variable var. The a c (calc-collect) command uses is-polynomial to turn an expression into a coefficient list, then build-polynomial-expr to turn the list back into an expression in regular form.

Function: check-unit-name var ¶
Check if var is a variable which can be interpreted as a unit name. If so, return the units table entry for that unit. This will be a list whose first element is the unit name (not counting prefix characters) as a symbol and whose second element is the Calc expression which defines the unit. (Refer to the Calc sources for details on the remaining elements of this list.) If var is not a variable or is not a unit name, return nil.

Function: units-in-expr-p expr sub-exprs ¶
Return true if expr contains any variables which can be interpreted as units. If sub-exprs is t, the entire expression is searched. If sub-exprs is nil, this checks whether expr is directly a units expression.

Function: single-units-in-expr-p expr ¶
Check whether expr contains exactly one units variable. If so, return the units table entry for the variable. If expr does not contain any units, return nil. If expr contains two or more units, return the symbol wrong.

Function: to-standard-units expr which ¶
Convert units expression expr to base units. If which is nil, use Calc’s native base units. Otherwise, which can specify a units system, which is a list of two-element lists, where the first element is a Calc base symbol name and the second is an expression to substitute for it.

Function: remove-units expr ¶
Return a copy of expr with all units variables replaced by ones. This expression is generally normalized before use.

Function: extract-units expr ¶
Return a copy of expr with everything but units variables replaced by ones.


***** I/O and Formatting Functions

The functions described here are responsible for parsing and formatting Calc numbers and formulas.

Function: calc-eval str sep arg1 arg2 … ¶
This is the simplest interface to the Calculator from another Lisp program. See Calling Calc from Your Lisp Programs.

Function: read-number str ¶
If string str contains a valid Calc number, either integer, fraction, float, or HMS form, this function parses and returns that number. Otherwise, it returns nil.

Function: read-expr str ¶
Read an algebraic expression from string str. If str does not have the form of a valid expression, return a list of the form ‘(error pos msg)’ where pos is an integer index into str of the general location of the error, and msg is a string describing the problem.

Function: read-exprs str ¶
Read a list of expressions separated by commas, and return it as a Lisp list. If an error occurs in any expressions, an error list as shown above is returned instead.

Function: calc-do-alg-entry initial prompt no-norm ¶
Read an algebraic formula or formulas using the minibuffer. All conventions of regular algebraic entry are observed. The return value is a list of Calc formulas; there will be more than one if the user entered a list of values separated by commas. The result is nil if the user presses Return with a blank line. If initial is given, it is a string which the minibuffer will initially contain. If prompt is given, it is the prompt string to use; the default is “Algebraic:”. If no-norm is t, the formulas will be returned exactly as parsed; otherwise, they will be passed through calc-normalize first.

To support the use of $ characters in the algebraic entry, use let to bind calc-dollar-values to a list of the values to be substituted for $, $$, and so on, and bind calc-dollar-used to 0. Upon return, calc-dollar-used will have been changed to the highest number of consecutive $s that actually appeared in the input.

Function: format-number a ¶
Convert the real or complex number or HMS form a to string form.

Function: format-flat-expr a prec ¶
Convert the arbitrary Calc number or formula a to string form, in the style used by the trail buffer and the calc-edit command. This is a simple format designed mostly to guarantee the string is of a form that can be re-parsed by read-expr. Most formatting modes, such as digit grouping, complex number format, and point character, are ignored to ensure the result will be re-readable. The prec parameter is normally 0; if you pass a large integer like 1000 instead, the expression will be surrounded by parentheses unless it is a plain number or variable name.

Function: format-nice-expr a width ¶
This is like format-flat-expr (with prec equal to 0), except that newlines will be inserted to keep lines down to the specified width, and vectors that look like matrices or rewrite rules are written in a pseudo-matrix format. The calc-edit command uses this when only one stack entry is being edited.

Function: format-value a width ¶
Convert the Calc number or formula a to string form, using the format seen in the stack buffer. Beware the string returned may not be re-readable by read-expr, for example, because of digit grouping. Multi-line objects like matrices produce strings that contain newline characters to separate the lines. The w parameter, if given, is the target window size for which to format the expressions. If w is omitted, the width of the Calculator window is used.

Function: compose-expr a prec ¶
Format the Calc number or formula a according to the current language mode, returning a “composition.” To learn about the structure of compositions, see the comments in the Calc source code. You can specify the format of a given type of function call by putting a math-compose-lang property on the function’s symbol, whose value is a Lisp function that takes a and prec as arguments and returns a composition. Here lang is a language mode name, one of normal, big, c, pascal, fortran, tex, eqn, math, or maple. In Big mode, Calc actually tries math-compose-big first, then tries math-compose-normal. If this property does not exist, or if the function returns nil, the function is written in the normal function-call notation for that language.

Function: composition-to-string c w ¶
Convert a composition structure returned by compose-expr into a string. Multi-line compositions convert to strings containing newline characters. The target window size is given by w. The format-value function basically calls compose-expr followed by composition-to-string.

Function: comp-width c ¶
Compute the width in characters of composition c.

Function: comp-height c ¶
Compute the height in lines of composition c.

Function: comp-ascent c ¶
Compute the portion of the height of composition c which is on or above the baseline. For a one-line composition, this will be one.

Function: comp-descent c ¶
Compute the portion of the height of composition c which is below the baseline. For a one-line composition, this will be zero.

Function: comp-first-char c ¶
If composition c is a “flat” composition, return the first (leftmost) character of the composition as an integer. Otherwise, return nil.

Function: comp-last-char c ¶
If composition c is a “flat” composition, return the last (rightmost) character, otherwise return nil.


***** Hooks

Hooks are variables which contain Lisp functions (or lists of functions) which are called at various times. Calc defines a number of hooks that help you to customize it in various ways. Calc uses the Lisp function run-hooks to invoke the hooks shown below. Several other customization-related variables are also described here. To run code after Calc has loaded, use with-eval-after-load.

Variable: calc-start-hook ¶
This hook is called as the last step in a M-x calc command. At this point, the Calc buffer has been created and initialized if necessary, the Calc window and trail window have been created, and the “Welcome to Calc” message has been displayed.

Variable: calc-mode-hook ¶
This hook is called when the Calc buffer is being created. Usually this will only happen once per Emacs session. The hook is called after Emacs has switched to the new buffer, the mode-settings file has been read if necessary, and all other buffer-local variables have been set up. After this hook returns, Calc will perform a calc-refresh operation, set up the mode line display, then evaluate any deferred calc-define properties that have not been evaluated yet.

Variable: calc-trail-mode-hook ¶
This hook is called when the Calc Trail buffer is being created. It is called as the very last step of setting up the Trail buffer. Like calc-mode-hook, this will normally happen only once per Emacs session.

Variable: calc-end-hook ¶
This hook is called by calc-quit, generally because the user presses q or C-x * c while in Calc. The Calc buffer will be the current buffer. The hook is called as the very first step, before the Calc window is destroyed.

Variable: calc-window-hook ¶
If this hook is non-nil, it is called to create the Calc window. Upon return, this new Calc window should be the current window. (The Calc buffer will already be the current buffer when the hook is called.) If the hook is not defined, Calc will generally use split-window, set-window-buffer, and select-window to create the Calc window.

Variable: calc-trail-window-hook ¶
If this hook is non-nil, it is called to create the Calc Trail window. The variable calc-trail-buffer will contain the buffer which the window should use. Unlike calc-window-hook, this hook must not switch into the new window.

Variable: calc-embedded-mode-hook ¶
This hook is called the first time that Embedded mode is entered.

Variable: calc-embedded-new-buffer-hook ¶
This hook is called each time that Embedded mode is entered in a new buffer.

Variable: calc-embedded-new-formula-hook ¶
This hook is called each time that Embedded mode is enabled for a new formula.

Variable: calc-edit-mode-hook ¶
This hook is called by calc-edit (and the other “edit” commands) when the temporary editing buffer is being created. The buffer will have been selected and set up to be in calc-edit-mode, but will not yet have been filled with text. (In fact it may still have leftover text from a previous calc-edit command.)

Variable: calc-mode-save-hook ¶
This hook is called by the calc-save-modes command, after Calc’s own mode features have been inserted into the Calc init file and just before the “End of mode settings” message is inserted.

Variable: calc-reset-hook ¶
This hook is called after C-x * 0 (calc-reset) has reset all modes. The Calc buffer will be the current buffer.

Variable: calc-other-modes ¶
This variable contains a list of strings. The strings are concatenated at the end of the modes portion of the Calc mode line (after standard modes such as “Deg”, “Inv” and “Hyp”). Each string should be a short, single word followed by a space. The variable is nil by default.

Variable: calc-mode-map ¶
This is the keymap that is used by Calc mode. The best time to adjust it is probably in a calc-mode-hook. If the Calc extensions package (calc-ext.el) has not yet been loaded, many of these keys will be bound to calc-missing-key, which is a command that loads the extensions package and “retypes” the key. If your calc-mode-hook rebinds one of these keys, it will probably be overridden when the extensions are loaded.

Variable: calc-digit-map ¶
This is the keymap that is used during numeric entry. Numeric entry uses the minibuffer, but this map binds every non-numeric key to calcDigit-nondigit which generally calls exit-minibuffer and “retypes” the key.

Variable: calc-alg-ent-map ¶
This is the keymap that is used during algebraic entry. This is mostly a copy of minibuffer-local-map.

Variable: calc-store-var-map ¶
This is the keymap that is used during entry of variable names for commands like calc-store and calc-recall. This is mostly a copy of minibuffer-local-completion-map.

Variable: calc-edit-mode-map ¶
This is the (sparse) keymap used by calc-edit and other temporary editing commands. It binds RET, LFD, and C-c C-c to calc-edit-finish.

Variable: calc-mode-var-list ¶
This is a list of variables which are saved by calc-save-modes. Each entry is a list of two items, the variable (as a Lisp symbol) and its default value. When modes are being saved, each variable is compared with its default value (using equal) and any non-default variables are written out.

Variable: calc-local-var-list ¶
This is a list of variables which should be buffer-local to the Calc buffer. Each entry is a variable name (as a Lisp symbol). These variables also have their default values manipulated by the calc and calc-quit commands; see Multiple Calculators. Since calc-mode-hook is called after this list has been used the first time, your hook should add a variable to the list and also call make-local-variable itself.






* The Calendar and the Diary

Emacs provides the functions of a desk calendar, with a diary of planned or past events. It also has facilities for managing your appointments, and keeping track of how much time you spend working on certain projects.

To enter the calendar, type M-x calendar. This displays a three-month calendar centered on the current month, with point on the current date. With a numeric argument, as in C-u M-x calendar, it prompts you for the month and year to be the center of the three-month calendar. The calendar uses its own buffer, whose major mode is Calendar mode.

mouse-3 in the calendar brings up a menu of operations on a particular date; mouse-2 brings up a menu of commonly used calendar features that are independent of any particular date. To exit the calendar, type q.


** Movement in the Calendar

Calendar mode provides commands to move through the calendar in logical units of time such as days, weeks, months, and years. If you move outside the three months originally displayed, the calendar display scrolls automatically through time to make the selected date visible. Moving to a date lets you view its holidays or diary entries, or convert it to other calendars; moving by long time periods is also useful simply to scroll the calendar.


*** Motion by Standard Lengths of Time

The commands for movement in the calendar buffer parallel the commands for movement in text. You can move forward and backward by days, weeks, months, and years.

C-f
Move point one day forward (calendar-forward-day).

C-b
Move point one day backward (calendar-backward-day).

C-n
Move point one week forward (calendar-forward-week).

C-p
Move point one week backward (calendar-backward-week).

M-}
Move point one month forward (calendar-forward-month).

M-{
Move point one month backward (calendar-backward-month).

C-x ]
Move point one year forward (calendar-forward-year).

C-x [
Move point one year backward (calendar-backward-year).

The day and week commands are natural analogues of the usual Emacs commands for moving by characters and by lines. Just as C-n usually moves to the same column in the following line, in Calendar mode it moves to the same day in the following week. And C-p moves to the same day in the previous week.

The arrow keys are equivalent to C-f, C-b, C-n and C-p, just as they normally are in other modes.

The commands for motion by months and years work like those for weeks, but move a larger distance. The month commands M-} and M-{ move forward or backward by an entire month. The year commands C-x ] and C-x [ move forward or backward a whole year.

The easiest way to remember these commands is to consider months and years analogous to paragraphs and pages of text, respectively. But the calendar movement commands themselves do not quite parallel those for movement through text: the ordinary Emacs paragraph commands move to the beginning or end of a paragraph, whereas these month and year commands move by an entire month or an entire year, keeping the same date within the month or year.

All these commands accept a numeric argument as a repeat count. For convenience, the digit keys and the minus sign specify numeric arguments in Calendar mode even without the Meta modifier. For example, 100 C-f moves point 100 days forward from its present location.


*** Beginning or End of Week, Month or Year

A week (or month, or year) is not just a quantity of days; we think of weeks (months, years) as starting on particular dates. So Calendar mode provides commands to move to the start or end of a week, month or year:

C-a
Move point to start of week (calendar-beginning-of-week).

C-e
Move point to end of week (calendar-end-of-week).

M-a
Move point to start of month (calendar-beginning-of-month).

M-e
Move point to end of month (calendar-end-of-month).

M-<
Move point to start of year (calendar-beginning-of-year).

M->
Move point to end of year (calendar-end-of-year).

These commands also take numeric arguments as repeat counts, with the repeat count indicating how many weeks, months, or years to move backward or forward.

By default, weeks begin on Sunday. To make them begin on Monday instead, set the variable calendar-week-start-day to 1. To change which day headers are highlighted as weekend days, set the variable calendar-weekend-days.


*** Specified Dates

Calendar mode provides commands for moving to a particular date specified in various ways.

g d
Move point to specified date (calendar-goto-date).

g D
Move point to specified day of year (calendar-goto-day-of-year).

g w
Move point to specified week of year (calendar-iso-goto-week).

o
Center calendar around specified month (calendar-other-month).

.
Move point to today’s date (calendar-goto-today).

g d (calendar-goto-date) prompts for a year, a month, and a day of the month, and then moves to that date. Because the calendar includes all dates from the beginning of the current era, you must type the year in its entirety; that is, type ‘2010’, not ‘10’.

g D (calendar-goto-day-of-year) prompts for a year and day number, and moves to that date. Negative day numbers count backward from the end of the year. g w (calendar-iso-goto-week) prompts for a year and week number, and moves to that week.

o (calendar-other-month) prompts for a month and year, then centers the three-month calendar around that month.

You can return to today’s date with . (calendar-goto-today).


** Scrolling in the Calendar

The calendar display scrolls automatically through time when you move out of the visible portion. You can also scroll it manually. Imagine that the calendar window contains a long strip of paper with the months on it. Scrolling the calendar means moving the strip horizontally, so that new months become visible in the window.

>
Scroll calendar one month forward (calendar-scroll-left).

<
Scroll calendar one month backward (calendar-scroll-right).

C-v
PageDown
next
Scroll forward by three months (calendar-scroll-left-three-months).

M-v
PageUp
prior
Scroll backward by three months (calendar-scroll-right-three-months).

The most basic calendar scroll commands scroll by one month at a time. This means that there are two months of overlap between the display before the command and the display after. > scrolls the calendar contents one month forward in time. < scrolls the contents one month backwards in time.

The commands C-v and M-v scroll the calendar by an entire screenful—three months—in analogy with the usual meaning of these commands. C-v makes later dates visible and M-v makes earlier dates visible. These commands take a numeric argument as a repeat count; in particular, since C-u multiplies the next command by four, typing C-u C-v scrolls the calendar forward by a year and typing C-u M-v scrolls the calendar backward by a year.

The function keys PageDown (or next) and PageUp (or prior) are equivalent to C-v and M-v, just as they are in other modes.


** Counting Days

M-=
Display the number of days in the current region (calendar-count-days-region).

To determine the number of days in a range, set the mark on one date using C-SPC, move point to another date, and type M-= (calendar-count-days-region). The numbers of days shown is inclusive; that is, it includes the days specified by mark and point.


** Miscellaneous Calendar Commands

p d
Display day-in-year (calendar-print-day-of-year).

C-c C-l
Regenerate the calendar window (calendar-redraw).

SPC
Scroll the next window up (scroll-other-window).

DEL
S-SPC
Scroll the next window down (scroll-other-window-down).

q
Exit from calendar (calendar-exit).

To display the number of days elapsed since the start of the year, or the number of days remaining in the year, type the p d command (calendar-print-day-of-year). This displays both of those numbers in the echo area. The count of days elapsed includes the selected date. The count of days remaining does not include that date.

If the calendar window text gets corrupted, type C-c C-l (calendar-redraw) to redraw it. (This can only happen if you use non-Calendar-mode editing commands.)

In Calendar mode, you can use SPC (scroll-other-window) and DEL (scroll-other-window-down) to scroll the other window (if there is one) up or down, respectively. This is handy when you display a list of holidays or diary entries in another window.

To exit from the calendar, type q (calendar-exit). This buries all buffers related to the calendar, selecting other buffers. (If a frame contains a dedicated calendar window, exiting from the calendar deletes or iconifies that frame depending on the value of calendar-remove-frame-by-deleting.)


** Writing Calendar Files

You can write calendars and diary entries to HTML and LaTeX files.

The Calendar HTML commands produce files of HTML code that contain calendar, holiday, and diary entries. Each file applies to one month, and has a name of the format yyyy-mm.html, where yyyy and mm are the four-digit year and two-digit month, respectively. The variable cal-html-directory specifies the default output directory for the HTML files. To prevent holidays from being shown, customize cal-html-holidays.

Diary entries enclosed by < and > are interpreted as HTML tags (for example: this is a diary entry with <font color=”red”>some red text</font>). You can change the overall appearance of the displayed HTML pages (for example, the color of various page elements, header styles) via a stylesheet cal.css in the directory containing the HTML files (see the value of the variable cal-html-css-default for relevant style settings).

H m
Generate a one-month calendar (cal-html-cursor-month).

H y
Generate a calendar file for each month of a year, as well as an index page (cal-html-cursor-year). By default, this command writes files to a yyyy subdirectory—if this is altered some hyperlinks between years will not work.

If the variable cal-html-print-day-number-flag is non-nil, then the monthly calendars show the day-of-the-year number. The variable cal-html-year-index-cols specifies the number of columns in the yearly index page.

The Calendar LaTeX commands produce a buffer of LaTeX code that prints as a calendar. Depending on the command you use, the printed calendar covers the day, week, month or year that point is in.

t m
Generate a one-month calendar (cal-tex-cursor-month).

t M
Generate a sideways-printing one-month calendar (cal-tex-cursor-month-landscape).

t d
Generate a one-day calendar (cal-tex-cursor-day).

t w 1
Generate a one-page calendar for one week, with hours (cal-tex-cursor-week).

t w 2
Generate a two-page calendar for one week, with hours (cal-tex-cursor-week2).

t w 3
Generate an ISO-style calendar for one week, without hours (cal-tex-cursor-week-iso).

t w 4
Generate a calendar for one Monday-starting week, with hours (cal-tex-cursor-week-monday).

t w W
Generate a two-page calendar for one week, without hours (cal-tex-cursor-week2-summary).

t f w
Generate a Filofax-style two-weeks-at-a-glance calendar (cal-tex-cursor-filofax-2week).

t f W
Generate a Filofax-style one-week-at-a-glance calendar (cal-tex-cursor-filofax-week).

t y
Generate a calendar for one year (cal-tex-cursor-year).

t Y
Generate a sideways-printing calendar for one year (cal-tex-cursor-year-landscape).

t f y
Generate a Filofax-style calendar for one year (cal-tex-cursor-filofax-year).

Some of these commands print the calendar sideways (in landscape mode), so it can be wider than it is long. Some of them use Filofax paper size (3.75in x 6.75in). All of these commands accept a prefix argument, which specifies how many days, weeks, months or years to print (starting always with the selected one).

If the variable cal-tex-holidays is non-nil (the default), then the printed calendars show the holidays in calendar-holidays. If the variable cal-tex-diary is non-nil (the default is nil), diary entries are included also (in monthly, Filofax, and iso-week calendars only). If the variable cal-tex-rules is non-nil (the default is nil), the calendar displays ruled pages in styles that have sufficient room. Consult the documentation of the individual cal-tex functions to see which calendars support which features.

You can use the variable cal-tex-preamble-extra to insert extra LaTeX commands in the preamble of the generated document if you need to.


** Holidays

The Emacs calendar knows about many major and minor holidays, and can display them. You can add your own holidays to the default list.

mouse-3 Holidays
h
Display holidays for the selected date (calendar-cursor-holidays).

x
Mark holidays in the calendar window (calendar-mark-holidays).

u
Unmark calendar window (calendar-unmark).

a
List all holidays for the displayed three months in another window (calendar-list-holidays).

M-x holidays
List all holidays for three months around today’s date in another window.

M-x list-holidays
List holidays in another window for a specified range of years.

To see if any holidays fall on a given date, position point on that date in the calendar window and use the h command. Alternatively, click on that date with mouse-3 and then choose Holidays from the menu that appears. Either way, this displays the holidays for that date, in the echo area if they fit there, otherwise in a separate window.

To view the distribution of holidays for all the dates shown in the calendar, use the x command. This displays the dates that are holidays in a different face. See calendar-holiday-marker. The command applies both to the currently visible months and to other months that subsequently become visible by scrolling. To turn marking off and erase the current marks, type u, which also erases any diary marks (see The Diary). If the variable calendar-mark-holidays-flag is non-nil, creating or updating the calendar marks holidays automatically.

To get even more detailed information, use the a command, which displays a separate buffer containing a list of all holidays in the current three-month range. You can use SPC and DEL in the calendar window to scroll that list up and down, respectively.

The command M-x holidays displays the list of holidays for the current month and the preceding and succeeding months; this works even if you don’t have a calendar window. If the variable calendar-view-holidays-initially-flag is non-nil, creating the calendar displays holidays in this way. If you want the list of holidays centered around a different month, use C-u M-x holidays, which prompts for the month and year.

The holidays known to Emacs include United States holidays and the major Bahá’í, Chinese, Christian, Islamic, and Jewish holidays; also the solstices and equinoxes.

The command M-x holiday-list displays the list of holidays for a range of years. This function asks you for the starting and stopping years, and allows you to choose all the holidays or one of several categories of holidays. You can use this command even if you don’t have a calendar window.

The dates used by Emacs for holidays are based on current practice, not historical fact. For example Veteran’s Day began in 1919, but is shown in earlier years.


** Times of Sunrise and Sunset

Special calendar commands can tell you, to within a minute or two, the times of sunrise and sunset for any date.

mouse-3 Sunrise/sunset
S
Display times of sunrise and sunset for the selected date (calendar-sunrise-sunset).

M-x sunrise-sunset
Display times of sunrise and sunset for today’s date.

C-u M-x sunrise-sunset
Display times of sunrise and sunset for a specified date.

M-x calendar-sunrise-sunset-month
Display times of sunrise and sunset for the selected month.

Within the calendar, to display the local times of sunrise and sunset in the echo area, move point to the date you want, and type S. Alternatively, click mouse-3 on the date, then choose ‘Sunrise/sunset’ from the menu that appears. The command M-x sunrise-sunset is available outside the calendar to display this information for today’s date or a specified date. To specify a date other than today, use C-u M-x sunrise-sunset, which prompts for the year, month, and day.

You can display the times of sunrise and sunset for any location and any date with C-u C-u M-x sunrise-sunset. This asks you for a longitude, latitude, number of minutes difference from Coordinated Universal Time, and date, and then tells you the times of sunrise and sunset for that location on that date.

Because the times of sunrise and sunset depend on the location on earth, you need to tell Emacs your latitude, longitude, and location name before using these commands. Here is an example of what to set:

(setq calendar-latitude 40.1)
(setq calendar-longitude -88.2)
(setq calendar-location-name "Urbana, IL")
Use one decimal place in the values of calendar-latitude and calendar-longitude.

Your time zone also affects the local time of sunrise and sunset. Emacs usually gets time zone information from the operating system, but if these values are not what you want (or if the operating system does not supply them), you must set them yourself. Here is an example:

(setq calendar-time-zone -360)
(setq calendar-standard-time-zone-name "CST")
(setq calendar-daylight-time-zone-name "CDT")
The value of calendar-time-zone is the number of minutes difference between your local standard time and Coordinated Universal Time (Greenwich time). The values of calendar-standard-time-zone-name and calendar-daylight-time-zone-name are the abbreviations used in your time zone. Emacs displays the times of sunrise and sunset corrected for daylight saving time. See Daylight Saving Time, for how daylight saving time is determined.

If you want to display numerical time zones (like ‘"+0100"’) instead of symbolic ones (like ‘"CET"’), set this to numeric.

As a user, you might find it convenient to set the calendar location variables for your usual physical location in your .emacs file. If you are a system administrator, you may want to set these variables for all users in a default.el file. See The Emacs Initialization File.


** Phases of the Moon

These calendar commands display the dates and times of the phases of the moon (new moon, first quarter, full moon, last quarter). This feature is useful for debugging problems that depend on the phase of the moon.

M
Display the dates and times for all the quarters of the moon for the three-month period shown (calendar-lunar-phases).

M-x lunar-phases
Display dates and times of the quarters of the moon for three months around today’s date.

Within the calendar, use the M command to display a separate buffer of the phases of the moon for the current three-month range. The dates and times listed are accurate to within a few minutes.

Outside the calendar, use the command M-x lunar-phases to display the list of the phases of the moon for the current month and the preceding and succeeding months. For information about a different month, use C-u M-x lunar-phases, which prompts for the month and year.

The dates and times given for the phases of the moon are given in local time (corrected for daylight saving, when appropriate). See the discussion in the previous section. See Times of Sunrise and Sunset.


** Conversion To and From Other Calendars

The Emacs calendar displayed is always the Gregorian calendar, sometimes called the New Style calendar, which is used in most of the world today. However, this calendar did not exist before the sixteenth century and was not widely used before the eighteenth century; it did not fully displace the Julian calendar and gain universal acceptance until the early twentieth century. The Emacs calendar can display any month since January, year 1 of the current era, but the calendar displayed is always the Gregorian, even for a date at which the Gregorian calendar did not exist.

While Emacs cannot display other calendars, it can convert dates to and from several other calendars.

*** Supported Calendar Systems

The ISO commercial calendar is often used in business.

The Julian calendar, named after Julius Caesar, was the one used in Europe throughout medieval times, and in many countries up until the nineteenth century.

Astronomers use a simple counting of days elapsed since noon, Monday, January 1, 4713 BC on the Julian calendar. The number of days elapsed is called the Julian day number or the Astronomical day number.

The Hebrew calendar is used by tradition in the Jewish religion. The Emacs calendar program uses the Hebrew calendar to determine the dates of Jewish holidays. Hebrew calendar dates begin and end at sunset.

The Islamic calendar is used in many predominantly Islamic countries. Emacs uses it to determine the dates of Islamic holidays. There is no universal agreement in the Islamic world about the calendar; Emacs uses a widely accepted version, but the precise dates of Islamic holidays often depend on proclamation by religious authorities, not on calculations. As a consequence, the actual dates of observance can vary slightly from the dates computed by Emacs. Islamic calendar dates begin and end at sunset.

The French Revolutionary calendar was created by the Jacobins after the 1789 revolution, to represent a more secular and nature-based view of the annual cycle, and to install a 10-day week in a rationalization measure similar to the metric system. The French government officially abandoned this calendar at the end of 1805.

The Maya of Central America used three separate, overlapping calendar systems, the long count, the tzolkin, and the haab. Emacs knows about all three of these calendars. Experts dispute the exact correlation between the Mayan calendar and our calendar; Emacs uses the Goodman-Martinez-Thompson correlation in its calculations.

The Copts use a calendar based on the ancient Egyptian solar calendar. Their calendar consists of twelve 30-day months followed by an extra five-day period. Once every fourth year they add a leap day to this extra period to make it six days. The Ethiopic calendar is identical in structure, but has different year numbers and month names.

The Persians use a solar calendar based on a design of Omar Khayyam. Their calendar consists of twelve months of which the first six have 31 days, the next five have 30 days, and the last has 29 in ordinary years and 30 in leap years. Leap years occur in a complicated pattern every four or five years. The calendar implemented here is the arithmetical Persian calendar championed by Birashk, based on a 2,820-year cycle. It differs from the astronomical Persian calendar, which is based on astronomical events. As of this writing the first future discrepancy is projected to occur on March 20, 2025. It is currently not clear what the official calendar of Iran will be at that time.

The Chinese calendar is a complicated system of lunar months arranged into solar years. The years go in cycles of sixty, each year containing either twelve months in an ordinary year or thirteen months in a leap year; each month has either 29 or 30 days. Years, ordinary months, and days are named by combining one of ten celestial stems with one of twelve terrestrial branches for a total of sixty names that are repeated in a cycle of sixty.

The Bahá’í calendar system is based on a solar cycle of 19 months with 19 days each. The four remaining intercalary days are placed between the 18th and 19th months.


*** Converting To Other Calendars

The following commands describe the selected date (the date at point) in various other calendar systems:

mouse-3 Other calendars
p o
Display the selected date in various other calendars. (calendar-print-other-dates).

p c
Display ISO commercial calendar equivalent for selected day (calendar-iso-print-date).

p j
Display Julian date for selected day (calendar-julian-print-date).

p a
Display astronomical (Julian) day number for selected day (calendar-astro-print-day-number).

p h
Display Hebrew date for selected day (calendar-hebrew-print-date).

p i
Display Islamic date for selected day (calendar-islamic-print-date).

p f
Display French Revolutionary date for selected day (calendar-french-print-date).

p b
Display Bahá’í date for selected day (calendar-bahai-print-date).

p C
Display Chinese date for selected day (calendar-chinese-print-date).

p k
Display Coptic date for selected day (calendar-coptic-print-date).

p e
Display Ethiopic date for selected day (calendar-ethiopic-print-date).

p p
Display Persian date for selected day (calendar-persian-print-date).

p m
Display Mayan date for selected day (calendar-mayan-print-date).

Otherwise, move point to the date you want to convert, then type the appropriate command starting with p from the table above. The prefix p is a mnemonic for “print”, since Emacs “prints” the equivalent date in the echo area. p o displays the date in all forms known to Emacs. You can also use mouse-3 and then choose Other calendars from the menu that appears. This displays the equivalent forms of the date in all the calendars Emacs understands, in the form of a menu. (Choosing an alternative from this menu doesn’t actually do anything—the menu is used only for display.)


*** Converting From Other Calendars

You can use the other supported calendars to specify a date to move to. This section describes the commands for doing this using calendars other than Mayan; for the Mayan calendar, see the following section.

g c
Move to a date specified in the ISO commercial calendar (calendar-iso-goto-date).

g w
Move to a week specified in the ISO commercial calendar (calendar-iso-goto-week).

g j
Move to a date specified in the Julian calendar (calendar-julian-goto-date).

g a
Move to a date specified with an astronomical (Julian) day number (calendar-astro-goto-day-number).

g b
Move to a date specified in the Bahá’í calendar (calendar-bahai-goto-date).

g h
Move to a date specified in the Hebrew calendar (calendar-hebrew-goto-date).

g i
Move to a date specified in the Islamic calendar (calendar-islamic-goto-date).

g f
Move to a date specified in the French Revolutionary calendar (calendar-french-goto-date).

g C
Move to a date specified in the Chinese calendar (calendar-chinese-goto-date).

g p
Move to a date specified in the Persian calendar (calendar-persian-goto-date).

g k
Move to a date specified in the Coptic calendar (calendar-coptic-goto-date).

g e
Move to a date specified in the Ethiopic calendar (calendar-ethiopic-goto-date).

These commands ask you for a date on the other calendar, move point to the Gregorian calendar date equivalent to that date, and display the other calendar’s date in the echo area. Emacs uses strict completion (see Completion Exit) whenever it asks you to type a month name, so you don’t have to worry about the spelling of Hebrew, Islamic, or French names.

One common issue concerning the Hebrew calendar is the computation of the anniversary of a date of death, called a yahrzeit. The Emacs calendar includes a facility for such calculations. If you are in the calendar, the command M-x calendar-hebrew-list-yahrzeits asks you for a range of years and then displays a list of the yahrzeit dates for those years for the date given by point. If you are not in the calendar, this command first asks you for the date of death and the range of years, and then displays the list of yahrzeit dates.



** The Diary

The Emacs diary keeps track of appointments or other events on a daily basis, in conjunction with the calendar. To use the diary feature, you must first create a diary file containing a list of events and their dates. Then Emacs can automatically pick out and display the events for today, for the immediate future, or for any specified date.

Although you probably will start by creating a diary manually, Emacs provides a number of commands to let you view, add, and change diary entries.

*** The Diary File

Your diary file is a file that records events associated with particular dates. The name of the diary file is specified by the variable diary-file. The default is ~/.emacs.d/diary, though for compatibility with older versions Emacs will use ~/diary if it exists.

Each entry in the diary file describes one event and consists of one or more lines. An entry always begins with a date specification at the left margin. The rest of the entry is simply text to describe the event. If the entry has more than one line, then the lines after the first must begin with whitespace to indicate they continue a previous entry. Lines that do not begin with valid dates and do not continue a preceding entry are ignored. Here’s an example:

12/22/2015  Twentieth wedding anniversary!
10/22       Ruth's birthday.
 21, *:    Payday
Tuesday--weekly meeting with grad students at 10am
         Supowit, Shen, Bitner, and Kapoor to attend.
1/13/89     Friday the thirteenth!!
thu 4pm     squash game with Lloyd.
mar 16      Dad's birthday
April 15, 2016 Income tax due.
 15        time cards due.
This example uses extra spaces to align the event descriptions of most of the entries. Such formatting is purely a matter of taste.

You can also use a format where the first line of a diary entry consists only of the date or day name (with no following blanks or punctuation). For example:

02/11/2012
      Bill B. visits Princeton today
      2pm Cognitive Studies Committee meeting
      2:30-5:30 Liz at Lawrenceville
      4:00pm Dentist appt
      7:30pm Dinner at George's
      8:00-10:00pm concert
This entry will have a different appearance if you use the simple diary display (see Diary Display). The simple diary display omits the date line at the beginning; only the continuation lines appear. This style of entry looks neater when you display just a single day’s entries, but can cause confusion if you ask for more than one day’s entries.


*** Displaying the Diary

Once you have created a diary file, you can use the calendar to view it. You can also view today’s events outside of Calendar mode. In the following, key bindings refer to the Calendar buffer.

mouse-3 Diary
d
Display all diary entries for the selected date (diary-view-entries).

s
Display the entire diary file (diary-show-all-entries).

m
Mark all visible dates that have diary entries (diary-mark-entries).

u
Unmark the calendar window (calendar-unmark).

M-x diary-print-entries
Print hard copy of the diary display as it appears.

M-x diary
Display all diary entries for today’s date.

M-x diary-mail-entries
Mail yourself email reminders about upcoming diary entries.

Displaying the diary entries with d shows in a separate buffer the diary entries for the selected date in the calendar. The mode line of the new buffer shows the date of the diary entries. Holidays are shown either in the buffer or in the mode line, depending on the display method you choose (see Diary Display). If you specify a numeric argument with d, it shows all the diary entries for that many successive days. Thus, 2 d displays all the entries for the selected date and for the following day.

Another way to display the diary entries for a date is to click mouse-3 on the date, and then choose Diary entries from the menu that appears. If the variable calendar-view-diary-initially-flag is non-nil, creating the calendar lists the diary entries for the current date (provided the current date is visible).

To get a broader view of which days are mentioned in the diary, use the m command. This marks the dates that have diary entries in a different face. See diary-entry-marker.

This command applies both to the months that are currently visible and to those that subsequently become visible after scrolling. To turn marking off and erase the current marks, type u, which also turns off holiday marks (see Holidays). If the variable calendar-mark-diary-entries-flag is non-nil, creating or updating the calendar marks diary dates automatically.

To prevent an individual diary entry from being marked in the calendar, insert the string that diary-nonmarking-symbol specifies (the default is ‘&’) at the beginning of the entry, before the date. This has no effect on display of the entry in the diary buffer; it only affects marks on dates in the calendar. Nonmarking entries can be useful for generic entries that would otherwise mark many different dates.

To see the full diary file, rather than just some of the entries, use the s command.

The command M-x diary displays the diary entries for the current date, independently of the calendar display, and optionally for the next few days as well; the variable diary-number-of-entries specifies how many days to include. See diary-number-of-entries.

If you put (diary) in your .emacs file, this automatically displays a window with the day’s diary entries when you start Emacs.

Some people like to receive email notifications of events in their diary. To send such mail to yourself, use the command M-x diary-mail-entries. A prefix argument specifies how many days (starting with today) to check; otherwise, the variable diary-mail-days says how many days.


*** Date Formats

Here are some sample diary entries, illustrating different ways of formatting a date. The examples all show dates in American order (month, day, year), but Calendar mode supports European order (day, month, year) and ISO order (year, month, day) as options.

4/20/12  Switch-over to new tabulation system
apr. 25  Start tabulating annual results
4/30  Results for April are due
*/25  Monthly cycle finishes
Friday  Don't leave without backing up files
The first entry appears only once, on April 20, 2012. The second and third appear every year on the specified dates, and the fourth uses a wildcard (asterisk) for the month, so it appears on the 25th of every month. The final entry appears every week on Friday.

You can use just numbers to express a date, as in ‘month/day’ or ‘month/day/year’. This must be followed by a nondigit. In the date itself, month and day are numbers of one or two digits. The optional year is also a number, and may be abbreviated to the last two digits; that is, you can use ‘11/12/2012’ or ‘11/12/12’.

Dates can also have the form ‘monthname day’ or ‘monthname day, year’, where the month’s name can be spelled in full or abbreviated (with or without a period). The preferred abbreviations for month and day names can be set using the variables calendar-abbrev-length, calendar-month-abbrev-array, and calendar-day-abbrev-array. The default is to use the first three letters of a name as its abbreviation. Case is not significant.

A date may be generic; that is, partially unspecified. Then the entry applies to all dates that match the specification. If the date does not contain a year, it is generic and applies to any year. Alternatively, month, day, or year can be ‘*’; this matches any month, day, or year, respectively. Thus, a diary entry ‘3/*/*’ matches any day in March of any year; so does ‘march *’.

If you prefer the European style of writing dates (in which the day comes before the month), or the ISO style (in which the order is year, month, day), type M-x calendar-set-date-style while in the calendar, or customize the variable calendar-date-style. This affects how diary dates are interpreted, date display, and the order in which some commands expect their arguments to be given.

You can use the name of a day of the week as a generic date which applies to any date falling on that day of the week. You can abbreviate the day of the week as described above, or spell it in full; case is not significant.


*** Commands to Add to the Diary

While in the calendar, there are several commands to create diary entries. The basic commands are listed here; more sophisticated commands are in the next section (see Special Diary Entries). Entries can also be based on non-Gregorian calendars. See Diary Entries Using non-Gregorian Calendars.

i d
Add a diary entry for the selected date (diary-insert-entry).

i w
Add a diary entry for the selected day of the week (diary-insert-weekly-entry).

i m
Add a diary entry for the selected day of the month (diary-insert-monthly-entry).

i y
Add a diary entry for the selected day of the year (diary-insert-yearly-entry).

You can make a diary entry for a specific date by selecting that date in the calendar window and typing the i d command. This command displays the end of your diary file in another window and inserts the date; you can then type the rest of the diary entry.

If you want to make a diary entry that applies to a specific day of the week, select that day of the week (any occurrence will do) and type i w. This inserts the day-of-week as a generic date; you can then type the rest of the diary entry. You can make a monthly diary entry in the same fashion: select the day of the month, use the i m command, and type the rest of the entry. Similarly, you can insert a yearly diary entry with the i y command.

All of the above commands make marking diary entries by default. To make a nonmarking diary entry, give a prefix argument to the command. For example, C-u i w makes a nonmarking weekly diary entry.

When you modify the diary file, be sure to save the file before exiting Emacs. Saving the diary file after using any of the above insertion commands will automatically update the diary marks in the calendar window, if appropriate. You can use the command calendar-redraw to force an update at any time.


*** Special Diary Entries

In addition to entries based on calendar dates, the diary file can contain sexp entries for regular events such as anniversaries. These entries are based on Lisp expressions (sexps) that Emacs evaluates as it scans the diary file. Instead of a date, a sexp entry contains ‘%%’ followed by a Lisp expression which must begin and end with parentheses. The Lisp expression determines which dates the entry applies to.

Calendar mode provides commands to insert certain commonly used sexp entries:

i a
Add an anniversary diary entry for the selected date (diary-insert-anniversary-entry).

i b
Add a block diary entry for the current region (diary-insert-block-entry).

i c
Add a cyclic diary entry starting at the date (diary-insert-cyclic-entry).

If you want to make a diary entry that applies to the anniversary of a specific date, move point to that date and use the i a command. This displays the end of your diary file in another window and inserts the anniversary description; you can then type the rest of the diary entry. The entry looks like this:

%%(diary-anniversary 10 31 1988) Arthur's birthday
This entry applies to October 31 in any year after 1988; ‘10 31 1988’ specifies the date. (If you are using the European or ISO calendar style, the input order of month, day and year is different.) The reason this expression requires a beginning year is that advanced diary functions can use it to calculate the number of elapsed years.

A block diary entry applies to a specified range of consecutive dates. Here is a block diary entry that applies to all dates from June 24, 2012 through July 10, 2012:

%%(diary-block 6 24 2012 7 10 2012) Vacation
The ‘6 24 2012’ indicates the starting date and the ‘7 10 2012’ indicates the stopping date. (Again, if you are using the European or ISO calendar style, the input order of month, day and year is different.)

To insert a block entry, place point and the mark on the two dates that begin and end the range, and type i b. This command displays the end of your diary file in another window and inserts the block description; you can then type the diary entry.

Cyclic diary entries repeat after a fixed interval of days. To create one, select the starting date and use the i c command. The command prompts for the length of interval, then inserts the entry, which looks like this:

%%(diary-cyclic 50 3 1 2012) Renew medication
This entry applies to March 1, 2012 and every 50th day following; ‘3 1 2012’ specifies the starting date. (If you are using the European or ISO calendar style, the input order of month, day and year is different.)

All three of these commands make marking diary entries. To insert a nonmarking entry, give a prefix argument to the command. For example, C-u i a makes a nonmarking anniversary diary entry.

Marking sexp diary entries in the calendar can be time-consuming, since every date visible in the calendar window must be individually checked. So it’s a good idea to make sexp diary entries nonmarking (with ‘&’) when possible.

Another sophisticated kind of sexp entry, a floating diary entry, specifies a regularly occurring event by offsets specified in days, weeks, and months. It is comparable to a crontab entry interpreted by the cron utility. Here is a nonmarking, floating diary entry that applies to the fourth Thursday in November:

&%%(diary-float 11 4 4) American Thanksgiving
The 11 specifies November (the eleventh month), the 4 specifies Thursday (the fourth day of the week, where Sunday is numbered zero), and the second 4 specifies the fourth Thursday (1 would mean “first”, 2 would mean “second”, −2 would mean “second-to-last”, and so on). The month can be a single month or a list of months. Thus you could change the 11 above to ‘'(1 2 3)’ and have the entry apply to the last Thursday of January, February, and March. If the month is t, the entry applies to all months of the year.

%%(diary-offset '(diary-float t 3 4) 2) Monthly committee meeting
This entry applies to the Saturday after the third Thursday of each month. The 2 specifies number of days after when the sexp '(diary-float t 3 4) would evaluate to t. This is useful when for example your organization has a committee meeting two days after every monthly meeting which takes place on the third Thursday, or if you would like to attend a virtual meeting scheduled in a different timezone causing a difference in the date.

Each of the standard sexp diary entries takes an optional parameter specifying the name of a face or a single-character string to use when marking the entry in the calendar. Most generally, sexp diary entries can perform arbitrary computations to determine when they apply. See Sexp Entries and the Fancy Diary Display.


*** Appointments

If you have a diary entry for an appointment, and that diary entry begins with a recognizable time of day, Emacs can warn you in advance that an appointment is pending. Emacs alerts you to the appointment by displaying a message in your chosen format, as specified by the variable appt-display-format. If the value of appt-audible is non-nil, the warning includes an audible reminder. In addition, if appt-display-mode-line is non-nil, Emacs displays the number of minutes to the appointment on the mode line.

If appt-display-format has the value window, then the variable appt-display-duration controls how long the reminder window is visible for; and the variables appt-disp-window-function and appt-delete-window-function give the names of functions used to create and destroy the window, respectively.

To enable appointment notification, type M-x appt-activate. With a positive argument, it enables notification; with a negative argument, it disables notification; with no argument, it toggles. Enabling notification also sets up an appointment list for today from the diary file, giving all diary entries found with recognizable times of day, and reminds you just before each of them.

For example, suppose the diary file contains these lines:

Monday
  9:30am Coffee break
 12:00pm Lunch
Then on Mondays, you will be reminded at around 9:20am about your coffee break and at around 11:50am about lunch. The variable appt-message-warning-time specifies how many minutes (default 12) in advance to warn you. This is a default warning time. Each appointment can specify a different warning time by adding a piece matching appt-warning-time-regexp (see that variable’s documentation for details).

You can write times in am/pm style (with ‘12:00am’ standing for midnight and ‘12:00pm’ standing for noon), or 24-hour European/military style. You need not be consistent; your diary file can have a mixture of the two styles. Times must be at the beginning of diary entries if they are to be recognized.

Emacs updates the appointments list from the diary file automatically just after midnight. You can force an update at any time by re-enabling appointment notification. Both these actions also display the day’s diary buffer, unless you set appt-display-diary to nil. The appointments list is also updated whenever the diary file (or a file it includes; see Fancy Diary Display) is saved. If you use the Org Mode and keep appointments in your Org agenda files, you can add those appointments to the list using the org-agenda-to-appt command. See Appointment reminders in The Org Manual, for more about that command.

You can also use the appointment notification facility like an alarm clock. The command M-x appt-add adds entries to the appointment list without affecting your diary file. You delete entries from the appointment list with M-x appt-delete.


*** Importing and Exporting Diary Entries

You can transfer diary entries between Emacs diary files and a variety of other formats.

You can import diary entries from Outlook-generated appointment messages. While viewing such a message in Rmail or Gnus, do M-x diary-from-outlook to import the entry. You can make this command recognize additional appointment message formats by customizing the variable diary-outlook-formats. Other mail clients can set diary-from-outlook-function to an appropriate value.

The icalendar package allows you to transfer data between your Emacs diary file and iCalendar files, which are defined in RFC 2445—Internet Calendaring and Scheduling Core Object Specification (iCalendar) (as well as the earlier vCalendar format).

The command icalendar-import-buffer extracts iCalendar data from the current buffer and adds it to your diary file. This function is also suitable for automatic extraction of iCalendar data; for example with the Rmail mail client one could use:

(add-hook 'rmail-show-message-hook 'icalendar-import-buffer)
The command icalendar-import-file imports an iCalendar file and adds the results to an Emacs diary file. For example:

(icalendar-import-file "/here/is/calendar.ics"
                       "/there/goes/ical-diary")
You can use an #include directive to add the import file contents to the main diary file, if these are different files. See Fancy Diary Display.

Use icalendar-export-file to interactively export an entire Emacs diary file to iCalendar format. To export only a part of a diary file, mark the relevant area, and call icalendar-export-region. In both cases, Emacs appends the result to the target file.


** Daylight Saving Time

Emacs understands the difference between standard time and daylight saving time—the times given for sunrise, sunset, solstices, equinoxes, and the phases of the moon take that into account. The rules for daylight saving time vary from place to place and have also varied historically from year to year. To do the job properly, Emacs needs to know which rules to use.

Some operating systems keep track of the rules that apply to the place where you are; on these systems, Emacs gets the information it needs from the system automatically. If some or all of this information is missing, Emacs fills in the gaps with the rules currently used in Cambridge, Massachusetts. If the resulting rules are not what you want, you can tell Emacs the rules to use by setting certain variables: calendar-daylight-savings-starts and calendar-daylight-savings-ends.

These values should be Lisp expressions that refer to the variable year, and evaluate to the Gregorian date on which daylight saving time starts or (respectively) ends, in the form of a list (month day year). The values should be nil if your area does not use daylight saving time.

Emacs uses these expressions to determine the starting date of daylight saving time for the holiday list and for correcting times of day in the solar and lunar calculations.

The values for Cambridge, Massachusetts are as follows:

(calendar-nth-named-day 2 0 3 year)
(calendar-nth-named-day 1 0 11 year)
That is, the second 0th day (Sunday) of the third month (March) in the year specified by year, and the first Sunday of the eleventh month (November) of that year. If daylight saving time were changed to start on October 1, you would set calendar-daylight-savings-starts to this:

(list 10 1 year)
If there is no daylight saving time at your location, or if you want all times in standard time, set calendar-daylight-savings-starts and calendar-daylight-savings-ends to nil.

The variable calendar-daylight-time-offset specifies the difference between daylight saving time and standard time, measured in minutes. The value for Cambridge, Massachusetts is 60.

Finally, the two variables calendar-daylight-savings-starts-time and calendar-daylight-savings-ends-time specify the number of minutes after midnight local time when the transition to and from daylight saving time should occur. For Cambridge, Massachusetts both variables’ values are 120.


** Summing Time Intervals

The timeclock package adds up time intervals, so you can (for instance) keep track of how much time you spend working on particular projects. (A more advanced alternative is to use the Org Mode’s facilities for clocking time, see Clocking Work Time in The Org Manual).

Use the M-x timeclock-in command when you start working on a project, and M-x timeclock-out command when you’re done. Each time you do this, it adds one time interval to the record of the project. You can change to working on a different project with M-x timeclock-change.

Once you’ve collected data from a number of time intervals, you can use M-x timeclock-workday-remaining to see how much time is left to work today (assuming a typical average of 8 hours a day), and M-x timeclock-when-to-leave which will calculate when you’re done.

If you want Emacs to display the amount of time left of your workday in the mode line, either customize the timeclock-mode-line-display variable and set its value to t, or invoke the M-x timeclock-mode-line-display command.

Terminating the current Emacs session might or might not mean that you have stopped working on the project and, by default, Emacs asks you. You can, however, customize the value of the variable timeclock-ask-before-exiting to nil to avoid the question; then, only an explicit M-x timeclock-out or M-x timeclock-change will tell Emacs that the current interval is over.

The timeclock functions work by accumulating the data in a file called ~/.emacs.d/timelog. You can specify a different name for this file by customizing the variable timeclock-file. If you edit the timeclock file manually, or if you change the value of any of timeclock’s customizable variables, you should run the command M-x timeclock-reread-log to update the data in Emacs from the file.


*** More advanced features of the Calendar and Diary

This section describes some of the more advanced/specialized features of the calendar and diary. It starts with some of the many ways in which you can customize the calendar and diary to suit your personal tastes.

**** Customizing the Calendar

The calendar display unfortunately cannot be changed from three months, but you can customize the whitespace used by setting the variables: calendar-left-margin, calendar-day-header-width, calendar-day-digit-width, calendar-column-width, and calendar-intermonth-spacing. To display text between the months, for example week numbers, customize the variables calendar-intermonth-header and calendar-intermonth-text as described in their documentation.

The variable calendar-month-header controls the text that appears above each month in the calendar. By default, it shows the month and year. The variable calendar-day-header-array controls the text that appears above each day’s column in every month. By default, it shows the first two letters of each day’s name.

The variable calendar-holiday-marker specifies how to mark a date that is a holiday. Its value may be a single-character string to insert next to the date, or a face name to use for displaying the date. Likewise, the variable diary-entry-marker specifies how to mark a date that has diary entries. The function calendar-mark-today uses calendar-today-marker to mark today’s date. By default, the calendar uses faces named holiday, diary, and calendar-today for these purposes.

Starting the calendar runs the normal hook calendar-initial-window-hook. Recomputation of the calendar display does not run this hook. But if you leave the calendar with the q command and reenter it, the hook runs again.

The variable calendar-today-visible-hook is a normal hook run after the calendar buffer has been prepared with the calendar, when the current date is visible in the window. One use of this hook is to mark today’s date; to do that use either of the functions calendar-mark-today or calendar-star-date:

(add-hook 'calendar-today-visible-hook 'calendar-mark-today)
A similar normal hook, calendar-today-invisible-hook is run if the current date is not visible in the window.

Each of the calendar cursor motion commands runs the hook calendar-move-hook after it moves the cursor.


**** Customizing the Holidays

There are several variables listing the default holidays that Emacs knows about. These are: holiday-general-holidays, holiday-local-holidays, holiday-solar-holidays, holiday-bahai-holidays, holiday-christian-holidays, holiday-hebrew-holidays, holiday-islamic-holidays, holiday-oriental-holidays, and holiday-other-holidays. The names should be self-explanatory; e.g., holiday-solar-holidays lists sun- and moon-related holidays.

You can customize these lists of holidays to your own needs, deleting or adding holidays as described below. Set any of them to nil to not show the associated holidays.

The general holidays are, by default, holidays common throughout the United States. In contrast, holiday-local-holidays and holiday-other-holidays are both empty by default. These are intended for system-wide settings and your individual use, respectively.

By default, Emacs does not include all the holidays of the religions that it knows, only those commonly found in secular calendars. For a more extensive collection of religious holidays, you can set any (or all) of the variables calendar-bahai-all-holidays-flag, calendar-christian-all-holidays-flag, calendar-hebrew-all-holidays-flag, or calendar-islamic-all-holidays-flag to t.

Each of the holiday variables is a list of holiday forms, each form describing a holiday (or sometimes a list of holidays). Here is a table of the possible kinds of holiday form. Day numbers and month numbers count starting from 1, but dayname numbers count Sunday as 0. The argument string is always the description of the holiday, as a string.

(holiday-fixed month day string)
A fixed date on the Gregorian calendar.

(holiday-float month dayname k string
&optional day) The kth dayname (dayname=0 for Sunday, and so on) after or before Gregorian date month, day. Negative k means count back from the end of the month. Optional day defaults to 1 if k is positive, and the last day of month otherwise.

(holiday-chinese month day string)
A fixed date on the Chinese calendar.

(holiday-hebrew month day string)
A fixed date on the Hebrew calendar.

(holiday-islamic month day string)
A fixed date on the Islamic calendar.

(holiday-julian month day string)
A fixed date on the Julian calendar.

(holiday-sexp sexp string)
A date calculated by the Lisp expression sexp. The expression should use the variable year to compute and return the date of a holiday in the form of a list (month day year), or nil if the holiday doesn’t happen this year.

(if condition holiday-form)
A holiday that happens only if condition is true.

(function [args])
A list of dates calculated by the function function, called with arguments args.

For example, suppose you want to add Bastille Day, celebrated in France on July 14 (i.e., the fourteenth day of the seventh month). You can do this as follows:

(setq holiday-other-holidays '((holiday-fixed 7 14 "Bastille Day")))
Many holidays occur on a specific day of the week, at a specific time of month. Here is a holiday form describing Hurricane Supplication Day, celebrated in the Virgin Islands on the fourth Monday in July:

(holiday-float 7 1 4 "Hurricane Supplication Day")
Here the 7 specifies July, the 1 specifies Monday (Sunday is 0, Tuesday is 2, and so on), and the 4 specifies the fourth occurrence in the month (1 specifies the first occurrence, 2 the second occurrence, −1 the last occurrence, −2 the second-to-last occurrence, and so on).

You can specify holidays that occur on fixed days of the Bahá’í, Chinese, Hebrew, Islamic, and Julian calendars too. For example,

(setq holiday-other-holidays
      '((holiday-hebrew 10 2 "Last day of Hanukkah")
        (holiday-islamic 3 12 "Mohammed's Birthday")
        (holiday-julian 4 2 "Jefferson's Birthday")))
adds the last day of Hanukkah (since the Hebrew months are numbered with 1 starting from Nisan), the Islamic feast celebrating Mohammed’s birthday (since the Islamic months are numbered from 1 starting with Muharram), and Thomas Jefferson’s birthday, which is 2 April 1743 on the Julian calendar.

To include a holiday conditionally, use either Emacs Lisp’s if or the holiday-sexp form. For example, American presidential elections occur on the first Tuesday after the first Monday in November of years divisible by 4:

(holiday-sexp '(if (zerop (% year 4))
                   (calendar-gregorian-from-absolute
                    (1+ (calendar-dayname-on-or-before
                          1 (+ 6 (calendar-absolute-from-gregorian
                                  (list 11 1 year)))))))
              "US Presidential Election")
or

(if (zerop (% displayed-year 4))
    (holiday-fixed 11
           (calendar-extract-day
             (calendar-gregorian-from-absolute
               (1+ (calendar-dayname-on-or-before
                     1 (+ 6 (calendar-absolute-from-gregorian
                              (list 11 1 displayed-year)))))))
           "US Presidential Election"))
Some holidays just don’t fit into any of these forms because special calculations are involved in their determination. In such cases you must write a Lisp function to do the calculation. To include eclipses, for example, add (eclipses) to holiday-other-holidays and write an Emacs Lisp function eclipses that returns a (possibly empty) list of the relevant Gregorian dates among the range visible in the calendar window, with descriptive strings, like this:

(((6 4 2012) "Lunar Eclipse") ((11 13 2012) "Solar Eclipse") ... )


**** Converting from the Mayan Calendar

Here are the commands to select dates based on the Mayan calendar:

g m l
Move to a date specified by the long count calendar (calendar-mayan-goto-long-count-date).

g m n t
Move to the next occurrence of a place in the tzolkin calendar (calendar-mayan-next-tzolkin-date).

g m p t
Move to the previous occurrence of a place in the tzolkin calendar (calendar-mayan-previous-tzolkin-date).

g m n h
Move to the next occurrence of a place in the haab calendar (calendar-mayan-next-haab-date).

g m p h
Move to the previous occurrence of a place in the haab calendar (calendar-mayan-previous-haab-date).

g m n c
Move to the next occurrence of a place in the calendar round (calendar-mayan-next-calendar-round-date).

g m p c
Move to the previous occurrence of a place in the calendar round (calendar-mayan-previous-calendar-round-date).

To understand these commands, you need to understand the Mayan calendars. The long count is a counting of days with these units:

1 kin = 1 day   1 uinal = 20 kin   1 tun = 18 uinal
1 katun = 20 tun   1 baktun = 20 katun
Thus, the long count date 12.16.11.16.6 means 12 baktun, 16 katun, 11 tun, 16 uinal, and 6 kin. The Emacs calendar can handle Mayan long count dates as early as 7.17.18.13.3, but no earlier. When you use the g m l command, type the Mayan long count date with the baktun, katun, tun, uinal, and kin separated by periods.

The Mayan tzolkin calendar is a cycle of 260 days formed by a pair of independent cycles of 13 and 20 days. Since this cycle repeats endlessly, Emacs provides commands to move backward and forward to the previous or next point in the cycle. Type g m p t to go to the previous tzolkin date; Emacs asks you for a tzolkin date and moves point to the previous occurrence of that date. Similarly, type g m n t to go to the next occurrence of a tzolkin date.

The Mayan haab calendar is a cycle of 365 days arranged as 18 months of 20 days each, followed by a 5-day monthless period. Like the tzolkin cycle, this cycle repeats endlessly, and there are commands to move backward and forward to the previous or next point in the cycle. Type g m p h to go to the previous haab date; Emacs asks you for a haab date and moves point to the previous occurrence of that date. Similarly, type g m n h to go to the next occurrence of a haab date.

The Maya also used the combination of the tzolkin date and the haab date. This combination is a cycle of about 52 years called a calendar round. If you type g m p c, Emacs asks you for both a haab and a tzolkin date and then moves point to the previous occurrence of that combination. Use g m n c to move point to the next occurrence of a combination. These commands signal an error if the haab/tzolkin date combination you have typed is impossible.

Emacs uses strict completion (see Completion Exit) whenever it asks you to type a Mayan name, so you don’t have to worry about spelling.


**** Date Display Format

You can customize the way dates are displayed in the diary, mode lines, and messages by setting calendar-date-display-form. This variable holds a list of expressions that can involve the variables month, day, and year, which are all numbers in string form, and monthname and dayname, which are both alphabetic strings. In the American style, the default value of this list is as follows:

((if dayname (concat dayname ", ")) monthname " " day ", " year)
while in the European style this value is the default:

((if dayname (concat dayname ", ")) day " " monthname " " year)
The default ISO date representation is:

((format "%s-%.2d-%.2d" year (string-to-number month)
         (string-to-number day)))
Another typical American format is:

(month "/" day "/" (substring year -2))


**** Time Display Format

The calendar and diary by default display times of day in the conventional American style with the hours from 1 through 12, minutes, and either ‘am’ or ‘pm’. If you prefer the European style, also known in the US as military, in which the hours go from 00 to 23, you can alter the variable calendar-time-display-form. This variable is a list of expressions that can involve the variables 12-hours, 24-hours, and minutes, which are all numbers in string form, and am-pm and time-zone, which are both alphabetic strings. The default value is:

(12-hours ":" minutes am-pm
          (if time-zone " (") time-zone (if time-zone ")"))
Here is a value that provides European style times:

(24-hours ":" minutes
          (if time-zone " (") time-zone (if time-zone ")"))
Note that few calendar functions return a time of day (at present, only solar functions).


**** Customizing the Diary

Ordinarily, the diary window indicates any holidays that fall on the date of the diary entries, either in the mode line or the buffer itself. The process of checking for holidays can be slow, depending on the defined holidays. In that case, setting diary-show-holidays-flag to nil will speed up the diary display.

The variable diary-number-of-entries controls the number of days of diary entries to be displayed at one time. It affects the initial display when calendar-view-diary-initially-flag is t, as well as the command M-x diary. For example, a value of 1 (the default) displays only the current day’s diary entries, whereas a value of 2 will also show the next day’s entries. The value can also be a vector of seven integers: for example, if the value is [0 2 2 2 2 4 1] then no diary entries appear on Sunday, the current date’s and the next day’s diary entries appear Monday through Thursday, Friday through Monday’s entries appear on Friday, while on Saturday only that day’s entries appear.

You can customize the form of dates in your diary file by setting the variable diary-date-forms. This variable is a list of patterns for recognizing a date. Each date pattern is a list whose elements may be regular expressions (see Regular Expressions in the Emacs Lisp Reference Manual) or the symbols month, day, year, monthname, and dayname. All these elements serve as patterns that match certain kinds of text in the diary file. In order for the date pattern as a whole to match, all of its elements must match consecutively.

A regular expression in a date pattern matches in its usual fashion, using the standard syntax table altered so that ‘*’ is a word constituent.

The symbols month, day, year, monthname, and dayname match the month number, day number, year number, month name, and day name of the date being considered. The symbols that match numbers allow leading zeros; those that match names allow capitalization and abbreviation (as specified by calendar-month-abbrev-array and calendar-day-abbrev-array). All the symbols can match ‘*’; since ‘*’ in a diary entry means “any day”, “any month”, and so on, it should match regardless of the date being considered.

The default value of diary-date-forms in the American style is provided by diary-american-date-forms:

((month "/" day "[^/0-9]")
 (month "/" day "/" year "[^0-9]")
 (monthname " *" day "[^,0-9]")
 (monthname " *" day ", *" year "[^0-9]")
 (dayname "\\W"))
The variables diary-european-date-forms and diary-iso-date-forms provide other default styles.

The date patterns in the list must be mutually exclusive and must not match any portion of the diary entry itself, just the date and one character of whitespace. If, to be mutually exclusive, the pattern must match a portion of the diary entry text—beyond the whitespace that ends the date—then the first element of the date pattern must be backup. This causes the date recognizer to back up to the beginning of the current word of the diary entry, after finishing the match. Even if you use backup, the date pattern must absolutely not match more than a portion of the first word of the diary entry. For example, the default value of diary-european-date-forms is:

((day "/" month "[^/0-9]")
 (day "/" month "/" year "[^0-9]")
 (backup day " *" monthname "\\W+\\<\\([^*0-9]\\|\\([0-9]+[:aApP]\\)\\)")
 (day " *" monthname " *" year "[^0-9]")
 (dayname "\\W"))
Notice the use of backup in the third pattern, because it needs to match part of a word beyond the date itself to distinguish it from the fourth pattern.


**** Diary Entries Using non-Gregorian Calendars

As well as entries based on the standard Gregorian calendar, your diary can have entries based on Bahá’í, Chinese, Hebrew, or Islamic dates. Recognition of such entries can be time-consuming, however, and since most people don’t use them, you must explicitly enable their use. If you want the diary to recognize Hebrew-date diary entries, for example, you must do this:

(add-hook 'diary-nongregorian-listing-hook 'diary-hebrew-list-entries)
(add-hook 'diary-nongregorian-marking-hook 'diary-hebrew-mark-entries)
Similarly, for Islamic, Bahá’í and Chinese entries, add diary-islamic-list-entries and diary-islamic-mark-entries, diary-bahai-list-entries and diary-bahai-mark-entries, or diary-chinese-list-entries and diary-chinese-mark-entries.

These diary entries have the same formats as Gregorian-date diary entries; except that diary-bahai-entry-symbol (default ‘B’) must precede a Bahá’í date, diary-chinese-entry-symbol (default ‘C’) a Chinese date, diary-hebrew-entry-symbol (default ‘H’) a Hebrew date, and diary-islamic-entry-symbol (default ‘I’) an Islamic date. Moreover, non-Gregorian month names may not be abbreviated (because the first three letters are often not unique). (Note also that you must use “Adar I” if you want Adar of a common Hebrew year.) For example, a diary entry for the Hebrew date Heshvan 25 could look like this:

HHeshvan 25 Happy Hebrew birthday!
and would appear in the diary for any date that corresponds to Heshvan 25 on the Hebrew calendar. And here is an Islamic-date diary entry that matches Dhu al-Qada 25:

IDhu al-Qada 25 Happy Islamic birthday!
As with Gregorian-date diary entries, non-Gregorian entries are nonmarking if preceded by diary-nonmarking-symbol (default ‘&’).

Here is a table of commands used in the calendar to create diary entries that match the selected date and other dates that are similar in the Bahá’í, Chinese, Hebrew, or Islamic calendars:

i h d
diary-hebrew-insert-entry

i h m
diary-hebrew-insert-monthly-entry

i h y
diary-hebrew-insert-yearly-entry

i i d
diary-islamic-insert-entry

i i m
diary-islamic-insert-monthly-entry

i i y
diary-islamic-insert-yearly-entry

i B d
diary-bahai-insert-entry

i B m
diary-bahai-insert-monthly-entry

i B y
diary-bahai-insert-yearly-entry

i C d
diary-chinese-insert-entry

i C m
diary-chinese-insert-monthly-entry

i C y
diary-chinese-insert-yearly-entry

i C a
diary-chinese-insert-anniversary-entry

These commands work much like the corresponding commands for ordinary diary entries: they apply to the date that point is on in the calendar window, and what they do is insert just the date portion of a diary entry at the end of your diary file. You must then insert the rest of the diary entry. The basic commands add an entry for the specific non-Gregorian date, the ‘monthly’ commands for the given non-Gregorian day-within-month in every month, and the ‘yearly’ commands for the given non-Gregorian day and month in every year.


**** Diary Display

Diary display works by preparing the list of diary entries and then running the function specified by the variable diary-display-function. The default value diary-fancy-display displays diary entries and holidays by copying them into a special buffer that exists only for the sake of display. Copying diary entries to a separate buffer provides an opportunity to change the displayed text to make it prettier—for example, to sort the entries by the dates they apply to.

Ordinarily, the fancy diary buffer does not show days for which there are no diary entries, even if that day is a holiday. If you want such days to be shown in the fancy diary buffer, set the variable diary-list-include-blanks to t.

The fancy diary buffer enables View mode (see View Mode).

The alternative display method diary-simple-display shows the actual diary buffer, and uses invisible text to hide entries that don’t apply. Holidays are shown in the mode line. The advantage of this method is that you can edit the buffer and save your changes directly to the diary file. This method is not as flexible as the fancy method, however. For example, it cannot sort entries. Another disadvantage is that invisible text can be confusing. For example, if you copy a region of text in order to paste it elsewhere, invisible text may be included. Similarly, since the diary buffer as you see it is an illusion, simply printing the buffer may not print what you see on your screen.

For this reason, there is a special command to print hard copy of the diary buffer as it appears; this command is M-x diary-print-entries. It works with either display method, although with the fancy display you can also print the buffer like any other. To print a hard copy of a day-by-day diary for a week, position point on the first day of the week, type 7 d, and then do M-x diary-print-entries. As usual, the inclusion of the holidays slows down the display slightly; you can speed things up by setting the variable diary-show-holidays-flag to nil.

This command prepares a temporary buffer that contains only the diary entries currently visible in the diary buffer. Unlike with the simple display, the other irrelevant entries are really absent, not just hidden. After preparing the buffer, it runs the hook diary-print-entries-hook. The default value of this hook sends the data directly to the printer with the command lpr-buffer (see Printing Hard Copies). If you want to use a different command to do the printing, just change the value of this hook. Other uses might include, for example, rearranging the lines into order by day and time.

You can edit the diary entries as they appear in the simple diary window, but it is important to remember that the buffer displayed contains the entire diary file, with portions of it concealed from view. This means, for instance, that the C-f (forward-char) command can put point at what appears to be the end of the line, but what is in reality the middle of some concealed line.

Be careful when editing the diary entries in the simple display! Inserting additional lines or adding/deleting characters in the middle of a visible line cannot cause problems, but editing at the end of a line may not do what you expect. Deleting a line may delete other invisible entries that follow it. Before editing the simple diary buffer, it is best to display the entire file with s (diary-show-all-entries).


**** Fancy Diary Display

The following features only work with the fancy diary display.

You can use the normal hook diary-list-entries-hook to sort each day’s diary entries by their time of day. Here’s how:

(add-hook 'diary-list-entries-hook 'diary-sort-entries t)
For each day, this sorts diary entries that begin with a recognizable time of day according to their times. Diary entries without times come first within each day. Note how the sort command is placed at the end of the hook list, in case earlier members of the list change the order of the diary entries, or add items.

You can write ‘comments’ in diary entries, by setting the variables diary-comment-start and diary-comment-end to strings that delimit comments. The fancy display does not print comments. You might want to put meta-data for the use of other packages (e.g., the appointment package, see Appointments) inside comments.

Your main diary file can include other files. This permits a group of people to share a diary file for events that apply to all of them. Lines in the diary file starting with diary-include-string:

#include "filename"
include the diary entries from the file filename in the fancy diary buffer. The include mechanism is recursive, so that included files can include other files, and so on (you must be careful not to have a cycle of inclusions, of course). Here is how to enable the include facility:

(add-hook 'diary-list-entries-hook 'diary-include-other-diary-files)
(add-hook 'diary-mark-entries-hook 'diary-mark-included-diary-files)
The include mechanism works only with the fancy diary display, because simple diary display shows the entries directly from your diary file.


**** Sexp Entries and the Fancy Diary Display

Sexp diary entries allow you to do more than just have complicated conditions under which a diary entry applies. Sexp entries should be preceded by diary-sexp-entry-symbol (default ‘%%’) in the diary file. With the fancy diary display, sexp entries can generate the text of the entry depending on the date itself.

For example, an anniversary diary entry can insert the number of years since the anniversary date into the text of the diary entry. Thus the ‘%d’ in this diary entry:

%%(diary-anniversary 10 31 1948) Arthur's birthday (%d years old)
gets replaced by the age, so on October 31, 1990 the entry appears in the fancy diary buffer like this:

Arthur's birthday (42 years old)
If the diary file instead contains this entry:

%%(diary-anniversary 10 31 1948) Arthur's %d%s birthday
the entry in the fancy diary buffer for October 31, 1990 appears like this:

Arthur's 42nd birthday
Similarly, cyclic diary entries can interpolate the number of repetitions that have occurred:

%%(diary-cyclic 50 1 1 2012) Renew medication (%d%s time)
looks like this:

Renew medication (5th time)
in the fancy diary display on September 7, 2012.

There is an early-reminder diary sexp that includes its entry in the diary not only on the date of occurrence, but also on earlier dates. For example, if you want a reminder a week before your anniversary, you can use

%%(diary-remind '(diary-anniversary 12 22 1968) 7) Ed's anniversary
and the fancy diary will show ‘Ed's anniversary’ both on December 15 and on December 22.

The function diary-date applies to dates described by a month, day, year combination, each of which can be an integer, a list of integers, or t (meaning all values). For example,

%%(diary-date '(10 11 12) 22 t) Rake leaves
causes the fancy diary to show

Rake leaves
on October 22, November 22, and December 22 of every year.

The function diary-float allows you to describe diary entries that apply to dates like the third Friday of November, or the last Tuesday in April. The parameters are the month, dayname, and an index n. The entry appears on the nth dayname after the first day of month, where dayname=0 means Sunday, 1 means Monday, and so on. If n is negative it counts backward from the end of month. The value of month can be a list of months, a single month, or t to specify all months. You can also use an optional parameter day to specify the nth dayname on or after/before day of month; the value of day defaults to 1 if n is positive and to the last day of month if n is negative. For example,

%%(diary-float t 1 -1) Pay rent
causes the fancy diary to show

Pay rent
on the last Monday of every month.

The generality of sexp diary entries lets you specify any diary entry that you can describe algorithmically. A sexp diary entry contains an expression that computes whether the entry applies to any given date. If its value is non-nil, the entry applies to that date; otherwise, it does not. The expression can use the variable date to find the date being considered; its value is a list (month day year) that refers to the Gregorian calendar.

The sexp diary entry applies to a date when the expression’s value is non-nil, but some values have more specific meanings. If the value is a string, that string is a description of the event which occurs on that date. The value can also have the form (mark . string); then mark specifies how to mark the date in the calendar, and string is the description of the event. If mark is a single-character string, that character appears next to the date in the calendar. If mark is a face name, the date is displayed in that face. If mark is nil, that specifies no particular highlighting for the date.

Suppose you get paid on the 21st of the month if it is a weekday, and on the Friday before if the 21st is on a weekend. Here is how to write a sexp diary entry that matches those dates:

&%%(let ((dayname (calendar-day-of-week date))
         (day (cadr date)))
      (or (and (= day 21) (memq dayname '(1 2 3 4 5)))
          (and (memq day '(19 20)) (= dayname 5)))
         ) Pay check deposited
The following sexp diary entries take advantage of the ability (in the fancy diary display) to concoct diary entries whose text varies based on the date:

%%(diary-sunrise-sunset)
Make a diary entry for today’s local times of sunrise and sunset.

%%(diary-lunar-phases)
Make a diary entry for the phases (quarters) of the moon.

%%(diary-day-of-year)
Make a diary entry with today’s day number in the current year and the number of days remaining in the current year.

%%(diary-iso-date)
Make a diary entry with today’s equivalent ISO commercial date.

%%(diary-julian-date)
Make a diary entry with today’s equivalent Julian calendar date.

%%(diary-astro-day-number)
Make a diary entry with today’s equivalent astronomical (Julian) day number.

%%(diary-bahai-date)
Make a diary entry with today’s equivalent Bahá’í calendar date.

%%(diary-chinese-date)
Make a diary entry with today’s equivalent Chinese calendar date.

%%(diary-coptic-date)
Make a diary entry with today’s equivalent Coptic calendar date.

%%(diary-ethiopic-date)
Make a diary entry with today’s equivalent Ethiopic calendar date.

%%(diary-french-date)
Make a diary entry with today’s equivalent date on the French Revolutionary calendar.

%%(diary-hebrew-date)
Make a diary entry with today’s equivalent Hebrew calendar date.

%%(diary-islamic-date)
Make a diary entry with today’s equivalent Islamic calendar date.

%%(diary-mayan-date)
Make a diary entry with today’s equivalent Mayan calendar date.

%%(diary-persian-date)
Make a diary entry with today’s equivalent Persian calendar date.

For example, including the diary entry

&%%(diary-hebrew-date)
causes every day’s diary display to contain the equivalent date on the Hebrew calendar, if you are using the fancy diary display. (With simple diary display, the literal line ‘&%%(diary-hebrew-date)’ appears in the diary for any date.)

This function has been used to construct certain standard Hebrew sexp diary entries:

%%(diary-hebrew-rosh-hodesh)
Make a diary entry that tells the occurrence and ritual announcement of each new Hebrew month.

%%(diary-hebrew-parasha)
Make a Saturday diary entry that tells the weekly synagogue scripture reading.

%%(diary-hebrew-sabbath-candles)
Make a Friday diary entry that tells the local time of Sabbath candle lighting.

%%(diary-hebrew-omer)
Make a diary entry that gives the omer count, when appropriate.

%%(diary-hebrew-yahrzeit month day year) name
Make a diary entry marking the anniversary of a date of death. The date is the Gregorian (civil) date of death. The diary entry appears on the proper Hebrew calendar anniversary and on the day before. (The order of the parameters changes according to the calendar date style; for example in the European style to day, month, year.)

%%(diary-hebrew-birthday month day year)
Make a diary entry for a birthday on the Hebrew calendar.

All the functions documented above take an optional argument mark which specifies how to mark the date in the calendar display. If one of these functions decides that it applies to a certain date, it returns a value that contains mark, as described above.





* Document Viewing

DocView mode is a major mode for viewing DVI, PostScript (PS), PDF, OpenDocument, Microsoft Office, EPUB, CBZ, FB2, XPS and OXPS documents. It provides features such as slicing, zooming, and searching inside documents. It works by converting the document to a set of images using the gs (GhostScript) or pdfdraw/mutool draw (MuPDF) commands and other external tools, and then displays those converted images.

When you visit a document file that can be displayed with DocView mode, Emacs automatically uses that mode 21. As an exception, when you visit a PostScript file, Emacs switches to PS mode, a major mode for editing PostScript files as text; however, it also enables DocView minor mode, so you can type C-c C-c to view the document with DocView. In either DocView mode or DocView minor mode, repeating C-c C-c (doc-view-toggle-display) toggles between DocView and the underlying file contents.

When you visit a file which would normally be handled by DocView mode but some requirement is not met (e.g., you operate in a terminal frame or Emacs has no PNG support), you are queried if you want to view the document’s contents as plain text. If you confirm, the buffer is put in text mode and DocView minor mode is activated. Thus, by typing C-c C-c you switch to the fallback mode. With another C-c C-c you return to DocView mode. The plain text contents can also be displayed from within DocView mode by typing C-c C-t (doc-view-open-text).

You can explicitly enable DocView mode with the command M-x doc-view-mode. You can toggle DocView minor mode with M-x doc-view-minor-mode.

When DocView mode starts, it displays a welcome screen and begins formatting the file, page by page. It displays the first page once that has been formatted.

To kill the DocView buffer, type k (doc-view-kill-proc-and-buffer). To bury it, type q (quit-window).


** DocView Navigation

In DocView mode, you can scroll the current page using the usual Emacs movement keys: C-p, C-n, C-b, C-f, and the arrow keys.

By default, the line-motion keys C-p and C-n stop scrolling at the beginning and end of the current page, respectively. However, if you change the variable doc-view-continuous to a non-nil value, then C-p displays the previous page if you are already at the beginning of the current page, and C-n displays the next page if you are at the end of the current page.

You can also display the next page by typing n, PageDown, next or C-x ] (doc-view-next-page). To display the previous page, type p, PageUp, prior or C-x [ (doc-view-previous-page).

SPC (doc-view-scroll-up-or-next-page) is a convenient way to advance through the document. It scrolls within the current page or advances to the next. DEL moves backwards in a similar way (doc-view-scroll-down-or-previous-page).

To go to the first page, type M-< (doc-view-first-page); to go to the last one, type M-> (doc-view-last-page). To jump to a page by its number, type M-g M-g or M-g g (doc-view-goto-page).

You can enlarge or shrink the document with + (doc-view-enlarge) and - (doc-view-shrink). By default, these commands just rescale the already-rendered image. If you instead want the image to be re-rendered at the new size, set doc-view-scale-internally to nil. To specify the default size for DocView, customize the variable doc-view-resolution.

When the mutool program is available, DocView will use it to generate entries for an outline menu, making it accessible via the imenu facility (see Imenu). To disable this functionality even when mutool can be found on your system, customize the variable doc-view-imenu-enabled to the nil value. You can further customize how imenu items are formatted and displayed using the variables doc-view-imenu-format and doc-view-flatten.


** DocView Searching

In DocView mode, you can search the file’s text for a regular expression (see Syntax of Regular Expressions). The interface for searching is inspired by isearch (see Incremental Search).

To begin a search, type C-s (doc-view-search) or C-r (doc-view-search-backward). This reads a regular expression using a minibuffer, then echoes the number of matches found within the document. You can move forward and back among the matches by typing C-s and C-r. DocView mode has no way to show the match inside the page image; instead, it displays a tooltip (at the mouse position) listing all matching lines in the current page. To force display of this tooltip, type C-t (doc-view-show-tooltip).

To start a new search, use the search command with a prefix argument; i.e., C-u C-s for a forward search or C-u C-r for a backward search.


** DocView Slicing

Documents often have wide margins for printing. They are annoying when reading the document on the screen, because they use up screen space and can cause inconvenient scrolling.

With DocView you can hide these margins by selecting a slice of pages to display. A slice is a rectangle within the page area; once you specify a slice in DocView, it applies to whichever page you look at.

To specify the slice numerically, type c s (doc-view-set-slice); then enter the top left pixel position and the slice’s width and height.

A more convenient graphical way to specify the slice is with c m (doc-view-set-slice-using-mouse), where you use the mouse to select the slice. Simply press and hold the left mouse button at the upper-left corner of the region you want to have in the slice, then move the mouse pointer to the lower-right corner and release the button.

The most convenient way is to set the optimal slice by using BoundingBox information automatically determined from the document by typing c b (doc-view-set-slice-from-bounding-box).

To cancel the selected slice, type c r (doc-view-reset-slice). Then DocView shows the entire page including its entire margins.


** DocView Conversion

For efficiency, DocView caches the images produced by gs. The name of the directory where it caches images is given by the variable doc-view-cache-directory. You can clear the cache directory by typing M-x doc-view-clear-cache.

To force reconversion of the currently viewed document, type r or g (revert-buffer). To kill the converter process associated with the current buffer, type K (doc-view-kill-proc). The command k (doc-view-kill-proc-and-buffer) kills the converter process and the DocView buffer.



* Running Shell Commands from Emacs

Emacs has commands for passing single command lines to shell subprocesses, and for running a shell interactively with input and output to an Emacs buffer, and for running a shell in a terminal emulator window.

M-! cmd RET
Run the shell command cmd and display the output (shell-command).

M-| cmd RET
Run the shell command cmd with region contents as input; optionally replace the region with the output (shell-command-on-region).

M-& cmd RET
Run the shell command cmd asynchronously, and display the output (async-shell-command).

M-x shell
Run a subshell with input and output through an Emacs buffer. You can then give commands interactively.

M-x term
Run a subshell with input and output through an Emacs buffer. You can then give commands interactively. Full terminal emulation is available.

Whenever you specify a relative file name for an executable program (either in the cmd argument to one of the above commands, or in other contexts), Emacs searches for the program in the directories specified by the variable exec-path. The value of this variable must be a list of directories; the default value is initialized from the environment variable PATH when Emacs is started (see General Variables).

M-x eshell invokes a shell implemented entirely in Emacs. It is documented in its own manual. See Eshell in Eshell: The Emacs Shell.


** Single Shell Commands

M-! (shell-command) reads a line of text using the minibuffer and executes it as a shell command, in a subshell made just for that command. Standard input for the command comes from the null device. If the shell command produces any output, the output appears either in the echo area (if it is short), or in the ‘"*Shell Command Output*"’ (shell-command-buffer-name) buffer (if the output is long). The variables resize-mini-windows and max-mini-window-height (see Editing in the Minibuffer) control when Emacs should consider the output to be too long for the echo area. Note that customizing shell-command-dont-erase-buffer, described below, can affect what is displayed in the echo area.

For instance, one way to decompress a file named foo.gz is to type M-! gunzip foo.gz RET. That shell command normally creates the file foo and produces no terminal output.

A numeric argument to shell-command, e.g., M-1 M-!, causes it to insert terminal output into the current buffer instead of a separate buffer. By default, it puts point before the output, and sets the mark after the output (but a non-default value of shell-command-dont-erase-buffer can change that, see below). For instance, M-1 M-! gunzip < foo.gz RET would insert the uncompressed form of the file foo.gz into the current buffer.

Provided the specified shell command does not end with ‘&’, it runs synchronously, and you must wait for it to exit before continuing to use Emacs. To stop waiting, type C-g to quit; this sends a SIGINT signal to terminate the shell command (this is the same signal that C-c normally generates in the shell). Emacs then waits until the command actually terminates. If the shell command doesn’t stop (because it ignores the SIGINT signal), type C-g again; this sends the command a SIGKILL signal, which is impossible to ignore.

A shell command that ends in ‘&’ is executed asynchronously, and you can continue to use Emacs as it runs. You can also type M-& (async-shell-command) to execute a shell command asynchronously; this is exactly like calling M-! with a trailing ‘&’, except that you do not need the ‘&’. The output from asynchronous shell commands, by default, goes into the ‘"*Async Shell Command*"’ buffer (shell-command-buffer-name-async). Emacs inserts the output into this buffer as it comes in, whether or not the buffer is visible in a window.

If you want to run more than one asynchronous shell command at the same time, they could end up competing for the output buffer. The option async-shell-command-buffer specifies what to do about this; e.g., whether to rename the pre-existing output buffer, or to use a different buffer for the new command. Consult the variable’s documentation for more possibilities.

If you want the output buffer for asynchronous shell commands to be displayed only when the command generates output, set async-shell-command-display-buffer to nil.

The option async-shell-command-width defines the number of display columns available for output of asynchronous shell commands. A positive integer tells the shell to use that number of columns for command output. The default value is nil that means to use the same number of columns as provided by the shell.

To make the above commands show the current directory in their prompts, customize the variable shell-command-prompt-show-cwd to a non-nil value.

M-| (shell-command-on-region) is like M-!, but passes the contents of the region as the standard input to the shell command, instead of no input. With a numeric argument, it deletes the old region and replaces it with the output from the shell command.

For example, you can use M-| with the gpg program to see what keys are in the buffer. If the buffer contains a GnuPG key, type C-x h M-| gpg RET to feed the entire buffer contents to gpg. This will output the list of keys to the buffer whose name is the value of shell-command-buffer-name.

The above commands use the shell specified by the variable shell-file-name. Its default value is determined by the SHELL environment variable when Emacs is started. If the file name is relative, Emacs searches the directories listed in exec-path (see Running Shell Commands from Emacs).

If the default directory is remote (see Remote Files), the default value is /bin/sh. This can be changed by declaring shell-file-name connection-local (see Per-Connection Local Variables).

To specify a coding system for M-! or M-|, use the command C-x RET c immediately beforehand. See Coding Systems for Interprocess Communication.

By default, error output is intermixed with the regular output in the output buffer. But if you change the value of the variable shell-command-default-error-buffer to a string, error output is inserted into a buffer of that name.

By default, the output buffer is erased between shell commands, except when the output goes to the current buffer. If you change the value of the option shell-command-dont-erase-buffer to erase, then the output buffer is always erased. Other non-nil values prevent erasing of the output buffer, and—if the output buffer is not the current buffer—also control where to put point after inserting the output of the shell command:

beg-last-out
Puts point at the beginning of the last shell-command output.

end-last-out
Puts point at the end of the last shell-command output, i.e. at the end of the output buffer.

save-point
Restores the position of point as it was before inserting the shell-command output.

Note that if this option is non-nil, the output shown in the echo area could be from more than just the last command, since the echo area just displays a portion of the output buffer.

In case the output buffer is not the current buffer, shell command output is appended at the end of this buffer.


** Interactive Subshell

To run a subshell interactively, type M-x shell. This creates (or reuses) a buffer named *shell*, and runs a shell subprocess with input coming from and output going to that buffer. That is to say, any terminal output from the subshell goes into the buffer, advancing point, and any terminal input for the subshell comes from text in the buffer. To give input to the subshell, go to the end of the buffer and type the input, terminated by RET.

By default, when the subshell is invoked interactively, the *shell* buffer is displayed in a new window, unless the current window already shows the *shell* buffer. This behavior can be customized via display-buffer-alist (see How display-buffer works).

While the subshell is waiting or running a command, you can switch windows or buffers and perform other editing in Emacs. Emacs inserts the output from the subshell into the Shell buffer whenever it has time to process it (e.g., while waiting for keyboard input).

In the Shell buffer, prompts are displayed with the face comint-highlight-prompt, and submitted input lines are displayed with the face comint-highlight-input. This makes it easier to distinguish input lines from the shell output. See Text Faces.

To make multiple subshells, invoke M-x shell with a prefix argument (e.g., C-u M-x shell). Then the command will read a buffer name, and create (or reuse) a subshell in that buffer. You can also rename the *shell* buffer using M-x rename-uniquely, then create a new *shell* buffer using plain M-x shell. Subshells in different buffers run independently and in parallel.

Emacs attempts to keep track of what the current directory is by looking at the commands you enter, looking for ‘cd’ commands and the like. This is an error-prone solution, since there are many ways to change the current directory, so Emacs also looks for special OSC (Operating System Commands) escape codes that are designed to convey this information in a more reliable fashion. You should arrange for your shell to print the appropriate escape sequence at each prompt, for instance with the following command:

printf "\e]7;file://%s%s\e\\" "$HOSTNAME" "$PWD"
To specify the shell file name used by M-x shell, customize the variable explicit-shell-file-name. If this is nil (the default), Emacs uses the environment variable ESHELL if it exists. Otherwise, it usually uses the variable shell-file-name (see Single Shell Commands); but if the default directory is remote (see Remote Files), it prompts you for the shell file name. See Minibuffers for File Names, for hints how to type remote file names effectively.

Emacs sends the new shell the contents of the file ~/.emacs_shellname as input, if it exists, where shellname is the name of the file that the shell was loaded from. For example, if you use bash, the file sent to it is ~/.emacs_bash. If this file is not found, Emacs tries with ~/.emacs.d/init_shellname.sh.

To specify a coding system for the shell, you can use the command C-x RET c immediately before M-x shell. You can also change the coding system for a running subshell by typing C-x RET p in the shell buffer. See Coding Systems for Interprocess Communication.

Emacs sets the environment variable INSIDE_EMACS in the subshell to ‘version,comint’, where version is the Emacs version (e.g., ‘28.1’). Programs can check this variable to determine whether they are running inside an Emacs subshell.


** Shell Mode

The major mode for Shell buffers is Shell mode. Many of its special commands are bound to the C-c prefix, and resemble the usual editing and job control characters present in ordinary shells, except that you must type C-c first. Here is a list of Shell mode commands:

RET ¶
Send the current line as input to the subshell (comint-send-input). Any shell prompt at the beginning of the line is omitted (see Shell Prompts). If point is at the end of buffer, this is like submitting the command line in an ordinary interactive shell. However, you can also invoke RET elsewhere in the shell buffer to submit the current line as input.

TAB ¶
Complete the command name or file name before point in the shell buffer (completion-at-point). This uses the usual Emacs completion rules (see Completion), with the completion alternatives being file names, environment variable names, the shell command history, and history references (see Shell History References). For options controlling the completion, see Shell Mode Options.

M-? ¶
Display temporarily a list of the possible completions of the file name before point (comint-dynamic-list-filename-completions).

C-d ¶
Either delete a character or send EOF (comint-delchar-or-maybe-eof). Typed at the end of the shell buffer, this sends EOF to the subshell. Typed at any other position in the buffer, this deletes a character as usual.

C-c C-a ¶
Move to the beginning of the line, but after the prompt if any (comint-bol-or-process-mark). If you repeat this command twice in a row, the second time it moves back to the process mark, which is the beginning of the input that you have not yet sent to the subshell. (Normally that is the same place—the end of the prompt on this line—but after C-c SPC the process mark may be in a previous line.)

C-c SPC
Accumulate multiple lines of input, then send them together (comint-accumulate). This command inserts a newline before point, but does not send the preceding text as input to the subshell—at least, not yet. Both lines, the one before this newline and the one after, will be sent together (along with the newline that separates them), when you type RET.

C-c C-u ¶
Kill all text pending at end of buffer to be sent as input (comint-kill-input). If point is not at end of buffer, this only kills the part of this text that precedes point.

C-c C-w ¶
Kill a word before point (backward-kill-word).

C-c C-c ¶
Interrupt the shell or its current subjob if any (comint-interrupt-subjob). This command also kills any shell input pending in the shell buffer and not yet sent.

C-c C-z ¶
Stop the shell or its current subjob if any (comint-stop-subjob). This command also kills any shell input pending in the shell buffer and not yet sent.

C-c C-\ ¶
Send quit signal to the shell or its current subjob if any (comint-quit-subjob). This command also kills any shell input pending in the shell buffer and not yet sent.

C-c C-o ¶
Delete the last batch of output from a shell command (comint-delete-output). This is useful if a shell command spews out lots of output that just gets in the way. With a prefix argument, this command saves the deleted text in the kill-ring (see The Kill Ring), so that you could later yank it (see Yanking) elsewhere.

C-c C-s ¶
Write the last batch of output from a shell command to a file (comint-write-output). With a prefix argument, the file is appended to instead. Any prompt at the end of the output is not written.

C-c C-r ¶
C-M-l
Scroll to display the beginning of the last batch of output at the top of the window; also move the cursor there (comint-show-output).

C-c C-e ¶
Scroll to put the last line of the buffer at the bottom of the window (comint-show-maximum-output).

C-c C-f ¶
Move forward across one shell command, but not beyond the current line (shell-forward-command). The variable shell-command-regexp specifies how to recognize the end of a command.

C-c C-b ¶
Move backward across one shell command, but not beyond the current line (shell-backward-command).

M-x dirs
Ask the shell for its working directory, and update the Shell buffer’s default directory. See Directory Tracking.

M-x comint-send-invisible RET text RET ¶
Send text as input to the shell, after reading it without echoing. This is useful when a shell command runs a program that asks for a password.

Please note that Emacs will not echo passwords by default. If you really want them to be echoed, evaluate (see Evaluating Emacs Lisp Expressions) the following Lisp expression:

(remove-hook 'comint-output-filter-functions
             'comint-watch-for-password-prompt)
M-x comint-continue-subjob ¶
Continue the shell process. This is useful if you accidentally suspend the shell process.22

M-x comint-strip-ctrl-m ¶
Discard all control-M characters from the current group of shell output. The most convenient way to use this command is to make it run automatically when you get output from the subshell. To do that, evaluate this Lisp expression:

(add-hook 'comint-output-filter-functions
          'comint-strip-ctrl-m)
M-x comint-truncate-buffer ¶
This command truncates the shell buffer to a certain maximum number of lines, specified by the variable comint-buffer-maximum-size. Here’s how to do this automatically each time you get output from the subshell:

(add-hook 'comint-output-filter-functions
          'comint-truncate-buffer)
By default, Shell mode handles common ANSI escape codes (for instance, for changing the color of text). Emacs also optionally supports some extend escape codes, like some of the OSC (Operating System Codes) if you put the following in your init file:

(add-hook 'comint-output-filter-functions 'comint-osc-process-output)
With this enabled, the output from, for instance, ls --hyperlink will be made into clickable buttons in the Shell mode buffer.

Shell mode is a derivative of Comint mode, a general-purpose mode for communicating with interactive subprocesses. Most of the features of Shell mode actually come from Comint mode, as you can see from the command names listed above. The special features of Shell mode include the directory tracking feature, and a few user commands.

Other Emacs features that use variants of Comint mode include GUD (see Running Debuggers Under Emacs) and M-x run-lisp (see Running an External Lisp).

You can use M-x comint-run to execute any program of your choice in a subprocess using unmodified Comint mode—without the specializations of Shell mode. To pass arguments to the program, use C-u M-x comint-run.

Footnotes
(22)
You should not suspend the shell process. Suspending a subjob of the shell is a completely different matter—that is normal practice, but you must use the shell to continue the subjob; this command won’t do it.


** Shell Prompts

A prompt is text output by a program to show that it is ready to accept new user input. Normally, Comint mode (and thus Shell mode) automatically figures out which part of the buffer is a prompt, based on the output of the subprocess. (Specifically, it assumes that any received output line which doesn’t end with a newline is a prompt.)

Comint mode divides the buffer into two types of fields: input fields (where user input is typed) and output fields (everywhere else). Prompts are part of the output fields. Most Emacs motion commands do not cross field boundaries, unless they move over multiple lines. For instance, when point is in the input field on a shell command line, C-a puts point at the beginning of the input field, after the prompt. Internally, the fields are implemented using the field text property (see Text Properties in the Emacs Lisp Reference Manual).

If you change the variable comint-use-prompt-regexp to a non-nil value, then Comint mode will recognize prompts using a regular expression (see Syntax of Regular Expressions). In Shell mode, the regular expression is specified by the variable shell-prompt-pattern. The default value of comint-use-prompt-regexp is nil, because this method for recognizing prompts is unreliable, but you may want to set it to a non-nil value in unusual circumstances. In that case, Emacs does not divide the Comint buffer into fields, so the general motion commands behave as they normally do in buffers without special text properties. However, you can use the paragraph motion commands to conveniently navigate the buffer (see Paragraphs); in Shell mode, Emacs uses shell-prompt-pattern as paragraph boundaries.


** Shell Command History

Shell buffers support three ways of repeating earlier commands. You can use keys like those used for the minibuffer history; these work much as they do in the minibuffer, inserting text from prior commands while point remains always at the end of the buffer. You can move through the buffer to previous inputs in their original place, then resubmit them or copy them to the end. Or you can use a ‘!’-style history reference.

*** Shell History Ring

M-p
C-UP
Fetch the next earlier old shell command (comint-previous-input).

M-n
C-DOWN
Fetch the next later old shell command (comint-next-input).

M-r
Begin an incremental regexp search of old shell commands (comint-history-isearch-backward-regexp).

C-c C-x ¶
Fetch the next subsequent command from the history (comint-get-next-from-history).

C-c . ¶
Fetch one argument from an old shell command (comint-input-previous-argument).

C-c C-l ¶
Display the buffer’s history of shell commands in another window (comint-dynamic-list-input-ring).

Shell buffers provide a history of previously entered shell commands. To reuse shell commands from the history, use the editing commands M-p, M-n, and M-r. These work similar to the minibuffer history commands (see Minibuffer History), except that they operate within the Shell buffer rather than the minibuffer, and M-r in a Shell buffer invokes incremental search through shell command history.

M-p fetches an earlier shell command to the end of the shell buffer. Successive use of M-p fetches successively earlier shell commands, each replacing any text that was already present as potential shell input. M-n does likewise except that it finds successively more recent shell commands from the buffer. C-UP works like M-p, and C-DOWN like M-n.

The history search command M-r begins an incremental regular expression search of previous shell commands. After typing M-r, start typing the desired string or regular expression; the last matching shell command will be displayed in the current line. Incremental search commands have their usual effects—for instance, C-s and C-r search forward and backward for the next match (see Incremental Search). When you find the desired input, type RET to terminate the search. This puts the input in the command line. Any partial input you were composing before navigating the history list is restored when you go to the beginning or end of the history ring.

Often it is useful to reexecute several successive shell commands that were previously executed in sequence. To do this, first find and reexecute the first command of the sequence. Then type C-c C-x; that will fetch the following command—the one that follows the command you just repeated. Then type RET to reexecute this command. You can reexecute several successive commands by typing C-c C-x RET over and over.

The command C-c . (comint-insert-previous-argument) copies an individual argument from a previous command, like ESC . in Bash and zsh. The simplest use copies the last argument from the previous shell command. With a prefix argument n, it copies the nth argument instead. Repeating C-c . copies from an earlier shell commands, always using the same value of n (don’t give a prefix argument when you repeat the C-c . command).

If you set comint-insert-previous-argument-from-end to a non-nil value, C-c . will instead copy the nth argument counting from the last one; this emulates ESC . in zsh.

These commands get the text of previous shell commands from a special history list, not from the shell buffer itself. Thus, editing the shell buffer, or even killing large parts of it, does not affect the history that these commands access.

Some shells store their command histories in files so that you can refer to commands from previous shell sessions. Emacs reads the command history file for your chosen shell, to initialize its own command history. The file name is ~/.bash_history for bash, ~/.sh_history for ksh, and ~/.history for other shells.

If you run the shell on a remote host, this setting might be overwritten by the variable tramp-histfile-override. It is recommended to set this variable to nil.


*** Shell History Copying

C-c C-p
Move point to the previous prompt (comint-previous-prompt).

C-c C-n
Move point to the following prompt (comint-next-prompt).

C-c RET
Copy the input command at point, inserting the copy at the end of the buffer (comint-copy-old-input). This is useful if you move point back to a previous command. After you copy the command, you can submit the copy as input with RET. If you wish, you can edit the copy before resubmitting it. If you use this command on an output line, it copies that line to the end of the buffer.

mouse-2
If comint-use-prompt-regexp is nil (the default), copy the old input command that you click on, inserting the copy at the end of the buffer (comint-insert-input). If comint-use-prompt-regexp is non-nil, or if the click is not over old input, just yank as usual.

Moving to a previous input and then copying it with C-c RET or mouse-2 produces the same results—the same buffer contents—that you would get by using M-p enough times to fetch that previous input from the history list. However, C-c RET copies the text from the buffer, which can be different from what is in the history list if you edit the input text in the buffer after it has been sent.


*** Shell History References

Various shells, including csh and bash, support history references that begin with ‘!’ and ‘^’. Shell mode recognizes these constructs, and can perform the history substitution for you.

If you insert a history reference and type TAB, this searches the input history for a matching command, performs substitution if necessary, and places the result in the buffer in place of the history reference. For example, you can fetch the most recent command beginning with ‘mv’ with ! m v TAB. You can edit the command if you wish, and then resubmit the command to the shell by typing RET.

Shell mode can optionally expand history references in the buffer when you send them to the shell. To request this, set the variable comint-input-autoexpand to input. You can make SPC perform history expansion by binding SPC to the command comint-magic-space. See Changing Key Bindings Interactively.

Shell mode recognizes history references when they follow a prompt. See Shell Prompts, for how Shell mode recognizes prompts.


** Directory Tracking

Shell mode keeps track of ‘cd’, ‘pushd’ and ‘popd’ commands given to the subshell, in order to keep the Shell buffer’s default directory (see File Names) the same as the shell’s working directory. It recognizes these commands by examining lines of input that you send.

If you use aliases for these commands, you can tell Emacs to recognize them also, by setting the variables shell-pushd-regexp, shell-popd-regexp, and shell-cd-regexp to the appropriate regular expressions (see Syntax of Regular Expressions). For example, if shell-pushd-regexp matches the beginning of a shell command line, that line is regarded as a pushd command. These commands are recognized only at the beginning of a shell command line.

If Emacs gets confused about changes in the working directory of the subshell, type M-x dirs. This command asks the shell for its working directory and updates the default directory accordingly. It works for shells that support the most common command syntax, but may not work for unusual shells.

You can also use Dirtrack mode, a buffer-local minor mode that implements an alternative method of tracking the shell’s working directory. To use this method, your shell prompt must contain the working directory at all times, and you must supply a regular expression for recognizing which part of the prompt contains the working directory; see the documentation of the variable dirtrack-list for details. To use Dirtrack mode, type M-x dirtrack-mode in the Shell buffer, or add dirtrack-mode to shell-mode-hook (see Hooks).


** Shell Mode Options

If the variable comint-scroll-to-bottom-on-input is non-nil, insertion and yank commands scroll the selected window to the bottom before inserting. The default is nil.

If comint-scroll-show-maximum-output is non-nil, then arrival of output when point is at the end tries to scroll the last line of text to the bottom line of the window, showing as much useful text as possible. (This mimics the scrolling behavior of most terminals.) The default is t.

By setting comint-move-point-for-output, you can opt for having point jump to the end of the buffer whenever output arrives—no matter where in the buffer point was before. If the value is this, point jumps in the selected window. If the value is all, point jumps in each window that shows the Comint buffer. If the value is other, point jumps in all nonselected windows that show the current buffer. The default value is nil, which means point does not jump to the end.

If you set comint-prompt-read-only, the prompts in the Comint buffer are read-only.

The variable comint-input-ignoredups controls whether successive identical inputs are stored in the input history. A non-nil value means to omit an input that is the same as the previous input. The default is nil, which means to store each input even if it is equal to the previous input.

Three variables customize file name completion. The variable comint-completion-addsuffix controls whether completion inserts a space or a slash to indicate a fully completed file or directory name (non-nil means do insert a space or slash). comint-completion-recexact, if non-nil, directs TAB to choose the shortest possible completion if the usual Emacs completion algorithm cannot add even a single character. comint-completion-autolist, if non-nil, says to list all the possible completions whenever completion is not exact.

Command completion normally considers only executable files. If you set shell-completion-execonly to nil, it considers nonexecutable files as well.

The variable shell-completion-fignore specifies a list of file name extensions to ignore in Shell mode completion. The default setting is nil, but some users prefer ("~" "#" "%") to ignore file names ending in ‘~’, ‘#’ or ‘%’. Other related Comint modes use the variable comint-completion-fignore instead.

Some implementation details of the shell command completion may also be found in the lisp documentation of the shell-dynamic-complete-command function.

You can configure the behavior of ‘pushd’. Variables control whether ‘pushd’ behaves like ‘cd’ if no argument is given (shell-pushd-tohome), pop rather than rotate with a numeric argument (shell-pushd-dextract), and only add directories to the directory stack if they are not already on it (shell-pushd-dunique). The values you choose should match the underlying shell, of course.

Comint mode sets the TERM environment variable to a safe default value, but this value disables some useful features. For example, color is disabled in applications that use TERM to determine if color is supported. Therefore, Emacs provides an option comint-terminfo-terminal to let you choose a terminal with more advanced features, as defined in your system’s terminfo database. Emacs will use this option as the value for TERM so long as system-uses-terminfo is non-nil.

Both comint-terminfo-terminal and system-uses-terminfo can be declared as connection-local variables to adjust these options to match what a remote system expects (see Per-Connection Local Variables).


** Emacs Terminal Emulator

To run a subshell in a text terminal emulator, use M-x term. This creates (or reuses) a buffer named *terminal*, and runs a subshell with input coming from your keyboard, and output going to that buffer.

The terminal emulator uses Term mode, which has two input modes. In line mode, Term basically acts like Shell mode (see Shell Mode). In char mode, each character is sent directly to the subshell, as terminal input; the sole exception is the terminal escape character, which by default is C-c (see Term Mode). Any echoing of your input is the responsibility of the subshell; any terminal output from the subshell goes into the buffer, advancing point.

Some programs (such as Emacs itself) need to control the appearance of the terminal screen in detail. They do this by emitting special control codes. Term mode recognizes and handles ANSI-standard VT100-style escape sequences, which are accepted by most modern terminals, including xterm. (Hence, you can actually run Emacs inside an Emacs Term window.)

The term face specifies the default appearance of text in the terminal emulator (the default is the same appearance as the default face). When terminal control codes are used to change the appearance of text, these are represented in the terminal emulator by the faces term-color-black, term-color-red, term-color-green, term-color-yellow term-color-blue, term-color-magenta, term-color-cyan, term-color-white, term-color-underline, and term-color-bold. See Text Faces.

You can also use Term mode to communicate with a device connected to a serial port. See Serial Terminal.

The file name used to load the subshell is determined the same way as for Shell mode. To make multiple terminal emulators, rename the buffer *terminal* to something different using M-x rename-uniquely, just as with Shell mode.

Unlike Shell mode, Term mode does not track the current directory by examining your input. But some shells can tell Term what the current directory is. This is done automatically by bash version 1.15 and later.


** Term Mode

To switch between line and char mode in Term mode, use these commands:

C-c C-j
Switch to line mode (term-line-mode). Do nothing if already in line mode.

C-c C-k
Switch to char mode (term-char-mode). Do nothing if already in char mode.

The following commands are only available in char mode:

C-c C-c
Send a literal C-c to the sub-shell (term-interrupt-subjob).

C-c char
This is equivalent to C-x char in normal Emacs. For example, C-c o invokes the global binding of C-x o, which is normally ‘other-window’.

Term mode has a page-at-a-time feature. When enabled, it makes output pause at the end of each screenful:

C-c C-q
Toggle the page-at-a-time feature (term-pager-toggle). This command works in both line and char modes. When the feature is enabled, the mode-line displays the word ‘page’, and each time Term receives more than a screenful of output, it pauses and displays ‘**MORE**’ in the mode-line. Type SPC to display the next screenful of output, or ? to see your other options. The interface is similar to the more program.


** Remote Host Shell

You can login to a remote computer, using whatever commands you would from a regular terminal (e.g., the ssh command), from a Term window.

A program that asks you for a password will normally suppress echoing of the password, so the password will not show up in the buffer. This will happen just as if you were using a real terminal, if the buffer is in char mode. If it is in line mode, the password is temporarily visible, but will be erased when you hit return. (This happens automatically; there is no special password processing.)

When you log in to a different machine, you need to specify the type of terminal you’re using, by setting the TERM environment variable in the environment for the remote login command. (If you use bash, you do that by writing the variable assignment before the remote login command, without a separating comma.) Terminal types ‘ansi’ or ‘vt100’ will work on most systems.


** Serial Terminal

If you have a device connected to a serial port of your computer, you can communicate with it by typing M-x serial-term. This command asks for a serial port name and speed, and switches to a new Term mode buffer. Emacs communicates with the serial device through this buffer just like it does with a terminal in ordinary Term mode.

The speed of the serial port is measured in bits per second. The most common speed is 9600 bits per second. You can change the speed interactively by clicking on the mode line.

A serial port can be configured even more by clicking on ‘8N1’ in the mode line. By default, a serial port is configured as ‘8N1’, which means that each byte consists of 8 data bits, No parity check bit, and 1 stopbit.

If the speed or the configuration is wrong, you cannot communicate with your device and will probably only see garbage output in the window.



* Eshell

Eshell is a shell-like command interpreter implemented in Emacs Lisp. It invokes no external processes except for those requested by the user. It is intended to be an alternative to the IELM (see Lisp Interaction in The Emacs Editor) REPL1 for Emacs and with an interface similar to command shells such as bash, zsh, rc, or 4dos.

This manual is for Eshell, the Emacs shell.

Copyright © 1999–2024 Free Software Foundation, Inc.

Permission is granted to copy, distribute and/or modify this document under the terms of the GNU Free Documentation License, Version 1.3 or any later version published by the Free Software Foundation; with no Invariant Sections, with the Front-Cover Texts being “A GNU Manual”, and with the Back-Cover Texts as in (a) below. A copy of the license is included in the section entitled “GNU Free Documentation License”.

1 Introduction
What is Eshell?
Contributors to Eshell
1.1 What is Eshell?
Eshell is a command shell written in Emacs Lisp. Everything it does, it uses Emacs’s facilities to do. This means that Eshell is as portable as Emacs itself. It also means that cooperation with Lisp code is natural and seamless.

What is a command shell? To properly understand the role of a shell, it’s necessary to visualize what a computer does for you. Basically, a computer is a tool; in order to use that tool, you must tell it what to do—or give it “commands.” These commands take many forms, such as clicking with a mouse on certain parts of the screen. But that is only one form of command input.

By far the most versatile way to express what you want the computer to do is by using an abbreviated language called script. In script, instead of telling the computer, “list my files, please”, one writes a standard abbreviated command word—‘ls’. Typing ‘ls’ in a command shell is a script way of telling the computer to list your files.2

The real flexibility of this approach is apparent only when you realize that there are many, many different ways to list files. Perhaps you want them sorted by name, sorted by date, in reverse order, or grouped by type. Most graphical browsers have simple ways to express this. But what about showing only a few files, or only files that meet a certain criteria? In very complex and specific situations, the request becomes too difficult to express using a mouse or pointing device. It is just these kinds of requests that are easily solved using a command shell.

For example, what if you want to list every Word file on your hard drive, larger than 100 kilobytes in size, and which hasn’t been looked at in over six months? That is a good candidate list for deletion, when you go to clean up your hard drive. But have you ever tried asking your computer for such a list? There is no way to do it! At least, not without using a command shell.

The role of a command shell is to give you more control over what your computer does for you. Not everyone needs this amount of control, and it does come at a cost: Learning the necessary script commands to express what you want done. A complicated query, such as the example above, takes time to learn. But if you find yourself using your computer frequently enough, it is more than worthwhile in the long run. Any tool you use often deserves the time spent learning to master it. 3

Up: Introduction   [Contents][Index]

1.2 Contributors to Eshell
Contributions to Eshell are welcome. I have limited time to work on this project, but I will gladly add any code you contribute to me to this package.

The following persons have made contributions to Eshell.

John Wiegley is the original author of Eshell.
Eli Zaretskii made it possible for Eshell to run without requiring asynchronous subprocess support. This is important for MS-DOS, which does not have such support.
Miles Bader contributed many fixes during the port to Emacs 21.
Stefan Monnier fixed the things which bothered him, which of course made things better for all.
Gerd Moellmann also helped to contribute bug fixes during the initial integration with Emacs 21.
Alex Schroeder contributed code for interactively querying the user before overwriting files.
Apart from these, a lot of people have sent suggestions, ideas, requests, bug reports and encouragement. Thanks a lot! Without you there would be no new releases of Eshell.

Next: Expansion, Previous: Introduction, Up: Eshell   [Contents][Index]

2 Commands
In a command shell, everything is done by invoking commands. This chapter covers command invocations in Eshell, including the command history and invoking commands in a script file.

Unlike regular system shells, Eshell never invokes kernel functions directly, such as exec(3). Instead, it uses the Lisp functions available in the Emacs Lisp library. It does this by transforming the input line into a callable Lisp form.4

Invocation
Arguments
Built-in commands
Variables
Aliases
Remote Access
History
Completion
Control Flow
Scripts
Next: Arguments, Up: Commands   [Contents][Index]

2.1 Invocation
Eshell is both a command shell and an Emacs Lisp REPL. As a result, you can invoke commands in two different ways: in command form or in Lisp form.

You can use the semicolon (;) to separate multiple command invocations on a single line, executing each in turn. You can also separate commands with && or ||. When using &&, Eshell will execute the second command only if the first succeeds (i.e. has an exit status of 0); with ||, Eshell will execute the second command only if the first fails.

A command invocation followed by an ampersand (&) will be run in the background. Eshell has no job control, so you can not suspend or background the current process, or bring a background process into the foreground. That said, background processes invoked from Eshell can be controlled the same way as any other background process in Emacs.

Command form
Lisp form
2.1.1 Command form
Command form looks much the same as in other shells. A command consists of arguments separated by spaces; the first argument is the command to run, with any subsequent arguments being passed to that command.

~ $ echo hello
hello
The command can be either an Elisp function or an external command. Eshell looks for the command in the following order:

As a command alias (see Aliases)
As a built-in command (see Built-in commands)
As an external program
As an ordinary Lisp function
If you would prefer to use ordinary Lisp functions over external programs, set the option eshell-prefer-lisp-functions to t. This will swap the lookup order of the last two items. You can also force Eshell to look for a command as an external program by prefixing its name with *, like *command (see Built-in commands).

You can also group command forms together into a subcommand with curly braces ({}). This lets you use the output of a subcommand as an argument to another command, or within control flow statements (see Control Flow).

~ $ echo {echo hello; echo there}
hellothere
2.1.2 Lisp form
Lisp form looks like ordinary Emacs Lisp code, because that’s what it is. As a result, you can use any syntax normally available to an Emacs Lisp program (see The Emacs Lisp Reference Manual).

~ $ (format "hello, %s" user-login-name)
hello, user
In addition, you can combine command forms and Lisp forms together into single statements, letting you use whatever form is the most convenient for expressing your intentions.

~ $ ls *.patch > (format-time-string "%F.log")
This command writes a list of all files matching the glob pattern *.patch (see Globbing) to a file named current-date.log (see Redirection).

Next: Built-in commands, Previous: Invocation, Up: Commands   [Contents][Index]

2.2 Arguments
Ordinarily, Eshell parses arguments in command form as either strings or numbers, depending on what the parser thinks they look like. To specify an argument of some other data type, you can use a Lisp form (see Invocation):

~ $ echo (list 1 2 3)
(1 2 3)
Additionally, many built-in Eshell commands (see Built-in commands) will flatten the arguments they receive, so passing a list as an argument will “spread” the elements into multiple arguments:

~ $ printnl (list 1 2) 3
1
2
3
Quoting and escaping
Special argument types
2.2.1 Quoting and escaping
As with other shells, you can escape special characters and spaces by prefixing the character with a backslash (‘\’), or by surrounding the string with apostrophes (‘''’) or double quotes (‘""’). This is needed especially for file names with special characters like pipe (‘|’) or square brackets (‘[’ or ‘]’), which could be part of remote file names.

When you escape a character with ‘\’ outside of any quotes, the result is the literal character immediately following it. For example, \$10 means the literal string $10.

Inside of double quotes, most characters have no special meaning. However, ‘\’, ‘"’, and ‘$’ are still special; to escape them, use backslash as above. Thus, if the value of the variable answer is 42, then "The answer is: \"$answer\"" returns the string The answer is: "42". However, when escaping characters with no special meaning, the result is the full \c sequence. For example, "foo\bar" means the literal string foo\bar.

Additionally, when escaping a newline, the whole escape sequence is removed by the parser. This lets you continue commands across multiple lines:

~ $ echo "foo\
bar"
foobar
Inside apostrophes, escaping works differently. All characters between the apostrophes have their literal meaning except ‘'’, which ends the quoted string. To insert a literal apostrophe, you can use ‘''’, so 'It''s me' means the literal string It's me.

When using expansions (see Expansion) in an Eshell command, the result may potentially be of any data type. To ensure that the result is always a string, the expansion can be surrounded by double quotes.

2.2.2 Special argument types
In addition to strings and numbers, Eshell supports a number of special argument types. These let you refer to various other Emacs Lisp data types, such as lists or buffers.

#'lisp-form
This refers to the quoted Emacs Lisp form lisp-form. Though this looks similar to the “sharp quote” syntax for functions (see Special Read Syntax in The Emacs Lisp Reference Manual), it instead corresponds to quote and can be used for any quoted form.5

`lisp-form
This refers to the backquoted Emacs Lisp form lisp-form (see Backquote in The Emacs Lisp Reference Manual). As in Emacs Lisp, you can use ‘,’ and ‘,@’ to refer to non-constant values.

#<buffer name>
#<name>
Return the buffer named name. This is equivalent to ‘$(get-buffer-create "name")’ (see Creating Buffers in The Emacs Lisp Reference Manual).

#<process name>
Return the process named name. This is equivalent to ‘$(get-process "name")’ (see Process Information in The Emacs Lisp Reference Manual).

Next: Variables, Previous: Arguments, Up: Commands   [Contents][Index]

2.3 Built-in commands
Eshell provides a number of built-in commands, many of them implementing common command-line utilities, but enhanced for Eshell. (These built-in commands are just ordinary Lisp functions whose names begin with eshell/.) In order to call the external variant of a built-in command foo, you could call *foo. Usually, this should not be necessary. You can check what will be applied by the which command:

~ $ which ls
eshell/ls is a compiled Lisp function in `em-ls.el'
~ $ which *ls
/bin/ls
If you want to discard a given built-in command, you could declare an alias (see Aliases). Example:

~ $ which sudo
eshell/sudo is a compiled Lisp function in `em-tramp.el'.
~ $ alias sudo '*sudo $*'
~ $ which sudo
sudo is an alias, defined as "*sudo $*"
Some of the built-in commands have different behavior from their external counterparts, and some have no external counterpart. Most of these will print a usage message when given the --help option.

In some cases, a built-in command’s behavior can be configured via user settings, some of which are mentioned below. For example, certain commands have two user settings to allow them to overwrite files without warning and to ensure that they always prompt before overwriting files. If both settings are non-nil, the commands always prompt. If both settings are nil (the default), the commands signal an error.

Several commands observe the value of eshell-default-target-is-dot. If non-nil, then the default target for the commands cp, mv, and ln is the current directory.

A few commands are wrappers for more niche Emacs features, and can be loaded as part of the eshell-xtra module. See Extension modules.

. ¶
Source an Eshell file in the current environment. This is not to be confused with the command source, which sources a file in a subshell environment.

addpath ¶
Adds a given path or set of paths to the PATH environment variable, or, with no arguments, prints the current paths in this variable.

alias ¶
Define an alias (see Aliases). This adds it to the aliases file.

basename ¶
Return a file name without its directory.

cat ¶
Concatenate file contents into standard output. If in a pipeline, or if the file is not a regular file, directory, or symlink, then this command reverts to the system’s definition of cat.

cd ¶
This command changes the current working directory. Usually, it is invoked as cd dir where dir is the new working directory. But cd knows about a few special arguments:

- When it receives no argument at all, it changes to the home directory.
- Giving the command cd - changes back to the previous working directory (this is the same as cd $-).
- The command cd = shows the directory ring. Each line is numbered.
- With cd =foo, Eshell searches the directory ring for a directory matching the regular expression ‘foo’, and changes to that directory.
- With cd -42, you can access the directory stack slots by number.
- If eshell-cd-shows-directory is non-nil, cd will report the directory it changes to. If eshell-list-files-after-cd is non-nil, then ls is called with any remaining arguments after changing directories.
clear ¶
Scrolls the contents of the Eshell window out of sight, leaving a blank window. If provided with an optional non-nil argument, the scrollback contents are cleared instead.

clear-scrollback ¶
Clear the scrollback contents of the Eshell window. Unlike the command clear, this command deletes content in the Eshell buffer.

cp ¶
Copy a file to a new location or copy multiple files to the same directory.

If eshell-cp-overwrite-files is non-nil, then cp will overwrite files without warning. If eshell-cp-interactive-query is non-nil, then cp will ask before overwriting anything.

date ¶
Print the current local time as a human-readable string. This command is similar to, but slightly different from, the GNU Coreutils date command.

diff ¶
Compare files using Emacs’s internal diff (not to be confused with ediff). See Comparing Files in The GNU Emacs Manual.

If eshell-plain-diff-behavior is non-nil, then this command does not use Emacs’s internal diff. This is the same as using ‘alias diff '*diff $*'’.

dirname ¶
Return the directory component of a file name.

dirs ¶
Prints the directory stack. Directories can be added or removed from the stack using the commands pushd and popd, respectively.

du ¶
Summarize disk usage for each file.

echo ¶
Echoes its input. By default, this prints in a Lisp-friendly fashion (so that the value is useful to a Lisp command using the result of echo as an argument). If a single argument is passed, echo prints that; if multiple arguments are passed, it prints a list of all the arguments; otherwise, it prints the empty string.

If eshell-plain-echo-behavior is non-nil, echo will try to behave more like a plain shell’s echo, printing each argument as a string, separated by a space.

env ¶
Prints the current environment variables. Unlike in Bash, this command does not yet support running commands with a modified environment.

eshell-debug ¶
Toggle debugging information for Eshell itself. You can pass this command the argument errors to enable/disable Eshell trapping errors when evaluating commands, or the argument commands to show/hide command execution progress in the buffer *eshell last cmd*.

exit ¶
Exit Eshell and save the history. By default, this command kills the Eshell buffer, but if eshell-kill-on-exit is nil, then the buffer is merely buried instead.

export ¶
Set environment variables using input like Bash’s export, as in ‘export var1=val1 var2=val2 …’.

grep ¶
agrep
egrep
fgrep
glimpse
The grep commands are compatible with GNU grep, but use Emacs’s internal grep instead. See Grep Searching in The GNU Emacs Manual.

If eshell-plain-grep-behavior is non-nil, then these commands do not use Emacs’s internal grep. This is the same as using ‘alias grep '*grep $*'’, though this setting applies to all of the built-in commands for which you would need to create a separate alias.

history ¶
Prints Eshell’s input history. With a numeric argument N, this command prints the N most recent items in the history.

info ¶
Browse the available Info documentation. This command is the same as the external info command, but uses Emacs’s internal Info reader. See Misc Help in The GNU Emacs Manual.

jobs ¶
List subprocesses of the Emacs process, if any, using the function list-processes.

kill ¶
Kill processes. Takes a PID or a process object and an optional signal specifier which can either be a number or a signal name.

listify ¶
Eshell version of list. Allows you to create a list using Eshell syntax, rather than Elisp syntax. For example, ‘listify foo bar’ and ("foo" "bar") both evaluate to ("foo" "bar").

ln ¶
Create links to files.

If eshell-ln-overwrite-files is non-nil, ln will overwrite files without warning. If eshell-ln-interactive-query is non-nil, then ln will ask before overwriting files.

locate ¶
Alias to Emacs’s locate function, which simply runs the external locate command and parses the results. See Dired and Find in The GNU Emacs Manual.

If eshell-plain-locate-behavior is non-nil, then Emacs’s internal locate is not used. This is the same as using ‘alias locate '*locate $*'’.

ls ¶
Lists the contents of directories.

If eshell-ls-use-colors is non-nil, the contents of a directory is color-coded according to file type and status. These colors and the regexps used to identify their corresponding files can be customized via M-x customize-group RET eshell-ls RET.

The user option eshell-ls-date-format determines how the date is displayed when using the -l option. The date is produced using the function format-time-string (see Time Parsing in GNU Emacs Lisp Reference Manual).

The user option eshell-ls-initial-args contains a list of arguments to include with any call to ls. For example, you can include the option -h to always use a more human-readable format.

The user option eshell-ls-default-blocksize determines the default blocksize used when displaying file sizes with the option -s.

make ¶
Run make through compile when run asynchronously (e.g., ‘make &’). See Compilation in The GNU Emacs Manual. Otherwise call the external make command.

man ¶
Display Man pages using the Emacs man command. See Man Page in The GNU Emacs Manual.

mkdir ¶
Make new directories.

mv ¶
Move or rename files.

If eshell-mv-overwrite-files is non-nil, mv will overwrite files without warning. If eshell-mv-interactive-query is non-nil, mv will prompt before overwriting anything.

occur ¶
Alias to Emacs’s occur. See Other Repeating Search in The GNU Emacs Manual.

popd ¶
Pop a directory from the directory stack and switch to a another place in the stack.

printnl ¶
Print the arguments separated by newlines.

pushd ¶
Push the current directory onto the directory stack, then change to another directory.

If eshell-pushd-dunique is non-nil, then only unique directories will be added to the stack. If eshell-pushd-dextract is non-nil, then ‘pushd +n’ will pop the nth directory to the top of the stack.

pwd ¶
Prints the current working directory.

rm ¶
Removes files, buffers, processes, or Emacs Lisp symbols, depending on the argument.

If eshell-rm-interactive-query is non-nil, rm will prompt before removing anything. If eshell-rm-removes-directories is non-nil, then rm can also remove directories. Otherwise, rmdir is required.

rmdir ¶
Removes directories if they are empty.

set ¶
Set variable values, using the function set like a command (see Setting Variables in GNU Emacs Lisp Reference Manual). A variable name can be a symbol, in which case it refers to a Lisp variable, or a string, referring to an environment variable (see Arguments).

setq ¶
Set variable values, using the function setq like a command (see Setting Variables in GNU Emacs Lisp Reference Manual).

source ¶
Source an Eshell file in a subshell environment. This is not to be confused with the command ., which sources a file in the current environment.

time ¶
Show the time elapsed during a command’s execution.

umask ¶
Set or view the default file permissions for newly created files and directories.

unset ¶
Unset one or more variables. As with set, a variable name can be a symbol, in which case it refers to a Lisp variable, or a string, referring to an environment variable.

wait ¶
Wait until a process has successfully completed.

which ¶
Identify a command and its location.

whoami ¶
Print the current user. This Eshell version of whoami supports Tramp.

Defining new built-in commands
2.3.1 Defining new built-in commands
While Eshell can run Lisp functions directly as commands, it may be more convenient to provide a special built-in command for Eshell. Built-in commands are just ordinary Lisp functions designed to be called from Eshell. When defining an Eshell-specific version of an existing function, you can give that function a name starting with eshell/ so that Eshell knows to use it.

Macro: eshell-eval-using-options name macro-args options body… ¶
This macro processes a list of macro-args for the command name using a set of command line options. If the arguments are parsed successfully, it will store the resulting values in local symbols and execute body; any remaining arguments will be available in the locally let-bound variable args. The return value is the value of the last form in body.

If an unknown option was passed in macro-args and an external command was specified (see below), this macro will start a process for that command and throw the tag eshell-external with the new process as its value.

options should be a list beginning with one or more elements of the following form, with each element representing a particular command-line switch:

(short long value symbol help-string)
short
This element, if non-nil, should be a character to be used as a short switch, like -short. At least one of this element and long must be non-nil.

long
This element, if non-nil, should be a string to be used as a long switch, like --long.

value
This element is the value associated with the option. It can be either:

t
The option needs a value to be specified after the switch.

nil
The option is given the value t.

anything else
The option is given the specified value.

symbol
This element is the Lisp symbol that will be bound to value. If symbol is nil, specifying this switch will instead call eshell-show-usage, and so is appropriate for an option like --help.

help-string
This element is a documentation string for the option, which will be displayed when eshell-show-usage is invoked.

After the list of command-line switch elements, options can include additional keyword arguments to control how eshell-eval-using-options behaves. Some of these take arguments, while others don’t. The recognized keywords are:

:external string
Specify string as an external command to run if there are unknown switches in macro-args.

:usage string
Set string as the initial part of the command’s documentation string. It appears before the options are listed.

:post-usage string
Set string to be the (optional) trailing part of the command’s documentation string. It appears after the list of options, but before the final part of the documentation about the associated external command, if there is one.

:show-usage
If present, then show the usage message if the command is called with no arguments.

:preserve-args
Normally, eshell-eval-using-options flattens the list of arguments in macro-args and converts each to a string. If this keyword is present, avoid doing that, instead preserving the original arguments. This is useful for commands which want to accept arbitrary Lisp objects.

:parse-leading-options-only
If present, do not parse dash or switch arguments after the first positional argument. Instead, treat them as positional arguments themselves.

For example, you could handle a subset of the options for the ls command like this:

(eshell-eval-using-options
 "ls" macro-args
 '((?a  nil      nil show-all       "show all files")
   (?I  "ignore" t   ignore-pattern "ignore files matching pattern")
   (nil "help"   nil nil            "show this help message")
 :external "ls"
 :usage "[OPTION]... [FILE]...
  List information about FILEs (the current directory by default).")
 ;; List the files in ARGS somehow...
 )
Next: Aliases, Previous: Built-in commands, Up: Commands   [Contents][Index]

2.4 Variables
Since Eshell is a combination of an Emacs REPL and a command shell, it can refer to variables from two different sources: ordinary Emacs Lisp variables, as well as environment variables. By default, when using a variable in Eshell, it will first look in the list of built-in variables, then in the list of environment variables, and finally in the list of Lisp variables. If you would prefer to use Lisp variables over environment variables, you can set eshell-prefer-lisp-variables to t.

You can set variables in a few different ways. To set a Lisp variable, you can use the command ‘setq name value’, which works much like its Lisp counterpart (see Setting Variables in The Emacs Lisp Reference Manual). To set an environment variable, use ‘export name=value’. You can also use ‘set variable value’, which sets a Lisp variable if variable is a symbol, or an environment variable if it’s a string (see Arguments). Finally, you can temporarily set environment variables for a single command with ‘name=value command …’. This is equivalent to:

{
  export name=value
  command …
}
Built-in variables
2.4.1 Built-in variables
Eshell knows a few built-in variables:

$PWD
$+
This variable always contains the current working directory.

$OLDPWD
$-
This variable always contains the previous working directory (the current working directory from before the last cd command). When using $-, you can also access older directories in the directory ring via subscripting, e.g. ‘$-[1]’ refers to the working directory before the previous one.

$PATH
This specifies the directories to search for executable programs. Its value is a string, separated by ":" for Unix and GNU systems, and ";" for MS systems. This variable is connection-aware, so whenever you change the current directory to a different host (see Remote Files in The GNU Emacs Manual), the value will automatically update to reflect the search path on that host.

$_
This refers to the last argument of the last command. With a subscript, you can access any argument of the last command. For example, ‘$_[1]’ refers to the second argument of the last command (excluding the command name itself).

$$
This is the result of the last command. For external commands, it is t if the exit code was 0 or nil otherwise.

$?
This variable contains the exit code of the last command. If the last command was a Lisp function, it is 0 for successful completion or 1 otherwise. If eshell-lisp-form-nil-is-failure is non-nil, then a command with a Lisp form, like ‘(command args…)’, that returns nil will set this variable to 2.

$COLUMNS
$LINES
These variables tell the number of columns and lines, respectively, that are currently visible in the Eshell window. They are both copied to the environment, so external commands invoked from Eshell can consult them to do the right thing.

$INSIDE_EMACS
This variable indicates to external commands that they are being invoked from within Emacs so they can adjust their behavior if necessary. By default, its value is emacs-version,eshell. Other parts of Emacs, such as Tramp, may add extra information to this value.

See Aliases, for the built-in variables ‘$*’, ‘$1’, ‘$2’, …, in alias definitions.

Next: Remote Access, Previous: Variables, Up: Commands   [Contents][Index]

2.5 Aliases
Aliases are commands that expand to a longer input line. For example, ll is a common alias for ls -l, and would be defined with the command invocation alias ll 'ls -l $*'; with this defined, running ‘ll foo’ in Eshell will actually run ‘ls -l foo’. Aliases defined (or deleted) by the alias command are automatically written to the file named by eshell-aliases-file, which you can also edit directly (although you will have to manually reload it).

Note that unlike aliases in Bash, arguments must be handled explicitly. Typically the alias definition would end in ‘$*’ to pass all arguments along. More selective use of arguments via ‘$1’, ‘$2’, etc., is also possible. For example, alias mcd 'mkdir $1 && cd $1' would cause mcd foo to create and switch to a directory called ‘foo’.

Next: History, Previous: Aliases, Up: Commands   [Contents][Index]

2.6 Remote Access
Since Eshell uses Emacs facilities for most of its functionality, you can access remote hosts transparently. To connect to a remote host, simply cd into it:

~ $ cd /ssh:user@remote:
/ssh:user@remote:~ $
Additionally, built-in Eshell commands (see Built-in commands) and ordinary Lisp functions accept remote file names, so you can access them even without explicitly connecting first. For example, to print the contents of a remote file, you could type ‘cat /ssh:user@remote:~/output.log’. However, this means that when using built-in commands or Lisp functions from a remote directory, you must be careful about specifying absolute file names: ‘cat /var/output.log’ will always print the contents of your local /var/output.log, even from a remote directory. If you find this behavior annoying, you can enable the optional electric forward slash module (see Electric forward slash).

Next: Completion, Previous: Remote Access, Up: Commands   [Contents][Index]

2.7 History
The ‘history’ command shows all commands kept in the history ring as numbered list. If the history ring contains eshell-history-size commands, those numbers change after every command invocation, therefore the ‘history’ command shall be applied before using the expansion mechanism with history numbers.

The n-th entry of the history ring can be applied with the ‘!n’ command. If n is negative, the entry is counted from the end of the history ring.

When history event designators are enabled (by adding eshell-expand-history-references to eshell-expand-input-functions), ‘!foo’ expands to the last command beginning with foo, and ‘!?foo’ to the last command containing foo. The n-th argument of the last command beginning with foo is accessible by !foo:n.

The history ring is loaded from a file at the start of every session, and written back to the file at the end of every session. The file path is specified in eshell-history-file-name. Unlike other shells, such as Bash, Eshell can not be configured to keep a history ring of a different size than that of the history file.

Since the default buffer navigation and searching key-bindings are still present in the Eshell buffer, the commands for history navigation and searching are bound to different keys:

M-r
M-s
History I-search.

M-p
M-n
Previous and next history line. If there is anything on the input line when you run these commands, they will instead jump to the previous or next line that begins with that string.

Next: Control Flow, Previous: History, Up: Commands   [Contents][Index]

2.8 Completion
Eshell uses the pcomplete package for programmable completion, similar to that of other command shells. Argument completion differs depending on the preceding command: for example, possible completions for rmdir are only directories, while rm completions can be directories and files. Eshell provides predefined completions for the built-in functions and some common external commands, and you can define your own for any command.

Eshell completion also works for Lisp forms and glob patterns. If the point is on a Lisp form, then TAB will behave similarly to completion in elisp-mode and lisp-interaction-mode. For glob patterns, the pattern will be removed from the input line, and replaced by the completion.

If you want to see the entire list of possible completions (e.g. when it’s below the completion-cycle-threshold), press M-?.

pcomplete
2.8.1 pcomplete
Pcomplete, short for programmable completion, is the completion library originally written for Eshell, but usable for command completion6 in other modes.

Completions are defined as functions (with defun) named pcomplete/COMMAND, where COMMAND is the name of the command for which this function provides completions; you can also name the function pcomplete/MAJOR-MODE/COMMAND to define completions for a specific major mode.

Next: Scripts, Previous: Completion, Up: Commands   [Contents][Index]

2.9 Control Flow
Because Eshell commands can not (easily) be combined with Lisp forms, Eshell provides command-oriented control flow statements for convenience.

Most of Eshell’s control flow statements accept a conditional. This can take a few different forms. If conditional is a dollar expansion, the condition is satisfied if the result is a non-nil value. If conditional is a ‘{ subcommand }’ or ‘(lisp form)’, the condition is satisfied if the command’s exit status is 0.

if conditional { true-commands }
if conditional { true-commands } { false-commands }
Evaluate true-commands if conditional is satisfied; otherwise, evaluate false-commands.

unless conditional { false-commands }
unless conditional { false-commands } { true-commands }
Evaluate false-commands if conditional is not satisfied; otherwise, evaluate true-commands.

while conditional { commands }
Repeatedly evaluate commands so long as conditional is satisfied.

until conditional { commands }
Repeatedly evaluate commands until conditional is satisfied.

for var in list… { commands }
Iterate over each element of list, storing the element in var and evaluating commands. If list is not a list, treat it as a list of one element. If you specify multiple lists, this will iterate over each of them in turn.

Previous: Control Flow, Up: Commands   [Contents][Index]

2.10 Scripts
You can run Eshell scripts much like scripts for other shells; the main difference is that since Eshell is not a system command, you have to run it from within Emacs. An Eshell script is simply a file containing a sequence of commands, as with almost any other shell script. Scripts are invoked from Eshell with source, or from anywhere in Emacs with eshell-source-file.

If you wish to load a script into your current environment, rather than in a subshell, use the . command.

Next: Input/Output, Previous: Commands, Up: Eshell   [Contents][Index]

3 Expansion
Expansion in a command shell is somewhat like macro expansion in macro parsers (such as cpp and m4), but in a command shell, they are less often used for constants, and usually for using variables and string manipulation.7 For example, $var on a line expands to the value of the variable var when the line is executed. Expansions are usually passed as arguments, but may also be used as commands.8

You can concatenate expansions with regular string arguments or even other expansions. In the simplest case, when the expansion returns a string value, this is equivalent to ordinary string concatenation; for example, ‘${echo "foo"}bar’ returns ‘foobar’. The exact behavior depends on the types of each value being concatenated:

both strings
Concatenate both values together.

one or both numbers
Concatenate the string representation of each value, converting back to a number if possible.

one or both (non-nil) lists
Concatenate “adjacent” elements of each value (possibly converting back to a number as above). For example, ‘$(list "a" "b")c’ returns ‘("a" "bc")’.

anything else
Concatenate the string representation of each value.

Dollars Expansion
Globbing
Argument Predication and Modification
Next: Globbing, Up: Expansion   [Contents][Index]

3.1 Dollars Expansion
Eshell has different $ expansion syntax from other shells. There are some similarities, but don’t let these lull you into a false sense of familiarity.

$var
Expands to the value bound to var. This is the main way to use variables in command invocations.

$"var"
$'var'
Expands to the value bound to var. This is useful to disambiguate the variable name when concatenating it with another value, such as ‘$"var"-suffix’.

$(lisp)
Expands to the result of evaluating the S-expression (lisp). On its own, this is identical to just (lisp), but with the $, it can be used inside double quotes or within a longer string, such as ‘/some/path/$(lisp).txt’.

${command}
Returns the output of command, which can be any valid Eshell command invocation, and may even contain expansions. Similar to $(lisp), this is identical to {command} when on its own, but the $ allows it to be used inside double quotes or as part of a string.

Normally, the output is split line-by-line, returning a list (or the first element if there’s only one line of output); if eshell-convert-numeric-arguments is non-nil and every line of output looks like a number, convert each line to a number. However, when this expansion is surrounded by double quotes, it returns the output as a single string instead.

$<command>
As with ‘${command}’, evaluates the Eshell command invocation command, but writes the output to a temporary file and returns the file name.

$expr[i...]
Expands to the ith element of the result of expr, an expression in one of the above forms listed here. If multiple indices are supplied, this will return a list containing the elements for each index. The exact behavior depends on the type of expr’s value:

a sequence
Expands to the element at the (zero-based) index i of the sequence (see Sequences Arrays Vectors in The Emacs Lisp Reference Manual).

a string
Split the string at whitespace, and then expand to the ith element of the resulting sequence.

an alist
If i is a non-numeric value, expand to the value associated with the key "i" in the alist. For example, if var is ‘(("dog" . "fido") ("cat" . "felix"))’, then ‘$var[dog]’ expands to "fido". Otherwise, this behaves as with sequences; e.g., ‘$var[0]’ expands to ("dog" . "fido"). See Association Lists in The Emacs Lisp Reference Manual.

anything else
Signals an error.

Multiple sets of indices can also be specified. For example, if var is ‘((1 2) (3 4))’, then ‘$var[0][1]’ will expand to 2, i.e. the second element of the first list member (all indices are zero-based).

$expr[regexp i...]
As above (when expr expands to a string), but use regexp to split the string. regexp can be any form other than a number. For example, ‘$var[: 0]’ will return the first element of a colon-delimited string.

$#expr
Expands to the length of the result of expr, an expression in one of the above forms. For example, ‘$#var’ returns the length of the variable var and ‘$#var[0]’ returns the length of the first element of var. Again, signals an error if the result of expr is not a string or a sequence.

Next: Argument Predication and Modification, Previous: Dollars Expansion, Up: Expansion   [Contents][Index]

3.2 Globbing
Eshell’s globbing syntax is very similar to that of Zsh (see Filename Generation in The Z Shell Manual). Users coming from Bash can still use Bash-style globbing, as there are no incompatibilities.

By default, globs are case sensitive, except on MS-DOS/MS-Windows systems. You can control this behavior via the eshell-glob-case-insensitive option. You can further customize the syntax and behavior of globbing in Eshell via the Customize group eshell-glob (see Easy Customization in The GNU Emacs Manual).

‘*’
Matches any string (including the empty string). For example, ‘*.el’ matches any file with the .el extension.

‘?’
Matches any single character. For example, ‘?at’ matches cat and bat, but not goat.

‘**/’
Matches zero or more subdirectories in a file name. For example, ‘**/foo.el’ matches foo.el, bar/foo.el, bar/baz/foo.el, etc. Note that this cannot be combined with any other patterns in the same file name segment, so while ‘foo/**/bar.el’ is allowed, ‘foo**/bar.el’ is not.

‘***/’
Like ‘**/’, but follows symlinks as well.

‘[ … ]’
Defines a character set (see Regexps in The GNU Emacs Manual). A character set matches characters between the two brackets; for example, ‘[ad]’ matches a and d. You can also include ranges of characters in the set by separating the start and end with ‘-’. Thus, ‘[a-z]’ matches any lower-case ASCII letter. Note that, unlike in Zsh, character ranges are interpreted in the Unicode codepoint order, not in the locale-dependent collation order.

Additionally, you can include character classes in a character set. A ‘[:’ and balancing ‘:]’ enclose a character class inside a character set. For instance, ‘[[:alnum:]]’ matches any letter or digit. See Char Classes in The Emacs Lisp Reference Manual, for a list of character classes.

‘[^ … ]’
Defines a complemented character set. This behaves just like a character set, but matches any character except the ones specified.

‘( … )’
Defines a group. A group matches the pattern between ‘(’ and ‘)’. Note that a group can only match a single file name component, so a ‘/’ inside a group will signal an error.

‘x|y’
Inside of a group, matches either x or y. For example, ‘e(m|sh)-*’ matches any file beginning with em- or esh-.

‘x#’
Matches zero or more copies of the glob pattern x. For example, ‘fo#.el’ matches f.el, fo.el, foo.el, etc.

‘x##’
Matches one or more copies of the glob pattern x. Thus, ‘fo#.el’ matches fo.el, foo.el, fooo.el, etc.

‘x~y’
Matches anything that matches the pattern x but not y. For example, ‘[[:digit:]]#~4?’ matches 1 and 12, but not 42. Note that unlike in Zsh, only a single ‘~’ operator can be used in a pattern, and it cannot be inside of a group like ‘(x~y)’.

Previous: Globbing, Up: Expansion   [Contents][Index]

3.3 Argument Predication and Modification
Eshell supports argument predication, to filter elements of a glob, and argument modification, to manipulate argument values. These are similar to glob qualifiers in Zsh (see Glob Qualifiers in The Z Shell Manual).

Predicates and modifiers are introduced with ‘(filters)’ after any list argument, where filters is a list of predicates or modifiers. For example, ‘*(.)’ expands to all regular files in the current directory and ‘*(^@:U^u0)’ expands to all non-symlinks not owned by root, upper-cased.

Some predicates and modifiers accept string parameters, such as ‘*(u'user')’, which matches all files owned by user. These parameters must be surrounded by delimiters; you can use any of the following pairs of delimiters: "…", '…', /…/, |…|, (…), […], <…>, or {…}.

You can customize the syntax and behavior of predicates and modifiers in Eshell via the Customize group eshell-pred (see Easy Customization in The GNU Emacs Manual).

Argument Predicates
Argument Modifiers
Next: Argument Modifiers, Up: Argument Predication and Modification   [Contents][Index]

3.3.1 Argument Predicates
You can use argument predicates to filter lists of file names based on various properties of those files. This is most useful when combined with globbing, but can be used on any list of files names. Eshell supports the following argument predicates:

‘/’
Matches directories.

‘.’ (Period)
Matches regular files.

‘@’
Matches symbolic links.

‘=’
Matches sockets.

‘p’
Matches named pipes.

‘%’
Matches block or character devices.

‘%b’
Matches block devices.

‘%c’
Matches character devices.

‘*’
Matches regular files that can be executed by the current user.

‘r’
‘A’
‘R’
Matches files that are readable by their owners (‘r’), their groups (‘A’), or the world (‘R’).

‘w’
‘I’
‘W’
Matches files that are writable by their owners (‘w’), their groups (‘I’), or the world (‘W’).

‘x’
‘E’
‘X’
Matches files that are executable by their owners (‘x’), their groups (‘E’), or the world (‘X’).

‘s’
Matches files with the setuid flag set.

‘S’
Matches files with the setgid flag set.

‘t’
Matches files with the sticky bit set.

‘U’
Matches files owned by the current effective user ID.

‘G’
Matches files owned by the current effective group ID.

‘l[+-]n’
Matches files with n links. With + (or -), matches files with more than (or less than) n links, respectively.

‘uuid’
‘u'user-name'’
Matches files owned by user ID uid or user name user-name.

‘ggid’
‘g'group-name'’
Matches files owned by group ID gid or group name group-name.

‘a[unit][+-]n’
‘a[+-]'file'’
Matches files last accessed exactly n days ago. With + (or -), matches files accessed more than (or less than) n days ago, respectively.

With unit, n is a quantity in that unit of time, so ‘aw-1’ matches files last accessed within one week. unit can be ‘M’ (30-day months), ‘w’ (weeks), ‘h’ (hours), ‘m’ (minutes), or ‘s’ (seconds).

If file is specified instead, compare against the modification time of file. Thus, ‘a-'hello.txt'’ matches all files accessed after hello.txt was last accessed.

‘m[unit][+-]n’
‘m[+-]'file'’
Like ‘a’, but examines modification time.

‘c[unit][+-]n’
‘c[+-]'file'’
Like ‘a’, but examines status change time.

‘L[unit][+-]n’
Matches files exactly n bytes in size. With + (or -), matches files larger than (or smaller than) n bytes, respectively.

With unit, n is a quantity in that unit of size, so ‘Lm+5’ matches files larger than 5 MiB in size. unit can be one of the following (case-insensitive) characters: ‘m’ (megabytes), ‘k’ (kilobytes), or ‘p’ (512-byte blocks).

The ‘^’ and ‘-’ operators are not argument predicates themselves, but they modify the behavior of all subsequent predicates. ‘^’ inverts the meaning of subsequent predicates, so ‘*(^RWX)’ expands to all files whose permissions disallow the world from accessing them in any way (i.e., reading, writing to, or modifying them). When examining a symbolic link, ‘-’ applies the subsequent predicates to the link’s target instead of the link itself.

Previous: Argument Predicates, Up: Argument Predication and Modification   [Contents][Index]

3.3.2 Argument Modifiers
You can use argument modifiers to manipulate argument values. For example, you can sort lists, remove duplicate values, capitalize words, etc. All argument modifiers are prefixed by ‘:’, so ‘$exec-path(:h:u:x/^\/home/)’ lists all of the unique parent directories of the elements in exec-path, excluding those in /home.

‘E’
Re-evaluates the value as an Eshell argument. For example, if foo is "${echo hi}", then the result of ‘$foo(:E)’ is hi.

‘L’
Converts the value to lower case.

‘U’
Converts the value to upper case.

‘C’
Capitalizes the value.

‘h’
Treating the value as a file name, gets the directory name (the “head”). For example, ‘foo/bar/baz.el(:h)’ expands to ‘foo/bar/’.

‘t’
Treating the value as a file name, gets the base name (the “tail”). For example, ‘foo/bar/baz.el(:t)’ expands to ‘baz.el’.

‘e’
Treating the value as a file name, gets the final extension of the file, excluding the dot. For example, ‘foo.tar.gz(:e)’ expands to gz.

‘r’
Treating the value as a file name, gets the file name excluding the final extension. For example, ‘foo/bar/baz.tar.gz(:r)’ expands to ‘foo/bar/baz.tar’.

‘q’
Marks that the value should be interpreted by Eshell literally, so that any special characters like ‘$’ no longer have any special meaning.

‘s/pattern/replace/’
Replaces the first instance of the regular expression pattern with replace. Signals an error if no match is found.

As with other modifiers taking string parameters, you can use different delimiters to separate pattern and replace, such as ‘s'…'…'’, ‘s[…][…]’, or even ‘s[…]/…/’.

‘gs/pattern/replace/’
Replaces all instances of the regular expression pattern with replace.

‘i/pattern/’
Filters a list of values to include only the elements matching the regular expression pattern.

‘x/pattern/’
Filters a list of values to exclude all the elements matching the regular expression pattern.

‘S’
‘S/pattern/’
Splits the value using the regular expression pattern as a delimiter. If pattern is omitted, split on spaces.

‘j’
‘j/delim/’
Joins a list of values, inserting the string delim between each value. If delim is omitted, use a single space as the delimiter.

‘o’
Sorts a list of strings in ascending lexicographic order, comparing pairs of characters according to their character codes (see Text Comparison in The Emacs Lisp Reference Manual).

‘O’
Sorts a list of strings in descending lexicographic order.

‘u’
Removes any duplicate elements from a list of values.

‘R’
Reverses the order of a list of values.

Next: Extension modules, Previous: Expansion, Up: Eshell   [Contents][Index]

4 Input/Output
Since Eshell does not communicate with a terminal like most command shells, IO is a little different.

Visual Commands
Redirection
Pipelines
Next: Redirection, Up: Input/Output   [Contents][Index]

4.1 Visual Commands
If you try to run programs from within Eshell that are not line-oriented, such as programs that use ncurses, you will just get garbage output, since the Eshell buffer is not a terminal emulator. Eshell solves this problem by running such programs in Emacs’s terminal emulator.

Programs that need a terminal to display output properly are referred to in this manual as “visual commands”, because they are not simply line-oriented. You must tell Eshell which commands are visual, by adding them to eshell-visual-commands; for commands that are visual for only certain sub-commands – e.g., ‘git log’ but not ‘git status’ – use eshell-visual-subcommands; and for commands that are visual only when passed certain options, use eshell-visual-options.

Caution: Some tools such as Git use the pager ‘less’ by default to paginate their output but call it with its ‘-F’ option. This option causes ‘less’ to echo the output instead of paginating it if the output is less than one page long. This causes undesirable behavior if, e.g., ‘git diff’, is defined as a visual subcommand. It’ll work if the output is big enough and fail if it is less than one page long. If that occurs to you, search for configuration options for calling ‘less’ without the ‘-F’ option. For Git, you can do that using ‘git config --global core.pager 'less -+F'’.

If you want the buffers created by visual programs killed when the program exits, customize the variable eshell-destroy-buffer-when-process-dies to a non-nil value; the default is nil.

Next: Pipelines, Previous: Visual Commands, Up: Input/Output   [Contents][Index]

4.2 Redirection
Redirection in Eshell is similar to that of other command shells. You can use the output redirection operators > and >>, but there is not yet any support for input redirection. In the cases below, fd specifies the file descriptor to redirect; if not specified, file descriptor 1 (standard output) will be used by default.

> dest
fd> dest
Redirect output to dest, overwriting its contents with the new output.

>> dest
fd>> dest
Redirect output to dest, appending it to the existing contents of dest.

>>> dest
fd>>> dest
Redirect output to dest, inserting it at the current mark if dest is a buffer, at the beginning of the file if dest is a file, or otherwise behaving the same as >>.

&> dest
>& dest
Redirect both standard output and standard error to dest, overwriting its contents with the new output.

&>> dest
>>& dest
Redirect both standard output and standard error to dest, appending it to the existing contents of dest.

&>>> dest
>>>& dest
Redirect both standard output and standard error to dest, inserting it like with >>> dest.

>&other-fd
fd>&other-fd
Duplicate the file descriptor other-fd to fd (or 1 if unspecified). The order in which this is used is significant, so

command > file 2>&1
redirects both standard output and standard error to file, whereas

command 2>&1 > file
only redirects standard output to file (and sends standard error to the display via standard output’s original handle).

Eshell supports redirecting output to several different types of targets:

files, including virtual targets (see below);
buffers (see Buffers in GNU Emacs Lisp Reference Manual);
markers (see Markers in GNU Emacs Lisp Reference Manual);
processes (see Processes in GNU Emacs Lisp Reference Manual); and
symbols (see Symbols in GNU Emacs Lisp Reference Manual).
Virtual Targets
4.2.1 Virtual Targets
Virtual targets are mapping of device names to functions. Eshell comes with four virtual devices:

/dev/null
Does nothing with the output passed to it.

/dev/eshell
Writes the text passed to it to the display.

/dev/kill
Adds the text passed to it to the kill ring.

/dev/clip
Adds the text passed to it to the clipboard.

You can, of course, define your own virtual targets. They are defined by adding a list of the form ‘("/dev/name" function mode)’ to eshell-virtual-targets. The first element is the device name; function may be either a lambda or a function name. If mode is nil, then the function is the output function; if it is non-nil, then the function is passed the redirection mode as a symbol–overwrite for >, append for >>, or insert for >>>–and the function is expected to return the output function.

The output function is called once on each line of output until nil is passed, indicating end of output.

Previous: Redirection, Up: Input/Output   [Contents][Index]

4.3 Pipelines
As with most other shells, Eshell supports pipelines to pass the output of one command the input of the next command. You can send the standard output of one command to the standard input of another using the | operator. For example,

~ $ echo hello | rev
olleh
To send both the standard output and standard error of a command to another command’s input, you can use the |& operator.

Running Shell Pipelines Natively
4.3.1 Running Shell Pipelines Natively
When constructing shell pipelines that will move a lot of data, it is a good idea to bypass Eshell’s own pipelining support and use the operating system shell’s instead. This is especially relevant when executing commands on a remote machine using Eshell’s Tramp integration: using the remote shell’s pipelining avoids copying the data which will flow through the pipeline to local Emacs buffers and then right back again.

Eshell recognizes a special syntax to make it easier to convert pipelines so as to bypass Eshell’s pipelining. Prefixing at least one |, < or > with an asterisk marks a command as intended for the operating system shell. To make it harder to invoke this functionality accidentally, it is also required that the asterisk be preceded by whitespace or located at the start of input. For example,

 cat *.ogg *| my-cool-decoder >file
Executing this command will not copy all the data in the *.ogg files, nor the decoded data, into Emacs buffers, as would normally happen.

The command is interpreted as extending up to the next | character which is not preceded by an unescaped asterisk following whitespace, or the end of the input if there is no such character. Thus, all < and > redirections occurring before the next asterisk-unprefixed | are implicitly prefixed with (whitespace and) asterisks. An exception is that Eshell-specific redirects right at the end of the command are excluded. This allows input like this:

 foo *| baz >#<buffer quux>
which is equivalent to input like this:

 sh -c "foo | baz" >#<buffer quux>
Next: Bugs and ideas, Previous: Input/Output, Up: Eshell   [Contents][Index]

5 Extension modules
Eshell provides a facility for defining extension modules so that they can be disabled and enabled without having to unload and reload them, and to provide a common parent Customize group for the modules.9

Optional modules
Writing a module
Next: Writing a module, Up: Extension modules   [Contents][Index]

5.1 Optional modules
In addition to the various modules enabled by default (documented above), Eshell provides several other modules which are not enabled by default. If you want to enable these, you can add them to eshell-modules-list.

Key rebinding
Smart scrolling
Electric forward slash
Tramp extensions
Extra built-in commands
Next: Smart scrolling, Up: Optional modules   [Contents][Index]

5.1.1 Key rebinding
This module allows for special keybindings that only take effect while the point is in a region of input text. The default keybindings mimic the bindings used in other shells when the user is editing new input text. To enable this module, add eshell-rebind to eshell-modules-list.

For example, it binds C-a to move to the beginning of the input text, C-u to kill the current input text, and C-w to backward-kill-word. If the history module is enabled, it also binds C-p and C-n to move through the input history.

If eshell-confine-point-to-input is non-nil, this module prevents certain commands from causing the point to leave the input area, such as backward-word, previous-line, etc.

Next: Electric forward slash, Previous: Key rebinding, Up: Optional modules   [Contents][Index]

5.1.2 Smart scrolling
This module combines the facility of normal, modern shells with some of the edit/review concepts inherent in the design of Plan 9’s 9term. To enable it, add eshell-smart to eshell-modules-list.

When you invoke a command, it is assumed that you want to read the output of that command.
If the output is not what you wanted, it is assumed that you will want to edit, and then resubmit a refined version of that command.
If the output is valid, pressing any self-inserting character key will jump to end of the buffer and insert that character, in order to begin entry of a new command.
If you show an intention to edit the previous command – by moving around within it – then the next self-inserting characters will insert *there*, instead of at the bottom of the buffer.
If you show an intention to review old commands, such as M-p or M-r, point will jump to the bottom of the buffer before invoking that command.
If none of the above has happened yet (i.e. your point is just sitting on the previous command), you can use SPC and BACKSPACE (or Delete) to page forward and backward through the output of the last command only. It will constrain the movement of the point and window so that the maximum amount of output is always displayed at all times.
While output is being generated from a command, the window will be constantly reconfigured (until it would otherwise make no difference) in order to always show you the most output from the command possible. This happens if you change window sizes, scroll, etc.
Next: Tramp extensions, Previous: Smart scrolling, Up: Optional modules   [Contents][Index]

5.1.3 Electric forward slash
To help with supplying absolute file name arguments to remote commands, you can add the eshell-elecslash module to eshell-modules-list. Then, typing / as the first character of a command line argument will automatically insert the Tramp prefix /method:host:. If this is not what you want (e.g. because you want to refer to a local file), you can type another / to undo the automatic insertion. Typing ~/ also inserts the Tramp prefix. The automatic insertion applies only when default-directory is remote and the command is a Lisp function. In particular, typing arguments to external commands doesn’t insert the prefix.

The result is that in most cases of supplying absolute file name arguments to commands you should see the Tramp prefix inserted automatically only when that’s what you’d reasonably expect. This frees you from having to keep track of whether commands are Lisp functions or external when typing command line arguments. For example, suppose you execute

 cd /ssh:root@example.com:
 find /etc -name "*gnu*"
and in reviewing the output of the command, you identify a file /etc/gnugnu that should be moved somewhere else. So you type

 mv /etc/gnugnu /tmp
But since mv refers to the local Lisp function eshell/mv, not a remote shell command, to say this is to request that the local file /etc/gnugnu be moved into the local /tmp directory. After you add eshell-elecslash to eshell-modules-list, then when you type the above mv invocation you will get the following input, which is what you intended:

 mv /ssh:root@example.com:/etc/gnugnu /ssh:root@example.com:/tmp
The code that determines whether or not the Tramp prefix should be inserted uses simple heuristics. A limitation of the current implementation is that it inspects whether only the command at the very beginning of input is a Lisp function or external program. Thus when chaining commands with the operators &&, ||, | and ;, the electric forward slash is active only within the first command.

Next: Extra built-in commands, Previous: Electric forward slash, Up: Optional modules   [Contents][Index]

5.1.4 Tramp extensions
This module adds built-in commands that use Tramp to handle running other commands as different users, replacing the corresponding external commands. To enable it, add eshell-tramp to eshell-modules-list.

su ¶
sudo
doas
Uses TRAMP’s su, sudo, or doas method (see Inline methods in The Tramp Manual) to run a command via su, sudo, or doas.

Previous: Tramp extensions, Up: Optional modules   [Contents][Index]

5.1.5 Extra built-in commands
This module provides several extra built-in commands documented below, primarily for working with lists of strings in Eshell. To enable it, add eshell-xtra to eshell-modules-list.

count ¶
A wrapper around the function cl-count (see Searching Sequences in GNU Emacs Common Lisp Emulation). This command can be used for comparing lists of strings.

expr ¶
An implementation of expr using the Calc package. See The GNU Emacs Calculator.

ff ¶
Shorthand for the the function find-name-dired (see Dired and Find in The Emacs Editor).

gf ¶
Shorthand for the the function find-grep-dired (see Dired and Find in The Emacs Editor).

intersection ¶
A wrapper around the function cl-intersection (see Lists as Sets in GNU Emacs Common Lisp Emulation). This command can be used for comparing lists of strings.

mismatch ¶
A wrapper around the function cl-mismatch (see Searching Sequences in GNU Emacs Common Lisp Emulation). This command can be used for comparing lists of strings.

set-difference ¶
A wrapper around the function cl-set-difference (see Lists as Sets in GNU Emacs Common Lisp Emulation). This command can be used for comparing lists of strings.

set-exclusive-or ¶
A wrapper around the function cl-set-exclusive-or (see Lists as Sets in GNU Emacs Common Lisp Emulation). This command can be used for comparing lists of strings.

substitute ¶
A wrapper around the function cl-substitute (see Sequence Functions in GNU Emacs Common Lisp Emulation). This command can be used for comparing lists of strings.

union ¶
A wrapper around the function cl-union (see Lists as Sets in GNU Emacs Common Lisp Emulation). This command can be used for comparing lists of strings.

Previous: Optional modules, Up: Extension modules   [Contents][Index]

5.2 Writing a module
An Eshell module is defined the same as any other library but with two additional requirements: first, the module’s source file should be named em-name.el; second, the module must define an autoloaded Customize group (see Customization in The Emacs Lisp Reference Manual) with eshell-module as the parent group. In order to properly autoload this group, you should wrap its definition with progn as follows:

;;;###autoload
(progn
(defgroup eshell-my-module nil
  "My module lets you do very cool things in Eshell."
  :tag "My module"
  :group 'eshell-module))
Even if you don’t have any Customize options in your module, you should still define the group so that Eshell can include your module in the Customize interface for eshell-modules-list.

Next: GNU Free Documentation License, Previous: Extension modules, Up: Eshell   [Contents][Index]

6 Bugs and ideas
If you find a bug or misfeature, don’t hesitate to report it, by using M-x report-emacs-bug. The same applies to feature requests. It is best to discuss one thing at a time. If you find several unrelated bugs, please report them separately.

Below is a list of some known problems with Eshell version 2.4.2, which is the version included with Emacs 22.

Differentiate between aliases and functions
Allow for a Bash-compatible syntax, such as:

alias arg=blah
function arg () { blah $* }
Pcomplete sometimes gets stuck
You press TAB, but no completions appear, even though the directory has matching files. This behavior is rare.

‘grep python $<rpm -qa>’ doesn’t work, but using ‘*grep’ does
This happens because the grep Lisp function returns immediately, and then the asynchronous grep process expects to examine the temporary file, which has since been deleted.

Problem with C-r repeating text
If the text before point reads "./run", and you type C-r r u n, it will repeat the line for every character typed.

Backspace doesn’t scroll back after continuing (in smart mode)
Hitting space during a process invocation, such as make, will cause it to track the bottom of the output; but backspace no longer scrolls back.

It’s not possible to fully unload-feature Eshell
Menu support was removed, but never put back
If an interactive process is currently running, M-! doesn’t work
Use a timer instead of sleep-for when killing child processes
Piping to a Lisp function is not supported
Make it so that the Lisp command on the right of the pipe is repeatedly called with the input strings as arguments. This will require changing eshell-do-pipelines to handle non-process targets.

Input redirection is not supported
See the above entry.

Problem running less without arguments on Windows
The result in the Eshell buffer is:

Spawning child process: invalid argument
Also a new less buffer was created with nothing in it… (presumably this holds the output of less).

If less.exe is invoked from the Eshell command line, the expected output is written to the buffer.

Note that this happens on NT-Emacs 20.6.1 on Windows 2000. The term.el package and the supplied shell both use the cmdproxy program for running shells.

Implement ‘-r’, ‘-n’ and ‘-s’ switches for cp
‘mv dir file.tar’ does not remove directories
This is because the tar option –remove-files doesn’t do so. Should it be Eshell’s job?

Bind standard-output and standard-error
This would be so that if a Lisp function calls print, everything will happen as it should (albeit slowly).

When an extension module fails to load, ‘cd /’ gives a Lisp error
If a globbing pattern returns one match, should it be a list?
Make sure syntax table is correct in Eshell mode
So that M-DEL acts in a predictable manner, etc.

Allow all Eshell buffers to share the same history and list-dir
There is a problem with script commands that output to /dev/null
If a script file, somewhere in the middle, uses ‘> /dev/null’, output from all subsequent commands is swallowed.

Split up parsing of text after ‘$’ in esh-var.el
Make it similar to the way that esh-arg.el is structured. Then add parsing of ‘$[?\n]’.

After pressing M-RET, redisplay before running the next command
Argument predicates and modifiers should work anywhere in a path
/usr/local/src/editors/vim $ vi **/CVS(/)/Root(.)  Invalid regexp:
"Unmatched ( or \\("
With zsh, the glob above expands to all files named Root in directories named CVS.

Typing ‘echo ${locate locate}/binTAB’ results in a Lisp error
Perhaps it should interpolate all permutations, and make that the globbing result, since otherwise hitting return here will result in “(list of filenames)/bin”, which is never valuable. Thus, one could cat only C backup files by using ‘ls ${identity *.c}~’. In that case, having an alias command name glob for identity would be useful.

Once symbolic mode is supported for umask, implement chmod in Lisp
Create eshell-expand-file-name
This would use a data table to transform things such as ‘~+’, ‘...’, etc.

Abstract em-smart.el into smart-scroll.el
It only really needs: to be hooked onto the output filter and the pre-command hook, and to have the input-end and input-start markers. And to know whether the last output group was “successful.”

Allow for fully persisting the state of Eshell
This would include: variables, history, buffer, input, dir stack, etc.

Implement D as an argument predicate
It means that files beginning with a dot should be included in the glob match.

A comma in a predicate list should mean OR
At the moment, this is not supported.

‘(+ RET SPC TAB’ does not cause indent-according-to-mode to occur
Create eshell-auto-accumulate-list
This is a list of commands for which, if the user presses RET, the text is staged as the next Eshell command, rather than being sent to the current interactive process.

Display file and line number if an error occurs in a script
wait doesn’t work with process ids at the moment
Enable the direct-to-process input code in em-term.el
Problem with repeating ‘echo ${find /tmp}’
With smart display active, if RET is held down, after a while it can’t keep up anymore and starts outputting blank lines. It only happens if an asynchronous process is involved…

I think the problem is that eshell-send-input is resetting the input target location, so that if the asynchronous process is not done by the time the next RET is received, the input processor thinks that the input is meant for the process; which, when smart display is enabled, will be the text of the last command line! That is a bug in itself.

In holding down RET while an asynchronous process is running, there will be a point in between termination of the process, and the running of eshell-post-command-hook, which would cause eshell-send-input to call eshell-copy-old-input, and then process that text as a command to be run after the process. Perhaps there should be a way of killing pending input between the death of the process, and the post-command-hook.

Allow for a more aggressive smart display mode
Perhaps toggled by a command, that makes each output block a smart display block.

Create more meta variables
‘$!’
The reason for the failure of the last disk command, or the text of the last Lisp error.

‘$=’
A special associate array, which can take references of the form ‘$=[REGEXP]’. It indexes into the directory ring.

Eshell scripts can’t execute in the background
Support zsh’s “Parameter Expansion” syntax, i.e., ‘${name:-val}’
Create a mode eshell-browse
It would treat the Eshell buffer as an outline. Collapsing the outline hides all of the output text. Collapsing again would show only the first command run in each directory

Allow other revisions of a file to be referenced using ‘file{rev}’
This would be expanded by eshell-expand-file-name (see above).

Print “You have new mail” when the “Mail” icon is turned on
Implement M-| for Eshell
Implement input redirection
If it’s a Lisp function, input redirection implies xargs (in a way…). If input redirection is added, also update the file-name-quote-list, and the delimiter list.

Allow ‘#<word arg>’ as a generic syntax
With the handling of word specified by an eshell-special-alist.

In eshell-eval-using-options, allow a :complete tag
It would be used to provide completion rules for that command. Then the macro will automagically define the completion function.

For eshell-command-on-region, apply redirections to the result
So that ‘+ > 'blah’ would cause the result of the + (using input from the current region) to be inserting into the symbol blah.

If an external command is being invoked, the input is sent as standard input, as if a ‘cat <region> |’ had been invoked.

If a Lisp command, or an alias, is invoked, then if the line has no newline characters, it is divided by whitespace and passed as arguments to the Lisp function. Otherwise, it is divided at the newline characters. Thus, invoking + on a series of numbers will add them; min would display the smallest figure, etc.

Write eshell-script-mode as a minor mode
It would provide syntax, abbrev, highlighting and indenting support like emacs-lisp-mode and shell-mode.

In the history mechanism, finish the Bash-style support
This means ‘!n’, ‘!#’, ‘!:%’, and ‘!:1-’ as separate from ‘!:1*’.

Support the -n command line option for history
Implement fc in Lisp
Specifying a frame as a redirection target should imply the currently active window’s buffer
Implement ‘>func-or-func-list’
This would allow for an “output translators”, that take a function to modify output with, and a target. Devise a syntax that works well with pipes, and can accommodate multiple functions (i.e., ‘>'(upcase regexp-quote)’ or ‘>'upcase’).

Allow Eshell to read/write to/from standard input and output
This would be optional, rather than always using the Eshell buffer. This would allow it to be run from the command line (perhaps).

Write a help command
It would call subcommands with --help, or -h or /?, as appropriate.

Implement stty in Lisp
Support rc’s matching operator, e.g., ‘~ (list) regexp’
Implement bg and fg as editors of eshell-process-list
Using bg on a process that is already in the background does nothing. Specifying redirection targets replaces (or adds) to the list current being used.

Have jobs print only the processes for the current shell
How can Eshell learn if a background process has requested input?
Make a customizable syntax table for redirects
This way, the user could change it to use rc syntax: ‘>[2=1]’.

Allow ‘$_[-1]’, which would indicate the last element of the array
Make ‘$x[*]’ equal to listing out the full contents of ‘x’
Return them as a list, so that ‘$_[*]’ is all the arguments of the last command.

Copy ANSI code handling from term.el into em-term.el
Make it possible for the user to send char-by-char to the underlying process. Ultimately, I should be able to move away from using term.el altogether, since everything but the ANSI code handling is already part of Eshell. Then, things would work correctly on MS-Windows as well (which doesn’t have /bin/sh, although term.el tries to use it).

Make the shell spawning commands be visual
That is, make (su, bash, ssh, etc.) be part of eshell-visual-commands. The only exception is if the shell is being used to invoke a single command. Then, the behavior should be based on what that command is.

Create a smart viewing command named open
This would search for some way to open its argument (similar to opening a file in the Windows Explorer).

Alias read to be the same as open, only read-only
Write a tail command which uses view-file
It would move point to the end of the buffer, and then turns on auto-revert mode in that buffer at frequent intervals—and a head alias which assumes an upper limit of eshell-maximum-line-length characters per line.

Make dgrep load dired, mark everything, then invoke dired-do-search
Write mesh.c
This would run Emacs with the appropriate arguments to invoke Eshell only. That way, it could be listed as a login shell.

Use an intangible PS2 string for multi-line input prompts
Auto-detect when a command is visual, by checking TERMCAP usage
The first keypress after M-x watson triggers
eshell-send-input

Make / more electric
so that it automatically expands and corrects file names, beyond what the em-elecslash module is able to do. Or make file name completion for Pcomplete auto-expand ‘/u/i/stdTAB’ to ‘/usr/include/stdTAB’.

Write the pushd stack to disk along with last-dir-ring
Add options to eshell/cat which would allow it to sort and uniq
Implement wc in Lisp
Add support for counting sentences, paragraphs, pages, etc.

Once piping is added, implement sort and uniq in Lisp
Implement touch in Lisp
Implement comm in Lisp
Implement an epatch command in Lisp
This would call ediff-patch-file, or ediff-patch-buffer, depending on its argument.

Have an option such that ‘ls -l’ generates a dired buffer
Write a version of xargs based on command rewriting
That is, ‘find X | xargs Y’ would be indicated using ‘Y ${find X}’. Maybe eshell-do-pipelines could be changed to perform this on-thy-fly rewriting.

Write an alias for less that brings up a view-mode buffer
Such that the user can press SPC and DEL, and then q to return to Eshell. It would be equivalent to: ‘X > #<buffer Y>; view-buffer #<buffer Y>’.

Make eshell-mode as much a full citizen as shell-mode
Everywhere in Emacs where shell-mode is specially noticed, add eshell-mode there.

Permit the umask to be selectively set on a cp target
Problem using M-x eshell after using eshell-command
If the first thing that I do after entering Emacs is to run eshell-command and invoke ls, and then use M-x eshell, it doesn’t display anything.

M-RET during a long command (using smart display) doesn’t work
Since it keeps the cursor up where the command was invoked.

Next: Concept Index, Previous: Bugs and ideas, Up: Eshell   [Contents][Index]

Appendix A GNU Free Documentation License
Version 1.3, 3 November 2008
Copyright © 2000, 2001, 2002, 2007, 2008 Free Software Foundation, Inc.
https://fsf.org/

Everyone is permitted to copy and distribute verbatim copies
of this license document, but changing it is not allowed.
PREAMBLE
The purpose of this License is to make a manual, textbook, or other functional and useful document free in the sense of freedom: to assure everyone the effective freedom to copy and redistribute it, with or without modifying it, either commercially or noncommercially. Secondarily, this License preserves for the author and publisher a way to get credit for their work, while not being considered responsible for modifications made by others.

This License is a kind of “copyleft”, which means that derivative works of the document must themselves be free in the same sense. It complements the GNU General Public License, which is a copyleft license designed for free software.

We have designed this License in order to use it for manuals for free software, because free software needs free documentation: a free program should come with manuals providing the same freedoms that the software does. But this License is not limited to software manuals; it can be used for any textual work, regardless of subject matter or whether it is published as a printed book. We recommend this License principally for works whose purpose is instruction or reference.

APPLICABILITY AND DEFINITIONS
This License applies to any manual or other work, in any medium, that contains a notice placed by the copyright holder saying it can be distributed under the terms of this License. Such a notice grants a world-wide, royalty-free license, unlimited in duration, to use that work under the conditions stated herein. The “Document”, below, refers to any such manual or work. Any member of the public is a licensee, and is addressed as “you”. You accept the license if you copy, modify or distribute the work in a way requiring permission under copyright law.

A “Modified Version” of the Document means any work containing the Document or a portion of it, either copied verbatim, or with modifications and/or translated into another language.

A “Secondary Section” is a named appendix or a front-matter section of the Document that deals exclusively with the relationship of the publishers or authors of the Document to the Document’s overall subject (or to related matters) and contains nothing that could fall directly within that overall subject. (Thus, if the Document is in part a textbook of mathematics, a Secondary Section may not explain any mathematics.) The relationship could be a matter of historical connection with the subject or with related matters, or of legal, commercial, philosophical, ethical or political position regarding them.

The “Invariant Sections” are certain Secondary Sections whose titles are designated, as being those of Invariant Sections, in the notice that says that the Document is released under this License. If a section does not fit the above definition of Secondary then it is not allowed to be designated as Invariant. The Document may contain zero Invariant Sections. If the Document does not identify any Invariant Sections then there are none.

The “Cover Texts” are certain short passages of text that are listed, as Front-Cover Texts or Back-Cover Texts, in the notice that says that the Document is released under this License. A Front-Cover Text may be at most 5 words, and a Back-Cover Text may be at most 25 words.

A “Transparent” copy of the Document means a machine-readable copy, represented in a format whose specification is available to the general public, that is suitable for revising the document straightforwardly with generic text editors or (for images composed of pixels) generic paint programs or (for drawings) some widely available drawing editor, and that is suitable for input to text formatters or for automatic translation to a variety of formats suitable for input to text formatters. A copy made in an otherwise Transparent file format whose markup, or absence of markup, has been arranged to thwart or discourage subsequent modification by readers is not Transparent. An image format is not Transparent if used for any substantial amount of text. A copy that is not “Transparent” is called “Opaque”.

Examples of suitable formats for Transparent copies include plain ASCII without markup, Texinfo input format, LaTeX input format, SGML or XML using a publicly available DTD, and standard-conforming simple HTML, PostScript or PDF designed for human modification. Examples of transparent image formats include PNG, XCF and JPG. Opaque formats include proprietary formats that can be read and edited only by proprietary word processors, SGML or XML for which the DTD and/or processing tools are not generally available, and the machine-generated HTML, PostScript or PDF produced by some word processors for output purposes only.

The “Title Page” means, for a printed book, the title page itself, plus such following pages as are needed to hold, legibly, the material this License requires to appear in the title page. For works in formats which do not have any title page as such, “Title Page” means the text near the most prominent appearance of the work’s title, preceding the beginning of the body of the text.

The “publisher” means any person or entity that distributes copies of the Document to the public.

A section “Entitled XYZ” means a named subunit of the Document whose title either is precisely XYZ or contains XYZ in parentheses following text that translates XYZ in another language. (Here XYZ stands for a specific section name mentioned below, such as “Acknowledgements”, “Dedications”, “Endorsements”, or “History”.) To “Preserve the Title” of such a section when you modify the Document means that it remains a section “Entitled XYZ” according to this definition.

The Document may include Warranty Disclaimers next to the notice which states that this License applies to the Document. These Warranty Disclaimers are considered to be included by reference in this License, but only as regards disclaiming warranties: any other implication that these Warranty Disclaimers may have is void and has no effect on the meaning of this License.

VERBATIM COPYING
You may copy and distribute the Document in any medium, either commercially or noncommercially, provided that this License, the copyright notices, and the license notice saying this License applies to the Document are reproduced in all copies, and that you add no other conditions whatsoever to those of this License. You may not use technical measures to obstruct or control the reading or further copying of the copies you make or distribute. However, you may accept compensation in exchange for copies. If you distribute a large enough number of copies you must also follow the conditions in section 3.

You may also lend copies, under the same conditions stated above, and you may publicly display copies.

COPYING IN QUANTITY
If you publish printed copies (or copies in media that commonly have printed covers) of the Document, numbering more than 100, and the Document’s license notice requires Cover Texts, you must enclose the copies in covers that carry, clearly and legibly, all these Cover Texts: Front-Cover Texts on the front cover, and Back-Cover Texts on the back cover. Both covers must also clearly and legibly identify you as the publisher of these copies. The front cover must present the full title with all words of the title equally prominent and visible. You may add other material on the covers in addition. Copying with changes limited to the covers, as long as they preserve the title of the Document and satisfy these conditions, can be treated as verbatim copying in other respects.

If the required texts for either cover are too voluminous to fit legibly, you should put the first ones listed (as many as fit reasonably) on the actual cover, and continue the rest onto adjacent pages.

If you publish or distribute Opaque copies of the Document numbering more than 100, you must either include a machine-readable Transparent copy along with each Opaque copy, or state in or with each Opaque copy a computer-network location from which the general network-using public has access to download using public-standard network protocols a complete Transparent copy of the Document, free of added material. If you use the latter option, you must take reasonably prudent steps, when you begin distribution of Opaque copies in quantity, to ensure that this Transparent copy will remain thus accessible at the stated location until at least one year after the last time you distribute an Opaque copy (directly or through your agents or retailers) of that edition to the public.

It is requested, but not required, that you contact the authors of the Document well before redistributing any large number of copies, to give them a chance to provide you with an updated version of the Document.

MODIFICATIONS
You may copy and distribute a Modified Version of the Document under the conditions of sections 2 and 3 above, provided that you release the Modified Version under precisely this License, with the Modified Version filling the role of the Document, thus licensing distribution and modification of the Modified Version to whoever possesses a copy of it. In addition, you must do these things in the Modified Version:

Use in the Title Page (and on the covers, if any) a title distinct from that of the Document, and from those of previous versions (which should, if there were any, be listed in the History section of the Document). You may use the same title as a previous version if the original publisher of that version gives permission.
List on the Title Page, as authors, one or more persons or entities responsible for authorship of the modifications in the Modified Version, together with at least five of the principal authors of the Document (all of its principal authors, if it has fewer than five), unless they release you from this requirement.
State on the Title page the name of the publisher of the Modified Version, as the publisher.
Preserve all the copyright notices of the Document.
Add an appropriate copyright notice for your modifications adjacent to the other copyright notices.
Include, immediately after the copyright notices, a license notice giving the public permission to use the Modified Version under the terms of this License, in the form shown in the Addendum below.
Preserve in that license notice the full lists of Invariant Sections and required Cover Texts given in the Document’s license notice.
Include an unaltered copy of this License.
Preserve the section Entitled “History”, Preserve its Title, and add to it an item stating at least the title, year, new authors, and publisher of the Modified Version as given on the Title Page. If there is no section Entitled “History” in the Document, create one stating the title, year, authors, and publisher of the Document as given on its Title Page, then add an item describing the Modified Version as stated in the previous sentence.
Preserve the network location, if any, given in the Document for public access to a Transparent copy of the Document, and likewise the network locations given in the Document for previous versions it was based on. These may be placed in the “History” section. You may omit a network location for a work that was published at least four years before the Document itself, or if the original publisher of the version it refers to gives permission.
For any section Entitled “Acknowledgements” or “Dedications”, Preserve the Title of the section, and preserve in the section all the substance and tone of each of the contributor acknowledgements and/or dedications given therein.
Preserve all the Invariant Sections of the Document, unaltered in their text and in their titles. Section numbers or the equivalent are not considered part of the section titles.
Delete any section Entitled “Endorsements”. Such a section may not be included in the Modified Version.
Do not retitle any existing section to be Entitled “Endorsements” or to conflict in title with any Invariant Section.
Preserve any Warranty Disclaimers.
If the Modified Version includes new front-matter sections or appendices that qualify as Secondary Sections and contain no material copied from the Document, you may at your option designate some or all of these sections as invariant. To do this, add their titles to the list of Invariant Sections in the Modified Version’s license notice. These titles must be distinct from any other section titles.

You may add a section Entitled “Endorsements”, provided it contains nothing but endorsements of your Modified Version by various parties—for example, statements of peer review or that the text has been approved by an organization as the authoritative definition of a standard.

You may add a passage of up to five words as a Front-Cover Text, and a passage of up to 25 words as a Back-Cover Text, to the end of the list of Cover Texts in the Modified Version. Only one passage of Front-Cover Text and one of Back-Cover Text may be added by (or through arrangements made by) any one entity. If the Document already includes a cover text for the same cover, previously added by you or by arrangement made by the same entity you are acting on behalf of, you may not add another; but you may replace the old one, on explicit permission from the previous publisher that added the old one.

The author(s) and publisher(s) of the Document do not by this License give permission to use their names for publicity for or to assert or imply endorsement of any Modified Version.

COMBINING DOCUMENTS
You may combine the Document with other documents released under this License, under the terms defined in section 4 above for modified versions, provided that you include in the combination all of the Invariant Sections of all of the original documents, unmodified, and list them all as Invariant Sections of your combined work in its license notice, and that you preserve all their Warranty Disclaimers.

The combined work need only contain one copy of this License, and multiple identical Invariant Sections may be replaced with a single copy. If there are multiple Invariant Sections with the same name but different contents, make the title of each such section unique by adding at the end of it, in parentheses, the name of the original author or publisher of that section if known, or else a unique number. Make the same adjustment to the section titles in the list of Invariant Sections in the license notice of the combined work.

In the combination, you must combine any sections Entitled “History” in the various original documents, forming one section Entitled “History”; likewise combine any sections Entitled “Acknowledgements”, and any sections Entitled “Dedications”. You must delete all sections Entitled “Endorsements.”

COLLECTIONS OF DOCUMENTS
You may make a collection consisting of the Document and other documents released under this License, and replace the individual copies of this License in the various documents with a single copy that is included in the collection, provided that you follow the rules of this License for verbatim copying of each of the documents in all other respects.

You may extract a single document from such a collection, and distribute it individually under this License, provided you insert a copy of this License into the extracted document, and follow this License in all other respects regarding verbatim copying of that document.

AGGREGATION WITH INDEPENDENT WORKS
A compilation of the Document or its derivatives with other separate and independent documents or works, in or on a volume of a storage or distribution medium, is called an “aggregate” if the copyright resulting from the compilation is not used to limit the legal rights of the compilation’s users beyond what the individual works permit. When the Document is included in an aggregate, this License does not apply to the other works in the aggregate which are not themselves derivative works of the Document.

If the Cover Text requirement of section 3 is applicable to these copies of the Document, then if the Document is less than one half of the entire aggregate, the Document’s Cover Texts may be placed on covers that bracket the Document within the aggregate, or the electronic equivalent of covers if the Document is in electronic form. Otherwise they must appear on printed covers that bracket the whole aggregate.

TRANSLATION
Translation is considered a kind of modification, so you may distribute translations of the Document under the terms of section 4. Replacing Invariant Sections with translations requires special permission from their copyright holders, but you may include translations of some or all Invariant Sections in addition to the original versions of these Invariant Sections. You may include a translation of this License, and all the license notices in the Document, and any Warranty Disclaimers, provided that you also include the original English version of this License and the original versions of those notices and disclaimers. In case of a disagreement between the translation and the original version of this License or a notice or disclaimer, the original version will prevail.

If a section in the Document is Entitled “Acknowledgements”, “Dedications”, or “History”, the requirement (section 4) to Preserve its Title (section 1) will typically require changing the actual title.

TERMINATION
You may not copy, modify, sublicense, or distribute the Document except as expressly provided under this License. Any attempt otherwise to copy, modify, sublicense, or distribute it is void, and will automatically terminate your rights under this License.

However, if you cease all violation of this License, then your license from a particular copyright holder is reinstated (a) provisionally, unless and until the copyright holder explicitly and finally terminates your license, and (b) permanently, if the copyright holder fails to notify you of the violation by some reasonable means prior to 60 days after the cessation.

Moreover, your license from a particular copyright holder is reinstated permanently if the copyright holder notifies you of the violation by some reasonable means, this is the first time you have received notice of violation of this License (for any work) from that copyright holder, and you cure the violation prior to 30 days after your receipt of the notice.

Termination of your rights under this section does not terminate the licenses of parties who have received copies or rights from you under this License. If your rights have been terminated and not permanently reinstated, receipt of a copy of some or all of the same material does not give you any rights to use it.

FUTURE REVISIONS OF THIS LICENSE
The Free Software Foundation may publish new, revised versions of the GNU Free Documentation License from time to time. Such new versions will be similar in spirit to the present version, but may differ in detail to address new problems or concerns. See https://www.gnu.org/licenses/.

Each version of the License is given a distinguishing version number. If the Document specifies that a particular numbered version of this License “or any later version” applies to it, you have the option of following the terms and conditions either of that specified version or of any later version that has been published (not as a draft) by the Free Software Foundation. If the Document does not specify a version number of this License, you may choose any version ever published (not as a draft) by the Free Software Foundation. If the Document specifies that a proxy can decide which future versions of this License can be used, that proxy’s public statement of acceptance of a version permanently authorizes you to choose that version for the Document.

RELICENSING
“Massive Multiauthor Collaboration Site” (or “MMC Site”) means any World Wide Web server that publishes copyrightable works and also provides prominent facilities for anybody to edit those works. A public wiki that anybody can edit is an example of such a server. A “Massive Multiauthor Collaboration” (or “MMC”) contained in the site means any set of copyrightable works thus published on the MMC site.

“CC-BY-SA” means the Creative Commons Attribution-Share Alike 3.0 license published by Creative Commons Corporation, a not-for-profit corporation with a principal place of business in San Francisco, California, as well as future copyleft versions of that license published by that same organization.

“Incorporate” means to publish or republish a Document, in whole or in part, as part of another Document.

An MMC is “eligible for relicensing” if it is licensed under this License, and if all works that were first published under this License somewhere other than this MMC, and subsequently incorporated in whole or in part into the MMC, (1) had no cover texts or invariant sections, and (2) were thus incorporated prior to November 1, 2008.

The operator of an MMC Site may republish an MMC contained in the site under CC-BY-SA on the same site at any time before August 1, 2009, provided the MMC is eligible for relicensing.

ADDENDUM: How to use this License for your documents
To use this License in a document you have written, include a copy of the License in the document and put the following copyright and license notices just after the title page:

  Copyright (C)  year  your name.
  Permission is granted to copy, distribute and/or modify this document
  under the terms of the GNU Free Documentation License, Version 1.3
  or any later version published by the Free Software Foundation;
  with no Invariant Sections, no Front-Cover Texts, and no Back-Cover
  Texts.  A copy of the license is included in the section entitled ``GNU
  Free Documentation License''.
If you have Invariant Sections, Front-Cover Texts and Back-Cover Texts, replace the “with…Texts.” line with this:

    with the Invariant Sections being list their titles, with
    the Front-Cover Texts being list, and with the Back-Cover Texts
    being list.
If you have Invariant Sections without Cover Texts, or some other combination of the three, merge those two alternatives to suit the situation.

If your document contains nontrivial examples of program code, we recommend releasing these examples in parallel under your choice of free software license, such as the GNU General Public License, to permit their use in free software.

Next: Function and Variable Index, Previous: GNU Free Documentation License, Up: Eshell   [Contents][Index]

Concept Index
Jump to:  	A   B   C   E   F   G   K   O   P   R   W  
Index Entry	 	Section
A		
argument modification:	 	Argument Predication and Modification
argument predication:	 	Argument Predication and Modification
author, how to reach:	 	Bugs and ideas
authors:	 	Contributors to Eshell
B		
bugs, how to report them:	 	Bugs and ideas
bugs, known:	 	Bugs and ideas
C		
character classes, in Eshell glob patterns:	 	Globbing
character sets, in Eshell glob patterns:	 	Globbing
command lookup order:	 	Invocation
complemented character sets, in Eshell glob patterns:	 	Globbing
contributors:	 	Contributors to Eshell
E		
email to the author:	 	Bugs and ideas
Eshell, what it is:	 	Introduction
event designators:	 	History
F		
FAQ:	 	Bugs and ideas
G		
groups, in Eshell glob patterns:	 	Globbing
K		
known bugs:	 	Bugs and ideas
O		
order of looking for commands:	 	Invocation
P		
problems, list of common:	 	Bugs and ideas
R		
reporting bugs and ideas:	 	Bugs and ideas
W		
what is Eshell?:	 	Introduction
Jump to:  	A   B   C   E   F   G   K   O   P   R   W  
Next: Command Index, Previous: Concept Index, Up: Eshell   [Contents][Index]

Function and Variable Index
Jump to:  	$  
E  
Index Entry	 	Section
$		
$$:	 	Variables
$*:	 	Aliases
$+:	 	Variables
$-:	 	Variables
$1, $2, …:	 	Aliases
$?:	 	Variables
$COLUMNS:	 	Variables
$INSIDE_EMACS:	 	Variables
$LINES:	 	Variables
$OLDPWD:	 	Variables
$PATH:	 	Variables
$PWD:	 	Variables
$_:	 	Variables
E		
eshell-aliases-file:	 	Aliases
eshell-cd-shows-directory:	 	Built-ins
eshell-confine-point-to-input:	 	Key rebinding
eshell-convert-numeric-arguments:	 	Dollars Expansion
eshell-cp-interactive-query:	 	Built-ins
eshell-cp-overwrite-files:	 	Built-ins
eshell-default-target-is-dot:	 	Built-ins
eshell-destroy-buffer-when-process-dies:	 	Visual Commands
eshell-eval-using-options:	 	Built-ins
eshell-expand-history-references:	 	History
eshell-glob-case-insensitive:	 	Globbing
eshell-history-file-name:	 	History
eshell-history-size:	 	History
eshell-kill-on-exit:	 	Built-ins
eshell-lisp-form-nil-is-failure:	 	Variables
eshell-list-files-after-cd:	 	Built-ins
eshell-ln-interactive-query:	 	Built-ins
eshell-ln-overwrite-files:	 	Built-ins
eshell-ls-date-format:	 	Built-ins
eshell-ls-default-blocksize:	 	Built-ins
eshell-ls-initial-args:	 	Built-ins
eshell-ls-use-colors:	 	Built-ins
eshell-modules-list:	 	Optional modules
eshell-mv-interactive-query:	 	Built-ins
eshell-mv-overwrite-files:	 	Built-ins
eshell-plain-diff-behavior:	 	Built-ins
eshell-plain-echo-behavior:	 	Built-ins
eshell-plain-grep-behavior:	 	Built-ins
eshell-plain-locate-behavior:	 	Built-ins
eshell-prefer-lisp-functions:	 	Invocation
eshell-prefer-lisp-variables:	 	Variables
eshell-pushd-dextract:	 	Built-ins
eshell-pushd-dunique:	 	Built-ins
eshell-rm-interactive-query:	 	Built-ins
eshell-rm-removes-directories:	 	Built-ins
eshell-source-file:	 	Scripts
eshell-virtual-targets:	 	Redirection
eshell-visual-commands:	 	Visual Commands
eshell-visual-options:	 	Visual Commands
eshell-visual-subcommands:	 	Visual Commands
Jump to:  	$  
E  
Previous: Function and Variable Index, Up: Eshell   [Contents][Index]

Command Index
Jump to:  	.  
A   B   C   D   E   F   G   H   I   J   K   L   M   O   P   R   S   T   U   W  
Index Entry	 	Section
.		
.:	 	Built-ins
.:	 	Scripts
A		
addpath:	 	Built-ins
agrep:	 	Built-ins
alias:	 	Built-ins
B		
basename:	 	Built-ins
C		
cat:	 	Built-ins
cd:	 	Built-ins
clear:	 	Built-ins
clear-scrollback:	 	Built-ins
count:	 	Extra built-in commands
cp:	 	Built-ins
D		
date:	 	Built-ins
diff:	 	Built-ins
dirname:	 	Built-ins
dirs:	 	Built-ins
doas:	 	Tramp extensions
du:	 	Built-ins
E		
echo:	 	Built-ins
egrep:	 	Built-ins
env:	 	Built-ins
eshell-debug:	 	Built-ins
exit:	 	Built-ins
export:	 	Built-ins
expr:	 	Extra built-in commands
F		
ff:	 	Extra built-in commands
fgrep:	 	Built-ins
G		
gf:	 	Extra built-in commands
glimpse:	 	Built-ins
grep:	 	Built-ins
H		
history:	 	Built-ins
history:	 	History
I		
info:	 	Built-ins
intersection:	 	Extra built-in commands
J		
jobs:	 	Built-ins
K		
kill:	 	Built-ins
L		
listify:	 	Built-ins
ln:	 	Built-ins
locate:	 	Built-ins
ls:	 	Built-ins
M		
make:	 	Built-ins
man:	 	Built-ins
mismatch:	 	Extra built-in commands
mkdir:	 	Built-ins
mv:	 	Built-ins
O		
occur:	 	Built-ins
P		
popd:	 	Built-ins
printnl:	 	Built-ins
pushd:	 	Built-ins
pwd:	 	Built-ins
R		
remote access:	 	Remote Access
rm:	 	Built-ins
rmdir:	 	Built-ins
S		
set:	 	Built-ins
set-difference:	 	Extra built-in commands
set-exclusive-or:	 	Extra built-in commands
setq:	 	Built-ins
source:	 	Built-ins
source:	 	Scripts
su:	 	Tramp extensions
substitute:	 	Extra built-in commands
sudo:	 	Tramp extensions
T		
time:	 	Built-ins
U		
umask:	 	Built-ins
union:	 	Extra built-in commands
unset:	 	Built-ins
W		
wait:	 	Built-ins
which:	 	Built-ins
whoami:	 	Built-ins
Jump to:  	.  
A   B   C   D   E   F   G   H   I   J   K   L   M   O   P   R   S   T   U   W  
Footnotes
(1)
Short for “Read-Eval-Print Loop”.

(2)
This is comparable to viewing the contents of a folder using a graphical display.

(3)
For the understandably curious, here is what that command looks like: But don’t let it fool you; once you know what’s going on, it’s easier than it looks: ls -lt **/*.doc(Lk+100aM+6).

(4)
To see the Lisp form that will be invoked, type this as the Eshell prompt: eshell-parse-command 'echo hello'

(5)
Eshell would interpret a bare apostrophe (') as the start of a single-quoted string.

(6)
Command completion, as opposed to code completion, which is beyond the scope of pcomplete.

(7)
Eshell has no string-manipulation expansions because the Elisp library already provides many functions for this.

(8)
E.g., entering just ‘$var’ at the prompt is equivalent to entering the value of var at the prompt.

(9)
ERC provides a similar module facility.




* Straight.el Manual

** Features
:PROPERTIES:
:CUSTOM_ID: features
:END:
- Install Emacs packages listed on [[http://melpa.org/#/][MELPA]],
  [[https://elpa.gnu.org/][GNU ELPA]], or
  [[https://emacsmirror.net/][Emacsmirror]], or provide your own
  recipes.
- Packages are cloned as Git (or other) repositories, not as opaque
  tarballs.
- Make changes to a package simply by editing its source code, no
  additional steps required. Contribute upstream just by pushing your
  changes.
- Powerful interactive workflows (with popups à la Magit) for performing
  bulk maintenance on the Git repositories for your packages.
- Save and load version lockfiles that ensure 100% reproducibility for
  your Emacs configuration. Package state is defined entirely by your
  init-file and (optional) lockfile, with no extra persistent data
  floating around.
- Specify package descriptions using a powerful format based on
  [[https://github.com/melpa/melpa#recipe-format][MELPA recipes]] (with
  a familiar but improved syntax).
- [[https://github.com/jwiegley/use-package][=use-package=]]
  integration.
- Modular: you can install your packages manually and straight.el will
  load them for you. Or you can also have straight.el install your
  packages, while you provide the recipes explicitly. Or straight.el can
  also fetch recipes, if you want. Bulk repository management and
  package updates are also optional.
- Extensible APIs to add new recipe sources and version-control
  backends.
- The cleanest source code you've ever seen.
  [[#comments-and-docstrings][45%]] of =straight.el= is comments and
  docstrings.

Note: =straight.el= is a replacement for =package.el=, *not*
=use-package=. =use-package= can be used with either =package.el= or
=straight.el=.


** Guiding principles
:PROPERTIES:
:CUSTOM_ID: guiding-principles
:END:
- Init-file and version lockfiles as the sole source of truth. No
  persistent state kept elsewhere.
- 100% reproducible package management, accounting for changes in
  packages, recipe repositories, configuration, and the package manager
  itself.
- No support whatsoever for =package.el=.
- Edit packages by editing their code, no extra steps required. Allow
  for manual version control operations.
- Compatibility with MELPA, GNU ELPA, and Emacsmirror.
- Trivial to quickly try out a package without permanently installing
  it.
- Good for reproducing an issue with =emacs -Q=.

** Getting started
:PROPERTIES:
:CUSTOM_ID: getting-started
:END:

#+begin_quote
*Note: =straight.el= supports a minimum version of Emacs 25.1, and works
on macOS, Windows, and most flavors of Linux. You must install
[[https://git-scm.com/][Git]] in order to use =straight.el=.*
#+end_quote

First, place the following bootstrap code in your init-file:

#+begin_html
  <!-- longlines-start -->
#+end_html

#+begin_src emacs-lisp
(defvar bootstrap-version)
(let ((bootstrap-file
       (expand-file-name
        "straight/repos/straight.el/bootstrap.el"
        (or (bound-and-true-p straight-base-dir)
            user-emacs-directory)))
      (bootstrap-version 7))
  (unless (file-exists-p bootstrap-file)
    (with-current-buffer
        (url-retrieve-synchronously
         "https://raw.githubusercontent.com/radian-software/straight.el/develop/install.el"
         'silent 'inhibit-cookies)
      (goto-char (point-max))
      (eval-print-last-sexp)))
  (load bootstrap-file nil 'nomessage))
#+end_src

(If =raw.githubusercontent.com= is blocked by your ISP, try replacing
the URL with =https://radian-software.github.io/straight.el/install.el=.
Or you can clone =straight.el= manually to
=~/.emacs.d/straight/repos/straight.el=.)

#+begin_html
  <!-- longlines-stop -->
#+end_html

Here are some variables you may be interested in (some of them must be
set *before* the bootstrap code runs, if they might affect how
=straight.el= itself is loaded):

- [[#overriding-the-recipe-for-straightel][=straight-repository-branch=]]
  -- to get the latest version of =straight.el= from the =develop=
  branch, rather than the default =master= which is updated less
  frequently but which is ostensibly more stable.
- [[#customizing-when-packages-are-built][=straight-check-for-modifications=]]
  -- to configure an alternate way for =straight.el= to check for
  modifications made to package source code, rather than the default
  (which is 100% reliable, but has a minor cost to startup time).
- [[#integration-with-use-package-1][=straight-use-package-by-default=]]
  -- if you use
  [[https://github.com/jwiegley/use-package][=use-package=]], then this
  makes each =use-package= form also invoke =straight.el= to install the
  package, unless otherwise specified.
- [[#git-backend][=straight-vc-git-default-protocol=]] -- by default,
  =straight.el= clones over HTTPS. If you need packages from private Git
  repositories in your configuration, then you might want to use SSH
  instead.
- =straight-base-dir= -- by default, straight's main directory,
  containing its build files and package repos, is located in
  =user-emacs-directory=. You can change the location of straight's base
  directory via this variable.
- =straight-build-dir= -- by default, the directory in which packages
  are built is located at =straight-base-dir=/build. Changing this
  variable will change the name of that directory and the name of the
  build cache file (unless =straight-build-cache-fixed-name= is
  non-nil).
- =straight-use-version-specific-build-dir= -- if non-nil, use an
  Emacs-version-specific =straight-build-dir= directory to support
  running multiple versions of Emacs against the same
  =user-emacs-directory=. There is a minor performance penalty on
  startup because =straight.el= will not be byte-compiled.

You should remove any code that relates to =package.el=; for example,
references to =package-initialize=, =package-archives=, and (if you're
using [[https://github.com/jwiegley/use-package][=use-package=]])
=:ensure= or =use-package-always-ensure=.

Users of Emacs versions >= 27 will want to add:

#+begin_src emacs-lisp
(setq package-enable-at-startup nil)
#+end_src

to their
[[https://www.gnu.org/software/emacs/manual/html_node/emacs/Early-Init-File.html][early
init-file]] to prevent package.el loading packages prior to their
init-file loading.

While it is technically possible to use both =package.el= and
=straight.el= at the same time, there is no real reason to, and it might
result in oddities like packages getting loaded more than once.

**** Debugging
:PROPERTIES:
:CUSTOM_ID: debugging
:END:
- Sometimes, in a corporate environment, =url-retrieve-synchronously=
  may not work and =straight.el= will be unable to download the
  installation script mentioned in the bootstrap snippet. In this case,
  you may simply clone this repository into
  =~/.emacs.d/straight/repos/straight.el= and check out your desired
  revision/branch. The installation script is just a more convenient way
  of doing that automatically when necessary (and looking up the correct
  revision of =straight.el= in your lockfile, if any).

- On macOS, you may receive an error:

  #+begin_example
  Could not create connection to raw.githubusercontent.com:443
  #+end_example

  This is likely because you are using an ancient version of Emacs which
  has a broken TLS configuration. Upgrade with =brew upgrade emacs=.

*** Install packages
:PROPERTIES:
:CUSTOM_ID: install-packages
:END:
Out of the box, you can install any package listed on
[[http://melpa.org/#/][MELPA]], [[https://elpa.gnu.org/][GNU ELPA]], or
[[https://emacsmirror.net/][Emacsmirror]], which is to say any package
in existence. (Although MELPA is used as a package listing, packages are
installed by cloning their Git repositories rather than by downloading
tarballs like =package.el= does.) To install a package temporarily
(until you restart Emacs), run =M-x straight-use-package= and select the
package you want. To install a package permanently, place a call to
=straight-use-package= in your init-file, like:

#+begin_src emacs-lisp
(straight-use-package 'el-patch)
#+end_src

Note that installing a package will activate all of its autoloads, but
it will not actually =require= the features provided by the package.
This means that you might need to use =require= or =autoload= for some
antiquated packages that do not properly declare their autoloads.

To learn more, see the documentation on
[[#installing-packages-programmatically][the package lifecycle]].

*** But what about my fork of (obscure .el package)?
:PROPERTIES:
:CUSTOM_ID: but-what-about-my-fork-of-obscure-.el-package
:END:
Instead of passing just a package name to =straight-use-package=, you
can pass a list ("recipe"). You can see the default recipe for any given
package by running =M-x straight-get-recipe=. For example, the recipe
for =el-patch= is:

#+begin_src emacs-lisp
(el-patch :type git :host github :repo "radian-software/el-patch")
#+end_src

So, if you have forked =el-patch= and you want to use your fork instead
of the upstream, do:

#+begin_src emacs-lisp
(straight-use-package
 '(el-patch :type git :host github :repo "your-name/el-patch"))
#+end_src

In fact, =straight.el= has explicit support for using a forked package,
since this is so common:

#+begin_src emacs-lisp
(straight-use-package
 '(el-patch :type git :host github :repo "radian-software/el-patch"
            :fork (:host github
                   :repo "your-name/el-patch")))
#+end_src

In the above, =:type git= may be omitted if you leave
=straight-default-vc= at its default value of =git=. Parts of the
=:fork= keyword may be omitted as well. One common case is when your
fork is on the same host and has the same name as the upstream
repository. In this case, assuming =straight-host-usernames= is set,
specifying a fork is as simple as:

#+begin_src emacs-lisp
(straight-use-package
 '(el-patch :type git :host github :repo "radian-software/el-patch"
            :fork t))
#+end_src

Note that =straight.el= doesn't do any Git operations during startup
unless it needs to clone a package from scratch. This is for
performance. You can explicitly request for =straight.el= to fix up the
Git configuration after you change a package recipe, e.g. to add a fork.
See [[#automatic-repository-management][Automatic repository
management]] below.

To learn more, see the documentation on [[#the-recipe-format][the recipe
format]] and [[#git-backend][the Git backend]].

*** Integration with =use-package=
:PROPERTIES:
:CUSTOM_ID: integration-with-use-package
:END:
[[https://github.com/jwiegley/use-package][=use-package=]] is a macro
that provides convenient syntactic sugar for many common tasks related
to installing and configuring Emacs packages. Of course, it does not
actually install the packages, but instead defers to a package manager,
like =straight.el= (which comes with =use-package= integration by
default).

To use =use-package=, first install it with =straight.el=:

#+begin_src emacs-lisp
(straight-use-package 'use-package)
#+end_src

Now =use-package= will use =straight.el= to automatically install
missing packages if you provide =:straight t=:

#+begin_src emacs-lisp
(use-package el-patch
  :straight t)
#+end_src

You can still provide a custom recipe for the package:

#+begin_src emacs-lisp
(use-package el-patch
  :straight (el-patch :type git :host github :repo "radian-software/el-patch"
                      :fork (:host github
                             :repo "your-name/el-patch")))
#+end_src

The =:straight= keyword accepts backquoted forms. This makes it possible
to dynamically compute part of the recipe:

#+begin_src emacs-lisp
(use-package el-patch
  :straight `(el-patch :type git
                       :repo ,(alist-get 'el-patch my-package-urls)))
#+end_src

Specifying =:straight t= is unnecessary if you set
=straight-use-package-by-default= to a non-nil value. (Note that the
variable =use-package-always-ensure= is associated with =package.el=,
and you should not use it with =straight.el=.)

To learn more, see the documentation on
[[#integration-with-use-package-1][=straight.el='s =use-package=
integration]].

*** Edit packages locally
:PROPERTIES:
:CUSTOM_ID: edit-packages-locally
:END:
One of the biggest strengths of =straight.el= is that editing packages
locally is trivial. You literally just edit the files (=find-function=
and friends all work as you would expect). Packages will be
automatically rebuilt if necessary when Emacs next starts up.

You can even commit your changes and push or pull to various remotes
using Git. You have complete control over your packages' Git
repositories.

To learn more, see the documentation on
[[#installing-packages-programmatically][the package lifecycle]].

*** Automatic repository management
:PROPERTIES:
:CUSTOM_ID: automatic-repository-management
:END:
While being able to make arbitrary changes to your packages is very
powerful, it can also get tiring to keep track of the all those changes.
For this reason, =straight.el= provides a suite of powerful interactive
workflows to perform bulk operations on your packages.

- To restore each package to its canonical state (a clean working
  directory with the main branch checked out, and the remotes set
  correctly), run =M-x straight-normalize-package= or
  =M-x   straight-normalize-all=.

- To fetch from each package's configured remote, run
  =M-x   straight-fetch-package-and-deps= or =M-x straight-fetch-all=;
  to also fetch from the upstream for forked packages, supply a prefix
  argument.

- To merge changes from each package's configured remote, run
  =M-x   straight-merge-package-and-deps= or =M-x straight-merge-all=;
  to also merge from the upstream for forked packages, supply a prefix
  argument.

- To push all local changes to each package's configured remote, run
  =M-x straight-push-package= or =M-x straight-push-all=.

All of these commands are highly interactive and ask you before making
any changes. At any point, you can stop and perform manual operations
with Magit or other tools in a recursive edit.

To learn more, see the documentation on
[[#version-control-operations][bulk repository management]].

*** Configuration reproducibility
:PROPERTIES:
:CUSTOM_ID: configuration-reproducibility
:END:
To save the currently checked out revisions of all of your packages, run
=M-x straight-freeze-versions=. The resulting file
(=~/.emacs.d/straight/versions/default.el=), together with your
init-file, perfectly define your package configuration. Keep your
version lockfile checked into version control; when you install your
Emacs configuration on another machine, the versions of packages
specified in your lockfile will automatically be checked out after the
packages are installed. You can manually revert all packages to the
revisions specified in the lockfile by running
=M-x straight-thaw-versions=.

To learn more, see the documentation on [[#lockfile-management][version
lockfiles]].



** Conceptual overview
:PROPERTIES:
:CUSTOM_ID: conceptual-overview
:END:
This section describes, at a high level, how the different mechanisms in
=straight.el= play together. This illustrates how =straight.el= manages
to accomplish all of its [[#guiding-principles][guiding principles]].

*** TL;DR
:PROPERTIES:
:CUSTOM_ID: tldr
:END:
=straight.el= operates by cloning Git repositories and then symlinking
files into Emacs' load path. The collection of symlinked files
constitutes the package, which is defined by its recipe. The recipe also
describes which local repository to link the files from, and how to
clone that repository, if it is absent.

When you call =straight-use-package=, the recipe you provide is
registered with =straight.el= for future reference. Then the package's
repository is cloned if it is absent, the package is rebuilt if its
files have changed since the last build (as determined by =find(1)=),
and its autoloads are evaluated.

You can also provide only a package name, in which case the recipe will
be looked up in one of several configurable recipe repositories, which
are just packages themselves (albeit with the build step disabled).

=straight.el= determines which packages are installed solely by how and
when =straight-use-package= is invoked in your init-file.

*** What is a package?
:PROPERTIES:
:CUSTOM_ID: what-is-a-package
:END:
A /package/ is a collection of Emacs Lisp (and possibly other) files.
The most common case is just a single =.el= file, but some packages have
many =.el= files, and some even have a directory structure.

Note that a package is defined only as a collection of files. It doesn't
necessarily correspond to a Git repository, or an entry on MELPA, or
anything like that. Frequently there is a relationship between all of
these concepts, but that relationship does not always have to be direct
or one-to-one.

A package also has a name, which must be unique. This is the name that
is used for the folder holding the package's files. It is frequently the
same as the name of a Git repository, or an entry on MELPA, but again
this does not have to be the case.

*** Where do packages come from?
:PROPERTIES:
:CUSTOM_ID: where-do-packages-come-from
:END:
If you really wanted all of your packages to be unambiguously defined,
you could just copy and paste all of their files into version control.
But that would defeat the purpose of using a package manager like
=straight.el=. In =straight.el=, packages are defined by two sources of
information:

- a /local repository/
- a /build recipe/

The local repository is just a directory containing some files. Of
course, it also has a name, which may or may not be the same as the
package's name. Frequently, the local repository is also a Git
repository, but this is not necessary.

The build recipe is not a literal data structure. It is a concept that
represents a certain subset of the package's recipe. Specifically, the
=:files=, =:local-repo=, and =:build= keywords.

To transform this /information/ into an actual package that Emacs can
load, =straight.el= /builds/ the package. This means that some symbolic
links are created in the package's directory that point back into the
local repository's directory. Exactly how these symlinks are created is
determined by the =:files= directive, and which local repository the
symlinks point to is determined by the =:local-repo= directive.

After the symlinks are created, the resulting files are byte-compiled,
and their autoloads are generated and written into a file in the
package's directory.

If =:build nil= is specified, however, this entire process is skipped.
This mechanism is used for recipe repositories.

*** What does this look like on disk?
:PROPERTIES:
:CUSTOM_ID: what-does-this-look-like-on-disk
:END:
The local repositories are kept in =~/.emacs.d/straight/repos=, and the
built packages are kept in =~/.emacs.d/straight/build=. If you have
initialized =straight.el= and loaded package =el-patch=, then your
=~/.emacs.d/straight= directory will look roughly like this (some
irrelevant details have been omitted for pedagogical purposes):

#+begin_html
  <!-- longlines-start -->
#+end_html

#+begin_example
straight
├── build
│   ├── el-patch
│   │   ├── el-patch-autoloads.el
│   │   ├── el-patch.el -> ~/.emacs.d/straight/repos/el-patch/el-patch.el
│   │   └── el-patch.elc
│   └── straight
│       ├── straight-autoloads.el
│       ├── straight.el -> ~/.emacs.d/straight/repos/straight.el/straight.el
│       └── straight.elc
└── repos
    ├── el-patch
    │   ├── CHANGELOG.md
    │   ├── LICENSE.md
    │   ├── README.md
    │   └── el-patch.el
    └── straight.el
        ├── LICENSE.md
        ├── Makefile
        ├── README.md
        ├── bootstrap.el
        ├── install.el
        └── straight.el
#+end_example

#+begin_html
  <!-- longlines-stop -->
#+end_html

As you can see, the package names are =el-patch= and =straight=. While
=el-patch= is built from a local repository of the same name, =straight=
is built from a local repository by the name =straight.el=. Also note
that only =.el= files are symlinked, since only they are relevant to
Emacs.

*** Where do repositories come from?
:PROPERTIES:
:CUSTOM_ID: where-do-repositories-come-from
:END:
Local repositories provide a way to define packages without specifying
the contents of all of their files explicitly. But that's not helpful
without a higher-level way to define local repositories without
specifying the contents of all of /their/ files. In =straight.el=, local
repositories are defined by two sources of information:

- a /fetch recipe/
- the /version lockfiles/

The fetch recipe is, like the build recipe, a concept representing a
certain subset of the package's overall recipe. The situation is more
interesting here because =straight.el= supports multiple version-control
backends. The version-control backend specified by the fetch recipe is
determined by the =:type= directive (which defaults to
=straight-default-vc=). Each version-control backend then accepts some
set of additional directives. For example, the =git= backend accepts:

- =:repo=
- =:host=
- =:branch=
- =:nonrecursive=
- =:fork=
- =:protocol=

If a local repository is not present, then its fetch recipe describes
how to obtain it. This is done using the =straight-vc-clone= function,
which delegates to one of the backend implementations of the =clone=
operation, according to =:type=. (The option =:type built-in= is a
special case that results in all version-control operations for the
package being ignored. You can also use =:type nil= to accomplish the
same, but with the difference that the package is still loaded from its
specified =:local-repo=.)

However, even with a particular repository source specified, there is
still the question of which version of the repository to use. This is
where the version lockfiles come in. When a local repository is cloned,
the version lockfiles are searched to see if there is a particular
commit specified for that local repository's name. If so, that commit is
checked out. (For the =git= backend, commits are 40-character strings
representing SHA-1 hashes, but the representation of a commit identifier
could be different across different backends.)

The =straight-freeze-versions= and =straight-thaw-versions= methods also
use backend-delegating methods; in this case, they are
=straight-vc-get-commit= and =straight-vc-check-out-commit=.

The fetch recipe and version lockfiles, together with the configuration
options for =straight.el=, precisely define the state of a local
repository. Of course, you may make any changes you want to the local
repository. But this information defines a "canonical" state that you
may revert to at any time.

When this information is combined with the build recipe, =straight.el=
is able to construct canonical, universal versions of your Emacs
packages that will be the same everywhere and forever.

Note that you do not have to provide fetch recipes or version lockfiles.
You may manage your local repositories manually, if you wish, although
this has obvious disadvantages in terms of repeatability and
maintainability.

*** What does it mean to load a package?
:PROPERTIES:
:CUSTOM_ID: what-does-it-mean-to-load-a-package
:END:
A prerequisite to loading a package is making sure the package has been
built. After that is done, loading the package means adding its
directory to the load path and evaluating its autoloads file.

Adding the directory to the load path means that you can use =require=
to load the package's files. Note that =straight.el= does not do this
for you, since loading packages immediately is usually not necessary and
it immensely slows down Emacs startup.

Evaluating the autoloads file means that calling the functions that are
defined in the autoloads file will automatically =require= the files
that define those functions. All modern packages define their functions
in autoloads and are designed to be loaded on-demand when those
functions are called. Antiquated packages may need you to explicitly
define autoloads, or to just =require= the package right away.

*** Where do recipes come from?
:PROPERTIES:
:CUSTOM_ID: where-do-recipes-come-from
:END:
=straight-use-package= does not require an actual recipe. You can just
give it a package name, and it will look up the recipe. This is done
using /recipe repositories/. Recipe repositories are set up as a
swappable backend system, much like the version-control backend system.

A recipe repository consists of four parts:

- a fetch recipe for the local repository (this will typically include
  =:build nil=, since recipe repositories usually do not need to be
  built)
- a function that, provided the local repository is already available,
  returns a list of all packages that have recipes in the recipe
  repository
- a function that, given a package name, returns the recipe for that
  package, or nil if the recipe repository does not provide a recipe for
  the package
- an entry in =straight-recipe-repositories= indicating that the recipe
  provided actually corresponds to a recipe repository (otherwise it
  would just be a regular package)

Note that recipe repositories are implemented as regular packages! This
means that all the usual package management operations work on them as
well. It also means that you use =straight-use-package= to register them
(although typically you will provide arguments to =straight-use-package=
so that the recipe repository is only registered, and not cloned until
it is needed; see [[#what-happens-when-i-call-straight-use-package][the
section on =straight-use-package=]]).

If you give =straight-use-package= just a package name, then each recipe
repository in =straight-recipe-repositories= is checked for a recipe for
that package. Once one is found, it is used. Otherwise, an error is
signaled (unless the package is built-in to Emacs, according to
=package.el=).

Note that =straight.el= uses its own recipe format which is similar, but
not identical, to the one used by MELPA (see [[#the-recipe-format][the
section on the recipe format]] for information on the differences). The
recipe repository backends abstract over the formatting differences in
different recipe sources to translate recipes into the uniform format
used by =straight.el=. When you run =M-x straight-get-recipe=, the
translated recipe is what is returned.

*** What happens when I call =straight-use-package=?
:PROPERTIES:
:CUSTOM_ID: what-happens-when-i-call-straight-use-package
:END:
There are three actions that =straight-use-package= can take:

- Register a package's recipe with =straight.el=.
- Clone a package's local repository, if it is missing.
- Build a package, if it has been changed since the last time it was
  built, and load it.

These actions must be performed in order. Depending on the arguments you
pass to =straight-use-package=, one, two, or all three may be performed.

The normal case is to do all three. The fetch recipe is only required if
the local repository is actually missing, but the build recipe is always
required.

Deferred installation can be accomplished by telling
=straight-use-package= to stop if the local repository is not already
available. The deferred installation can be triggered by invoking
=straight-use-package= again, but telling it to go ahead and clone the
repository (this is the default behavior). Because
=straight-use-package= already registered the package's recipe the first
time, you don't have to provide it again.

In some extraordinary circumstances (such as when =straight.el= is
bootstrapping its own installation), it may be desirable to clone a
package's local repository if it is missing, but to stop before building
and loading the package. This can also be done by
=straight-use-package=.

*** What does it mean to register a package?
:PROPERTIES:
:CUSTOM_ID: what-does-it-mean-to-register-a-package
:END:
Package registration is the first action taken by
=straight-use-package=, before building and cloning. First, if only a
package name was provided to =straight-use-package=, a recipe is
obtained from the configured recipe repositories. Next, the resulting
recipe is recorded in various caches.

This is important, since it allows for several things to happen:

- if you later want to perform another operation on the package using
  =straight.el=, you do not need to provide the recipe again
- if you use a custom recipe for Package A, and Package B requires
  Package A as a dependency, your custom recipe is remembered and
  re-used when Package A is used as a dependency, to avoid conflicts.
- when multiple packages are built from the same local repository, and
  you have specified a custom fetch recipe for one of those packages,
  =straight.el= can intelligently merge that fetch recipe into the
  automatically retrieved recipes of dependencies, in order to avoid
  conflicts.
- =straight.el= knows which packages you have installed, if you want to
  perform interactive operations on them.
- if you accidentally provide two different recipes for the same
  package, =straight.el= can issue a helpful warning, since this may
  lead to surprising behavior.

*** How does =straight.el= know when to rebuild packages?
:PROPERTIES:
:CUSTOM_ID: how-does-straight.el-know-when-to-rebuild-packages
:END:
When you request for =straight.el= to load a package (using
=straight-use-package=), it first checks if the package needs to be
rebuilt. This means that some of the files in its local repository have
been modified since the last time the package was built. =straight.el=
uses an optimized =find(1)= command to check for package modifications,
and it uses some caching mechanisms to perform bulk =find(1)= operations
on multiple packages, to speed up these checks (although it never
performs optimizations that may result in erroneous behavior).

This check occurs during Emacs init, when your init-file makes calls to
=straight-use-package=. You may notice a significant delay on the first
=straight-use-package= call, because this is when =straight.el= performs
a bulk =find(1)= call and caches the results for later usage (this
speeds up init considerably). The total delay is likely to be on the
order of 100ms for a double-digit number of packages.

The rebuild detection system is what allows for you to make changes to
packages whenever you would like, without performing any additional
operations.

(Packages are also rebuilt when their recipes change, of course.)

*** How does =straight.el= know what packages are installed?
:PROPERTIES:
:CUSTOM_ID: how-does-straight.el-know-what-packages-are-installed
:END:
=straight.el= does not require you to declare a central list of packages
anywhere, like Cask does. Instead, it determines what packages are to be
loaded implicitly, by your invocations of =straight-use-package= during
Emacs initialization. Furthermore, =straight.el= allows you to install
packages after initialization using =M-x straight-use-package= (or even
by evaluating =straight-use-package= forms). However, =straight.el=
still provides advanced features such as bulk package management and
version locking. This creates some interesting challenges which other
package managers do not have to deal with.

=straight.el= solves these problems using a concept called
/transactions/. The operation of the transaction system is mostly
transparent to the user, at least in recent versions of =straight.el=.
Basically, it provides a way for =straight.el= to keep track of what
happens within a single user operation (e.g. evaluate a buffer of
=straight-use-package= calls, or load the init-file).

=straight.el= uses the transaction system to keep track of what packages
you request in your init-file. If you invoke =straight-use-package=
interactively, then this invalidates that information, since you have
now requested a package that is not in your init-file. For this reason,
if you have invoked =straight-use-package= interactively, running
=M-x straight-freeze-versions= will prompt you to first reload your
init-file.

*Note: reloading your init-file must have the effect of running all of
the same =straight.el=-related functions again. For example, if you
bootstrap =straight.el= in a sub-file that you only =require= instead of
=load=, then the reloading functionality will not work correctly and you
may receive the message
=Caches are still outdated; something is seriously wrong=. See
[[https://github.com/radian-software/straight.el/issues/437][#437]] for
discussion.*


** Comparison to other package managers
:PROPERTIES:
:CUSTOM_ID: comparison-to-other-package-managers
:END:
(Disclaimer: while I try to be as objective and comprehensive as
possible here, I'm obviously biased. Please submit corrections if I have
unfairly disparaged your favorite package manager!)

There are many package managers for Emacs, ranging from simple scripts
to download files from EmacsWiki to full-featured package management
solutions like =straight.el=. Here are the most feature-rich
alternatives to =straight.el=:

- [[https://www.gnu.org/software/emacs/manual/html_node/emacs/Packages.html][=package.el=]]:
  de facto standard, bundled with Emacs.
- =package.el=. Essentially a local [[http://melpa.org/#/][MELPA]].
- =Cask= file; can be used for project management or an Emacs
  configuration.
- can pull packages from (=package.el=, every known VCS, distro package
  managers, =go get=(!!)).
- relying on [[https://emacsmirror.net/][Emacsmirror]].
- "Screw package managers! I'll just handle it all myself!"

*** TL;DR
:PROPERTIES:
:CUSTOM_ID: tldr-1
:END:
Here is a summary of the main differences in philosophy between the
package managers:

- Use =package.el= if you want package management to be as easy as
  possible, and do not much care for installing packages from specific
  sources, keeping track of their versions, or doing local development
  on them.
- Use Quelpa if you like =package.el= but really wish you could specify
  the sources of your packages.
- Use Cask if you like =package.el= but wish it came with some project
  management tools, as well.
- Use el-get if you want to easily install packages from as many
  different sources as possible.
- Use Borg if you like a more lightweight approach to package management
  that leverages existing solutions, if contributing changes to packages
  upstream is important to you, and if using Git submodules isn't a
  deal-breaker.
- Use the manual approach if you need to contribute changes to a package
  that is versioned in something other than Git.
- Use =straight.el= if you like reproducibility in your Emacs
  configuration, you regularly contribute changes to packages upstream,
  or you are writing an Emacs configuration to be used by others.

And here is a brief list of the main reasons you might not want to use
=straight.el=:

- =straight.el= is largely unusable if you do not have Git installed,
  although it is still possible to use the package-building features if
  you manage your repositories manually (you also cannot use the magic
  bootstrap snippet, in that case). If you don't want to install Git,
  you'll have to use =package.el= or take the manual approach.
- =straight.el= is not built in to Emacs. If you want something that
  will work right out of the box, you're stuck with =package.el= or the
  manual approach.
- =straight.el= takes a minute or two to update all your packages, since
  it does not rely on a centralized server. If you want quick update
  checking, you'll have to use =package.el=.
- =straight.el= does not provide any user interface for package
  management. For that, you'll have to use =package.el=, el-get, Cask,
  or Borg (which expects you to use
  [[https://github.com/emacscollective/epkg][=epkg=]] for browsing
  packages).
- =straight.el= does not currently support using only stable versions of
  packages (i.e. tagged revisions), although this is a
  [[https://github.com/radian-software/straight.el/issues/31][planned
  feature]]. If this is important to you, you probably want to go with
  =package.el= (with GNU ELPA and MELPA Stable), Cask, or Quelpa.
- If you don't like having to modify your init-file to do package
  management, then =straight.el= is absolutely not for you. You want
  =package.el=, Quelpa, el-get, or Borg.
- If you really want to contribute changes to packages that are not
  versioned in Git, then =straight.el= will not help you. You'll have to
  manage the package's repository manually. Unfortunately, there is no
  existing package manager that supports both non-Git version-control
  systems and contributing changes upstream. You'll have to go with the
  manual approach.
- =straight.el= does not provide project management tools. It is a
  package manager. If you want project management tools, check out Cask.
- =straight.el= is quite new and moving fast. Things might break. The
  other package managers can generally be ranked as follows, from most
  active to least active: el-get, Quelpa, Borg, Cask, =package.el=
  (glacial).

*** Comparison to =package.el=
:PROPERTIES:
:CUSTOM_ID: comparison-to-package.el
:END:
- =package.el= downloads pre-built packages from central servers using a
  special (undocumented?) HTTP protocol, while =straight.el= clones Git
  (or other) repositories and builds packages locally.

**** Advantages of =straight.el=
:PROPERTIES:
:CUSTOM_ID: advantages-of-straight.el
:END:
- =straight.el= allows you to install a package from any branch of any
  Git repository. =package.el= only allows you to install a package from
  a =package.el=-compliant central server.
- =straight.el= allows you to check out any Git revision of any package.
  =package.el= only allows you to install the latest version, and there
  is no way to downgrade.
- =straight.el= supports Emacsmirror, while =package.el= does not.
- =straight.el= uses your init-file as the sole source of truth for
  package operations. =package.el= loads every package you ever
  installed at startup, even if some of those packages are no longer
  referenced by your init-file.
- =straight.el= supports 100% reproducibility for your Emacs packages
  with version lockfiles. =package.el= cannot provide reproducibility
  for the set of packages installed, the central servers they were
  installed from, or the versions in use.
- =straight.el= allows you to make arbitrary changes to your packages
  locally. While it is possible to make local changes to =package.el=
  packages, these changes cannot be version-controlled and they will be
  silently overwritten whenever =package.el= performs an update.
- =straight.el= allows you to perform arbitrary version-control
  operations on your package's Git repositories, including contributing
  changes upstream. =straight.el= has explicit support for specifying
  both an upstream and a fork for a package. Contributing changes
  upstream with =package.el= is impossible.
- =straight.el= is designed with =emacs -Q= bug reports in mind.
  =package.el= is unsuitable for minimal bug reproductions, since it
  automatically loads all of your packages on any package operation,
  even in =emacs -Q=.
- =straight.el= operates quietly when all is going well. =package.el=
  displays all messages, errors, and warnings that come from
  byte-compilation and autoload generation.
- =straight.el= considers modifying the user's init-file extremely
  uncouth. =package.el= aggressively inserts (via Customize)
  auto-generated code setting =package-selected-packages= into the
  init-file whenever a package is installed. Furthermore, =package.el=
  has a history of impolite treatment of user configuration, which I
  think says some things about the design: until Emacs 27.1 (when
  [[https://git.savannah.gnu.org/cgit/emacs.git/commit/?id=24acb31c04b4048b85311d794e600ecd7ce60d3b][my
  patch to fix this issue]] was adopted after around 300 emails' worth
  of squabbling on emacs-devel), it also inserted a call to the
  =package-initialize= function into the init-file if it was not already
  present, with the officially recommended workaround "comment it out if
  you don't want it, but don't get rid of it".
- =straight.el= has a profile system that allows users of someone else's
  Emacs configuration to manage an additional subset of packages, or to
  override upstream package configuration, without forking the upstream.
  =package.el= has no such concept.
- =straight.el= is developed openly on GitHub, using a modern
  [[https://github.com/radian-software/straight.el/issues][issue
  tracker]] and continuous integration from GitHub Actions. It welcomes
  contributions of any type. =straight.el= is licensed under the
  permissive MIT license and does not require a copyright assignment.
  =straight.el= is developed actively and has explicit support for
  installing development versions of itself, as well as for contributing
  upstream changes. =package.el= is maintained as a part of Emacs core,
  meaning that the contribution process is poorly documented and
  discouraging. Releases of =package.el= coincide with releases of
  Emacs, which are infrequent and inflexible. There is no issue tracker
  specifically for =package.el=, only the Emacs bug tracker and the
  emacs-devel mailing list. Contributing to =package.el= requires a
  poorly-documented, cumbersome copyright assignment process and is done
  by submitting patches to an antiquated mailing list, unsupported by
  modern code review tooling or continuous integration.

**** Advantages of =package.el=
:PROPERTIES:
:CUSTOM_ID: advantages-of-package.el
:END:
- =package.el= does not require that you have Git installed, since the
  central server deals with where the packages originally came from.
  =straight.el= cannot be used at all without Git.
- =package.el= is built in to Emacs and does not require additional
  configuration to get started with. =straight.el= requires the use of a
  10-line bootstrap snippet in your init-file.
- =package.el= can perform bulk package updates more quickly since it
  relies on central servers.
- =package.el= has a user interface for package management that also
  displays package metadata. =straight.el= has no user interface for
  package management; any UI is provided by the user's =completing-read=
  framework.
- =package.el= does not require you to touch your init-file to install
  packages, while =straight.el= absolutely refuses to permanently
  install a package without an explicit reference to it in your
  init-file (although this may be considered an advantage, depending on
  your perspective).
- Using MELPA Stable, =package.el= can install only stable versions of
  packages. By default, =package.el= also installs only stable versions
  of packages from GNU ELPA. These modes of operation are unsupported by
  =straight.el= at this time, although this is a
  [[https://github.com/radian-software/straight.el/issues/31][planned
  feature]].

**** Additional notes
:PROPERTIES:
:CUSTOM_ID: additional-notes
:END:
- =package.el= and =straight.el= usually take approximately the same
  time to install packages, despite the fact that =straight.el= is
  cloning entire Git repositories. This is because network latency and
  byte-compilation are the dominant factors.
- Some =package.el= servers build packages from non-Git upstreams.
  =package.el= can install these packages, while =straight.el= cannot.
  However, since =package.el= has no version-control support, this is
  more or less equivalent to installing those packages from the
  [[https://emacsmirror.net/][Emacsmirror]], which =straight.el= can do
  by default.

*** Comparison to Quelpa
:PROPERTIES:
:CUSTOM_ID: comparison-to-quelpa
:END:
- Quelpa allows for fetching packages from arbitrary sources and
  building them into a format that can be installed by =package.el=.
  =straight.el= has a philosophy which is fundamentally incompatible
  with =package.el=, and non-compatibility with =package.el= is one of
  its design goals.

**** Advantages of =straight.el=
:PROPERTIES:
:CUSTOM_ID: advantages-of-straight.el-1
:END:
- =straight.el= has out-of-the-box compatibility with MELPA, GNU ELPA,
  and Emacsmirror, while Quelpa only has support for MELPA. To use GNU
  ELPA, you must drop down to =package.el=.
  [[https://emacsmirror.net/][Emacsmirror]] is not supported by default,
  although it is easy to specify an Emacsmirror repository in a recipe.
  While Quelpa allows you to specify custom recipe folders, it does not
  have support for cloning these folders automatically from version
  control, nor for generating the recipes in any way other than copying
  them literally from files. =straight.el= allows you full flexibility
  in this regard.
- =straight.el= has integrated support for selecting particular Git
  revisions of packages. This process is more manual in Quelpa, as it
  requires placing the commit hash into the recipe, which disables
  updates.
- =straight.el= uses your init-file as the sole source of truth for
  package operations. Since Quelpa is based on =package.el=, it also
  loads every package you ever installed at startup, even if those
  packages are no longer referenced by your init-file. Furthermore,
  there is an additional caching layer, so that deleting a package from
  the =package.el= interface and removing it from your init-file still
  does not actually delete it.
- =straight.el= supports 100% reproducibility for your Emacs packages
  with version lockfiles. Quelpa can theoretically provide some measure
  of reproducibility, but this requires significant manual effort since
  all packages are not associated with specific revisions by default,
  nor is the revision of MELPA saved anywhere.
- =straight.el= allows you to make arbitrary changes to your packages
  locally. While it is possible to make local changes to Quelpa
  packages, there are two places to do so: the built package, which is
  the default destination of =find-function=, and the original
  repository. Changes to the former are not version-controlled and will
  be silently overwritten by =package.el= operations, while changes to
  the latter will be silently overwritten by Quelpa operations.
- =straight.el= has explicit support for configuring both an upstream
  repository and a fork for the same package. Quelpa does not have such
  a concept.
- =straight.el= allows you complete control over how your repositories
  are managed, and the default behavior is to draw all packages
  versioned in a single repository from a single copy of that
  repository. Quelpa is hardcoded to require a separate repository for
  each package, so that installing Magit requires three copies of the
  Magit repository.
- =straight.el= builds packages using symlinks, meaning that
  =find-function= works as expected. Quelpa builds packages by copying,
  a feature inherited from MELPA. This means that =find-function= brings
  you to the built package, instead of the actual repository, which is
  not version-controlled and will be overwritten whenever =package.el=
  performs an update.
- =straight.el= allows you to perform arbitrary version-control
  operations on your package's Git repositories. Quelpa allows this, but
  all local changes will be silently overridden whenever Quelpa performs
  an update.
- =straight.el= is designed with =emacs -Q= bug reports in mind. Since
  Quelpa is based on =package.el=, it is also unsuitable for minimal bug
  reproductions, since it automatically loads all of your packages on
  any package operation, even in =emacs -Q=.
- =straight.el= operates quietly when all is going well. Since Quelpa is
  based on =package.el=, it displays all messages, errors, and warnings
  that come from byte-compilation and autoload generation. It also
  displays additional messages while cloning Git repositories,
  downloading files, and building packages from their repositories into
  =package.el= format.
- =straight.el= does not modify your init-file. Since Quelpa is based on
  =package.el=, it inherits the behavior of aggressively inserting a
  call to =package-initialize= into your init-file on any package
  management operation.
- =straight.el= has a profile system that allows users of someone else's
  Emacs configuration to manage an additional subset of packages, or to
  override upstream package configuration, without forking the upstream.
  Quelpa has no such concept.

**** Advantages of Quelpa
:PROPERTIES:
:CUSTOM_ID: advantages-of-quelpa
:END:
- Quelpa supports all the version-control systems supported by MELPA,
  which is to say almost every commonly and uncommonly used VCS.
  =straight.el= only supports Git, although it is designed to support
  other version-control backends.
- Quelpa allows for installing only stable versions of packages, from
  any source. This mode of operation is unsupported by =straight.el=,
  although it is a
  [[https://github.com/radian-software/straight.el/issues/31][planned
  feature]].
- Since Quelpa is based on =package.el=, it inherits a user interface
  for package management that also displays package metadata.
  =straight.el= has no such interface.

**** Additional notes
:PROPERTIES:
:CUSTOM_ID: additional-notes-1
:END:
- =straight.el= and Quelpa both allow you to manage your package's local
  repositories manually, if you wish.
- In principle, =straight.el= and Quelpa have identical package
  installation times, since they are performing the same operations. In
  practice, Quelpa is slightly slower since it builds packages by
  copying rather than symlinking, and it clones multiple copies of the
  same Git repository when multiple packages are built from it.
- =straight.el= encourages you to keep a tight handle on your package
  versions by default. Quelpa encourages you to stick to the latest
  versions of your packages, and to upgrade them automatically.

*** Comparison to Cask
:PROPERTIES:
:CUSTOM_ID: comparison-to-cask
:END:
I have not used Cask extensively, so please feel especially free to
offer corrections for this section.

- Cask installs packages using the =package.el= protocol, based on a
  =Cask= file written in the Cask DSL. =straight.el= eschews
  =package.el= entirely, and clones packages from source based on how
  you invoke =straight-use-package= in your init-file.
- Cask focuses more on being a build manager, like Maven or Leiningen,
  while =straight.el= focuses /exclusively/ on being a package manager.

**** Advantages of =straight.el=
:PROPERTIES:
:CUSTOM_ID: advantages-of-straight.el-2
:END:
- =straight.el= has out-of-the-box compatibility with Emacsmirror, while
  Cask only supports =package.el=-compliant repositories. However, it is
  easy to specify an Emacsmirror repository in a recipe. Cask does not
  support custom package sources. =straight.el= supports MELPA, GNU
  ELPA, and Emacsmirror, and allows you to add any other sources you
  would like.
- =straight.el= has integrated support for selecting particular Git
  revisions of packages. This process is more manual in Cask, as it
  requires placing the commit hash into the recipe, which disables
  updates.
- =straight.el= uses your init-file as the sole source of truth for
  package operations. Since Cask is based on =package.el=, it loads
  every package you ever installed at startup, even if some of those
  packages are no longer referenced by your =Cask= file.
- =straight.el= determines your package management configuration
  implicitly by detecting how you call =straight-use-package= in your
  init-file and making the appropriate changes immediately. Cask
  requires manual intervention (for example, issuing a =cask install=
  command when you have updated your =Cask= file). However, both
  =straight.el= and Cask can be considered declarative package managers.
- =straight.el= supports 100% reproducibility for your Emacs packages
  with version lockfiles. Cask can theoretically provide some measure of
  reproducibility, but this requires significant manual effort since all
  packages are not associated with specific revisions by default, nor is
  the revision of Cask saved anywhere.
- =straight.el= allows you to make arbitrary changes to your packages
  locally. While it is possible to make local changes to Cask packages,
  these will not be version-controlled and they will be silently
  overwritten or shadowed when Cask performs an update.
- =straight.el= allows you to perform arbitrary version-control
  operations on your package's Git repositories, including contributing
  changes upstream. =straight.el= has explicit support for specifying
  both an upstream and a fork for a package. Contributing changes
  upstream with Cask is impossible.
- =straight.el= is designed with =emacs -Q= bug reports in mind. Cask
  appears to be unsuitable for minimal bug reproductions, since there
  does not appear to be a straightforward way to load a single package,
  without loading all other packages configured in your =Cask= file.
- =straight.el= operates quietly when all is going well. Since Cask is
  based on =package.el=, it displays all messages, errors, and warnings
  that come from byte-compilation and autoload generation.
- =straight.el= has a profile system that allows users of someone else's
  Emacs configuration to manage an additional subset of packages, or to
  override upstream package configuration, without forking the upstream.
  Cask has no such concept.

**** Advantages of Cask
:PROPERTIES:
:CUSTOM_ID: advantages-of-cask
:END:
- Cask provides a useful toolbox of operations for project management,
  which are completely absent from =straight.el=.
- Since Cask is based on =package.el=, it does not require that you have
  Git installed. (It does require Python, however.) =straight.el= is
  mostly unusable without Git.
- Since Cask is based on =package.el=, it can perform bulk package
  updates more quickly than =straight.el=.
- Since Cask is based on =package.el=, it inherits a user interface for
  package management that also displays package metadata.
- Since Cask is based on =package.el=, you can install packages without
  editing a file manually, although this rather defeats the entire
  purpose of using Cask instead of =package.el=. =straight.el=
  absolutely refuses to permanently install a package without an
  explicit reference to it in your init-file (although this may be
  considered an advantage, depending on your perspective).
- Using MELPA Stable, Cask can install only stable versions of packages.
  By default, Cask also installs only stable versions of packages from
  GNU ELPA. These modes of operation are unsupported by =straight.el= at
  this time, although this is a
  [[https://github.com/radian-software/straight.el/issues/31][planned
  feature]].
- Cask supports more version-control systems than =straight.el= (which
  only supports Git).

*** Comparison to el-get
:PROPERTIES:
:CUSTOM_ID: comparison-to-el-get
:END:
I have not used el-get extensively, so please feel especially free to
offer corrections for this section.

- Both el-get and =straight.el= implement their own package management
  abstractions instead of delegating to =package.el=. However:
  - el-get goes the route of adding as many package sources as possible
    (e.g. =package.el=, many different version-control systems, various
    specific websites, and even system package managers) so that
    packages can be used very easily.
  - =straight.el= only supports Git and in doing so is able to provide
    more advanced package management features.

**** Advantages of =straight.el=
:PROPERTIES:
:CUSTOM_ID: advantages-of-straight.el-3
:END:
- =straight.el= uses your init-file as the sole source of truth for
  package operations. el-get has additional metadata stored outside the
  init-file, although specifying all packages in your init-file is a
  supported mode of operation.
- =straight.el= supports 100% reproducibility for your Emacs packages
  with version lockfiles. el-get can theoretically provide some measure
  of reproducibility, but this requires significant manual effort since
  all packages are not associated with specific revisions by default,
  nor is the revision of el-get saved anywhere.
- =straight.el= allows you to make arbitrary changes to your packages
  locally, and conflicts during updates are presented to the user and
  resolved interactively. While it is possible to make local changes to
  el-get packages, the el-get manual warns that such changes may break
  the update mechanism.
- =straight.el= has explicit support for configuring both an upstream
  repository and a fork for the same package. el-get does not have such
  a concept.
- =straight.el= allows you to perform arbitrary version-control
  operartions on your package's Git repositories. el-get allows this,
  but local changes will be overwritten when el-get performs an update.
- =straight.el= provides a suite of powerful interactive workflows for
  performing bulk operations on your package's Git repositories. el-get
  only allows you to install, uninstall, and update packages.
- =straight.el= operates quietly when all is going well. el-get reports
  its progress verbosely.
- =straight.el= has a profile system that allows users of someone else's
  Emacs configuration to manage an additional subset of packages, or to
  override upstream package configuration, without forking the upstream.
  el-get has no such concept.

**** Advantages of el-get
:PROPERTIES:
:CUSTOM_ID: advantages-of-el-get
:END:
- el-get supports virtually all known version-control systems, as well
  as system package managers, EmacsWiki, arbitrary HTTP, and even
  =go   get=. =straight.el= supports only Git, although it does allow
  you to manage your local repositories manually if you would like.
- el-get has been around since 2010 and is on its fifth major version,
  whereas =straight.el= was created in January 2017 and is only now
  approaching a 1.0 release. Clearly, el-get is more stable, although
  despite its recency =straight.el= is already almost 50% of the size of
  el-get, by the line count. Both package managers are actively
  maintained.
- el-get has a recipe format which is several orders of magnitude more
  powerful than that of =straight.el=, since it supports many more
  package sources that can be configured and since it allows for a more
  complex build process.
- el-get provides a number of features for running per-package
  initialization and setup code, including pulling that code from
  arbitrary sources. =straight.el= does not support this and expects you
  to use a dedicated tool like
  [[https://github.com/jwiegley/use-package][=use-package=]] (with which
  integration is built in) for that purpose.
- el-get has a user interface for package management that also displays
  package metadata, similarly to =package.el=. =straight.el= has no user
  interface for package management; any UI is provided by the user's
  =completing-read= framework.

*** Comparison to Borg
:PROPERTIES:
:CUSTOM_ID: comparison-to-borg
:END:
- Borg and =straight.el= are perhaps the two most similar package
  managers on this list. The difference is that Borg is very minimal and
  expects you to complement it with other tools such as
  [[https://magit.vc/][Magit]],
  [[https://github.com/emacscollective/epkg][epkg]],
  [[https://github.com/jwiegley/use-package][=use-package=]], and
  [[https://github.com/tarsius/auto-compile][auto-compile]]. On the
  other hand, =straight.el= aspires to be a one-stop package management
  solution, although it does not try to replace dedicated
  version-control packages (Magit) or dedicated package /configuration/
  packages (=use-package=).
- Borg uses Git submodules, while =straight.el= uses independently
  managed Git repositories.

**** Advantages of =straight.el=
:PROPERTIES:
:CUSTOM_ID: advantages-of-straight.el-4
:END:
- =straight.el= supports MELPA, GNU ELPA, Emacsmirror, and custom recipe
  sources. Borg only supports Emacsmirror and custom recipe sources.
  However, as the Emacsmirror is a near-complete superset of both GNU
  ELPA and MELPA, this does not necessarily mean you have access to more
  packages: it just means you benefit from the recipe maintenance
  efforts of the MELPA team and the Emacsmirror team, rather than only
  the latter.
- Borg, even when combined with related tools, do not allow for the kind
  of massive interactive repository management provided by
  =straight.el=.
- =straight.el= provides an API designed for other version-control
  backends to be added in future. Borg is inextricably tied to Git.
- The interface for Git submodules has a number of sharp edges.
- =straight.el= provides dependency management. This is a manual process
  in Borg.
- =straight.el= provides mechanisms for updating your packages. This is
  a manual process in Borg.
- =straight.el= is configured solely by how you use in your init-file.
  Configuring Borg requires customizing =~/.emacs.d/.gitmodules=, which
  means (for example) that you cannot generate recipes dynamically.
  (However, the handling of configuration is
  [[https://github.com/radian-software/straight.el/issues/95#issuecomment-316379495][planned]]
  to be improved in a future release.)
- =straight.el= has a profile system that allows users of someone else's
  Emacs configuration to manage an additional subset of packages, or to
  override upstream package configuration, without forking the upstream.
  Borg has no such concept.

**** Advantages of Borg
:PROPERTIES:
:CUSTOM_ID: advantages-of-borg
:END:
- Borg does a heck of a lot less magic, so if you want a solution with
  simple implementation details, =straight.el= may not be for you. (But
  see the developer manual and docstrings, first.)

*** Comparison to the manual approach
:PROPERTIES:
:CUSTOM_ID: comparison-to-the-manual-approach
:END:
- The manual approach is to download packages yourself and put them on
  your =load-path=. =straight.el= is more or less what you get when you
  take the manual approach, think very hard about the best way to do
  everything, and then automate all of it.

**** Advantages of =straight.el=
:PROPERTIES:
:CUSTOM_ID: advantages-of-straight.el-5
:END:
- =straight.el= figures out where to clone your packages from for you.
- =straight.el= byte-compiles your packages for you and generates their
  autoloads automatically.
- =straight.el= frees you from needing to manually recompile and
  regenerate autoloads.
- =straight.el= keeps track of dependencies for you.
- =straight.el= provides tools to manage all your packages in bulk,
  which would otherwise be a long, tedious process.
- =straight.el= allows you to get reproducibility for your configuration
  without needing to keep all of your packages under version control.
- =straight.el= links packages into a separate build directories.
  Running packages directly from their repositories has a number of
  problems, including:
  - making it impossible to run only one package, if others are provided
    in the same repository.
  - making your working directory dirty when the package author forgot
    to add their build artifacts like =*.elc= and autoload files to the
    =.gitignore=.
  - instantly losing compatibility with MELPA recipes.
- =straight.el= offers you a single entry point to install only a single
  package in isolation, for a minimal bug reproduction. With the manual
  approach this would be more complicated, especially if the package has
  dependencies.
- =straight.el= frees you from needing to think about package
  management, since I already did all the thinking to figure how best to
  design everything.

**** Advantages of the manual approach
:PROPERTIES:
:CUSTOM_ID: advantages-of-the-manual-approach
:END:
- No dependencies.
- You learn a lot, if you don't give up first.
- You might end up writing a package manager (case in point).
- This is the only way to deal with packages that have non-Git upstreams
  which you need to contribute changes to. (However, you can always use
  the manual approach for one package and =straight.el= for the rest. Or
  you can just eschew =straight.el='s version-control support for that
  package, and use it only for building the package.)



** User manual
:PROPERTIES:
:CUSTOM_ID: user-manual
:END:
This section tells you everything you need to know about the user-facing
features of =straight.el=. For implementation details, see the
[[#developer-manual][developer manual]]. It may also be helpful to get
some perspective on the overarching concepts of =straight.el= from the
[[#conceptual-overview][conceptual overview]].

*** Bootstrapping =straight.el=
:PROPERTIES:
:CUSTOM_ID: bootstrapping-straight.el
:END:
In order to use =straight.el=, you will need to somehow get it loaded
into Emacs. (This is easy for =package.el=, since =package.el= is built
in to Emacs. =straight.el= must work a little harder.)

=straight.el= comes with a file to do just this, =bootstrap.el=. All you
need to do is load that file. You can do this with =M-x load-file= or by
a call to =load= in your init-file. However, there is an obvious
shortcoming: =bootstrap.el= will only be available once =straight.el= is
already installed.

You could just invoke =git clone= from your init-file, if =straight.el=
is not installed, but then you would have to manually take care of
selecting the correct branch, parsing your version lockfile to check out
the right revision, and so on. Instead, you can just use this snippet,
which uses a copious amount of magic to take care of all these details
for you:

#+begin_html
  <!-- longlines-start -->
#+end_html

#+begin_src emacs-lisp
(defvar bootstrap-version)
(let ((bootstrap-file
       (expand-file-name
        "straight/repos/straight.el/bootstrap.el"
        (or (bound-and-true-p straight-base-dir)
            user-emacs-directory)))
      (bootstrap-version 7))
  (unless (file-exists-p bootstrap-file)
    (with-current-buffer
        (url-retrieve-synchronously
         "https://raw.githubusercontent.com/radian-software/straight.el/develop/install.el"
         'silent 'inhibit-cookies)
      (goto-char (point-max))
      (eval-print-last-sexp)))
  (load bootstrap-file nil 'nomessage))
#+end_src

#+begin_html
  <!-- longlines-stop -->
#+end_html

Despite the reference to =develop=, this snippet actually installs from
the =master= branch by default, just like every other package.
Furthermore, the correct revision of =straight.el= is checked out, if
you have one specified in your lockfile. Even better, you can
[[#overriding-the-recipe-for-straightel][override the recipe for
=straight.el=]], just like for any other package.

*** Installing packages programmatically
:PROPERTIES:
:CUSTOM_ID: installing-packages-programmatically
:END:
The primary entry point to =straight.el= is the =straight-use-package=
function. It can be invoked interactively (for installing a package
temporarily) or programmatically (for installing a package permanently).
This section covers the programmatic usage; see
[[#interactive-usage][later]] for interactive usage.

Here is the basic usage of =straight-use-package=:

#+begin_src emacs-lisp
(straight-use-package 'el-patch)
#+end_src

This will ensure that the package =el-patch= is installed and loaded.
(Note that =straight-use-package= takes a symbol, not a string, for the
name of the package.) Precisely, this is what happens:

- If the local Git repository for =el-patch= is not available, it is
  cloned, and the appropriate revision is checked out (if one is
  specified in your version lockfiles).
- If the local Git repository has been modified since the last time the
  package was built, it is rebuilt. This means:
  - The =.el= files are symlinked into a separate directory to isolate
    them from other, irrelevant files.
  - The main package file is checked for dependencies, which are
    installed recursively if necessary using =straight-use-package=.
  - The =.el= files are byte-compiled.
  - Autoloads are extracted from the =.el= files and saved into a
    separate file.
- The package's directory is added to Emacs' =load-path=.
- The package's autoloads are evaluated.

Package authors should note that =straight.el= checks for dependencies
that are specified in the
[[https://www.gnu.org/software/emacs/manual/html_node/elisp/Packaging-Basics.html][=package.el=
format]]. To spare you reading that documentation, this is either a
=Package-Requires= header in =PACKAGENAME.el=, or an argument to a
=define-package= invocation in =PACKAGENAME-pkg.el=. Despite the
[[#advantages-of-straightel][many shortcomings]] of =package.el=, it has
done a good job of creating a standardized format for dependency
declarations.

There is one exception to the above statement: not all entries specified
in the =Package-Requires= header necessarily correspond to packages. For
example, specifying a minimum Emacs version for a package is done by
depending on the =emacs= pseudo-package. Such packages are simply
ignored by =straight.el=, using the variable
=straight-built-in-pseudo-packages=.

Note that loading a package does not entail invoking =require= on any of
its features. If you wish to actually load the files of the package, you
need to do this separately. This is because most packages do not need to
be loaded immediately, and are better served by the autoload system.

**** Installing with a custom recipe
:PROPERTIES:
:CUSTOM_ID: installing-with-a-custom-recipe
:END:
=straight-use-package= can also take a list instead of a symbol. In that
case, the first member of the list is a symbol giving the package name,
and the remainder of the list is a
[[https://www.gnu.org/software/emacs/manual/html_node/elisp/Property-Lists.html][property
list]] providing information about how to install and build the package.
Here is an example:

#+begin_src emacs-lisp
(straight-use-package
 '(el-patch :type git :host github :repo "radian-software/el-patch"
            :fork (:host github
                   :repo "your-name/el-patch")))
#+end_src

If you give =straight-use-package= just a package name, then a recipe
will be looked up by default (see the section on
[[#recipe-lookup][recipe lookup]]). You can see the default recipe for a
package by invoking [[#interactive-usage][=M-x straight-get-recipe=]].

If =straight-allow-recipe-inheritance= is non-nil, then you only need to
specify the components of the recipe that you want to override. All
other components will still be looked up in the default recipe. In the
example above, we are only interested in changing the =:fork= component.
Therefore if =straight-allow-recipe-inheritance= is set, the recipe
could be simplifed as follows:

#+begin_src emacs-lisp
(straight-use-package
 '(el-patch :fork (:repo "your-name/el-patch")))
#+end_src

or even simpler:

#+begin_src emacs-lisp
(straight-use-package
 '(el-patch :fork "your-name/el-patch"))
#+end_src

The =:files= keyword and all version control keywords support
inheritance.

To learn more, see the section on [[#the-recipe-format][the recipe
format]].

**** Additional arguments to =straight-use-package=
:PROPERTIES:
:CUSTOM_ID: additional-arguments-to-straight-use-package
:END:
The full user-facing signature of =straight-use-package= is:

#+begin_src emacs-lisp
(straight-use-package PACKAGE-OR-RECIPE &optional NO-CLONE NO-BUILD)
#+end_src

As discussed [[#installing-packages-programmatically][previously]], by
default =straight-use-package= will do three things:

- Register the recipe provided with =straight.el=.
- Clone the package's local repository, if it is absent.
- Rebuild the package if necessary, and load it.

By providing the optional arguments, you may cause processing to halt
before all three of these tasks are completed. Specifically, providing
=NO-CLONE= causes processing to halt after registration but before
cloning, and providing =NO-BUILD= causes processing to halt after
cloning (if necessary) but before building and loading.

=straight.el= supports lazy-loading by means of a special value for
=NO-CLONE=, the symbol =lazy=. If this symbol is passed, then processing
will halt at the clone step, unless the package is already cloned. This
means that the package is built and loaded if it is already installed,
but otherwise installation is deferred until later. When you want to
trigger the lazy installation, simply call =straight-use-package= again,
but without =NO-CLONE=. (There is no need to pass the recipe again; see
[[#recipe-lookup][recipe lookup]].)

You can also pass functions for =NO-CLONE= or =NO-BUILD=, which will be
called with the package name as a string; their return values will then
be used instead.

Note that if it makes no sense to build a package, then you should put
=:build nil= in its [[#the-recipe-format][recipe]], rather than
specifying =NO-BUILD= every time you register it with =straight.el=.
(This is especially relevant when writing recipes for
[[#customizing-recipe-repositories][recipe repositories]].)

**** Variants of =straight-use-package=
:PROPERTIES:
:CUSTOM_ID: variants-of-straight-use-package
:END:
For convenience, =straight.el= provides some functions that wrap
=straight-use-package= with particular arguments, to cover all of the
common cases. Each of these functions takes only a package name or
recipe, and no additional arguments.

- =straight-register-package=: always stop after the registration step.
  This may be useful for specifying the recipe for an optional
  dependency (see [[#recipe-lookup][recipe lookup]], but see also
  [[#overriding-recipes][recipe overrides]]).
- =straight-use-package-no-build=: always stop before the build step.
  This is used by [[#lockfile-management][=straight-freeze-versions=]]
  to make sure packages are cloned, since building them is unnecessary
  for writing the lockfiles.
- =straight-use-package-lazy=: stop at the clone step if the package's
  local repository is not already cloned. This is used for lazy-loading.

**** Customizing when packages are built
:PROPERTIES:
:CUSTOM_ID: customizing-when-packages-are-built
:END:
By default, when =straight.el= is bootstrapped during Emacs init, it
uses a bulk =find(1)= command to identify files that were changed since
the last time a package depending on them was built. These packages are
then rebuilt when they are requested via =straight-use-package=.
Normally, =straight.el= will try to detect what sort of =find(1)=
program is installed, and issue the appropriate command. If it makes a
mistake, then you can manually customize =straight-find-flavor=.
Alternately, you can install GNU find and customize the variable
=straight-find-executable= to point to it.

For about 100 packages on an SSD, calling =find(1)= to detect
modifications takes about 500ms. You can save this time by customizing
=straight-check-for-modifications=. This is a list of symbols which
determines how =straight.el= detects package modifications. The default
value is =(find-at-startup find-when-checking)=, which means that
=find(1)= is used to detect modifications at startup, and also when you
invoke =M-x straight-check-package= or =M-x straight-check-all=. If you
prefer to avoid this performance hit, or do not have =find(1)=
installed, then you can remove these symbols from the list. In that
case, you will probably want to add either =check-on-save= or
=watch-files= to the list.

=check-on-save= causes =straight.el= to use =before-save-hook= to detect
package modifications as you make them (modifications made by the
=straight.el= repository management commands are also detected). This
reduces init time, but modifications made outside of Emacs (or
modifications that bypass =before-save-hook=) are not detected. Pull
requests extending the number of cases in which =straight.el= is able to
detect live modifications are welcome. Also, for the sake of efficiency,
this form of modification checking is restricted to subdirectories of
=~/.emacs.d/straight/repos=, so you must put your local repositories
into that directory for it to work. (Pull requests to change this would
be welcome.)

=watch-files= causes =straight.el= to automatically invoke a filesystem
watcher to detect modifications as they are made, inside or outside of
Emacs. For this setting to work, you must have
[[https://www.python.org/][=python3=]] and
[[https://github.com/mattgreen/watchexec][=watchexec=]] installed on
your =PATH=. By default, the watcher persists after Emacs is closed. You
can stop it manually by running =M-x straight-watcher-stop=, and start
it again by running =M-x straight-watcher-start=. The watcher script is
designed so that when one instance is started, all the others gracefully
shut down, so you don't have to worry about accidentally ending up with
more than one. There is nothing exciting in the process buffer for the
watcher, but if you are interested in it then its name is given by
=straight-watcher-process-buffer=. (By default, the name has a leading
space so that the buffer does not appear in the buffer list.)

There is probably no good reason to use both =check-on-save= and
=watch-files= at the same time. Your configuration can dynamically
switch between which one is used depending on
=(executable-find "watchexec")= or similar.

If you prefer to eschew automatic package rebuilding entirely, you can
just set =straight-check-for-modifications= to =nil=. In that case,
packages will only be rebuilt when metadata (e.g. the recipe or the
Emacs version) changes, or when you manually invoke
=M-x straight-rebuild-package= or =M-x straight-rebuild-all=.

Regardless of your preferred setting for
=straight-check-for-modifications=, you should set it before the
=straight.el= bootstrap snippet is run, since hooks relating to this
variable are set during bootstrap.

On Microsoft Windows, =find(1)= is generally not available, so the
default value of =straight-check-for-modifications= is instead
=(check-on-save)=.

***** Custom or manual modification detection
:PROPERTIES:
:CUSTOM_ID: custom-or-manual-modification-detection
:END:
You can also use the low-level functions for modification detection
directly.

The function =straight-register-repo-modification= takes a string
(e.g. ="straight.el"=) corresponding to the name of a local repository,
and marks all packages from that local repository to be rebuilt at next
Emacs startup. This function silently ignores local repositories which
contain slashes, a limitation which might be removed in future.

The function =straight-register-file-modification= takes no arguments
and checks if the file visited by the current buffer (if any) is
contained by any local repository. If so, it delegates to
=straight-register-repo-modification=. The =check-on-save= value for
=straight-check-for-modifications= just adds
=straight-register-file-modification= to =before-save-hook=.

***** Summary of options for package modification detection
:PROPERTIES:
:CUSTOM_ID: summary-of-options-for-package-modification-detection
:END:
****** =find-at-startup=
:PROPERTIES:
:CUSTOM_ID: find-at-startup
:END:
Save build timestamps and run =find(1)= at startup to detect changes

- Most reliable, never misses changes
- Requires =find(1)=
- Slows down startup

****** =check-on-save=
:PROPERTIES:
:CUSTOM_ID: check-on-save
:END:
Use =before-save-hook= to detect changes

- No external dependencies
- No startup delay
- No additional CPU or memory impact
- Doesn't catch changes made except via =save-file= inside Emacs

****** =watch-files=
:PROPERTIES:
:CUSTOM_ID: watch-files
:END:
Run filesystem watcher to detect changes

- Requires Python 3 and Watchexec
- No startup delay
- Takes a few seconds to build virtualenv the first time
- Memory and CPU impact of running filesystem watcher
- Only misses changes if you make them after booting the system but
  before starting Emacs

--------------

**** Customizing how packages are built
:PROPERTIES:
:CUSTOM_ID: customizing-how-packages-are-built
:END:
By specifying =:build nil= in a package's
[[#the-recipe-format][recipe]], you may prevent the package from being
built at all. This is usually useful for recipe repositories which do
not bundle executable Lisp code. (Make sure to use
[[#customizing-recipe-repositories][=straight-use-recipes=]] for
registering recipe repositories.)

***** Autoload generation
:PROPERTIES:
:CUSTOM_ID: autoload-generation
:END:
By specifying =:build (:not autoloads)= in a package's recipe, you may
prevent any autoloads provided by the package from being generated and
loaded into Emacs. This is mostly useful if the package provides a large
number of autoloads, you know you need only a few of them, and you wish
to optimize your startup time (although this is almost certainly
premature optimization unless you /really/ know what you're doing). You
can also customize the variable =straight-disable-autoloads= to effect
this change on all recipes which do not explicitly disable autoloads via
the =:build= keyword.

***** Byte compilation
:PROPERTIES:
:CUSTOM_ID: byte-compilation
:END:
By specifying =:build (:not compile)= in a package's recipe, you may
inhibit byte-compilation. See
[[https://github.com/radian-software/straight.el/issues/357][this
issue]] for discussion of why this might be useful. You can also
customize the variable =straight-disable-compile= to effect this change
on all recipes which do not explicitly disable byte-compilation via the
=:build= keyword.

***** Native compilation
:PROPERTIES:
:CUSTOM_ID: native-compilation
:END:
Experimental support for native compilation of Emacs Lisp code can be
enabled in the latest =master= branch of the official Emacs repository
(see [[http://akrl.sdf.org/gccemacs.html][gccemacs]]). When running on
this version of Emacs, =straight.el= will perform native compilation of
packages.

By specifying a =:build (:not native-compile)= in a package's recipe,
you may inhibit native compilation. You can also customize the variable
=straight-disable-native-compile= to effect this change on all recipes
which do not explicitly disable native-compilation via the =:build=
keyword.

Native compilation requires byte-compilation, so =:build (:not compile)=
and =straight-disable-compile= will also disable native compilation.

***** Symbolic links
:PROPERTIES:
:CUSTOM_ID: symbolic-links
:END:
Usually, =straight.el= uses symbolic links ("symlinks") to make package
files available from the build directory. This happens when
=straight-use-symlinks= is non-nil, the default. On Microsoft Windows,
however, support for symlinks is not always available, so the default
value of =straight-use-symlinks= is nil on that platform. That causes
copying to be used instead, and an advice is placed on =find-file= to
cause the copied files to act as symlinks if you try to edit them.

If you want to activate symlink-support on MS Windows 7, 8, or 10, you
should ensure the following requirements:

- =straight-use-symlinks= has to be set to non-nil manually.

- Your user-account needs to be assigned the right to create symbolic
  links. To do so, run "secpol.msc" and in "Local Policies → User Rights
  Assignment" assign the right to "Create symbolic links" to your
  user-account.

- If you have User Account Control (UAC) enabled and your user-account
  belongs to the the /Administrators/ group you'll need to run Emacs in
  elevated mode to be able to create symlinks (see
  [[https://community.perforce.com/s/article/3472][here]] and
  [[https://stackoverflow.com/a/29065060/3538165][here]] and, for an
  official reference, section Access Token Changes
  [[https://msdn.microsoft.com/en-us/library/bb530410.aspx#vistauac_topic8][in
  this document]].

- [[https://blogs.windows.com/buildingapps/2016/12/02/symlinks-windows-10/][Windows
  Creators Update]] supports symlink-creation without any special
  permission setup.

**** Customizing how packages are made available
:PROPERTIES:
:CUSTOM_ID: customizing-how-packages-are-made-available
:END:
By setting the variable =straight-cache-autoloads= to a non-nil value,
you can cause =straight.el= to cache the autoloads of all used packages
in a single file on disk, and load them from there instead of from the
individual package files if they are still up to date. This reduces the
number of disk IO operations during startup from O(number of packages)
to O(1), so it should improve performance. No other configuration should
be necessary to make this work; however, you may wish to call
[[#interactive-usage][=straight-prune-build=]] occasionally, since
otherwise this cache file may grow quite large over time.

**** Hooks run by =straight-use-package=
:PROPERTIES:
:CUSTOM_ID: hooks-run-by-straight-use-package
:END:
Currently, =straight-use-package= supports four hooks:

- =straight-vc-git-post-clone-hook=: The functions in this hook are run
  just after cloning a git repository. This allows users to automate
  custom configuration of Elisp Git repositories after they have been
  cloned. For example, the =user.email= =git-config= variable could be
  set on clone, to make upstream contributions more convenient for
  developers who use different email addresses for different
  repositories.

  Each hook function is passed the following
  [[https://www.emacswiki.org/emacs/KeywordArguments][keyword
  arguments]]:

  - =:repo-dir= - the local directory to which the repository was cloned
  - =:remote= - the name of the remote from which the repository was
    cloned
  - =:url= - the URL from which the repository was cloned
  - =:branch= - the branch as specified by the recipe, if any, otherwise
    =nil=
  - =:depth= - the clone depth as specified by the recipe or
    =straight-vc-git-default-clone-depth=
  - =:commit= - the specific commit which was requested via the
    lockfile, if any, otherwise =nil=

  Since keyword arguments are used, each function should be defined via
  =cl-defun=, and =&key= used at the front of the argument list.

- =straight-use-package-prepare-functions=: The functions in this hook
  are run just before a package would be built, even if the package does
  not actually need to be rebuilt. They are passed the name of the
  package being (maybe) built as a string, and should take and ignore
  any additional arguments.

- =straight-use-package-pre-build-functions=: The functions in this hook
  are run just before building a package (and only if the package needs
  to be built). They are passed the name of the package being built as a
  string, and should take and ignore any additional arguments.

- =straight-use-package-post-build-functions=: The functions in this
  hook are run just after building a package (and only if the package
  needs to be built). They are passed the name of the package being
  built as a string, and should take and ignore any additional
  arguments.

*** The recipe format
:PROPERTIES:
:CUSTOM_ID: the-recipe-format
:END:
The general format for a =straight.el= recipe is:

#+begin_src emacs-lisp
(package-name :keyword value :keyword value ...)
#+end_src

Note that if you wish to pass a recipe to =straight-use-package=, you
will need to quote it. If you need to compute part of the recipe
dynamically, use backquoting:

#+begin_src emacs-lisp
(straight-use-package
  `(el-patch :type git :repo ,(alist-get 'el-patch my-package-urls)))
#+end_src

The supported keywords are /similar, but not identical/ to those used in
MELPA recipes. There is a complete list below which you can compare with
the [[https://github.com/melpa/melpa#recipe-format][MELPA
documentation]], but the main differences from the user's point of view
are:

- We use =:host= instead of =:fetcher=.

- We only support Git recipes by default, although the system is
  extensible to other VCs to be added in the future or in user
  configurations. Thus the supported =:host= values are:

  - =nil= (any Git repository)
  - =github=, =gitlab=, =sourcehut=, =codeberg=, or =bitbucket=.

- We support =:branch=, but not =:commit= or =:version-regexp=. To lock
  a package to a specific commit, use a
  [[#lockfile-management][lockfile]]. See also
  [[https://github.com/radian-software/straight.el/issues/246][#246]]
  for discussion of extensions to the recipe to support package pinning,
  which is a planned feature.

- We support several additional keywords that affect how a package is
  built; see below.

- There are consistency and feature improvements to edge cases of the
  =:files= keyword as documented in =straight-expand-files-directive=.

- =:includes= indicates a package is a superset of another package.

Here is a comprehensive list of all keywords which have special meaning
in a recipe (unknown keywords are ignored but preserved):

- =:local-repo=

  This is the name of the local repository that is used for the package.
  If a local repository by that name does not exist when you invoke
  =straight-use-package=, one will be cloned according to the package's
  [[#version-control-backends][version-control settings]].

  Multiple packages can use the same local repository. If so, then a
  change to the local repository will cause both packages to be rebuilt.
  Typically, if multiple packages are drawn from the same repository,
  both should specify a =:files= directive.

  If you do not provide =:local-repo=, then it defaults to a value
  derived from the [[#version-control-backends][version-control
  settings]], or as a last resort the package name.

- =:files=

  This is a list specifying which files in a package's local repository
  need to be symlinked into its build directory, and how to arrange the
  symlinks. For most packages, the default value
  (=straight-default-files-directive=) will suffice, and you do not need
  to specify anything.

  If you do need to override the =:files= directive (this happens most
  commonly when you are taking a single package from a repository that
  holds multiple packages), it is almost always sufficient to just
  specify a list of globs or filenames. All matching files will be
  linked into the top level of the package's build directory.

  In spite of this, the =:files= directive supports an almost comically
  powerful DSL (with nested excludes and everything!) that allows you
  full flexibility on how the links are made; see the docstring of
  =straight-expand-files-directive= for the full details.

- =:flavor=

  If this is non-nil, then it changes the interpretation of the =:files=
  directive for compatibility with an existing upstream recipe source.
  See the docstring of =straight-expand-files-directive= for details.

- =:build= This specifies the steps taken on the files symlinked within
  a package's straight/build/PACKAGE directory. It may be any of the
  following values:

  - nil, in which case nothing is done. This also prevents
    :pre/:post-build commands from running.

#+begin_src emacs-lisp
(example :build nil)
#+end_src

- t, runs the steps listed in =straight--build-default-steps=. Note this
  ignores all =straight-disable-SYMBOL= keywords.

#+begin_src emacs-lisp
(example :build t)
#+end_src

- A list of steps. Each step is a symbol which represents a function
  named: =straight--build-SYMBOL=. The function is passed the recipe as
  its sole argument. Steps are exectuted in the order they are listed.
  e.g.

#+begin_src emacs-lisp
(example :build (autoloads compile native-compile info))
#+end_src

- A list which has =:not= as its car and step symbols as its cdr. This
  eliminates the listed steps from the default steps. e.g. The following
  recipe will not be compiled or have its texinfo generated:

#+begin_src emacs-lisp
(example :build (:not compile info))
#+end_src

Steps may be disabled globally for recipes which do not explicilty
declare their =:build= via the defcustom variables named
=straight--build-SYMBOL=. e.g. The last example but for all recipes
without a =:build=:

#+begin_src emacs-lisp
(setq straight-disable-compile t
      straight-disable-info t)
#+end_src

In the absence of a =:build= keyword, =straight--build-default-steps=
are run.

- =:pre-build=

  This specifies system commands and/or elisp to be evaluated before
  symlinking, and running a recipe's =:build= steps.

  Each command is either an elisp form to be evaluated or a list of
  strings to be executed in a shell context of the form:

#+begin_src emacs-lisp
("executable" "arg"...)
#+end_src

Commands are executed in the package's repository directory.

The =:pre-build= keyword's value may be:

- A single command

- A list of commands

- nil, in which case no commands are executed.

  For example:

#+begin_src emacs-lisp
(straight-use-package
 '( example :type git :host github :repo "user/example.el"
    :pre-build ("make" "all")))

(straight-use-package
 `( example :type git :host github :repo "user/example.el"
    :pre-build ,(pcase system-type
                  (`windows-nt '(message "This might take a while"))
                  (_ '(("./configure") ("make") ("make" "install"))))))
#+end_src

- =:post-build=

  This specifies system commands and/or elisp to be evaluated after the
  =:build= steps are run.

  Otherwise, it is identical to the =:pre-build= keyword in terms of the
  values it accepts and how it is executed.

  For example:

#+begin_src emacs-lisp
(straight-use-package
 '( example :type git :host github :repo "user/example.el"
    :pre-build  (("./pre-build.sh") (message "hi"))
    :post-build (("./post-build.sh") (message "bye"))))
#+end_src

- =:type=

  This specifies the version-control backend to use for cloning and
  managing the package's local repository. It defaults to the value of
  =straight-default-vc=, which defaults to =git=.

  The only traditional version-control backend currently supported is
  =git=, although more backends may be added.

  As a special case, however, you may specify the value =built-in=,
  which results in all version-control operations on the package being
  ignored. This allows you to tell =straight.el= that a package has
  already been provided (for example, because a version of it is shipped
  by Emacs) and does not have a local repository which needs to be
  cloned, updated, and so on. Here is how you can tell =straight.el=
  that you would like to use the Emacs-provided copy of Org, rather than
  cloning it from the upstream repository if another package declares it
  as a dependency:

#+begin_src emacs-lisp
(straight-use-package '(org :type built-in))
#+end_src

You can also use =:type nil=, which has the same effect as
=:type   'built-in=, except that the package is still loaded from its
configured =:local-repo=.

- =:source=

Overrides =straight-recipe-repositories= on a per-recipe basis. Its
value may be: - a symbol representing a recipe repository - a list of
such symbols The order of the symbols determines their precedence. For
example:

#+begin_src emacs-lisp
(straight-use-package '(package :source melpa))
#+end_src

Will search only the melpa recipe repository for package's recipe.
While:

#+begin_src emacs-lisp
(straight-use-package '(package :source (melpa gnu-elpa-mirror)))
#+end_src

will search for package's recipe first in melpa. If it is not found
there it will check gnu-elpa-mirror next.

- backend-specific keywords

  Depending on the value of =:type=, additional keywords (relevant to
  how the package's repository is cloned and managed) will be
  meaningful. See the next section.

  The =built-in= and =nil= pseudo-backends do not take any other
  keywords.

- =:includes=

Informs =straight.el= that a package is a superset of another package.
For example =org-contrib= includes =ol-vm=. The following will prevent
=straight.el= from attempting to install =ol-vm= after =org-contrib= has
been installed:

#+begin_src emacs-lisp
(straight-use-package '(org-contrib :includes ol-vm))
#+end_src

Its value may also be a list of symbols indicating multiple packages:

#+begin_src emacs-lisp
(straight-use-package '(example :includes (foo bar)))
#+end_src

- =:inherit=

Overrides =straight-allow-recipe-inheritance= on a per-recipe basis. If
its value is non-nil, inheritance is enabled for the recipe. Otherwise
it is not.

**** Version-control backends
:PROPERTIES:
:CUSTOM_ID: version-control-backends
:END:
Defining a version-control backend consists of declaring a number of
functions named as =straight-vc-BACKEND-METHOD=, where =BACKEND= is the
name of the version-control backend being defined and =METHOD= is a
backend API method. The relevant methods are:

- =clone=: given a recipe and a commit object, clone the repository and
  attempt to check out the given commit.
- =commit-present-p=: given a recipe and a commit object, return whether
  the commit can be checked out offline, i.e., without fetching from the
  remote.
- =normalize=: given a recipe, "normalize" the repository (this
  generally means reverting it to a standard state, such as a clean
  working directory, but does not entail checking out any particular
  commit).
- =fetch-from-remote=: given a recipe, fetch the latest version from its
  configured remote, if one is specified.
- =fetch-from-upstream=: given a recipe, fetch the latest version from
  its configured upstream, if the package is forked.
- =merge-from-remote=: given a recipe, merge the latest version fetched
  from the configured remote, if any, to the local copy.
- =merge-from-upstream=: given a recipe, merge the latest version
  fetched from the configured upstream, if the package is forked, to the
  local copy.
- =push-to-remote=: given a recipe, push the current version of the
  repository to its configured remote, if one is specified.
- =check-out-commit=: given a recipe and a commit object, attempt to
  check out that commit in the repository for that recipe.
- =get-commit=: given a local repository name, return the commit object
  that is currently checked out, or nil if the local repository should
  not be included in a lockfile.
- =local-repo-name=: given a recipe, return a good name for the local
  repository, or nil.
- =keywords=: return a list of keywords which are meaningful for this
  version-control backend.

Most of these methods are highly interactive: they don't actually do
anything without prompting you to confirm it, and very often they will
offer you a number of different options to proceed (including starting a
recursive edit and allowing you to do whatever you would like).

Also, all of the methods in this section take
[[#developer-manual][=straight.el=-style recipes]]; see the section on
[[#developer-manual][defining VC backends]] in the developer manual for
more details.

**** Git backend
:PROPERTIES:
:CUSTOM_ID: git-backend
:END:
These are the keywords meaningful for the =git= backend:

- =:repo=: the clone URL for the Git repository.

- =:host=: either nil or one of the symbols =github=, =gitlab=,
  =bitbucket=, =codeberg=, or =sourcehut=.

  - If nil, then =:repo= should be a string which is the full URL of the
    target repository. For example:

  #+begin_src emacs-lisp
  ( :package "package" :host nil :type git
    :repo "http://myhost.tld/repo")
  #+end_src

  - If non-nil, then =:repo= should be a string "username/repo", and the
    URL is constructed automatically. For example:

  #+begin_src emacs-lisp
  ( :package "package" :host github :type git
    :repo "username/repo")
  #+end_src

- =:branch=: the name of the branch used for primary development, as a
  string. If your version lockfiles do not specify a commit to check out
  when the repository is cloned, then this branch is checked out, if
  possible. This branch is also viewed as the "primary" branch for the
  purpose of normalization and interaction with the remote.

- =:remote=: the name to use for the Git remote. If the package is
  forked, this name is used for the upstream remote.

- =:nonrecursive=: if non-nil, then submodules are not cloned. This is
  particularly important for the Emacsmirror recipe repository, which
  contains every known Emacs package in existence as submodules.

- =:fork=: the settings for a fork, if desired. This causes the
  =fetch-from-remote= method to operate on the fork; you can use the
  =fetch-from-upstream= method to operate on the upstream instead.

  Note: the following section assumes =straight-host-usernames= has a
  value of:

#+begin_src emacs-lisp
'((github    . "githubUser")
  (gitlab    . "gitlabUser")
  (codeberg  . "codebergUser")
  (sourcehut . "sourcehutUser")
  (bitbucket . "bitbucketUser")))
#+end_src

Its value may be:

- =t=: Look up the username in =straight-host-usernames=. Inherit the
  repository name from the upstream repository. For example:

#+begin_src emacs-lisp
( :package "package" :host github :type git :repo "upstream/repo"
  :fork t)
#+end_src

computes the fork's =:repo= value as =githubUser/repo=.

- a string (optionally ending with "/"): Use the string as the username.
  Inherit repository name from the upstream repository. For example:

#+begin_src emacs-lisp
( :package "package" :host github :type git :repo "upstream/repo"
  :fork "user")
#+end_src

computes the fork's =:repo= value as =user/repo=.

- a string starting with "/": Look up the username in
  =straight-host-usernames=. Use the string as the repository name. For
  example:

#+begin_src emacs-lisp
( :package "package" :host github :type git :repo "upstream/repo"
  :fork "/renamed")
#+end_src

computes the fork's =:repo= value as =githubUser/renamed=.

- a string with both the recipe and repository specified: Use string as
  the =:repo= value for the fork. For example:

#+begin_src emacs-lisp
( :package "package" :host github :type git :repo "upstream/repo"
  :fork "user/renamed")
#+end_src

computes the fork's =:repo= value as =user/renamed=.

- a plist: The allowed keywords are =:repo=, =:host=, =:branch=, and
  =:remote=. The same rules as above apply for the =:repo= string.
  Likewise, if the =:host= is overridden and the =:repo= does not
  provide the username, it is looked up in =straight-host-usernames=.
  For example:

#+begin_src emacs-lisp
( :package "package" :host github :type git :repo "upstream/repo"
  :fork (:host gitlab))
#+end_src

computes the fork's =:repo= value as =gitlabUser/repo=.

#+begin_src emacs-lisp
( :package "package" :host github :type git :repo "upstream/repo"
  :fork (:host gitlab :repo "/renamed"))
#+end_src

computes the fork's =:repo= value as =gitlabUser/renamed=.

#+begin_src emacs-lisp
( :package "package" :host github :type git :repo "upstream/repo"
  :fork (:host gitlab :repo "user"))
#+end_src

computes the fork's =:repo= value as =user/repo=.

- =:depth=: either the symbol =full= or an integer. If =full=, then the
  repository is cloned with its whole history. If an integer =N=, then
  the repository is cloned with the option =--depth N=. This works even
  when a commit is specified (e.g. by version lockfiles). The default
  value is =full=.
- =:protocol=: If non-nil, force this protocol to be used when
  interacting with the remote repository. Takes the same values as
  =straight-vc-git-default-protocol=.

This section tells you how the =git= backend, specifically, implements
the version-control backend API:

- =clone=: clones the repository, including submodules if
  =:nonrecursive= is not provided. Checks out the commit specified in
  your revision lockfile, or the =:branch= (from the =:fork=
  configuration, if given), or =origin/HEAD=. If a =:fork= is specified,
  also fetches from the upstream.
- =commit-present-p=: checks if the commit SHA is among the revisions
  that are present locally.
- =normalize=: verifies that remote URLs are set correctly, that no
  merge is in progress, that the worktree is clean, and that the primary
  =:branch= (from the =:fork= configuration, if given) is checked out.
- =fetch-from-remote=: checks that remote URLs are set correctly, then
  fetches from the primary remote (the fork, if the package is forked).
- =fetch-from-upstream=: checks that remote URLs are set correctly, then
  fetches from the upstream remote. If the package is not a fork, does
  nothing.
- =merge-from-remote=: performs normalization, then merges from the
  primary remote (the fork, if the package is forked) into the primary
  local =:branch=.
- =merge-from-upstream=: performs normalization, then merges from the
  upstream remote into the primary local =:branch=. If the package is
  not a fork, does not attempt to merge.
- =push-to-remote=: performs normalization, pulls from the primary
  remote if necessary, and then pushes if necessary. This operation acts
  on the fork, if the package is forked.
- =check-out-commit=: verifies that no merge is in progress and that the
  worktree is clean, then resets the worktree to the specified commit.
- =get-commit=: returns HEAD as a 40-character string.
- =local-repo-name=: if =:host= is non-nil, then =:repo= will be of the
  form "username/repository", and "repository" is used. Otherwise, if
  the URL is of the form =.../<something>.git=, then =<something>= is
  used. Otherwise, nil is returned.
- =keywords=: see the list of keywords above.

You can customize the following user options:

- =straight-vc-git-default-remote-name=: the name to use for the primary
  remote, or the upstream remote if the package is forked. Defaults to
  "origin". The =:remote= keyword may be used to override the value of
  this variable on a per-repository basis.

- =straight-vc-git-default-fork-name=: the name to use for the fork
  remote, if the package is forked. Defaults to "fork". The =:remote=
  keyword may be used to override the value of this variable on a
  per-repository basis.

- =straight-vc-git-default-protocol=: the default protocol to use for
  automatically generated URLs when =:host= is non-nil. It can be either
  =https= or =ssh=, and defaults to =https= because this requires less
  work to set up.

- =straight-vc-git-force-protocol=: if this is non-nil, then HTTPS and
  SSH URLs are not treated as equivalent, so that bulk version-control
  operations will offer to re-set your remote URLs from HTTPS to SSH or
  vice versa, depending on the value of
  =straight-vc-git-default-protocol=. This is nil by default.

- =straight-vc-git-auto-fast-forward=: if this is non-nil, pulling will
  quietly do fast-forward, to suppress asking for instructions on each
  package with updates, unless they're not trivial. Set to nil if you'd
  prefer to inspect all changes.

- =straight-vc-git-default-clone-depth=: the default value for the
  =:depth= keyword. It can be either the symbol =full= or an integer,
  and defaults to =full=. Setting this variable to a small integer will
  reduce the size of repositories. This variable affects all packages,
  even those whose versions are locked.

  Please be careful with setting =straight-vc-git-default-clone-depth=,
  which may break some packages' installing processes such as =elfeed=
  that depend on =org=.

***** Deprecated =:upstream= keyword
:PROPERTIES:
:CUSTOM_ID: deprecated-upstream-keyword
:END:
=straight.el= previously supported fork configuration in recipes using
an =:upstream= keyword rather than a =:fork= keyword. For various
reasons, this was more complex to handle, which is why the change was
made. For backwards compatibility, the =:upstream= keyword is still
accepted, with the following behavior.

When =straight.el= processes a recipe which uses the =:upstream=
keyword, it moves the =:repo=, =:host=, and =:branch= keywords from that
sub-plist to the top level, and moves those top-level keywords to a new
=:fork= sub-plist. Then it sets the top-level and =:fork= sub-plist
values of =:remote= to the values of the deprecated variables
=straight-vc-git-upstream-remote= (defaults to "upstream") and
=straight-vc-git-primary-remote= (defaults to "origin"), respectively.

For backwards compatibility, if =straight-vc-git-primary-remote= differs
from its default value of "origin", then its value is used in place of
=straight-vc-git-default-remote-name=.


*** Recipe lookup
:PROPERTIES:
:CUSTOM_ID: recipe-lookup
:END:
If you only provide a symbol (package name) to =straight-use-package=,
then the recipe is looked up automatically. By default,
[[http://melpa.org/#/][MELPA]], [[https://elpa.gnu.org/][GNU ELPA]], and
[[https://emacsmirror.net/][Emacsmirror]] are searched for recipes, in
that order. This means that one or more of them may need to be cloned.
Recipe repositories are actually just the same as ordinary packages,
except that their recipes specify =:build nil=, so they are not
symlinked or added to the =load-path=.

Note that dependencies always use the default recipes, since the only
information =straight.el= gets about a package's dependencies are their
names.

This leads to a few interesting questions regarding requesting a package
multiple times. For example, you might need to load two features using
[[https://github.com/jwiegley/use-package][=use-package=]] that are
provided from the same package, or one of the packages you have
installed is also requested as a dependency by another package.
=straight.el= uses a number of heuristics to try to make these
interactions as intuitive and painless as possible:

- The first time a package is registered with =straight.el=, its recipe
  (either the recipe that you provided, or the one that was looked up
  from a recipe repository) is recorded. In future registration, if you
  just provide the package name to =straight-use-package=, the existing
  recipe is reused.

  Note, however: /if/ you want to use a custom recipe for a given
  package, you must load it /before/ all of its dependencies. Otherwise,
  the package will first be registered as a dependency, using the
  default recipe.

- If a package has already been registered with =straight.el=, and you
  attempt to load it again with an explicit recipe which is different
  from the one previously registered, the new recipe is used but a
  warning is signalled.

- If you attempt to register a package which shares a =:local-repo=
  (either by default, or due to explicit specification) with a
  previously registered package, and the two packages specify different
  values for their version-control keywords (see
  [[#version-control-backends][version-control backends]]), then the new
  recipe is used but a warning is signalled. If the repository was
  already cloned, this means the second recipe will have no effect.

  But if the second recipe was fetched automatically from a recipe
  repository, all of its version-control keywords will be silently
  overwritten with the ones from the first recipe, to avoid conflicts
  (although if there are conflicts in other parts of the recipe, a
  warning will still be displayed).

**** Updating recipe repositories
:PROPERTIES:
:CUSTOM_ID: updating-recipe-repositories
:END:
As mentioned in the [[#where-do-recipes-come-from][conceptual
overview]], recipe repositories are just regular packages, with some
extra code to look up recipes in the relevant local repository.

This means that updating a recipe repository may be done the same way as
updating a regular package, i.e. with
[[#version-control-operations][=M-x straight-pull-package=]]. A
convenience command with interactive completion for recipe repositories,
=straight-pull-recipe-repositories=, is provided as well. You should use
one of these if you find that a package isn't listed by
=M-x straight-use-package=---perhaps it was added recently.

Note that there is currently some potentially surprising behavior if you
update all packages at once using =M-x straight-pull-all= or
=M-x straight-merge-all=, and this bulk update includes recipe
repository updates: see
[[https://github.com/radian-software/straight.el/issues/323][#323]].

**** Customizing recipe repositories
:PROPERTIES:
:CUSTOM_ID: customizing-recipe-repositories
:END:
The recipe repository system is designed to be extended. Firstly, you
can control which recipe repositories are searched, and in what order of
precedence, by customizing =straight-recipe-repositories=. The default
value is:

#+begin_src emacs-lisp
(org-elpa melpa gnu-elpa-mirror el-get emacsmirror)
#+end_src

***** GNU ELPA
:PROPERTIES:
:CUSTOM_ID: gnu-elpa
:END:
You can customize the following user options:

- =straight-recipes-gnu-elpa-url=: The Git URL to use for the =gnu-elpa=
  recipe repository.
- =straight-recipes-gnu-elpa-use-mirror=: GNU ELPA uses a stupidly
  complex build system for no good reason, and it's unlikely to change
  any time soon. What this means for you is that you have to run the
  Elisp-powered Makefile of the GNU ELPA repository (which has a fatal
  bug last I checked, so you'd have to patch it locally) /and/ have a
  full checkout of the Emacs source repository (more than 1GB) if you
  want all the packages to work correctly. To work around this problem,
  I maintain a [[https://github.com/emacs-straight][full mirror of GNU
  ELPA on GitHub]]. (The tooling used to maintain this mirror is located
  [[https://github.com/radian-software/gnu-elpa-mirror][here]].) By
  default, =straight.el= retrieves packages from this mirror instead of
  the source repository; this behavior is controlled by the value of
  =straight-recipes-gnu-elpa-use-mirror=. You must do any customization
  of this variable /before/ the =straight.el=
  [[#getting-started][bootstrap]]. Note that setting the value of this
  user option to nil causes the default value of
  =straight-recipe-repositories= to shift to:

#+begin_src emacs-lisp
(org-elpa melpa gnu-elpa el-get emacsmirror)
#+end_src

***** Emacsmirror
:PROPERTIES:
:CUSTOM_ID: emacsmirror
:END:
You can customize the following user option:

- =straight-recipes-emacsmirror-use-mirror=: Yes, there is also a mirror
  for Emacsmirror. This is because the
  [[https://github.com/emacsmirror/epkgs][epkgs]] repository contains a
  fair amount of metadata, which means it can take a little on the long
  side to clone with slow network connections (see
  [[https://github.com/radian-software/straight.el/issues/356][#356]]
  and
  [[https://github.com/radian-software/straight.el/issues/700][#700]]).
  My solution to this problem is to generate a new repository which
  contains the information that =straight.el= needs but which is much
  smaller. By default, =straight.el= uses the official
  [[https://github.com/emacsmirror/epkgs][epkgs]] repository to find
  packages on Emacsmirror, but you can tell it to use my mirror by
  configuring the value of this variable to non-nil. You must do any
  customization of this variable /before/ the =straight.el=
  [[#getting-started][bootstrap]]. Note that setting the value of this
  user option to non-nil causes the default value of
  =straight-recipe-repositories= to shift to:

#+begin_src emacs-lisp
(org-elpa melpa gnu-elpa-mirror el-get emacsmirror-mirror)
#+end_src

***** Defining new recipe repositories
:PROPERTIES:
:CUSTOM_ID: defining-new-recipe-repositories
:END:
To define a new recipe repository called =NAME=, you should do the
following things:

- Define a function =straight-recipes-NAME-retrieve=, which takes a
  package name as a symbol and returns a recipe for that package if it
  is available, else nil. This is used for recipe lookup. This function
  may assume that the local repository for the recipe repository has
  already been cloned, and that =default-directory= has been set to that
  local repository. This is used for recipe lookup during the course of
  =straight-use-package=.

  If the returned recipe is a backquoted list, it will be evaluated
  during =straight--convert-recipe=. This is useful for specifying
  dynamic elements within the recipe such as system-specific build
  commands. For example, if =straight-recipes-NAME-retrieve= returns:

#+begin_src emacs-lisp
'`( package :type git :repo "host/repo"
    :pre-build ,(pcase system-type
                  (`berkeley-unix '("gmake"))
                  (_ '("make")))
    :files (:defaults))
#+end_src

The recipe is converted to:

#+begin_src emacs-lisp
(package :type git :repo "host/repo"
 :pre-build ("make")
 :files (:defaults))
#+end_src

on a =gnu/linux= system, and:

#+begin_src emacs-lisp
(package :type git :repo "host/repo"
         :pre-build ("gmake")
         :files (:defaults))
#+end_src

on a =berkely-unix= system.

The recipe could be read from a file in the recipe repository as well.
In this case, the quote is /not/ included in the recipe, as
=straight-recipes-NAME-retrieve= would make use of =read=, which will
return the literal Lisp object. For example, considering the following
retrieval function:

#+begin_src emacs-lisp
(defun straight-recipes-example-retrieve (name)
  (with-temp-buffer
    (insert-file-literally "./recipes/example.recipe")
    (read (buffer-string))))
#+end_src

The recipe from above could be stored in the file, =example.recipe=, as:

#+begin_src emacs-lisp
`( package :type git :repo "host/repo"
   :pre-build ,(pcase system-type
                 (`berkeley-unix '("gmake"))
                 (_ '("make")))
   :files (:defaults))
#+end_src

- Define a function =straight-recipes-NAME-list=, which takes no
  arguments and returns a list of strings representing packages for
  which recipes are available. It is permissible to return some strings
  for which recipes are actually not available, for performance reasons.
  However, this is discouraged. (The [[http://melpa.org/#/][MELPA]]
  backend uses this functionality, since all files in the =recipes=
  directory are potentially recipes, but only the Git-based ones can
  actually be used.)
- (Optional) Define a function =straight-recipes-NAME-version= which
  returns a non-nil value indicating the current version of the logic in
  your =straight-recipes-NAME-retrieve= function. Each time you change
  the logic, this version value must be changed. If this function is
  defined, then =straight.el= automatically and transparently caches
  calls to =straight-recipes-NAME-retrieve= persistently, using your
  version value (and its detection of modifications to the recipe
  repository) to decide when to invalidate the cache.
- Call =straight-use-recipes= with the recipe for your recipe
  repository. Make sure to include =:build nil= in the recipe, unless
  you also want to use the recipe repository as an executable Emacs Lisp
  package. Alternatively, you can take the manual approach:
  - Call =straight-use-package-lazy= with the recipe for your recipe
    repository.
  - Add the symbol for your recipe repository's name (the car of the
    recipe you provided, that is) to =straight-recipe-repositories=, at
    the appropriate place.

*** Overriding recipes
:PROPERTIES:
:CUSTOM_ID: overriding-recipes
:END:
You can always use =straight-register-package= to specify a specific
recipe for a package without cloning or building it, so that just in
case that package is requested later (possibly as a dependency, or in
somebody else's code) your recipe will be used instead of the default
one. However, this does not help in the case that a specific recipe is
passed to =straight-use-package=.

Also, it is obviously impossible to call =straight-register-package=
before =straight.el= has been loaded, so you can't use it to specify a
custom recipe for =straight.el= itself.

To remedy these difficulties, =straight.el= provides a mechanism for
specifically overriding the recipe for a particular package. You can use
it by customizing =straight-recipe-overrides=, or by calling
=straight-override-recipe=.

=straight-recipe-overrides= is an association list from
[[#the-profile-system][profile names]] to /override alists/. If you
don't care about the profile system, you can just use a single override
specification, with the profile name nil. Each override alist is just a
list of recipes. Because the car of a recipe is just the package name as
a symbol, this list of recipes is also an alist whose keys are recipe
names and whose values are the plists for those recipes.

Even if an explicit recipe is supplied to =straight-use-package=, the
one given in =straight-recipe-overrides= will be used instead, if such a
recipe is specified there.

For convenience, you may add to =straight-recipe-overrides= by passing a
recipe to =straight-override-recipe=. This will register it in the
override alist for the current profile. Note that if you do this, you
will probably want to explicitly set =straight-recipe-overrides= to nil
before bootstrapping =straight.el=. This will make it so that if you
remove a call to =straight-override-recipe= from your init-file and then
reload it, the entry will actually be removed from
=straight-recipe-overrides=.

**** Overriding the recipe for =straight.el=
:PROPERTIES:
:CUSTOM_ID: overriding-the-recipe-for-straight.el
:END:
As was briefly mentioned earlier, you can actually override the recipe
of =straight.el= itself using =straight-recipe-overrides=! How does this
work? Well, it's basically black magic. If you want the details, go read
the [[#developer-manual][developer manual]]. All you need to know is
that you can set =straight-recipe-overrides=, and it will magically
work. The only caveat is that if you change the =:local-repo= for
=straight.el=, then you will also need to adjust the value of
=bootstrap-file= in the [[#getting-started][bootstrap snippet]]
accordingly, since otherwise your init-file will not know where to find
=straight.el=. (You must use =straight-recipe-overrides= instead of
=straight-override-recipe=, since the latter function definition hasn't
been loaded yet before =straight.el= is installed and bootstrapped.)

Here is the default recipe used for =straight.el=, if you don't override
it:

#+begin_src emacs-lisp
(straight :type git :host github
          :repo ,(format "%s/straight.el" straight-repository-user)
          :files ("straight*.el")
          :branch ,straight-repository-branch)
#+end_src

Note that even though the bootstrap snippet references the =develop=
branch of =straight.el=, the default recipe installs from =master=.

If all you want to do is change which branch you are installing
=straight.el= from, simply customize the variable
=straight-repository-branch=, which is provided for this purpose.
(Although using =straight-recipe-overrides= will work just as well, at
least until the recipe happens to be changed upstream and your init-file
isn't updated.)

Similarly, if all you want to do is switch to your own fork of
=straight.el= on GitHub, simply customize the variable
=straight-repository-user= to your GitHub username.

There is one minor caveat to the above discussion. If your fork makes
changes to the way in which recipes are interpreted, then those changes
will not be effective during the interpretation of your own recipe for
=straight.el=. If you wish for them to be, then you will have to follow
the same procedure that is followed in =straight.el= itself for making
changes to recipe interpretation. These details are outlined in the
[[#developer-manual][developer manual]]; see also =install.el= for an
explanation of this aspect of the bootstrap mechanism.

*** Interactive usage
:PROPERTIES:
:CUSTOM_ID: interactive-usage
:END:
The primary usage of =straight.el= is expected to be in your init-file.
For example, this is where you will need to put the bootstrap code as
well as any packages that you always want to be installed. However,
there are three important interactive uses of =straight.el=: temporary
installation of packages, various helpful utility functions, and
[[#version-control-operations][version control operations]].

To install a package temporarily, run =M-x straight-use-package=. All
registered recipe repositories will be cloned, and you will be presented
with a combined list of all recipes available from them. Simply select a
package and it will be cloned, built, and loaded automatically. This
does not affect future Emacs sessions.

If you provide a prefix argument to =M-x straight-use-package=, then you
are presented with a list of registered recipe repositories. After you
select one, you are shown a list of recipes specifically from that
recipe repository. This is helpful if you do not want to clone all
registered recipe repositories, or you have a particular recipe
repository in mind.

You can also call =M-x straight-get-recipe=, which has the same
interface as =M-x straight-use-package=, except that instead of the
package being cloned, built, and loaded, its recipe is copied to the
kill ring. If you are writing a custom recipe, this may be helpful,
because you may be able to reuse parts of the existing recipe,
particularly the =:files= directive.

Normally, packages are rebuilt automatically if needed, when Emacs
restarts. If you for some reason want them to be rebuilt at another
time, you can call =M-x straight-check-all= to rebuild all packages that
have been modified since their last build. Alternatively, use
=M-x straight-rebuild-all= to unconditionally rebuild all packages. Note
that this will probably take a while. There are also
=M-x straight-check-package= and =M-x straight-rebuild-package=, which
allow you to select a particular package to check or rebuild.

Finally, you may use =M-x straight-prune-build= in order to tell
=straight.el= to forget about any packages which were not registered
since the last time you loaded your init-file. This may improve
performance, although only slightly, and will clean up stale entries in
the =build= directory. You can call this function in your init-file if
you really wish your filesystem to be as clean as possible, although
it's not particularly recommended as the performance implications are
uninvestigated. If you do call it in your init-file, be sure to only
call it on a fully successful init; otherwise, an error during init will
result in some packages' build information being discarded, and they
will need to be rebuilt next time.

If you have enabled
[[#customizing-how-packages-are-made-available][autoloads caching]], it
is advisable to call =straight-prune-build= occasionally, since
otherwise the build cache may grow quite large over time.

**** Version control operations
:PROPERTIES:
:CUSTOM_ID: version-control-operations
:END:
=straight.el= provides a number of highly interactive workflows for
managing your package's local repositories, using the configured
[[#version-control-backends][version-control backends]]. They are as
follows:

- =M-x straight-normalize-package=: normalize a package
- =M-x straight-normalize-all=: normalize all packages
- =M-x straight-fetch-package=: fetch from a package's configured
  remote; with prefix argument, then for forks also fetch from the
  upstream
- =M-x straight-fetch-package-and-deps=: fetch from the configured
  remotes of a package and all of its dependencies (including the
  dependencies of its dependencies); with prefix argment, then for forks
  also fetch from the upstream
- =M-x straight-fetch-all=: fetch from all packages' configured remotes;
  with prefix argument, then for forks also fetch from the upstreams
- =M-x straight-merge-package=: merge the latest version fetched from a
  package's configured remote into the local copy; with prefix argument,
  then for forks also merge from the upstream
- =M-x straight-merge-package-and-deps=: merge the latest versions
  fetched from the configured remotes of a package and all of its
  dependencies (including the dependencies of its dependencies); with
  prefix argment, then for forks also merge from the upstreams
- =M-x straight-merge-all=: merge the latest versions fetched from each
  package's configured remote into its local copy; with prefix argument,
  then for forks also merge from the upstreams
- =M-x straight-pull-package=: combination of
  =M-x   straight-fetch-package= and =M-x straight-merge-package=
- =M-x straight-pull-package-and-deps=: combination of
  =M-x   straight-fetch-package-and-deps= and
  =M-x   straight-merge-package-and-deps=
- =M-x straight-pull-all=: combination of =M-x straight-fetch-all= and
  =M-x straight-merge-all=
- =M-x straight-push-package=: push a package to its remote, if
  necessary
- =M-x straight-push-all=: push all packages to their remotes, if
  necessary

See the sections on [[#version-control-backends][version-control
backends]] and the [[#git-backend][Git backend]] in particular for more
information about the meanings of these operations.

*** Lockfile management
:PROPERTIES:
:CUSTOM_ID: lockfile-management
:END:
=straight.el= determines your package management configuration from two,
and only two, sources: the contents of your init-file, and your version
lockfiles (which are optional). Your init-file specifies the
configuration of =straight.el= (for example, the values of
=straight-recipe-overrides= and =straight-default-vc=), the packages you
want to use, and their recipes. Your version lockfiles specify the exact
revisions of each package, recipe repository, and even =straight.el=
itself. Together, they lock down your Emacs configuration to a state of
no uncertainty: perfect reproducibility.

To write the current revisions of all your packages into version
lockfiles, run =M-x straight-freeze-versions=. This will first check
that =straight.el= has an up-to-date account of what packages are
installed by your init-file, then ensure that all your local changes are
pushed (remember, we are aiming for perfect reproducibility!). If you
wish to bypass these checks, provide a prefix argument.

*Note: reloading your init-file must have the effect of running all of
the same =straight.el=-related functions again. For example, if you
bootstrap =straight.el= in a sub-file that you only =require= instead of
=load=, then the reloading functionality will not work correctly and you
may receive the message
=Caches are still outdated; something is seriously wrong=. See
[[https://github.com/radian-software/straight.el/issues/437][#437]] for
discussion.*

Version lockfiles are written into =~/.emacs.d/straight/versions=. By
default, there will be one, called =default.el=. It is recommended that
you keep your version lockfiles under version control with the rest of
your Emacs configuration. If you symlink your init-file into
=~/.emacs.d= from somewhere else, you should also make sure to symlink
your version lockfiles into =~/.emacs.d/straight/versions=. On a new
machine, do this /before/ launching Emacs: that way, =straight.el= can
make sure to check out the specified revisions of each package when
cloning them for the first time.

To install the versions of the packages specified in your version
lockfiles, run =M-x straight-thaw-versions=. Thawing will interactively
check for local changes before checking out the relevant revisions, so
don't worry about things getting overwritten.

**** The profile system
:PROPERTIES:
:CUSTOM_ID: the-profile-system
:END:
=straight.el= has support for writing multiple version lockfiles,
instead of just one. Why? Consider a large Emacs configuration such as
[[https://github.com/radian-software/radian][Radian]],
[[http://spacemacs.org/][Spacemacs]], or
[[https://github.com/bbatsov/prelude][Prelude]], which is used by many
different people. There are two parts to the configuration that is
actually loaded: the "default" part, and the local customizations that
each user has added. Generally, these configurations have a mechanism
for making local customizations without forking the entire project.

So Radian will have some set of packages that it requires, and my local
customizations of Radian have some other set of packages that they
require. In order for me to maintain Radian, I need to be able to
separate Radian's packages (which go into a versions lockfile in the
Radian repository) from my own local packages (which go into a versions
lockfile in my own private local dotfiles repository). =straight.el=
provides this ability through the /profile system/.

The idea is that whenever a package is registered, either directly or as
a dependency, it is associated with a given profile. Any given package
can be associated with multiple profiles.

When you call =straight-use-package=, which profile the registered
packages are associated with is determined by the value of
=straight-current-profile=, which defaults to nil. In Radian, for
example, =straight-current-profile= is bound to =radian= while the
Radian libraries are being loaded, and it is bound to =radian-local=
while the user's local customizations are being loaded. This results in
Radian packages being associated with the =radian= profile, and the
user's local packages being associated with the =radian-local= profile.

When you call =M-x straight-freeze-versions=, one or more version
lockfiles are written, according to the value of =straight-profiles=.
This variable is an association list whose keys are symbols naming
profiles and whose values are filenames for the corresponding version
lockfiles to be written into =~/.emacs.d/straight/versions=. You should
make sure that each potential value of =straight-current-profile= has a
corresponding entry in =straight-profiles=, since otherwise some
packages might not be written into your lockfiles.

When customizing [[#overriding-recipes][=straight-recipe-overrides=]],
note that if multiple profiles are set to override the same recipe, then
the last one listed in =straight-profiles= will take precedence.
Similarly, when using =M-x straight-thaw-versions=, if different
lockfiles specify revisions for the same local repository, the last one
in =straight-profiles= will take precedence.

*** Packages and the init-file
:PROPERTIES:
:CUSTOM_ID: packages-and-the-init-file
:END:
Package managers like =package.el= store mutable state outside your
init-file, including the set of packages that are installed.
=straight.el= does not do this, so it has a rather different way of
determining what packages are installed. To =straight.el=, a package is
part of your Emacs configuration if it is passed to
=straight-use-package= when your init-file is loaded.

Note that this means packages installed interactively (using
=M-x straight-use-package=) are not considered part of your Emacs
configuration, since the invocation of =straight-use-package= does not
happen in your init-file.

This raises an interesting question: if you /add/ a package to your
init-file, how can you convince =straight.el= that it really is part of
your init-file, and not just part of a temporary =straight-use-package=
form that you evaluated ad-hoc? The answer is simple: /reload your
entire init-file/. That way, =straight.el= will see whether or not that
package is registered during your init-file.

One might ask how =straight.el= determines that you have finished
loading your init-file. The answer is simple: =post-command-hook= is
used to execute code only after the current interactive operation has
finished. The implementation of this concept is part of the /transaction
system/ of =straight.el=, and it is also used to amortize certain
performance costs when many calls to =straight-use-package= are made
sequentially. However, since the transaction system (at least in recent
versions of =straight.el=) operates transparently, its details are
relegated to the [[#developer-manual][developer manual]].


*** Using =straight.el= to reproduce bugs
:PROPERTIES:
:CUSTOM_ID: using-straight.el-to-reproduce-bugs
:END:
**** ... in other packages
:PROPERTIES:
:CUSTOM_ID: in-other-packages
:END:
One of the major reasons I wanted to write =straight.el= was that
existing package managers were not good for reproducing bugs. For
instance, some of them would load all installed packages when the
package manager was initialized! Obviously that is not acceptable for a
"minimal test case".

On the contrary, bootstrapping =straight.el= does not load anything
except for =straight.el= itself (the default recipe repositories are
registered, but not cloned until needed). You should normally be loading
=straight.el= by means of the [[#getting-started][bootstrap snippet]],
but when you are in =emacs -Q=, here is how you can initialize
=straight.el=:

#+begin_example
M-x load-file RET ~/.emacs.d/straight/repos/straight.el/bootstrap.el RET
#+end_example

You can also do this from the command line, perhaps by creating an alias
for it:

#+begin_example
$ emacs -Q -l ~/.emacs.d/straight/repos/straight.el/bootstrap.el
#+end_example

Let's say you are making a bug report for Projectile. To load just
Projectile and all of its dependencies, run:

#+begin_example
M-x straight-use-package RET projectile RET
#+end_example

Note that this will use the currently checked-out revisions of
Projectile and all of its dependencies, so you should take note of those
in order to make your bug report.

**** ... in =straight.el= itself
:PROPERTIES:
:CUSTOM_ID: in-straight.el-itself
:END:
=straight.el= provides a macro, =straight-bug-report=, to test
=straight.el= in a clean environment. If possible, please use this when
creating bug reports.

=straight-bug-report= accepts the following keyword value pairs:

- =:pre-bootstrap (Form)...= Forms evaluated before bootstrapping
  =straight.el= e.g.

#+begin_src emacs-lisp
(setq straight-repository-branch "develop")
#+end_src

#+begin_example
Note this example is already in the default bootstrapping code.
#+end_example

- =:post-bootstrap (Form)...= Forms evaluated in the testing environment
  after boostrapping. e.g.

#+begin_src emacs-lisp
(straight-use-package '(example :type git :host github))
#+end_src

- =:interactive Boolean= If nil, the subprocess will immediately exit
  after the test. Output will be printed to
  =straight-bug-report--process-buffer= Otherwise, the subprocess will
  be interactive.

- =:preserve Boolean= If t, the test directory is left in the directory
  stored in the variable `temporary-file-directory'. Otherwise, it is
  immediately removed after the test is run.

- =:executable String= Indicate the Emacs executable to launch. Defaults
  to ="emacs"=.

- =:raw Boolean= If t, the raw process output is sent to
  =straight-bug-report--process-buffer=. Otherwise, it is formatted as
  markdown for submitting as an issue.”

For example:

#+begin_src emacs-lisp
(straight-bug-report
  :pre-bootstrap
  (message "before bootstrap")
  (message "multiple forms allowed")
  :post-bootstrap
  (message "after bootstrap")
  (message "multiple forms allowed")
  (straight-use-package '(my-broken-package))
  (message "bye"))
#+end_src

The above will run your test in a clean environment and produce a buffer
with information you can paste directly into the issue body.

*** Using =straight.el= to develop packages
:PROPERTIES:
:CUSTOM_ID: using-straight.el-to-develop-packages
:END:
The workflow for developing a package using =straight.el= is quite
straightforward: * Add the package to your configuration as usual, via a
call to =straight-use-package=. * Use =M-x find-function= or a similar
command to jump to the code you wish to edit. * Edit the code. * Either
evaluate the edited code using =M-x eval-buffer=, =M-x   eval-defun=, or
a similar command, or just restart Emacs to pick up your changes. * When
you are satisfied with your changes, use [[https://magit.vc/][Magit]] or
just Git directly in order to commit and possibly push them. I suggest
using [[https://github.com/magit/forge][Forge]] to create pull requests
directly from Emacs, with Magit integration.

*** Integration with other packages
:PROPERTIES:
:CUSTOM_ID: integration-with-other-packages
:END:
**** Integration with =use-package=
:PROPERTIES:
:CUSTOM_ID: integration-with-use-package-1
:END:
By default, =straight.el= installs a new keyword =:straight= for
=use-package= which may be used to install packages via =straight.el=.
The algorithm is extremely simple. This:

#+begin_src emacs-lisp
(use-package el-patch
  :straight t)
#+end_src

macroexpands (essentially) to:

#+begin_src emacs-lisp
(straight-use-package 'el-patch)
#+end_src

And this:

#+begin_src emacs-lisp
(use-package el-patch
  :straight (:host github :repo "radian-software/el-patch"
             :branch "develop"))
#+end_src

becomes:

#+begin_src emacs-lisp
(straight-use-package
 '(el-patch :host github :repo "radian-software/el-patch"
            :branch "develop"))
#+end_src

If the feature you are requiring with =use-package= is different from
the package name, you can provide a full recipe:

#+begin_src emacs-lisp
(use-package tex-site
  :straight (auctex :host github
                    :repo "emacsmirror/auctex"
                    :files (:defaults (:exclude "*.el.in"))))
#+end_src

And you may also provide just the package name:

#+begin_src emacs-lisp
(use-package tex-site
  :straight auctex)
#+end_src

If you don't provide =:straight=, then by default nothing happens. You
may customize =straight-use-package-by-default= to make it so that
=:straight t= is assumed unless you explicitly override it with
=:straight nil=.

Previously, =straight.el= used a different syntax for its =use-package=
integration. For backwards compatibility, you can use this syntax
instead by customizing =straight-use-package-version=.

You can disable =use-package= integration entirely by customizing
=straight-enable-use-package-integration=.

***** Loading packages conditionally
:PROPERTIES:
:CUSTOM_ID: loading-packages-conditionally
:END:
=use-package= has various features intended to support code being
executed conditionally for a package. For example, the =:when= keyword
lets you provide a form that will essentially disable the =use-package=
form if it evaluates to nil.

However, when using the =:straight= keyword, either explicitly or via
=straight-use-package-by-default=, then =:when= has no effect on it.
=straight.el= is invoked unconditionally. The reason for this behavior
is that if you invoke =straight-use-package= on a different set of
packages during different init sessions, then your version lockfile
would end up containing different sets of packages depending on which
session you generated it in.

Currently, the officially recommended pattern for conditionally loading
a package is the following:

#+begin_src elisp
(straight-register-package 'foobar)
(when some-condition
  (use-package foobar
    :straight t))
#+end_src

This ensures that the package is registered to =straight.el=, so it will
be cloned if absent, and will be added to the lockfile, but it will not
be compiled or loaded unless the subsequent =use-package= form is
evaluated. You can also invoke =straight-register-package= only in the
case that =some-condition= is nil; either way will produce the same
result with roughly the same performance due to idempotency and caching.

If you do this for a lot of packages, it may be advisable to wrap it in
a macro, as
[[https://github.com/radian-software/radian/blob/20c0c9d929a57836754559b470ba4c3c20f4212a/emacs/radian.el#L606-L619][my
own Emacs configuration Radian does]] in the macro =radian-use-package=.
It would be a good idea if =straight.el= did this by default in its
=use-package= integration but this has not been implemented yet.

If you want to not even clone a package when it is disabled, you can
also technically achieve it by simply making the entire =use-package=
form conditional, without using =straight-register-package=. However,
this is not recommended because it will cause the generated lockfile to
be deterministic, so =straight.el= will not be changed to make =:when=
act that way by default.

It would be desirable if you could clone a package conditionally without
breaking the lockfile functionality; this is a hopefully planned future
feature, but it needs design work.

**** "Integration" with =package.el=
:PROPERTIES:
:CUSTOM_ID: integration-with-package.el
:END:
By default, =package.el= will automatically insert a call to
=package-initialize= into your init-file as soon as Emacs starts, which
is ridiculous. It will also do this when you perform any package
management operation. A separate system inserts some =custom= forms into
your init-file when you install a package. =straight.el= disables all of
these "features" by setting =package-enable-at-startup= to nil and
enabling some advices. You can override this behavior by customizing
=straight-enable-package-integration=, however.

To help avoid you shooting yourself in the foot by using both =:ensure=
and =:straight= at the same time in a =use-package= form (which would
cause the same package to be installed twice using two different package
managers), =straight.el= will helpfully disable =:ensure= whenever you
include =:straight= in a =use-package= form. See
[[https://github.com/radian-software/straight.el/issues/425][#425]].

**** Integration with Flycheck
:PROPERTIES:
:CUSTOM_ID: integration-with-flycheck
:END:
[[https://www.flycheck.org/en/latest/][Flycheck]] sometimes creates
temporary files in order to perform syntax checking. This is a problem
for =straight.el= because creation of temporary files will cause
=straight.el= to think that you have modified a package when you
actually have not. (You might ask why =straight.el= cannot recognize
temporary files and ignore them. The answer is that for eager
modification checking, all we see is that the directory mtime for the
repository has been updated, and there's no way to disambiguate between
temporary file shenanigans versus if you, say, deleted a file.)

To work around the problem, a user option =straight-fix-flycheck= is
provided, disabled by default (for now). You can enable it /before/
loading =straight.el=, and it will work around the Flycheck problem in
the following way. When you first visit a buffer, any Flycheck checker
that involves creation of temporary files will be inhibited
automatically, although other checkers will still run. (In practice this
means no byte-compilation errors for Emacs Lisp, but you still get
Checkdoc errors.) However, after you make a change to the buffer (by
typing, etc.) then all checkers will be re-enabled. This means that
=straight.el= won't think the package was modified unless you actually
modify the buffer of a file inside it, which I think is a reasonable
compromise.

See [[https://github.com/radian-software/straight.el/issues/508][#508]]
for discussion.

**** Integration with Hydra
:PROPERTIES:
:CUSTOM_ID: integration-with-hydra
:END:
See [[https://github.com/abo-abo/hydra/wiki/straight.el][the Hydra
wiki]].

*** Miscellaneous
:PROPERTIES:
:CUSTOM_ID: miscellaneous
:END:
- By default, =straight.el= explains what it is doing in the echo area,
  like this:

#+begin_example
Looking for cider recipe → Cloning melpa...
#+end_example

If your terminal does not support Unicode characters nicely, you can
customize =straight-arrow= to display something else for the arrow.

- By default, =straight.el= reports process output the
  =*straight-process*= buffer. You can customize the name of this buffer
  via the =straight-process-buffer= user option. If you want to hide
  this buffer by default, consider adding a leading space to the name.

- You can prevent =straight.el= from making any modifications to the
  filesystem (though it may still read) by customizing the user option
  =straight-safe-mode= to non-nil. This may be useful for running tasks
  automatically in batch mode, to avoid multiple concurrent Emacs
  processes all making changes to the filesystem. For an example of how
  this feature may be used to safely implement asynchronous
  byte-compilation of the init-file on successful startup, see
  [[https://github.com/radian-software/radian][Radian]].



** Developer manual
:PROPERTIES:
:CUSTOM_ID: developer-manual
:END:
This section tells you about all the interesting implementation details
and design decisions that power =straight.el= behind the scenes. It
assumes you have already read the [[#user-manual][user manual]] and the
[[#conceptual-overview][conceptual overview]].

More to be written here in future. See
[[https://github.com/radian-software/straight.el/issues/51][#51]].

*** Low-level functions
:PROPERTIES:
:CUSTOM_ID: low-level-functions
:END:
- The function =straight-chase-emulated-symlink= is provided in order
  for external packages to correctly handle the emulated symlinks
  created by =straight.el= when =straight-use-symlinks= is nil. See, for
  example,
  [[https://github.com/radian-software/straight.el/issues/520][#520]].



** Trivia
:PROPERTIES:
:CUSTOM_ID: trivia
:END:
This section has random, (possibly) interesting tidbits about
=straight.el= that don't fit in the other sections.

*** Comments and docstrings
:PROPERTIES:
:CUSTOM_ID: comments-and-docstrings
:END:
How did I get that statistic about the percentage of =straight.el= that
is comments and docstrings? Simple: by abusing the syntax highlighting.

#+begin_src emacs-lisp
(let ((lines (make-hash-table :test #'equal)))
  (goto-char (point-min))
  (while (< (point) (point-max))
    (when (memq (face-at-point)
                '(font-lock-comment-face
                  font-lock-doc-face))
      (puthash (line-number-at-pos) t lines))
    (forward-char))
  (* (/ (float (length (hash-table-keys lines)))
        (line-number-at-pos))
     100))
#+end_src

Note that you will have to scroll through the entire buffer first, since
=font-lock-mode= computes syntax highlighting lazily.


** Contributing
:PROPERTIES:
:CUSTOM_ID: contributing
:END:
Please do! Development takes place on the =develop= branch. You can
switch to that branch with

#+begin_src emacs-lisp
(setq straight-repository-branch "develop")
#+end_src

and base your pull requests from it. If you have an outstanding pull
request whose features you would like to use in your configuration,
there is full support for defining =straight.el= as coming from any
branch in any fork:

#+begin_src emacs-lisp
(setq straight-repository-user "my-github-username")
(setq straight-repository-branch "feat/my-cool-feature")
#+end_src

For additional information, please see
[[https://github.com/radian-software/contributor-guide][the contributor
guide for my projects]]. Note that =straight.el= has not yet had an
initial release, so you don't have to worry about a changelog.


** FAQ
:PROPERTIES:
:CUSTOM_ID: faq
:END:
*** My init time got slower
:PROPERTIES:
:CUSTOM_ID: my-init-time-got-slower
:END:
Your first step should be to customize the value of
=straight-check-for-modifications=. The best setting is
=(watch-files find-when-checking)=; this is not enabled by default
because it is impolite to spawn persistent background processes without
asking, and because you must install [[https://www.python.org/][Python
3]] and [[https://github.com/mattgreen/watchexec][=watchexec=]] for it
to work. If you can't stand the extra dependencies and background
process, consider the setting =(check-on-save find-when-checking)=
instead, which is just as fast but won't catch package modifications
unless they are made within Emacs via the =save-buffer= command.

Even with lazy modification detection, as described above, =straight.el=
is not quite as fast as =package.el= (by a few percentage points). There
are some planned changes which will make =straight.el= just as fast as
=package.el=, if not faster. See
[[https://github.com/radian-software/straight.el/issues/9][#9]].

*** "Could not find package in recipe repositories"
:PROPERTIES:
:CUSTOM_ID: could-not-find-package-in-recipe-repositories
:END:
Assuming that the package you're trying to install actually exists, you
need to update your recipe repositories (most likely MELPA, possibly
Emacsmirror). See the next FAQ entry. This is like running
=package-refresh-contents= under =package.el=.

Another possibility is that you are providing =straight.el= with a
feature name rather than a package name. Features are what you load with
=require= or =load=, or find in files. For example, =org-agenda= and
=org-capture= are features. Packages, on the other hand, can provide one
or more features. They are what are listed on MELPA et al. or by
=M-x straight-get-recipe=. For example, =org= and =org-contrib= are
packages.

When you write =(use-package foo ...)=, the =foo= is a /feature/, not a
package. You can give a different package name =bar= by saying
=(use-package foo :straight bar)=. And when you write
=(straight-use-package 'bar)=, the =bar= is a /package/, not a feature.

*** How do I update MELPA et al.?
:PROPERTIES:
:CUSTOM_ID: how-do-i-update-melpa-et-al.
:END:
Using [[#version-control-operations][=M-x straight-pull-package=]], like
for any other package. [[#updating-recipe-repositories][Read more.]]

*** My =use-package= form isn't working properly
:PROPERTIES:
:CUSTOM_ID: my-use-package-form-isnt-working-properly
:END:
There are a number of common problems you might be encountering. Check
out the following list to see if there is an easy fix.

- Make sure you're not using =:ensure= or =use-package-always-ensure=.
  Those are for =package.el= and using them with =straight.el= will
  produce weird results (namely both =package.el= and =straight.el= will
  be invoked for the same package).
- Make sure you know /both/ the name of the feature and the name of the
  package. These are usually the same but not always (packages may
  provide more than one feature, ...). You give =use-package= the name
  of a /feature/, not a package (despite the name of the macro). With
  =straight-use-package-by-default= or with =:straight t=, the default
  is to try installing a package by the same name as the feature.
  - If you don't actually need to install a package, then pass
    =:straight nil= to override =straight-use-package-by-default=.
  - If the package name is different from the feature name, then pass
    =:straight <package-name>=.
- If the package or your configurations aren't being loaded, you
  probably have something wrong with your usage of =:init= and
  =:config=. By default, the behavior of =use-package= is unusably
  inconsistent. You must set either =use-package-always-defer= (override
  with =:demand t=) or =use-package-always-demand= (override with
  =:defer t=) to set a default for whether evaluating a =use-package=
  form will load the package and your configurations.
  - If you've set a package to be deferred, you then need to make sure
    there's a way for it to get loaded when needed, for example by means
    of an autoload (either provided by the package, or set up
    automatically by =use-package= via =:bind=, or set up manually
    through =use-package= via =:commands=) or by an explicit =require=
    in one of your custom commands.

*** How do I uninstall a package?
:PROPERTIES:
:CUSTOM_ID: how-do-i-uninstall-a-package
:END:
My first question is: do you really need to uninstall the package? Under
=package.el=, every package on disk gets loaded into Emacs, whether you
asked for it or not. However, under =straight.el=, only the packages you
explicitly mention in your init-file get loaded into Emacs. So the
/only/ problem with leaving a package on disk is that it takes up a
little bit of disk space. (But the advantage is if you decide you want
to use that package again later then you won't have to redownload it.)

If you really want to uninstall a package, simply delete its local
repository from =~/.emacs.d/straight/repos= or run the
=straight-remove-unused-repos= command.

*** The wrong version of my package was loaded
:PROPERTIES:
:CUSTOM_ID: the-wrong-version-of-my-package-was-loaded
:END:
To explain this problem, let us consider a concrete example. In
[[https://github.com/radian-software/straight.el/issues/355][this
issue]], a user found that the code

#+begin_src emacs-lisp
(straight-use-package 'company-lsp)
(straight-use-package 'eglot)
#+end_src

sometimes resulted in runtime errors because an old version of Flymake
was being used.

The root problem here is that you want the most recent version of
Flymake to be installed by =straight.el=, but Emacs also ships an older
version, and that older version is getting loaded instead.

The older version will be loaded if =(require 'flymake)= (or similar) is
invoked before =straight.el= has made Flymake available (by means of
=(straight-use-package 'flymake)= or similar). But why would
=straight.el= not make Flymake available?

The only way that =straight.el= knows to make Flymake available is if
either you manually invoke =straight-use-package= in your init-file, or
if one of the packages that you request in your init-file declares
Flymake as a dependency. Now, any package that uses Flymake ought to
declare it as a dependency. Thus, there should be no way for a package
to load the Emacs-provided version of Flymake. However, sometimes
package authors overlook this problem (it does not always cause an
error, and sometimes package authors do not test exhaustively enough).

In this case, the problem was that =company-lsp= declared a dependency
on =lsp-mode=, and =lsp-mode= used Flymake without declaring a
dependency on =flymake=. There are two ways to work around the problem:

- (Preferable) Fix =lsp-mode= to declare a dependency on =flymake=.
- (Workaround) Manually invoke =(straight-use-package 'flymake)= before
  =(straight-use-package 'company-lsp)=.

If you test this yourself, you might find it difficult to reproduce the
problem. That is because there is only an issue when Flymake is actually
loaded, and this doesn't necessarily happen when invoking
=(straight-use-package 'company-lsp)= /unless/ =straight.el= needs to
rebuild the relevant packages (which includes byte-compilation, which
sometimes means actually loading dependencies). Keep this in mind when
testing.

This problem commonly occurs with Org, since (1) Org is popular, (2)
Emacs ships an obsolete version of Org, (3) many users want to use the
up-to-date version, and (4) Org breaks backwards compatibility
frequently. To solve it, simply make sure that you invoke
=(straight-use-package 'org)= before running any code that could load
Org, including installing any package that lists it as a dependency.

See [[https://github.com/radian-software/straight.el/issues/236][this
issue]] for discussion about ways of mitigating the bad UX of this
situation.

*** I get "could not read username/password" errors
:PROPERTIES:
:CUSTOM_ID: i-get-could-not-read-usernamepassword-errors
:END:
This is because =straight.el= is not currently able to detect when SSH
or Git asks for your username and/or password/passphrase and then pipe
that prompt through to the minibuffer
([[https://github.com/radian-software/straight.el/issues/334][#334]]).

To work around the problem, set up
[[https://git-scm.com/docs/git-credential-cache][git-credential-cache]]
if you use HTTPS, and [[https://www.ssh.com/ssh/agent][ssh-agent]] if
you use SSH. That way, you won't be prompted for your username/password.
When setting up ssh-agent, be careful to make sure that the relevant
environment variables get set in Emacs. This might be tricky since
starting Emacs from the desktop (rather than from the command line)
sometimes results in it not inheriting any environment variables from
your shell.

*** How do I pin package versions or use only tagged releases?
:PROPERTIES:
:CUSTOM_ID: how-do-i-pin-package-versions-or-use-only-tagged-releases
:END:
This is a planned feature. In the meantime, contributors have proposed
various workarounds. See
[[https://github.com/radian-software/straight.el/issues/246][#246]] and
[[https://github.com/radian-software/straight.el/issues/31][#31]].

=straight-x.el= now contains an experimental solution. In order to use
it you will need to add similar snippets to your Emacs configuration.

First you need to add a new profile to =straight-profiles= which also
needs to be the last profile in the list. This should be done before you
bootstrap =straight.el=.

#+begin_src emacs-lisp
;; Tell straight.el about the profiles we are going to be using.
(setq straight-profiles
      '((nil . "default.el")
        ;; Packages which are pinned to a specific commit.
        (pinned . "pinned.el")))
#+end_src

After straight's install procedure you will need to add =straight-x.el=
and load the required commands.

#+begin_src emacs-lisp
(autoload #'straight-x-pull-all "straight-x")
(autoload #'straight-x-freeze-versions "straight-x")
#+end_src

A variable called =straight-x-pinned-packages= has been defined in
=straight-x.el= and will contain your list of pinned packages.

From now on, you can pin a package to a specific commit like in the
following example which will pin =org-mode= to the 9.2.3 release
version:

#+begin_src emacs-lisp
(let ((straight-current-profile 'pinned))
  (straight-use-package 'org)
  (straight-use-package 'org-contrib)
  ;; Pin org-mode version.
  (add-to-list 'straight-x-pinned-packages
               '("org" . "924308a150ab82014b69c46c04d1ab71e874a2e6")))
#+end_src

If you invoke =straight-x-freeze-versions= it will first write the
default lockfile and then pinned lockfile which takes precedence over
the default one if packages are thawed. =straight-x-pull-all= will first
invoke =straight-pull-all= and then restore all pinned packages.

You might want to assign the following aliases for more convenience:

#+begin_src emacs-lisp
(defalias 'straight-pull-all #'straight-x-pull-all)
(defalias 'straight-freeze-versions #'straight-x-freeze-versions)
#+end_src

Please keep in mind that this is only a temporary solution and
experimental!

*** How can I use the built-in version of a package?
:PROPERTIES:
:CUSTOM_ID: how-can-i-use-the-built-in-version-of-a-package
:END:
To tell =straight.el= that you want to use the version of Org shipped
with Emacs, rather than cloning the upstream repository:

#+begin_src emacs-lisp
(straight-use-package '(org :type built-in))
#+end_src

Note that =:type= is a keyword for =straight.el=, not for =use-package=.
If you are using =use-package=, then use:

#+begin_src emacs-lisp
(use-package org :straight (:type built-in))
#+end_src

[[#the-recipe-format][Read more.]]

** News
:PROPERTIES:
:CUSTOM_ID: news
:END:
*** Jan 1, 2021
:PROPERTIES:
:CUSTOM_ID: jan-1-2021
:END:
Breaking change: The previous behavior of the =:build= keyword is now
associated with the =:pre-build= keyword. =:build= is now used to
specify build steps (generating autoloads and texinfo, byte/native
compilation, etc). For more information on both of these keywords see
[[#the-recipe-format][the recipe format]].

The following customization variable names have changed:

- =straight-disable-byte-compilation= is now =straight-disable-compile=

- =straight-disable-native-compilation= is now
  =straight-disable-native-compile=

*** April 19, 2020
:PROPERTIES:
:CUSTOM_ID: april-19-2020
:END:
Shallow clones are now compatible with lockfiles, so you can safely set
=straight-vc-git-default-clone-depth= to =1= and get massive savings on
network bandwidth and disk space.






* Customizing Specific Items

M-x customize-option RET option RET
M-x customize-variable RET option RET
Set up a customization buffer for just one user option, option.

M-x customize-face RET face RET
Set up a customization buffer for just one face, face.

M-x customize-icon RET face RET
Set up a customization buffer for just one icon, icon.

M-x customize-group RET group RET
Set up a customization buffer for just one group, group.

M-x customize-apropos RET regexp RET
Set up a customization buffer for all the settings and groups that match regexp.

M-x customize-changed RET version RET
Set up a customization buffer with all the user options, faces and groups whose meaning has changed since (or been added after) Emacs version version.

M-x customize-saved
Set up a customization buffer containing all settings that you have saved with customization buffers.

M-x customize-unsaved
Set up a customization buffer containing all settings that you have set but not saved.

If you want to customize a particular user option, type M-x customize-option. This reads the variable name, and sets up the customization buffer with just that one user option. When entering the variable name into the minibuffer, completion is available, but only for the names of variables that have been loaded into Emacs.

Likewise, you can customize a specific face using M-x customize-face. You can set up a customization buffer for a specific customization group using M-x customize-group.

M-x customize-apropos prompts for a search term—either one or more words separated by spaces, or a regular expression—and sets up a customization buffer for all loaded settings and groups with matching names. This is like using the search field at the top of the customization buffer (see Customization Groups).

When you upgrade to a new Emacs version, you might want to consider customizing new settings, and settings whose meanings or default values have changed. To do this, use M-x customize-changed and specify a previous Emacs version number using the minibuffer. It creates a customization buffer which shows all the settings and groups whose definitions have been changed since the specified version, loading them if necessary.

If you change settings and then decide the change was a mistake, you can use two commands to revisit your changes. Use M-x customize-saved to customize settings that you have saved. Use M-x customize-unsaved to customize settings that you have set but not saved.


*** Custom Themes

Custom themes are collections of settings that can be enabled or disabled as a unit. You can use Custom themes to switch easily between various collections of settings, and to transfer such collections from one computer to another.

A Custom theme is stored as an Emacs Lisp source file. If the name of the Custom theme is name, the theme file is named name-theme.el. See Creating Custom Themes, for the format of a theme file and how to make one.

Type M-x customize-themes to switch to a buffer named *Custom Themes*, which lists the Custom themes that Emacs knows about. By default, Emacs looks for theme files in two locations: the directory specified by the variable custom-theme-directory (which defaults to ~/.emacs.d/), and a directory named etc/themes in your Emacs installation (see the variable data-directory). The latter contains several Custom themes distributed with Emacs that customize Emacs’s faces to fit various color schemes. (Note, however, that Custom themes need not be restricted to this purpose; they can be used to customize variables too.)

If you want Emacs to look for Custom themes in some other directory, add the directory to the list variable custom-theme-load-path. Its default value is (custom-theme-directory t); here, the symbol custom-theme-directory has the special meaning of the value of the variable custom-theme-directory, while t stands for the built-in theme directory etc/themes. The themes listed in the *Custom Themes* buffer are those found in the directories specified by custom-theme-load-path.

In the *Custom Themes* buffer, you can activate the checkbox next to a Custom theme to enable or disable the theme for the current Emacs session. When a Custom theme is enabled, all of its settings (variables and faces) take effect in the Emacs session. To apply the choice of theme(s) to future Emacs sessions, type C-x C-s (custom-theme-save) or use the ‘[Save Theme Settings]’ button.

When you first enable a Custom theme, Emacs displays the contents of the theme file and asks if you really want to load it. Because loading a Custom theme can execute arbitrary Lisp code, you should only say yes if you know that the theme is safe; in that case, Emacs offers to remember in the future that the theme is safe (this is done by saving the theme file’s SHA-256 hash to the variable custom-safe-themes; if you want to treat all themes as safe, change its value to t). Themes that come with Emacs (in the etc/themes directory) are exempt from this check, and are always considered safe.

Setting or saving Custom themes actually works by customizing the variable custom-enabled-themes. The value of this variable is a list of Custom theme names (as Lisp symbols, e.g., tango). Instead of using the *Custom Themes* buffer to set custom-enabled-themes, you can customize the variable using the usual customization interface, e.g., with M-x customize-option. Note that Custom themes are not allowed to set custom-enabled-themes themselves.

Any customizations that you make through the customization buffer take precedence over theme settings. This lets you easily override individual theme settings that you disagree with. If settings from two different themes overlap, the theme occurring earlier in custom-enabled-themes takes precedence. In the customization buffer, if a setting has been changed from its default by a Custom theme, its ‘State’ display shows ‘THEMED’ instead of ‘STANDARD’.

You can enable a specific Custom theme in the current Emacs session by typing M-x load-theme. This prompts for a theme name, loads the theme from the theme file, and enables it. If a theme file has been loaded before, you can enable the theme without loading its file by typing M-x enable-theme. To disable a Custom theme, type M-x disable-theme.

To see a description of a Custom theme, type ? on its line in the *Custom Themes* buffer; or type M-x describe-theme anywhere in Emacs and enter the theme name.

Some themes have variants (most often just two: light and dark). You can switch to another variant using M-x theme-choose-variant. If the currently active theme has only one other variant, it will be selected; if there are more variants, the command will prompt you which one to switch to.

Note that theme-choose-variant only works if a single theme is active.


*** Creating Custom Themes

You can define a Custom theme using an interface similar to the customization buffer, by typing M-x customize-create-theme. This switches to a buffer named *Custom Theme*. It also offers to insert some common Emacs faces into the theme (a convenience, since Custom themes are often used to customize faces). If you answer no, the theme will initially contain no settings.

Near the top of the *Custom Theme* buffer, there are editable fields where you can enter the theme’s name and description. The name can be anything except ‘user’. The description is the one that will be shown when you invoke M-x describe-theme for the theme. Its first line should be a brief one-sentence summary; in the buffer made by M-x customize-themes, this sentence is displayed next to the theme name.

To add a new setting to the theme, use the ‘[Insert Additional Face]’ or ‘[Insert Additional Variable]’ buttons. Each button reads a face or variable name using the minibuffer, with completion, and inserts a customization entry for the face or variable. You can edit the variable values or face attributes in the same way as in a normal customization buffer. To remove a face or variable from the theme, uncheck the checkbox next to its name.

After specifying the Custom theme’s faces and variables, type C-x C-s (custom-theme-write) or use the buffer’s ‘[Save Theme]’ button. This saves the theme file, named name-theme.el where name is the theme name, in the directory named by custom-theme-directory.

From the *Custom Theme* buffer, you can view and edit an existing Custom theme by activating the ‘[Visit Theme]’ button and specifying the theme name. You can also add the settings of another theme into the buffer, using the ‘[Merge Theme]’ button. You can import your non-theme settings into a Custom theme by using the ‘[Merge Theme]’ button and specifying the special theme named ‘user’.

A theme file is simply an Emacs Lisp source file, and loading the Custom theme works by loading the Lisp file. Therefore, you can edit a theme file directly instead of using the *Custom Theme* buffer. See Custom Themes in The Emacs Lisp Reference Manual, for details.



** Variables

A variable is a Lisp symbol which has a value. The symbol’s name is also called the variable name. A variable name can contain any characters that can appear in a file, but most variable names consist of ordinary words separated by hyphens.

The name of the variable serves as a compact description of its role. Most variables also have a documentation string, which describes what the variable’s purpose is, what kind of value it should have, and how the value will be used. You can view this documentation using the help command C-h v (describe-variable). See Examining and Setting Variables.

Emacs uses many Lisp variables for internal record keeping, but the most interesting variables for a non-programmer user are those meant for users to change—these are called customizable variables or user options (see Easy Customization Interface). In the following sections, we will describe other aspects of Emacs variables, such as how to set them outside Customize.

Emacs Lisp allows any variable (with a few exceptions) to have any kind of value. However, many variables are meaningful only if assigned values of a certain type. For example, only numbers are meaningful values for kill-ring-max, which specifies the maximum length of the kill ring (see Yanking Earlier Kills); if you give kill-ring-max a string value, commands such as C-y (yank) will signal an error. On the other hand, some variables don’t care about type; for instance, if a variable has one effect for nil values and another effect for non-nil values, then any value that is not the symbol nil induces the second effect, regardless of its type (by convention, we usually use the value t—a symbol which stands for “true”—to specify a non-nil value). If you set a variable using the customization buffer, you need not worry about giving it an invalid type: the customization buffer usually only allows you to enter meaningful values. When in doubt, use C-h v (describe-variable) to check the variable’s documentation string to see what kind of value it expects (see Examining and Setting Variables).


*** Examining and Setting Variables

C-h v var RET
Display the value and documentation of variable var (describe-variable).

M-x set-variable RET var RET value RET
Change the value of variable var to value.

To examine the value of a variable, use C-h v (describe-variable). This reads a variable name using the minibuffer, with completion, and displays both the value and the documentation of the variable. For example,

C-h v fill-column RET
displays something like this:

fill-column is a variable defined in ‘C source code’.
Its value is 70

  Automatically becomes buffer-local when set.
  This variable is safe as a file local variable if its value
  satisfies the predicate ‘integerp’.
  Probably introduced at or before Emacs version 18.

Documentation:
Column beyond which automatic line-wrapping should happen.
Interactively, you can set the buffer local value using C-x f.

You can customize this variable.
The line that says ‘You can customize the variable’ indicates that this variable is a user option. C-h v is not restricted to user options; it allows non-customizable variables too.

The most convenient way to set a specific customizable variable is with M-x set-variable. This reads the variable name with the minibuffer (with completion), and then reads a Lisp expression for the new value using the minibuffer a second time (you can insert the old value into the minibuffer for editing via M-n). For example,

M-x set-variable RET fill-column RET 75 RET
sets fill-column to 75.

M-x set-variable is limited to customizable variables, but you can set any variable with a Lisp expression like this:

(setq fill-column 75)
To execute such an expression, type M-: (eval-expression) and enter the expression in the minibuffer (see Evaluating Emacs Lisp Expressions). Alternatively, go to the *scratch* buffer, type in the expression, and then type C-j (see Lisp Interaction Buffers).

Setting variables, like all means of customizing Emacs except where otherwise stated, affects only the current Emacs session. The only way to alter the variable in future sessions is to put something in your initialization file (see The Emacs Initialization File).

If you’re setting a customizable variable in your initialization file, and you don’t want to use the Customize interface, you can use the setopt macro. For instance:

(setopt fill-column 75)
This works the same as setq, but if the variable has any special setter functions, they will be run automatically when using setopt. You can also use setopt on other, non-customizable variables, but this is less efficient than using setq.


*** Hooks

Hooks are an important mechanism for customizing Emacs. A hook is a Lisp variable which holds a list of functions, to be called on some well-defined occasion. (This is called running the hook.) The individual functions in the list are called the hook functions of the hook. For example, the hook kill-emacs-hook runs just before exiting Emacs (see Exiting Emacs).

Most hooks are normal hooks. This means that when Emacs runs the hook, it calls each hook function in turn, with no arguments. We have made an effort to keep most hooks normal, so that you can use them in a uniform way. Every variable whose name ends in ‘-hook’ is a normal hook.

A few hooks are abnormal hooks. Their names end in ‘-functions’, instead of ‘-hook’ (some old code may also use the deprecated suffix ‘-hooks’). What makes these hooks abnormal is the way its functions are called—perhaps they are given arguments, or perhaps the values they return are used in some way. For example, find-file-not-found-functions is abnormal because as soon as one hook function returns a non-nil value, the rest are not called at all (see Visiting Files). The documentation of each abnormal hook variable explains how its functions are used.

You can set a hook variable with setq like any other Lisp variable, but the recommended way to add a function to a hook (either normal or abnormal) is to use add-hook, as shown by the following examples. See Hooks in The Emacs Lisp Reference Manual, for details.

Most major modes run one or more mode hooks as the last step of initialization. Mode hooks are a convenient way to customize the behavior of individual modes; they are always normal. For example, here’s how to set up a hook to turn on Auto Fill mode in Text mode and other modes based on Text mode:

(add-hook 'text-mode-hook 'auto-fill-mode)
This works by calling auto-fill-mode, which enables the minor mode when no argument is supplied (see Minor Modes). Next, suppose you don’t want Auto Fill mode turned on in LaTeX mode, which is one of the modes based on Text mode. You can do this with the following additional line:

(add-hook 'latex-mode-hook (lambda () (auto-fill-mode -1)))
Here we have used the special macro lambda to construct an anonymous function (see Lambda Expressions in The Emacs Lisp Reference Manual), which calls auto-fill-mode with an argument of -1 to disable the minor mode. Because LaTeX mode runs latex-mode-hook after running text-mode-hook, the result leaves Auto Fill mode disabled.

Here is a more complex example, showing how to use a hook to customize the indentation of C code:

(setq my-c-style
  '((c-comment-only-line-offset . 4)
    (c-cleanup-list . (scope-operator
                       empty-defun-braces
                       defun-close-semi))))

(add-hook 'c-mode-common-hook
  (lambda () (c-add-style "my-style" my-c-style t)))
Major mode hooks also apply to other major modes derived from the original mode (see Derived Modes in The Emacs Lisp Reference Manual). For instance, HTML mode is derived from Text mode (see SGML and HTML Modes); when HTML mode is enabled, it runs text-mode-hook before running html-mode-hook. This provides a convenient way to use a single hook to affect several related modes. In particular, if you want to apply a hook function to any programming language mode, add it to prog-mode-hook; Prog mode is a major mode that does little else than to let other major modes inherit from it, exactly for this purpose.

It is best to design your hook functions so that the order in which they are executed does not matter. Any dependence on the order is asking for trouble. However, the order is predictable: the hook functions are executed in the order they appear in the hook.

If you play with adding various different versions of a hook function by calling add-hook over and over, remember that all the versions you added will remain in the hook variable together. You can clear out individual functions by calling remove-hook, or do (setq hook-variable nil) to remove everything.

If the hook variable is buffer-local, the buffer-local variable will be used instead of the global variable. However, if the buffer-local variable contains the element t, the global hook variable will be run as well.


*** Local Variables

M-x make-local-variable RET var RET
Make variable var have a local value in the current buffer.

M-x kill-local-variable RET var RET
Make variable var use its global value in the current buffer.

M-x make-variable-buffer-local RET var RET
Mark variable var so that setting it will make it local to the buffer that is current at that time.

Almost any variable can be made local to a specific Emacs buffer. This means that its value in that buffer is independent of its value in other buffers. A few variables are always local in every buffer. Every other Emacs variable has a global value which is in effect in all buffers that have not made the variable local.

M-x make-local-variable reads the name of a variable and makes it local to the current buffer. Changing its value subsequently in this buffer will not affect others, and changes in its global value will not affect this buffer.

M-x make-variable-buffer-local marks a variable so it will become local automatically whenever it is set. More precisely, once a variable has been marked in this way, the usual ways of setting the variable automatically do make-local-variable first. We call such variables per-buffer variables. Many variables in Emacs are normally per-buffer; the variable’s document string tells you when this is so. A per-buffer variable’s global value is normally never effective in any buffer, but it still has a meaning: it is the initial value of the variable for each new buffer.

Major modes (see Major Modes) always make variables local to the buffer before setting the variables. This is why changing major modes in one buffer has no effect on other buffers. Minor modes also work by setting variables—normally, each minor mode has one controlling variable which is non-nil when the mode is enabled (see Minor Modes). For many minor modes, the controlling variable is per buffer, and thus always buffer-local. Otherwise, you can make it local in a specific buffer like any other variable.

A few variables cannot be local to a buffer because they are always local to each display instead (see Multiple Displays). If you try to make one of these variables buffer-local, you’ll get an error message.

M-x kill-local-variable makes a specified variable cease to be local to the current buffer. The global value of the variable henceforth is in effect in this buffer. Setting the major mode kills all the local variables of the buffer except for a few variables specially marked as permanent locals.

To set the global value of a variable, regardless of whether the variable has a local value in the current buffer, you can use the Lisp construct setq-default. This construct is used just like setq, but it sets variables’ global values instead of their local values (if any). When the current buffer does have a local value, the new global value may not be visible until you switch to another buffer. Here is an example:

(setq-default fill-column 75)
setq-default is the only way to set the global value of a variable that has been marked with make-variable-buffer-local.

Lisp programs can use default-value to look at a variable’s default value. This function takes a symbol as argument and returns its default value. The argument is evaluated; usually you must quote it explicitly. For example, here’s how to obtain the default value of fill-column:

(default-value 'fill-column)


*** Local Variables in Files

A file can specify local variable values to use when editing the file with Emacs. Visiting the file or setting a major mode checks for local variable specifications; it automatically makes these variables local to the buffer, and sets them to the values specified in the file.

File local variables override directory local variables (see Per-Directory Local Variables), if any are specified for a file’s directory.

**** Specifying File Variables

There are two ways to specify file local variable values: in the first line, or with a local variables list. Here’s how to specify them in the first line:

-*- mode: modename; var: value; … -*-
You can specify any number of variable/value pairs in this way, each pair with a colon and semicolon. The special variable/value pair mode: modename;, if present, specifies a major mode (without the “-mode” suffix). The values are used literally, and not evaluated.

You can use M-x add-file-local-variable-prop-line instead of adding entries by hand. This command prompts for a variable and value, and adds them to the first line in the appropriate way. M-x delete-file-local-variable-prop-line prompts for a variable, and deletes its entry from the line. The command M-x copy-dir-locals-to-file-locals-prop-line copies the current directory-local variables to the first line (see Per-Directory Local Variables).

Here is an example first line that specifies Lisp mode and sets two variables with numeric values:

;; -*- mode: Lisp; fill-column: 75; comment-column: 50; -*-
Aside from mode, other keywords that have special meanings as file variables are coding, unibyte, and eval. These are described below.

In shell scripts, the first line is used to identify the script interpreter, so you cannot put any local variables there. To accommodate this, Emacs looks for local variable specifications in the second line if the first line specifies an interpreter. The same is true for man pages which start with the magic string ‘'\"’ to specify a list of troff preprocessors (not all do, however).

Apart from using a ‘-*-’ line, you can define file local variables using a local variables list near the end of the file. The start of the local variables list should be no more than 3000 characters from the end of the file, and must be on the last page if the file is divided into pages.

If a file has both a local variables list and a ‘-*-’ line, Emacs processes everything in the ‘-*-’ line first, and everything in the local variables list afterward. The exception to this is a major mode specification. Emacs applies this first, wherever it appears, since most major modes kill all local variables as part of their initialization.

A local variables list starts with a line containing the string ‘Local Variables:’, and ends with a line containing the string ‘End:’. In between come the variable names and values, one set per line, like this:

/* Local Variables:  */
/* mode: c           */
/* comment-column: 0 */
/* End:              */
In this example, each line starts with the prefix ‘/*’ and ends with the suffix ‘*/’. Emacs recognizes the prefix and suffix by finding them surrounding the magic string ‘Local Variables:’, on the first line of the list; it then automatically discards them from the other lines of the list. The usual reason for using a prefix and/or suffix is to embed the local variables list in a comment, so it won’t confuse other programs that the file is intended for. The example above is for the C programming language, where comments start with ‘/*’ and end with ‘*/’.

If some unrelated text might look to Emacs as a local variables list, you can countermand that by inserting a form-feed character (a page delimiter, see Pages) after that text. Emacs only looks for file-local variables in the last page of a file, after the last page delimiter.

Instead of typing in the local variables list directly, you can use the command M-x add-file-local-variable. This prompts for a variable and value, and adds them to the list, adding the ‘Local Variables:’ string and start and end markers as necessary. The command M-x delete-file-local-variable deletes a variable from the list. M-x copy-dir-locals-to-file-locals copies directory-local variables to the list (see Per-Directory Local Variables).

As with the ‘-*-’ line, the variables in a local variables list are used literally, and are not evaluated first. If you want to split a long string value across multiple lines of the file, you can use backslash-newline, which is ignored in Lisp string constants; you should put the prefix and suffix on each line, even lines that start or end within the string, as they will be stripped off when processing the list. Here is an example:

# Local Variables:
# compile-command: "cc foo.c -Dfoo=bar -Dhack=whatever \
#   -Dmumble=blaah"
# End:
Some names have special meanings in a local variables list:

mode enables the specified major mode.
eval evaluates the specified Lisp expression (the value returned by that expression is ignored).
coding specifies the coding system for character code conversion of this file. See Coding Systems.
unibyte says to load or compile a file of Emacs Lisp in unibyte mode, if the value is t. See Disabling Multibyte Characters in GNU Emacs Lisp Reference Manual.
These four keywords are not really variables; setting them in any other context has no special meaning.

If you’re editing a file across Emacs versions, and a new mode has been introduced to handle a file in a newer Emacs version, you can use several mode entries to use the new mode (called my-new-mode) in the new Emacs, and fall back to the old mode (called my-old-mode) in older Emacs versions. If you’re enabling the modes in the first line of the file, can say:

-*- mode: my-old; mode: my-new -*-
Emacs will use the final defined mode it finds, so in older Emacs versions it will ignore my-new-mode, while in Emacs versions where my-new-mode is defined, it’ll ignore my-old-mode. Similarly, in a local variable block at the end of the file:

Local variables:
mode: my-old
mode: my-new
Do not use the mode keyword for minor modes. To enable or disable a minor mode in a local variables list, use the eval keyword with a Lisp expression that runs the mode command (see Minor Modes). For example, the following local variables list enables ElDoc mode (see Programming Language Documentation Lookup) by calling eldoc-mode with no argument (calling it with an argument of 1 would do the same), and disables Font Lock mode (see Font Lock mode) by calling font-lock-mode with an argument of −1.

;; Local Variables:
;; eval: (eldoc-mode)
;; eval: (font-lock-mode -1)
;; End:
Note, however, that it is often a mistake to specify minor modes this way. Minor modes represent individual user preferences, and it may be inappropriate to impose your preferences on another user who might edit the file. If you wish to automatically enable or disable a minor mode in a situation-dependent way, it is often better to do it in a major mode hook (see Hooks).

Use the command M-x normal-mode to reset the local variables and major mode of a buffer according to the file name and contents, including the local variables list if any. See Choosing File Modes.



**** Safety of File Variables

File-local variables can be dangerous; when you visit someone else’s file, there’s no telling what its local variables list could do to your Emacs. Improper values of the eval “variable”, and other variables such as load-path, could execute Lisp code you didn’t intend to run.

Therefore, whenever Emacs encounters file local variable values that are not known to be safe, it displays the file’s entire local variables list, and asks you for confirmation before setting them. You can type y or SPC to put the local variables list into effect, or n to ignore it. When Emacs is run in batch mode (see Initial Options), it can’t really ask you, so it assumes the answer n.

Emacs normally recognizes certain variable/value pairs as safe. For instance, it is safe to give comment-column or fill-column any integer value. If a file specifies only known-safe variable/value pairs, Emacs does not ask for confirmation before setting them. Otherwise, you can tell Emacs to record all the variable/value pairs in this file as safe, by typing ! at the confirmation prompt. When Emacs encounters these variable/value pairs subsequently, in the same file or others, it will assume they are safe.

You can also tell Emacs to permanently ignore all the variable/value pairs in the file, by typing i at the confirmation prompt – these pairs will thereafter be ignored in this file and in all other files.

Some variables, such as load-path, are considered particularly risky: there is seldom any reason to specify them as local variables, and changing them can be dangerous. If a file contains only risky local variables, Emacs neither offers nor accepts ! as input at the confirmation prompt. If some of the local variables in a file are risky, and some are only potentially unsafe, you can enter ! at the prompt. It applies all the variables, but only marks the non-risky ones as safe for the future. If you really want to record safe values for risky variables, do it directly by customizing ‘safe-local-variable-values’ (see Easy Customization Interface). Similarly, if you want to record values of risky variables that should be permanently ignored, customize ignored-local-variable-values.

The variable enable-local-variables allows you to change the way Emacs processes local variables. Its default value is t, which specifies the behavior described above. If it is nil, Emacs simply ignores all file local variables. :safe means use only the safe values and ignore the rest. :all instructs Emacs to set all file local variables regardless of whether their value is safe or not (we advise not to use this permanently). Any other value says to query you about each file that has local variables, without trying to determine whether the values are known to be safe.

The variable enable-local-eval controls whether Emacs processes eval variables. The three possibilities for the variable’s value are t, nil, and anything else, just as for enable-local-variables. The default is maybe, which is neither t nor nil, so normally Emacs does ask for confirmation about processing eval variables.

As an exception, Emacs never asks for confirmation to evaluate any eval form if that form occurs within the variable safe-local-eval-forms.


*** Per-Directory Local Variables

Sometimes, you may wish to define the same set of local variables to all the files in a certain directory and its subdirectories, such as the directory tree of a large software project. This can be accomplished with directory-local variables. File local variables override directory local variables, so if some of the files in a directory need specialized settings, you can specify the settings for the majority of the directory’s files in directory variables, and then define file local variables in a few files which need the general settings overridden.

The usual way to define directory-local variables is to put a file named .dir-locals.el24 in a directory. Whenever Emacs visits any file in that directory or any of its subdirectories, it will apply the directory-local variables specified in .dir-locals.el, as though they had been defined as file-local variables for that file (see Local Variables in Files). Emacs searches for .dir-locals.el starting in the directory of the visited file, and moving up the directory tree. To avoid slowdown, this search is skipped for remote files. If needed, the search can be extended for remote files by setting the variable enable-remote-dir-locals to t.

You can also use .dir-locals-2.el; if found, Emacs loads it in addition to .dir-locals.el. This is useful when .dir-locals.el is under version control in a shared repository and can’t be used for personal customizations.

The .dir-locals.el file should hold a specially-constructed list, which maps major mode names (symbols) to alists (see Association Lists in The Emacs Lisp Reference Manual). Each alist entry consists of a variable name and the directory-local value to assign to that variable, when the specified major mode is enabled. Instead of a mode name, you can specify ‘nil’, which means that the alist applies to any mode; or you can specify a subdirectory (a string), in which case the alist applies to all files in that subdirectory.

Here’s an example of a .dir-locals.el file:

((nil . ((indent-tabs-mode . t)
         (fill-column . 80)
         (mode . auto-fill)))
 (c-mode . ((c-file-style . "BSD")
            (subdirs . nil)))
 ("src/imported"
  . ((nil . ((change-log-default-name
              . "ChangeLog.local"))))))
This sets the variables ‘indent-tabs-mode’ and fill-column for any file in the directory tree, and the indentation style for any C source file. The special mode element specifies the minor mode to be enabled. So (mode . auto-fill) specifies that the minor mode auto-fill-mode needs to be enabled. The special subdirs element is not a variable, but a special keyword which indicates that the C mode settings are only to be applied in the current directory, not in any subdirectories. Finally, it specifies a different ChangeLog file name for any file in the src/imported subdirectory.

If the .dir-locals.el file contains multiple different values for a variable using different mode names or directories, the values will be applied in an order such that the values for more specific modes take priority over more generic modes. Values specified under a directory have even more priority. For example:

((nil . ((fill-column . 40)))
 (c-mode . ((fill-column . 50)))
 (prog-mode . ((fill-column . 60)))
 ("narrow-files" . ((nil . ((fill-column . 20))))))
Files that use c-mode also match prog-mode because the former inherits from the latter. The value used for fill-column in C files will however be 50 because the mode name is more specific than prog-mode. Files using other modes inheriting from prog-mode will use 60. Any file under the directory narrow-files will use the value 20 even if they use c-mode because directory entries have priority over mode entries.

You can specify the variables mode, eval, and unibyte in your .dir-locals.el, and they have the same meanings as they would have in file local variables. coding cannot be specified as a directory local variable. See Local Variables in Files.

The special key auto-mode-alist in a .dir-locals.el lets you set a file’s major mode. It works much like the variable auto-mode-alist (see Choosing File Modes). For example, here is how you can tell Emacs that .def source files in this directory should be in C mode:

((auto-mode-alist . (("\\.def\\'" . c-mode))))
Instead of editing the .dir-locals.el file by hand, you can use the command M-x add-dir-local-variable. This prompts for a mode or subdirectory, and for variable and value, and adds the entry defining the directory-local variable. M-x delete-dir-local-variable deletes an entry. M-x copy-file-locals-to-dir-locals copies the file-local variables in the current file into .dir-locals.el.

Another method of specifying directory-local variables is to define a group of variables/value pairs in a directory class, using the dir-locals-set-class-variables function; then, tell Emacs which directories correspond to the class by using the dir-locals-set-directory-class function. These function calls normally go in your initialization file (see The Emacs Initialization File). This method is useful when you can’t put .dir-locals.el in a directory for some reason. For example, you could apply settings to an unwritable directory this way:

(dir-locals-set-class-variables 'unwritable-directory
   '((nil . ((some-useful-setting . value)))))

(dir-locals-set-directory-class
   "/usr/include/" 'unwritable-directory)
If a variable has both a directory-local and file-local value specified, the file-local value takes effect. Unsafe directory-local variables are handled in the same way as unsafe file-local variables (see Safety of File Variables).

Directory-local variables also take effect in certain buffers that do not visit a file directly but perform work within a directory, such as Dired buffers (see Dired, the Directory Editor).

Footnotes
(24)
On MS-DOS, the name of this file should be _dir-locals.el, due to limitations of the DOS filesystems. If the filesystem is limited to 8+3 file names, the name of the file will be truncated by the OS to _dir-loc.el.


*** Per-Connection Local Variables

Most of the variables reflect the situation on the local machine. Often, they must use a different value when you operate in buffers with a remote default directory. Think about the behavior when calling shell – on your local machine, you might use /bin/bash and rely on termcap, but on a remote machine, it may be /bin/ksh and terminfo.

This can be accomplished with connection-local variables. Directory and file local variables override connection-local variables. Unsafe connection-local variables are handled in the same way as unsafe file-local variables (see Safety of File Variables).

Connection-local variables are declared as a group of variables/value pairs in a profile, using the connection-local-set-profile-variables function. The function connection-local-set-profiles activates profiles for a given criteria, identifying a remote machine:

(connection-local-set-profile-variables 'remote-terminfo
   '((system-uses-terminfo . t)
     (comint-terminfo-terminal . "dumb-emacs-ansi")))

(connection-local-set-profile-variables 'remote-ksh
   '((shell-file-name . "/bin/ksh")
     (shell-command-switch . "-c")))

(connection-local-set-profile-variables 'remote-bash
   '((shell-file-name . "/bin/bash")
     (shell-command-switch . "-c")))

(connection-local-set-profiles
   '(:application tramp :machine "remotemachine")
   'remote-terminfo 'remote-ksh)
This code declares three different profiles, remote-terminfo, remote-ksh, and remote-bash. The profiles remote-terminfo and remote-ksh are applied to all buffers which have a remote default directory matching the regexp "remotemachine" as host name. Such a criteria can also discriminate for the properties :protocol (this is the Tramp method) or :user (a remote user name). The nil criteria matches all buffers with a remote default directory.

Be careful when declaring different profiles with the same variable, and setting these profiles to criteria which could match in parallel. It is unspecified which variable value is used then.


* Customizing Key Bindings

This section describes key bindings, which map keys to commands, and keymaps, which record key bindings. It also explains how to customize key bindings, which is done by editing your init file (see Rebinding Keys in Your Init File).

Since most modes define their own key bindings, activating a mode might override your custom key bindings. A small number of keys are reserved for user-defined bindings, and should not be used by modes, so key bindings using those keys are safer in this regard. The reserved key sequences are those consisting of C-c followed by a letter (either upper or lower case), and function keys F5 through F9 without modifiers (see Modifier Keys).

*** Keymaps

As described in Keys and Commands, each Emacs command is a Lisp function whose definition provides for interactive use. Like every Lisp function, a command has a function name, which usually consists of lower-case letters and hyphens.

A key sequence (key, for short) is a sequence of input events that have a meaning as a unit. Input events include characters, function keys, and mouse buttons—all the inputs that you can send to the computer. A key sequence gets its meaning from its binding, which says what command it runs.

The bindings between key sequences and command functions are recorded in data structures called keymaps. Emacs has many of these, each used on particular occasions.

The global keymap is the most important keymap because it is always in effect. The global keymap defines keys for Fundamental mode (see Major Modes); most of these definitions are common to most or all major modes. Each major or minor mode can have its own keymap which overrides the global definitions of some keys.

For example, a self-inserting character such as g is self-inserting because the global keymap binds it to the command self-insert-command. The standard Emacs editing characters such as C-a also get their standard meanings from the global keymap. Commands to rebind keys, such as M-x keymap-global-set, work by storing the new binding in the proper place in the global map (see Changing Key Bindings Interactively). To view the current key bindings, use the C-h b command.

Most modern keyboards have function keys as well as character keys. Function keys send input events just as character keys do, and keymaps can have bindings for them. Key sequences can mix function keys and characters. For example, if your keyboard has a Home function key, Emacs can recognize key sequences like C-x Home. You can even mix mouse events with keyboard events, such as S-down-mouse-1.

On text terminals, typing a function key actually sends the computer a sequence of characters; the precise details of the sequence depend on the function key and on the terminal type. (Often the sequence starts with ESC [.) If Emacs understands your terminal type properly, it automatically handles such sequences as single input events.

Key sequences that consist of C-c followed by a letter (upper or lower case; ASCII or non-ASCII) are reserved for users. Emacs itself will never bind those key sequences, and Emacs extensions should avoid binding them. In other words, users can bind key sequences like C-c a or C-c ç and rely on these never being shadowed by other Emacs bindings.


*** Prefix Keymaps

Internally, Emacs records only single events in each keymap. Interpreting a key sequence of multiple events involves a chain of keymaps: the first keymap gives a definition for the first event, which is another keymap, which is used to look up the second event in the sequence, and so on. Thus, a prefix key such as C-x or ESC has its own keymap, which holds the definition for the event that immediately follows that prefix.

The definition of a prefix key is usually the keymap to use for looking up the following event. The definition can also be a Lisp symbol whose function definition is the following keymap; the effect is the same, but it provides a command name for the prefix key that can be used as a description of what the prefix key is for. Thus, the binding of C-x is the symbol Control-X-prefix, whose function definition is the keymap for C-x commands. The definitions of C-c, C-x, C-h, and ESC as prefix keys appear in the global map, so these prefix keys are always available.

Aside from ordinary prefix keys, there is a fictitious “prefix key” which represents the menu bar; see Menu Bar in The Emacs Lisp Reference Manual, for special information about menu bar key bindings. Mouse button events that invoke pop-up menus are also prefix keys; see Menu Keymaps in The Emacs Lisp Reference Manual, for more details.

Some prefix keymaps are stored in variables with names:

ctl-x-map is the variable name for the map used for characters that follow C-x.
help-map is for characters that follow C-h.
esc-map is for characters that follow ESC. Thus, all Meta characters are actually defined by this map.
ctl-x-4-map is for characters that follow C-x 4.
mode-specific-map is for characters that follow C-c.
project-prefix-map is for characters that follow C-x p, used for project-related commands (see Working with Projects).


*** Local Keymaps

So far, we have explained the ins and outs of the global map. Major modes customize Emacs by providing their own key bindings in local keymaps. For example, C mode overrides TAB to make it indent the current line for C code. Minor modes can also have local keymaps; whenever a minor mode is in effect, the definitions in its keymap override both the major mode’s local keymap and the global keymap. In addition, portions of text in the buffer can specify their own keymaps, which override all other keymaps.

A local keymap can redefine a key as a prefix key by defining it as a prefix keymap. If the key is also defined globally as a prefix, its local and global definitions (both keymaps) effectively combine: both definitions are used to look up the event that follows the prefix key. For example, if a local keymap defines C-c as a prefix keymap, and that keymap defines C-z as a command, this provides a local meaning for C-c C-z. This does not affect other sequences that start with C-c; if those sequences don’t have their own local bindings, their global bindings remain in effect.

Another way to think of this is that Emacs handles a multi-event key sequence by looking in several keymaps, one by one, for a binding of the whole key sequence. First it checks the minor mode keymaps for minor modes that are enabled, then it checks the major mode’s keymap, and then it checks the global keymap. This is not precisely how key lookup works, but it’s good enough for understanding the results in ordinary circumstances.


*** Minibuffer Keymaps

The minibuffer has its own set of local keymaps; they contain various completion and exit commands.

minibuffer-local-map is used for ordinary input (no completion).
minibuffer-local-ns-map is similar, except that SPC exits just like RET.
minibuffer-local-completion-map is for permissive completion.
minibuffer-local-must-match-map is for strict completion and for cautious completion.
minibuffer-local-filename-completion-map is like the two previous ones, but specifically for file name completion. It does not bind SPC.
By default, TAB, SPC and ? do completion in minibuffer-local-completion-map. If you commonly complete over collections that have elements with space or question mark characters in them, it may be convenient to disable completion on those keys by putting this in your init file:

(keymap-set minibuffer-local-completion-map "SPC" 'self-insert-command)
(keymap-set minibuffer-local-completion-map "?" 'self-insert-command)


*** Changing Key Bindings Interactively

The way to redefine an Emacs key is to change its entry in a keymap. You can change the global keymap, in which case the change is effective in all major modes (except those that have their own overriding local bindings for the same key). Or you can change a local keymap, which affects all buffers using the same major mode.

In this section, we describe how to rebind keys for the present Emacs session. See Rebinding Keys in Your Init File, for a description of how to make key rebindings affect future Emacs sessions.

M-x keymap-global-set RET key cmd RET
Define key globally to run cmd.

M-x keymap-local-set RET key cmd RET
Define key locally (in the major mode now in effect) to run cmd.

M-x keymap-global-unset RET key
Make key undefined in the global map.

M-x keymap-local-unset RET key
Make key undefined locally (in the major mode now in effect).

For example, the following binds C-z to the shell command (see Interactive Subshell), replacing the normal global definition of C-z:

M-x keymap-global-set RET C-z shell RET
The keymap-global-set command reads the command name after the key. After you press the key, a message like this appears so that you can confirm that you are binding the key you want:

Set key C-z to command:
You can redefine function keys and mouse events in the same way; just type the function key or click the mouse when it’s time to specify the key to rebind.

You can rebind a key that contains more than one event in the same way. Emacs keeps reading the key to rebind until it is a complete key (that is, not a prefix key). Thus, if you type C-f for key, that’s the end; it enters the minibuffer immediately to read cmd. But if you type C-x, since that’s a prefix, it reads another character; if that is 4, another prefix character, it reads one more character, and so on. For example,

M-x keymap-global-set RET C-x 4 $ spell-other-window RET
redefines C-x 4 $ to run the (fictitious) command spell-other-window.

You can remove the global definition of a key with keymap-global-unset. This makes the key undefined; if you type it, Emacs will just beep. Similarly, keymap-local-unset makes a key undefined in the current major mode keymap, which makes the global definition (or lack of one) come back into effect in that major mode.

If you have redefined (or undefined) a key and you subsequently wish to retract the change, undefining the key will not do the job—you need to redefine the key with its standard definition. To find the name of the standard definition of a key, go to a Fundamental mode buffer in a fresh Emacs and use C-h c. The documentation of keys in this manual also lists their command names.

If you want to prevent yourself from invoking a command by mistake, it is better to disable the command than to undefine the key. A disabled command is less work to invoke when you really want to. See Disabling Commands.


*** Rebinding Keys in Your Init File

If you have a set of key bindings that you like to use all the time, you can specify them in your initialization file by writing Lisp code. See The Emacs Initialization File, for a description of the initialization file.

The recommended way to write a key binding using Lisp is to use either the keymap-global-set or the keymap-set functions. For example, here’s how to bind C-z to the shell command in the global keymap (see Interactive Subshell):

(keymap-global-set "C-z" 'shell)
The first argument to keymap-global-set describes the key sequence. It is a string made of a series of characters separated by spaces, with each character corresponding to a key. Keys with modifiers can be specified by prepending the modifier, such as ‘C-’ for Control, or ‘M-’ for Meta. Special keys, such as TAB and RET, can be specified within angle brackets as in TAB and RET.

The single-quote before the command name that is being bound to the key sequence, shell in the above example, marks it as a constant symbol rather than a variable. If you omit the quote, Emacs would try to evaluate shell as a variable. This will probably cause an error; it certainly isn’t what you want.

Here are some additional examples, including binding function keys and mouse events:

(keymap-global-set "C-c y" 'clipboard-yank)
(keymap-global-set "C-M-q" 'query-replace)
(keymap-global-set "<f5>" 'flyspell-mode)
(keymap-global-set "C-<f5>" 'display-line-numbers-mode)
(keymap-global-set "C-<right>" 'forward-sentence)
(keymap-global-set "<mouse-2>" 'mouse-save-then-kill)
Language and coding systems may cause problems with key bindings for non-ASCII characters. See Non-ASCII Characters in Init Files.

Alternatively, you can use the low level functions define-key and global-set-key. For example, to bind C-z to the shell command, as in the above example, using these low-level functions, use:

(global-set-key (kbd "C-z") 'shell)
There are various ways to specify the key sequence but the simplest is to use the function kbd as shown in the example above. kbd takes a single string argument that is a textual representation of a key sequence, and converts it into a form suitable for low-level functions such as global-set-key. For more details about binding keys using Lisp, see Keymaps in The Emacs Lisp Reference Manual.

As described in Local Keymaps, major modes and minor modes can define local keymaps. These keymaps are constructed when the mode is loaded for the first time in a session. The function keymap-set can be used to make changes in a specific keymap. To remove a key binding, use keymap-unset.

Since a mode’s keymaps are not constructed until it has been loaded, you must delay running code which modifies them, e.g., by putting it on a mode hook (see Hooks). For example, Texinfo mode runs the hook texinfo-mode-hook. Here’s how you can use the hook to add local bindings for C-c n and C-c p, and remove the one for C-c C-x x in Texinfo mode:

(add-hook 'texinfo-mode-hook
          (lambda ()
            (keymap-set texinfo-mode-map "C-c p"
                        'backward-paragraph)
            (keymap-set texinfo-mode-map "C-c n"
                        'forward-paragraph)
            (keymap-set texinfo-mode-map "C-c C-x x" nil)))


*** Modifier Keys

The default key bindings in Emacs are set up so that modified alphabetical characters are case-insensitive. In other words, C-A does the same thing as C-a, and M-A does the same thing as M-a. This concerns only alphabetical characters, and does not apply to shifted versions of other keys; for instance, C-@ is not the same as C-2.

A Control-modified alphabetical character is generally considered case-insensitive: Emacs always treats C-A as C-a, C-B as C-b, and so forth. The reason for this is historical: In non-graphical environments there is no distinction between those keystrokes. However, you can bind shifted Control alphabetical keystrokes in GUI frames:

(keymap-global-set "C-S-n" #'previous-line)
For all other modifiers, you can make the modified alphabetical characters case-sensitive (even on non-graphical frames) when you customize Emacs. For instance, you could make M-a and M-A run different commands.

Although only the Control and Meta modifier keys are commonly used, Emacs supports three other modifier keys. These are called Super, Hyper, and Alt. Few terminals provide ways to use these modifiers; the key labeled Alt on most keyboards usually issues the Meta modifier, not Alt. The standard key bindings in Emacs do not include any characters with the Super and Hyper modifiers, and only a small number of standard key bindings use Alt. However, you can customize Emacs to assign meanings to key bindings that use these modifiers. The modifier bits are labeled as ‘s-’, ‘H-’ and ‘A-’ respectively.

Even if your keyboard lacks these additional modifier keys, you can enter them using C-x @: C-x @ h adds the Hyper flag to the next character, C-x @ s adds the Super flag, and C-x @ a adds the Alt flag. For instance, C-x @ h C-a is a way to enter Hyper-Control-a. (Unfortunately, there is no way to add two modifiers by using C-x @ twice for the same character, because the first one goes to work on the C-x.) You can similarly enter the Shift, Control, and Meta modifiers by using C-x @ S, C-x @ c, and C-x @ m, respectively, although this is rarely needed.


*** Rebinding Function Keys

Key sequences can contain function keys as well as ordinary characters. Just as Lisp characters (actually integers) represent keyboard characters, Lisp symbols represent function keys. If the function key has a word as its label, then that word is also the name of the corresponding Lisp symbol. Here are the conventional Lisp names for common function keys:

left, up, right, down
Cursor arrow keys.

begin, end, home, next, prior
Other cursor repositioning keys.

select, print, execute, backtab
insert, undo, redo, clearline
insertline, deleteline, insertchar, deletechar
Miscellaneous function keys.

f1, f2, … f35
Numbered function keys (across the top of the keyboard).

kp-add, kp-subtract, kp-multiply, kp-divide
kp-backtab, kp-space, kp-tab, kp-enter
kp-separator, kp-decimal, kp-equal
kp-prior, kp-next, kp-end, kp-home
kp-left, kp-up, kp-right, kp-down
kp-insert , kp-delete
Keypad keys (to the right of the regular keyboard), with names or punctuation.

kp-0, kp-1, … kp-9
Keypad keys with digits.

kp-f1, kp-f2, kp-f3, kp-f4
Keypad PF keys.

These names are conventional, but some systems (especially when using X) may use different names. To make certain what symbol is used for a given function key on your terminal, type C-h c followed by that key.

See Rebinding Keys in Your Init File, for examples of binding function keys.

Many keyboards have a numeric keypad on the right-hand side. The numeric keys in the keypad double up as cursor motion keys, toggled by a key labeled ‘Num Lock’. By default, Emacs translates these keys to the corresponding keys on the main keyboard. For example, when ‘Num Lock’ is on, the key labeled ‘8’ on the numeric keypad produces kp-8, which is translated to 8; when ‘Num Lock’ is off, the same key produces kp-up, which is translated to UP. If you rebind a key such as 8 or UP, it affects the equivalent keypad key too. However, if you rebind a ‘kp-’ key directly, that won’t affect its non-keypad equivalent. Note that the modified keys are not translated: for instance, if you hold down the Meta key while pressing the ‘8’ key on the numeric keypad, that generates M-kp-8.

Emacs provides a convenient method for binding the numeric keypad keys, using the variables keypad-setup, keypad-numlock-setup, keypad-shifted-setup, and keypad-numlock-shifted-setup. These can be found in the ‘keyboard’ customization group (see Easy Customization Interface). You can rebind the keys to perform other tasks, such as issuing numeric prefix arguments.


*** Named ASCII Control Characters

TAB, RET, BS, LFD, ESC, and DEL started out as names for certain ASCII control characters, used so often that they have special keys of their own. For instance, TAB was another name for C-i. Later, users found it convenient to distinguish in Emacs between these keys and the corresponding control characters typed with the Ctrl key. Therefore, on most modern terminals, they are no longer the same: TAB is different from C-i.

Emacs can distinguish these two kinds of input if the keyboard does. It treats the special keys as function keys named tab, return, backspace, linefeed, escape, and delete. These function keys translate automatically into the corresponding ASCII characters if they have no bindings of their own. As a result, neither users nor Lisp programs need to pay attention to the distinction unless they care to.

If you do not want to distinguish between (for example) TAB and C-i, make just one binding, for the ASCII character TAB (octal code 011). If you do want to distinguish, make one binding for this ASCII character, and another for the function key tab.

With an ordinary ASCII terminal, there is no way to distinguish between TAB and C-i (and likewise for other such pairs), because the terminal sends the same character in both cases.


*** Rebinding Mouse Buttons

Emacs uses Lisp symbols to designate mouse buttons, too. The ordinary mouse events in Emacs are click events; these happen when you press a button and release it without moving the mouse. You can also get drag events, when you move the mouse while holding the button down. Drag events happen when you finally let go of the button.

The symbols for basic click events are mouse-1 for the leftmost button, mouse-2 for the next, and so on. Here is how you can redefine the second mouse button to split the current window:

(keymap-global-set "<mouse-2>" 'split-window-below)
The symbols for drag events are similar, but have the prefix ‘drag-’ before the word ‘mouse’. For example, dragging the first button generates a drag-mouse-1 event.

You can also define bindings for events that occur when a mouse button is pressed down. These events start with ‘down-’ instead of ‘drag-’. Such events are generated only if they have key bindings. When you get a button-down event, a corresponding click or drag event will always follow.

If you wish, you can distinguish single, double, and triple clicks. A double click means clicking a mouse button twice in approximately the same place. The first click generates an ordinary click event. The second click, if it comes soon enough, generates a double-click event instead. The event type for a double-click event starts with ‘double-’: for example, double-mouse-3.

This means that you can give a special meaning to the second click at the same place, but it must act on the assumption that the ordinary single click definition has run when the first click was received.

This constrains what you can do with double clicks, but user interface designers say that this constraint ought to be followed in any case. A double click should do something similar to the single click, only more so. The command for the double-click event should perform the extra work for the double click.

If a double-click event has no binding, it changes to the corresponding single-click event. Thus, if you don’t define a particular double click specially, it executes the single-click command twice.

Emacs also supports triple-click events whose names start with ‘triple-’. Emacs does not distinguish quadruple clicks as event types; clicks beyond the third generate additional triple-click events. However, the full number of clicks is recorded in the event list, so if you know Emacs Lisp you can distinguish if you really want to (see Click Events in The Emacs Lisp Reference Manual). We don’t recommend distinct meanings for more than three clicks, but sometimes it is useful for subsequent clicks to cycle through the same set of three meanings, so that four clicks are equivalent to one click, five are equivalent to two, and six are equivalent to three.

Emacs also records multiple presses in drag and button-down events. For example, when you press a button twice, then move the mouse while holding the button, Emacs gets a ‘double-drag-’ event. And at the moment when you press it down for the second time, Emacs gets a ‘double-down-’ event (which is ignored, like all button-down events, if it has no binding).

The variable double-click-time specifies how much time can elapse between clicks and still allow them to be grouped as a multiple click. Its value is in units of milliseconds. If the value is nil, double clicks are not detected at all. If the value is t, then there is no time limit. The default is 500.

The variable double-click-fuzz specifies how much the mouse can move between clicks and still allow them to be grouped as a multiple click. Its value is in units of pixels on windowed displays and in units of 1/8 of a character cell on text-mode terminals; the default is 3.

The symbols for mouse events also indicate the status of the modifier keys, with the usual prefixes ‘C-’, ‘M-’, ‘H-’, ‘s-’, ‘A-’, and ‘S-’. These always precede ‘double-’ or ‘triple-’, which always precede ‘drag-’ or ‘down-’.

A frame includes areas that don’t show text from the buffer, such as the mode line and the scroll bar. You can tell whether a mouse button comes from a special area of the screen by means of dummy prefix keys. For example, if you click the mouse in the mode line, you get the prefix key mode-line before the ordinary mouse-button symbol. Thus, here is how to define the command for clicking the first button in a mode line to run scroll-up-command:

(keymap-global-set "<mode-line> <mouse-1>" 'scroll-up-command)
Here is the complete list of these dummy prefix keys and their meanings:

mode-line
The mouse was in the mode line of a window.

vertical-line
The mouse was in the vertical line separating side-by-side windows. (If you use scroll bars, they appear in place of these vertical lines.)

vertical-scroll-bar
The mouse was in a vertical scroll bar. (This is the only kind of scroll bar Emacs currently supports.)

menu-bar
The mouse was in the menu bar.

tab-bar
The mouse was in a tab bar.

tab-line
The mouse was in a tab line.

header-line
The mouse was in a header line.

You can put more than one mouse button in a key sequence, but it isn’t usual to do so.


*** Disabling Commands

Disabling a command means that invoking it interactively asks for confirmation from the user. The purpose of disabling a command is to prevent users from executing it by accident; we do this for commands that might be confusing to the uninitiated.

Attempting to invoke a disabled command interactively in Emacs displays a window containing the command’s name, its documentation, and some instructions on what to do immediately; then Emacs asks for input saying whether to execute the command as requested, enable it and execute it, or cancel. If you decide to enable the command, you must then answer another question—whether to do this permanently, or just for the current session. (Enabling permanently works by automatically editing your initialization file.) You can also type ! to enable all commands, for the current session only.

The direct mechanism for disabling a command is to put a non-nil disabled property on the Lisp symbol for the command. Here is the Lisp program to do this:

(put 'delete-region 'disabled t)
If the value of the disabled property is a string, that string is included in the message displayed when the command is used:

(put 'delete-region 'disabled
     "It's better to use `kill-region' instead.\n")
As a less heavy-handed alternative to disabling commands, you may want to be queried before executing a command. For instance, to be queried before executing the M-> (end-of-buffer) command, you could put something like the following in your init file:

(command-query
 'end-of-buffer
 "Do you really want to go to the end of the buffer?")
By default, you’ll be queried with a y/n question, but if you give a non-nil value to the third, optional argument, you’ll be queried with yes/no instead.

You can make a command disabled either by editing the initialization file directly, or with the command M-x disable-command, which edits the initialization file for you. Likewise, M-x enable-command edits the initialization file to enable a command permanently. See The Emacs Initialization File.

If Emacs was invoked with the -q or --no-init-file options (see Initial Options), it will not edit your initialization file. Doing so could lose information because Emacs has not read your initialization file.

Whether a command is disabled is independent of what key is used to invoke it; disabling also applies if the command is invoked using M-x. However, disabling a command has no effect on calling it as a function from Lisp programs.


* GNU Hyperbole

  Send an email or a testimonial if you like Hyperbole to <rsw@gnu.org>.

  This interactive demo is the fast way to get started with Hyperbole after
  installation.  The prior, lengthier Hyperbole demo/tutorial can be found
  in this file: "DEMO".  For a non-interactive introduction to Hyperbole
  concepts, see "HY-CONCEPTS.kotl".


** Introductory Videos

  If you prefer video introductions, visit the videos linked to in the tables below;
  otherwise, skip to the next section.  The first table is an overview talk of
  Hyperbole broken into few minute sections that you can watch individually.  The
  second table has links to separate videos covering aspects of Hyperbole.

  Hyperbole video demos start with 'section 06 - Hyperbole Buttons' in this first
  table.  Press {M-RET} either in the first column <[button name]> or in the second
  column video link to watch each section.
  
  |--------------------------------------+-----------------------------------------|
  | Hyperbole Video Overview Sections    | Video Snippets                          |
  |--------------------------------------+-----------------------------------------|
  |--------------------------------------+-----------------------------------------|
  | 01. <[Introduction]>                 | <yt-play "WKwZHSbHmPg" "0:01" "1:38">   |
  | 02. <[Hyperbole Mission]>            | <yt-play "WKwZHSbHmPg" "1:39" "2:43">   |
  | 03. <[Why Use Hyperbole]>            | <yt-play "WKwZHSbHmPg" "2:44" "4:34">   |
  | 04. <[Components]>                   | <yt-play "WKwZHSbHmPg" "4:35" "7:30">   |
  | 05. <[Installation & Use]>           | <yt-play "WKwZHSbHmPg" "7:31" "8:35">   |
  | 06. <[Hyperbole Buttons]>            | <yt-play "WKwZHSbHmPg" "8:36" "10:03">  |
  | 07. <[Button Categories & Files]>    | <yt-play "WKwZHSbHmPg" "10:04" "12:25"> |
  | 08. <[Implicit Buttons]>             | <yt-play "WKwZHSbHmPg" "12:26" "20:03"> |
  | 09. <[Implicit Button Types]>        | <yt-play "WKwZHSbHmPg" "20:04" "21:47"> |
  | 10. <[Explicit Buttons]>             | <yt-play "WKwZHSbHmPg" "21:48" "33:28"> |
  | 11. <[Global Buttons]>               | <yt-play "WKwZHSbHmPg" "33:29" "36:08"> |
  | 12. <[Mouse Keys/Buttons]>           | <yt-play "WKwZHSbHmPg" "36:09" "36:55"> |
  | 13. <[Mouse Drags & Treemacs]>       | <yt-play "WKwZHSbHmPg" "36:56" "38:00"> |
  | 14. <[Window Grids & Throws]>        | <yt-play "WKwZHSbHmPg" "38:01" "39:45"> |
  | 15. <[The Find Menu]>                | <yt-play "WKwZHSbHmPg" "39:46" "41:14"> |
  | 16. <[The Koutliner]>                | <yt-play "WKwZHSbHmPg" "41:15" "47:09"> |
  | 17. <[HyRolo]>                       | <yt-play "WKwZHSbHmPg" "47:10" "49:04"> |
  | 18. <[HyControl & Org Mode]>         | <yt-play "WKwZHSbHmPg" "49:05" "50:33"> |
  | 19. <[Integrations]>                 | <yt-play "WKwZHSbHmPg" "50:34" "50:58"> |
  | 20. <[Hyperbole History]>            | <yt-play "WKwZHSbHmPg" "50:59" "53:28"> |
  | 21. <[Acknowledgements & Resources]> | <yt-play "WKwZHSbHmPg" "53:29" "54:24"> |
  | 22. <[The Big Picture]>              | <yt-play "WKwZHSbHmPg" "54:25" "56:44"> |
  |--------------------------------------+-----------------------------------------|

  |-----------------------------------------------------+------------------------------|
  | GNU Hyperbole Videos                                | Web Link                     |
  |-----------------------------------------------------+------------------------------|
  |-----------------------------------------------------+------------------------------|
  | <[Overview and Demo]>                               | https://youtu.be/WKwZHSbHmPg |
  | Sections broken out in the prior table              |                              |
  |-----------------------------------------------------+------------------------------|
  | <[Quick Introduction]>                              | https://youtu.be/K1MNUctggwI |
  |-----------------------------------------------------+------------------------------|
  | <[Top 10 ways Hyperbole amps up Emacs]>             | https://youtu.be/BysjfL25Nlc |
  |-----------------------------------------------------+------------------------------|
  | <[Introduction to Buttons]>                         | https://youtu.be/zoEht66N2PI |
  |-----------------------------------------------------+------------------------------|
  | <[Linking Personal Info with Implicit Buttons]>     | https://youtu.be/TQ_fG7b1iHI |
  |-----------------------------------------------------+------------------------------|
  | <[Powerful Productivity with Hyperbole and Org]>    | https://youtu.be/BrTpTNEXMyY |
  |-----------------------------------------------------+------------------------------|
  | <[HyRolo, fast contact/hierarchical record viewer]> | https://youtu.be/xdJGFdgKPFY |
  |-----------------------------------------------------+------------------------------|
  | <[Using Koutline for stream of thought journaling]> | https://youtu.be/dO-gv898Vmg |
  |-----------------------------------------------------+------------------------------|
  | <[Build a Zettelkasten with HyRolo]>                | https://youtu.be/HdlCK9w-LyQ |
  |-----------------------------------------------------+------------------------------|
  | <[HyControl, fast Emacs frame and window manager]>  | https://youtu.be/M3-aMh1ccJk |
  |-----------------------------------------------------+------------------------------|
  | <[Writing test cases for GNU Hyperbole]>            | https://youtu.be/maNQSKxXIzI |
  |-----------------------------------------------------+------------------------------|
  | <[Find/Web Search]>                                 | https://youtu.be/8lMlJed0-OM |
  |-----------------------------------------------------+------------------------------|


** Introduction

  Welcome to GNU Hyperbole.  Hyperbole will super-charge your GNU Emacs
  experience, allowing you to work faster, utilize fewer key bindings, recall
  more information and link it all together by learning just a few concepts
  and keys.  Invest an hour learning Hyperbole now and speed your daily
  information management for years to come.

  Hyperbole assumes you know how to use Emacs.  Otherwise, run the Emacs
  tutorial by pressing {C-h t} first.

  You should be looking at this file within Emacs and Hyperbole should
  already be installed within your copy of Emacs.  To be sure, press 'C-h h'
  and you should see the Hyperbole menu in your minibuffer window at the
  bottom of your current Emacs frame.  Press 'q' to quit out of this menu
  and we can begin.  If Hyperbole is not installed, see the "INSTALL" file,
  in the same directory as this file, for instructions on installing it,
  though {M-x package-install RET hyperbole RET} is typically all you need.

  If you simply want to know what Hyperbole is, see the file "HY-ABOUT".
  Hyperbole displays that file when you press the minibuffer menu command,
  {C-h h d a}.  Any of Hyperbole's menu commands can be programmatically
  bound to another key, like so:

    (global-set-key "\C-cd" (kbd "C-h h d a"))


** Implicit Buttons

  Hyperbole automatically recognizes many common and complex patterns within
  Emacs buffers and turns them into hyperbuttons that either link to other
  things or perform a set of actions.  No need for markup, simply press on a
  button in any kind of Emacs buffer to activate it.

  These patterns are called `implicit buttons' and are activated by pressing
  {M-RET} (ESC RETURN, ALT-RETURN, or CMD-RETURN) or SHIFT-MIDDLE-MOUSE
  anywhere within them (this is known as the Action Key).  Hyperbole
  recognizes these buttons using its many predefined implicit button types
  that specify how to recognize each type of button and what action it
  performs.  (For example, the web links in the table above are implicit
  buttons that display web pages.  So are the series of key presses
  surrounded by braces throughout this document).  You can also add your own
  button and action types.

  Try pressing {M-RET} or SHIFT-MIDDLE-MOUSE on some of the implicit buttons
  in double quotes below to activate them and see how they behave.  Press
  {C-h A} (the A must be capitalized) on any Hyperbole button or highlighted
  Emacs push-button to see exactly what it does prior to activating it.


*** Implicit Link Buttons

  You can simply type implicit buttons into a buffer or you can use {C-h h i
  c} to create them and give them names.  When you have exactly two windows
  in an Emacs frame, you can instantly create an unnamed implicit link
  button from the selected window to point in the other window by using {C-h
  h i l}.  {M-1 C-h h i l} creates or renames a named implicit button that
  looks like <[name]>.

  You can create the same button by depressing the Action Mouse Key in the
  text of one window and dragging to the text of the other and releasing it.
  An implicit link button of an appropriate type for the release context
  will be inserted at the original depress point.

  With more than two windows, Hyperbole will prompt you to choose the
  referent window and its associated point to which to link.  If the Ace
  Window package is installed and active, this will be used to choose the
  window; otherwise, you will be prompted to select it by mouse.


*** Pathname Implicit Buttons

    "HY-NEWS#ORG MODE:3:6"   - outline section anchor & relative line number

       Display the file, "HY-NEWS", go to the star-outline section 'ORG
       MODE', move 3 lines into that section and then move 6 characters
       forward.  "HY-NEWS#ORG MODE:L3:C6" with the line and column numbers
       labeled works as well.

       Existing files and pathnames without spaces are also recognized without
       double quotes.

       The variable, <hpath:display-where>, determines where Hyperbole
       displays all button referents, whether in another window or frame.

    "#Key Series Implicit Buttons"

       Display at the top of another window the named section from the
       current buffer.

    <[comp]>: "README.md#Hyperbole Components" - Markdown anchor with spaces intact

       Display the file, "README.md", scrolled to it outline section,
       "Hyperbole Components".  Name this button, 'comp'.  Then you can link
       to it elsewhere in the buffer with <ilink: comp>.  {M-RET} on the
       ilink to activates the button it links to.

    "${hyperb:dir}/HY-NEWS"          - Elisp or environment variables; $VAR
                                       shell vars work too


    "subr.el"                        - edit any Elisp library in load-path

       The variable, hpath:auto-variable-alist, determines which file
       suffixes are looked up using variables containing multiple search
       directories. By default, Org files, Python files and Elisp files are
       handled.

    "(hyperbole)action-key-modeline-function" 

       Double quoted Info manual references are also implicit buttons.  You
       can link to both nodes/sections in GNU Info manuals as well as to
       specific lines referenced by an index entry, as shown above, providing
       fine-grained structured document linking.  Remember this as there will
       be more Info links below.


*** Key Series Implicit Buttons

    A key series is an arbitrary length set of bound Emacs keystrokes
    surrounded by braces, like a visual keyboard macro.  RET, SPC and
    ESC are translated into their respective keys.  Activate them with
    {M-RET} or SHIFT-MIDDLE-MOUSE.

    {C-h A}

       Press {C-h A} when over any Hyperbole button for an explanation of
       what it does.

    {M-x dired-other-window RET ${hyperb:dir}/*.el M-RET}

       Hyperbole home directory Dired listing of Emacs Lisp files only

    {C-22 C-c @}

       Display a 2x2 windows grid in the current frame of the 4 most recently
       used buffers.  Before you try this, remember the binding {C-h h y} for
       History.  Use that to return to your current window configuration
       after pressing the Action Key on any windows grid button.

    {C--1 C-c @ kotl/kotl-*.el RET}

       Find the Hyperbole Koutliner source files that begin with 'kotl' and
       display them in an auto-sized grid of windows.

    {C-0 C-c @ emacs-lisp-mode RET 33 RET}

       Display the 9 mostly recently used Emacs Lisp buffers in a 3x3 grid.
       A BLANK buffer fills in the grid if there are not enough Emacs Lisp
       ones.

    {C-x 4 d ${hyperb:dir} RET}

       Dired the Hyperbole home directory based on its variable.  {M-RET}
       on the directory itself will display the directory's value in the
       minibuffer.

       Within this dired buffer, mark a few files with {m} and then press
       {@} to display a window grid of those files only.  That works in
       Buffer Menu and IBuffer modes as well.

    {C-x C-b C-x C-q M-x keep-lines RET .el$ RET C-x C-q}

       Display a buffer list of Emacs Lisp file buffers only

    {C-x C-b C-x C-q M-x keep-lines RET [\\/]$ RET C-x C-q}

       Buffer list of directory buffers only


*** Posix/Linux Shell Command Implicit Buttons

    Some of the below commands require recursive use of the minibuffer, so let's
    ensure that is enabled:

    <setq enable-recursive-minibuffers t>

    The shell command part of the demo requires a shell that is compatible
    with bash.  If you are using another shell you can switch to bash for
    this part of the demo:

    { M-x set-variable RET shell-file-name RET C-u M-! /usr/bin/env SPC bash RET RET }

       Set the name of the inferior shell to /bin/bash. If you do this
       don't forget to reset it to your preferred shell when you are ready
       with the demo.

    { M-x shell RET M-> (cd ${hyperb:dir}) RET }

       Move to a directory in a shell based on a Lisp variable.  Sections
       within key series surrounded by parentheses maintain spaces between
       words without the need to use 'SPC'.

    {M-x shell RET M-> (export HYPERBOLE_DIR=${hyperb:dir} && 
     cd $HYPERBOLE_DIR && grep -n gbut:label-list *.el) RET}

       Use both a Hyperbole resolved variable, ${hyperb:dir}, and a
       shell-resolved environment variable, $HYPERBOLE_DIR, to grep through
       Lisp files.

    {M-x shell RET M-> (apropos grep) RET}

       Use Posix apropos command to list grep-related commands.  Then press
       {M-RET} on any lines output to display the man page for the associated
       command.


*** Grep Messages, Stack Traces, Man Page Apropos Implicit Buttons

  These implicit buttons typically appear in shell buffers.  You issue a
  shell command and then use {M-RET} or SHIFT-MIDDLE-MOUSE on the output
  lines of the command to display the associated reference.

**** grep -n gbut:label-list *.el
hactypes.el:454:					      (mapcar #'list (gbut:label-list))
hbut.el:605:				       (mapcar #'list (gbut:label-list))

       An Action Key press anywhere on the text of the two above output lines
       from a grep -n or a ripgrep command jumps to the referenced line.

**** python topwin.py
Traceback (most recent call last):
  File "topwin.py", line 18, in <module>
    import Quartz

       An Action Key press anywhere on the above 2 non-blank lines jumps to
       the source of the error.  You can jump into any stack frame this way
       when debugging from pretty much any language, even in a regular shell.

**** man -k spell
aspell(1)                - interactive spell checker
aspell-import(1)         - import old personal dictionaries into GNU Aspell
pspell-config(1)         - prints information about a libpspell installation

       An Action Key press anywhere on the above 3 non-blank lines displays
       the associated man documentation page.


*** Action Buttons

  These are a generalized form of implicit buttons.

  If you know your way around Emacs Lisp and want to quickly turn snippets of
  Lisp code or Lisp variables into Hyperbole buttons, just remove any outer
  parentheses and surround the remaining code with <angle-brackets>.

  Here are some examples.

    <shell>

       Jump to an existing shell buffer or create a new one.

    <fill-column>

       Display the variable value of 'fill-column' in the minibuffer

    <find-file-other-window (expand-file-name "DEMO" hyperb:dir)>
    <hpath:find "${hyperb:dir}/DEMO")>
    "${hyperb:dir}/DEMO"

       All three of the above do essentially the same thing, displaying the
       file.

    <kotl/EXAMPLE.kotl#3b10|c2en>

       Display a Hyperbole Koutline starting from cell 3b10 with lines per
       cell clipped to 2.

    <ert-deftest hbut-tests-ibut-program-link-to-directory ()
      "Test programmatically creating a link-to-directory implicit button."
      (with-temp-buffer
	(ibut:program nil 'link-to-directory "/tmp")
	(should (string= "\"/tmp\"" (buffer-string))))>

    <hbut-tests-ibut-program-link-to-directory>

       Tests defined with the Emacs Regression Test framework using
       `ert-deftest' can be run via action buttons as well.  Press {M-RET}
       on the first line of each of the two above action buttons, within
       the <> delimiters.  Start with the first one which defines an ERT
       test case; the second one runs it, displaying the result which should
       be successful.

    <hyperbole-run-tests hyrolo>

       The above will even run all Hyperbole regression tests for the HyRolo
       hierarchical full-text record retriever part of Hyperbole.


*** Many More Implicit Button Types to Learn Across Time

  Activate this button, <emacs-lisp-mode>, to set this buffer into Emacs Lisp
  mode.  Then an Action Key press on each of the implicit button types below
  will jump to its Lisp definition.  Use this if you want to see what each
  type can do.  <normal-mode> reverts to the standard mode.

|------------------------+---------------------------+-----------------------|
|                          Implicit Button Types                             |
|------------------------+---------------------------+-----------------------|
| action                 | annot-bib                 | completion            |
| cscope                 | ctags                     | debbugs-gnu-mode      |
| debbugs-gnu-query      | debugger-source           | dir-summary           |
| doc-id                 | elink                     | elisp-compiler-msg    |
| etags                  | git-commit-reference      | glink                 |
| gnus-push-button       | grep-msg                  | hyp-address           |
| hyp-source             | id-cflow                  | ilink                 |
| Info-node              | ipython-stack-frame       | kbd-key               |
| klink                  | mail-address              | man-apropos           |
| markdown-internal-link | org-link-outside-org-mode | patch-msg             |
| pathname               | pathname-line-and-column  | rfc                   |
| rfc-toc                | ripgrep-msg               | social-reference      |
| texinfo-ref            | text-toc                  | www-url               |
|----------------------------------------------------------------------------|

Implicit button types are stored in their own namespace, 'ibtypes::', so to
see the doc on the 'pathname' ibtype, use {C-h f ibtypes::pathname RET}.

See "DEMO#Implicit Buttons" or "(hyperbole)Implicit Buttons" for more detail.
To learn how to create new kinds of implicit button and action types, see
"(hyperbole)Creating Types".


** Hyperbole Explicit and Global Buttons

  You have learned the basics of Hyperbole implicit button types.  Hyperbole
  has two other categories of buttons:

  `Explicit buttons' are manually created and embedded within buffers and
  explicitly assigned any of the many action types that Hyperbole includes.
  These contrast with implicit buttons which Hyperbole generates
  automatically by recognizing text patterns in buffers.  Explicit buttons
  look like this: <(fake button)>.  They are quickly recognizable, yet
  relatively non-distracting as one scans the text in which they are
  embedded.  Explicit buttons can link to local and remote files or to a
  section within a document; they can calculate things or query databases or
  show different views of bodies of information.

  Unlike HTML hyperbuttons, there is no markup language to learn nor
  specific document format required.  You can create explicit buttons with
  simple keyboard presses or mouse drags from one window to another (when
  not on a draggable item).  See the {C-h h e} menu for explicit button
  commands.  {C-h h e c} creates an explicit button and {C-h h e l} creates
  an explicit link button between two windows, just like their counterparts
  for implicit buttons.  See "DEMO#Explicit Buttons" or "(hyperbole)Explicit
  Buttons" for more detail.

  `Global buttons' are explicit or named implicit Hyperbole buttons that are
  stored in your personal button file edited with {C-h h b p}.  Any such
  button in there becomes global and is accessible by name without the need
  to have the that file on screen.  Simply press {C-h h g a} to activate a
  global button and you will be prompted with completion for the button
  name.  See the {C-h h g} menu for the rest of the global button commands.
  See "DEMO#Global Buttons" or "(hyperbole)Global Buttons" for more detail.


** Hyperbole Subsystems

  Hyperbole includes a number of subsystems that can raise your productivity
  when looking up any kind of hierarchical records (including those from Org
  mode or Outline mode), managing the precise location of windows and frames,
  and one of the most advanced legal outliners available anywhere.

*** HyWiki

  HyWiki is Hyperbole's markup-free personal wiki system for note-taking
  and automatic wiki-word highlighting and hyperlinking.  It uses Org
  mode for note taking and adds automatic hyperlinking of HyWikiWords
  within Org files in `hywiki-directory' (default = "~/hywiki"), where
  a HyWikiWord is a capitalized word that contains upper and lowercase
  letters only and has a corresponding HyWikiWord.org wiki page file
  below `hywiki-directory'.  HyWikiWords require no delimiters.
  
  Use {M-RET} on the first line of the expression below to set a demo
  HyWiki directory and turn on hywiki-mode so HyWikiWords are
  highlighted outside of the HyWiki directory.
  
    <progn (setq hywiki-directory (hpath:expand "${hyperb:dir}/hywiki/"))
           (hywiki-mode 1)>
  
  Now all these wiki-words should be highlighted and can appear in any
  text buffer and will be treated as hyperlinks.  Simply press {M-RET}
  on each to display the associated wiki page:
  
    HyWiki
    HyWikiMenus
    Publishing
  
  Let's create a new page.  Press {M-RET} on the HyWikiWord below:

  TestWord

  Finally, let's restore the standard HyWiki directory so you can add
  your own HyWiki pages.  Press {M-RET} on the following expression.

    <setq hywiki-directory "~/hywiki/">

  See "(hyperbole)HyWiki" for full details on HyWiki.

*** HyRolo

  HyRolo is an advanced hierarchical, record-oriented retrieval system that
  uses text files for storing its records.  Most often this is used for
  contact management but it can quickly be adapted to most any
  record-oriented lookup task requiring fast retrieval.  Press {M-RET} on
  "(hyperbole)HyRolo".

*** HyControl

  Hyperbole includes the fastest, easiest-to-use Emacs window and frame
  management system available, HyControl, found under the Hyperbole Screen
  menu, {C-h h s}.  If you use a lot of Emacs windows or frames (native
  window system windows), then this tool is for you.  Press {M-RET} on
  "(hyperbole)HyControl".

*** Koutliner

  The Hyperbole Koutliner produces multi-level, autonumbered hierarchies of
  cells.  Each cell has two identifiers, a relative autonumber indicating its
  present position within the outline and a permanent identifier suitable for
  use within hyperlink references to the cell.

  A demonstration of the Koutliner is found on the Hyperbole Kotl/Example
  menu entry, {C-h h k e}.  This gives you an editable copy of Hyperbole's
  example Koutliner file.  This file explains the Koutliner commands and
  lets you try them out as you learn.  Additional documentation can be found
  in "(hyperbole)Koutliner".  "(hyperbole)Koutliner Keys" summarizes, in
  alphabetical order, the Koutliner commands which are bound to keys.


** Reference Documentation

  As noted at the start, "DEMO" provides a more extensive, interactive look
  into Hyperbole, {C-h h d d}, if you have more time.

  For a quick, non-interactive introduction to Hyperbole concepts, use
  "HY-CONCEPTS.kotl" available with {C-h h d c}.

  For those who want the deepest knowledge of Hyperbole, there is the long
  Hyperbole reference manual that you can read in sections.  This covers in
  detail how each button and action type works, how to create your own button
  and action types and much more.  See "(hyperbole)" or use {C-h h d i}.

  It is included in the "${hyperb:dir}/man/" subdirectory of Hyperbole in
  four forms, accessible as the links below:

    "man/hyperbole.info"   - online Info browser version
    "man/hyperbole.html"   - web HTML version
    "man/hyperbole.pdf"    - printable version
    "man/hyperbole.texi"   - source form

-- The 





* D-Bus integration in Emacs 

** D-Bus Integration in Emacs: Use Cases

  D-Bus integration allows Emacs to communicate with system services and other applications. Here are some practical use cases:

*** 1. Desktop Notifications
   You can trigger system-wide desktop notifications from Emacs.
   Example:
   #+begin_src elisp
     (dbus-call-method 
      :session "org.freedesktop.Notifications" 
      "/org/freedesktop/Notifications" 
      "org.freedesktop.Notifications" 
      "Notify" "Emacs" 0 "" "Task Completed" "Your task has finished!" '() '() 5000)
   #+end_src

*** 2. Controlling Media Players
   Use Emacs to control music players (like VLC, Rhythmbox, or Spotify) via D-Bus.
   Example:
   #+begin_src elisp
     (dbus-call-method 
      :session "org.mpris.MediaPlayer2.rhythmbox" 
      "/org/mpris/MediaPlayer2" 
      "org.mpris.MediaPlayer2.Player" 
      "PlayPause")
   #+end_src

*** 3. Interacting with System Services
   Interact with system services such as network management, power management, or Bluetooth. For instance, you could disconnect from Wi-Fi or check battery status from Emacs.

*** 4. File Management
   You can use D-Bus to interact with file managers like Nautilus or Dolphin, opening specific directories or files from within Emacs.

*** 5. Custom Automation
   Automate workflows by sending D-Bus commands to other programs and services, such as starting applications or managing desktop environments.

*** 6. Receiving Messages
   Emacs can listen for signals from D-Bus, such as system power events (e.g., low battery) or notifications from other apps.


** An overview of D-Bus

D-Bus is an inter-process communication mechanism for applications residing on the same host. The communication is based on messages. Data in the messages is carried in a structured way, it is not just a byte stream.

The communication is connection oriented to two kinds of message buses: a so called system bus, and a session bus. On a given machine, there is always one single system bus for miscellaneous system-wide communication, like changing of hardware configuration. On the other hand, the session bus is always related to a single user’s session.

Every client application, which is connected to a bus, registers under a unique name at the bus. This name is used for identifying the client application. Such a unique name starts always with a colon, and looks like ‘:1.42’.

Additionally, a client application can register itself to a so called known name, which is a series of identifiers separated by dots, as in ‘org.gnu.Emacs’. If several applications register to the same known name, these registrations are queued, and only the first application which has registered for the known name is reachable via this name. If this application disconnects from the bus, the next queued unique name becomes the owner of this known name.

An application can install one or several objects under its name. Such objects are identified by an object path, which looks similar to paths in a filesystem. An example of such an object path could be ‘/org/gnu/Emacs/’.

Applications might send a request to an object, that means sending a message with some data as input parameters, and receiving a message from that object with the result of this message, the output parameters. Such a request is called method in D-Bus.

The other form of communication are signals. The underlying message is emitted from an object and will be received by all other applications which have registered for such a signal.

All methods and signals an object supports are called interface of the object. Interfaces are specified under a hierarchical name in D-Bus; an object can support several interfaces. Such an interface name could be ‘org.gnu.Emacs.TextEditor’ or ‘org.gnu.Emacs.FileManager’.


** Inspection of D-Bus services.

*** D-Bus version

D-Bus has evolved over the years. New features have been added with new D-Bus versions. There are two variables, which allow the determination of the D-Bus version used.

Variable: dbus-compiled-version ¶
This variable, a string, determines the version of D-Bus Emacs is compiled against. If it cannot be determined the value is nil.

Variable: dbus-runtime-version ¶
The other D-Bus version to be checked is the version of D-Bus Emacs runs with. This string can be different from dbus-compiled-version. It is also nil, if it cannot be determined at runtime.


*** Bus names

There are several basic functions which inspect the buses for registered names. Internally they use the basic interface ‘org.freedesktop.DBus’, which is supported by all objects of a bus.

Function: dbus-list-activatable-names &optional bus ¶
This function returns the D-Bus service names, which can be activated for bus. It must be either the keyword :system (the default) or the keyword :session. An activatable service is described in a service registration file. Under GNU/Linux, such files are located at /usr/share/dbus-1/system-services/ (for the :system bus) or /usr/share/dbus-1/services/. An activatable service is not necessarily registered at bus already.

The result is a list of strings, which is nil when there are no activatable service names at all. Example:

;; Check, whether the document viewer can be accessed via D-Bus.
(member "org.gnome.evince.Daemon"
        (dbus-list-activatable-names :session))
Function: dbus-list-names bus ¶
This function returns all service names, which are registered at D-Bus bus. The result is a list of strings, which is nil when there are no registered service names at all. Well known names are strings like ‘org.freedesktop.DBus’. Names starting with ‘:’ are unique names for services.

bus must be either the keyword :system or the keyword :session.

Function: dbus-list-known-names bus ¶
This function retrieves all registered services which correspond to a known name in bus. A service has a known name if it doesn’t start with ‘:’. The result is a list of strings, which is nil when there are no known names at all.

bus must be either the keyword :system or the keyword :session.

Function: dbus-list-queued-owners bus service ¶
For a given service, registered at D-Bus bus under the name service, this function returns all queued unique names. The result is a list of strings, or nil when there are no queued names for service at all.

bus must be either the keyword :system or the keyword :session. service must be a known service name as string.

Function: dbus-get-name-owner bus service ¶
For a given service, registered at D-Bus bus under the name service, this function returns the unique name of the name owner. The result is a string, or nil when there is no name owner of service.

bus must be either the keyword :system or the keyword :session. service must be a known service name as string.

Function: dbus-ping bus service &optional timeout ¶
This function checks whether the service name service is registered at D-Bus bus. If service has not yet started, it is autostarted if possible. The result is either t or nil.

bus must be either the keyword :system or the keyword :session. service must be a string. timeout, a nonnegative integer, specifies the maximum number of milliseconds before dbus-ping must return. The default value is 25,000. Example:

(message
 "%s screensaver on board."
 (cond
  ((dbus-ping :session "org.gnome.ScreenSaver" 100) "Gnome")
  ((dbus-ping :session "org.freedesktop.ScreenSaver" 100) "KDE")
  (t "No")))
To check whether service is already running without autostarting it, you can instead write:

(member service (dbus-list-known-names bus))
Function: dbus-get-unique-name bus ¶
This function returns the unique name, under which Emacs is registered at D-Bus bus, as a string.

bus must be either the keyword :system or the keyword :session.


*** Knowing the details of D-Bus services

D-Bus services publish their interfaces. This can be retrieved and analyzed during runtime, in order to understand the used implementation.

The resulting introspection data are in XML format. The root introspection element is always a node element. It might have a name attribute, which denotes the (absolute) object path an interface is introspected.

The root node element may have node and interface children. A child node element must have a name attribute, this case it is the relative object path to the root node element.

An interface element has just one attribute, name, which is the full name of that interface. The default interface ‘org.freedesktop.DBus.Introspectable’ is always present. Example:

<node name="/org/bluez">
  <interface name="org.freedesktop.DBus.Introspectable">
    …
  </interface>
  <interface name="org.bluez.Manager">
    …
  </interface>
  <interface name="org.bluez.Database">
    …
  </interface>
  <interface name="org.bluez.Security">
    …
  </interface>
  <node name="service_audio"/>
  <node name="service_input"/>
  <node name="service_network"/>
  <node name="service_serial"/>
</node>
Children of an interface element can be method, signal and property elements. A method element stands for a D-Bus method of the surrounding interface. The element itself has a name attribute, showing the method name. Children elements arg stand for the arguments of a method. Example:

<method name="ResolveHostName">
  <arg name="interface" type="i" direction="in"/>
  <arg name="protocol" type="i" direction="in"/>
  <arg name="name" type="s" direction="in"/>
  <arg name="aprotocol" type="i" direction="in"/>
  <arg name="flags" type="u" direction="in"/>
  <arg name="interface" type="i" direction="out"/>
  <arg name="protocol" type="i" direction="out"/>
  <arg name="name" type="s" direction="out"/>
  <arg name="aprotocol" type="i" direction="out"/>
  <arg name="address" type="s" direction="out"/>
  <arg name="flags" type="u" direction="out"/>
</method>
arg elements can have the attributes name, type and direction. The name attribute is optional. The type attribute stands for the signature of the argument in D-Bus. For a discussion of D-Bus types and their Lisp representation see Mapping Lisp types and D-Bus types..1 The direction attribute of an arg element can be only ‘in’ or ‘out’; in case it is omitted, it defaults to ‘in’.

A signal element of an interface has a similar structure. The direction attribute of an arg child element can be only ‘out’ here; which is also the default value. Example:

<signal name="StateChanged">
  <arg name="state" type="i"/>
  <arg name="error" type="s"/>
</signal>
A property element has no arg child element. It just has the attributes name, type and access, which are all mandatory. The access attribute allows the values ‘readwrite’, ‘read’, and ‘write’. Example:

<property name="Status" type="u" direction="read"/>
annotation elements can be children of interface, method, signal, and property elements. Unlike properties, which can change their values during lifetime of a D-Bus object, annotations are static. Often they are used for code generators of D-Bus language bindings. Example:

<annotation name="de.berlios.Pinot.GetStatistics" value="pinotDBus"/>
Annotations have just name and value attributes, both must be strings.

Function: dbus-introspect bus service path ¶
This function returns all interfaces and sub-nodes of service, registered at object path path at bus bus.

bus must be either the keyword :system or the keyword :session. service must be a known service name, and path must be a valid object path. The last two parameters are strings. The result, the introspection data, is a string in XML format. Example:

(dbus-introspect
 :system "org.freedesktop.Hal"
 "/org/freedesktop/Hal/devices/computer")

⇒ "<!DOCTYPE node PUBLIC
    "-//freedesktop//DTD D-BUS Object Introspection 1.0//EN"
    "http://www.freedesktop.org/standards/dbus/1.0/introspect.dtd">
    <node>
      <interface name="org.freedesktop.Hal.Device">
        <method name="GetAllProperties">
          <arg name="properties" direction="out" type="a{sv}"/>
        </method>
        …
        <signal name="PropertyModified">
          <arg name="num_updates" type="i"/>
          <arg name="updates" type="a(sbb)"/>
        </signal>
      </interface>
      …
    </node>"
This example informs us, that the service ‘org.freedesktop.Hal’ at object path ‘/org/freedesktop/Hal/devices/computer’ offers the interface ‘org.freedesktop.Hal.Device’ (and 2 other interfaces not documented here). This interface contains the method ‘GetAllProperties’, which needs no input parameters, but returns as output parameter an array of dictionary entries (key-value pairs). Every dictionary entry has a string as key, and a variant as value.

The interface offers also a signal, which returns 2 parameters: an integer, and an array consisting of elements which are a struct of a string and 2 boolean values.2

Function: dbus-introspect-xml bus service path ¶
This function serves a similar purpose to the function dbus-introspect. The returned value is a parsed XML tree, which can be used for further analysis. Example:

(dbus-introspect-xml
 :session "org.freedesktop.xesam.searcher"
 "/org/freedesktop/xesam/searcher/main")

⇒ (node ((name . "/org/freedesktop/xesam/searcher/main"))
    (interface ((name . "org.freedesktop.xesam.Search"))
      (method ((name . "GetHitData"))
        (arg ((name . "search")
              (type . "s")
              (direction . "in")))
        (arg ((name . "hit_ids")
              (type . "au")
              (direction . "in")))
        (arg ((name . "fields")
              (type . "as")
              (direction . "in")))
        (arg ((name . "hit_data")
              (type . "aav")
              (direction . "out"))))
      …
      (signal ((name . "HitsAdded"))
        (arg ((name . "search") (type . "s")))
        (arg ((name . "count") (type . "u")))))
    …)
Function: dbus-introspect-get-attribute object attribute ¶
This function returns the attribute value of a D-Bus introspection object. The value of object can be any subtree of a parsed XML tree as retrieved with dbus-introspect-xml. attribute must be a string according to the attribute names in the D-Bus specification. Example:

(dbus-introspect-get-attribute
 (dbus-introspect-xml
  :system "org.freedesktop.SystemToolsBackends"
  "/org/freedesktop/SystemToolsBackends/UsersConfig")
 "name")

⇒ "/org/freedesktop/SystemToolsBackends/UsersConfig"
If object has no attribute, the function returns nil.

Footnotes
(1)
D-Bus signatures are explained in the D-Bus specification https://dbus.freedesktop.org/doc/dbus-specification.html#message-protocol-signatures.

(2)
The interfaces of the service ‘org.freedesktop.Hal’ are described in the HAL specification.


*** Detecting object paths and interfaces

The first elements, to be introspected for a D-Bus object, are further object paths and interfaces.

Function: dbus-introspect-get-node-names bus service path ¶
This function returns all node names of service in D-Bus bus at object path path as a list of strings. Example:

(dbus-introspect-get-node-names
 :session "org.gnome.seahorse" "/org/gnome/seahorse")

⇒ ("crypto" "keys")
The node names stand for further object paths of the D-Bus service, relative to path. In the example, ‘/org/gnome/seahorse/crypto’ and ‘/org/gnome/seahorse/keys’ are also object paths of the D-Bus service ‘org.gnome.seahorse’.

Function: dbus-introspect-get-all-nodes bus service path ¶
This function returns all node names of service in D-Bus bus at object path path. It returns a list of strings with all object paths of service, starting at path. Example:

(dbus-introspect-get-all-nodes :session "org.gnome.seahorse" "/")

⇒ ("/" "/org" "/org/gnome" "/org/gnome/seahorse"
    "/org/gnome/seahorse/crypto"
    "/org/gnome/seahorse/keys"
    "/org/gnome/seahorse/keys/openpgp"
    "/org/gnome/seahorse/keys/openpgp/local"
    "/org/gnome/seahorse/keys/openssh"
    "/org/gnome/seahorse/keys/openssh/local")
Function: dbus-introspect-get-interface-names bus service path ¶
This function returns a list strings of all interface names of service in D-Bus bus at object path path. This list will contain the default interface ‘org.freedesktop.DBus.Introspectable’.

Another default interface is ‘org.freedesktop.DBus.Properties’. If present, interface elements can also have property children. Example:

(dbus-introspect-get-interface-names
 :system "org.freedesktop.Hal"
 "/org/freedesktop/Hal/devices/computer")

⇒ ("org.freedesktop.DBus.Introspectable"
    "org.freedesktop.Hal.Device"
    "org.freedesktop.Hal.Device.SystemPowerManagement"
    "org.freedesktop.Hal.Device.CPUFreq")
Function: dbus-introspect-get-interface bus service path interface ¶
This function returns interface of service in D-Bus bus at object path path. The return value is an XML element. interface must be a string and a member of the list returned by dbus-introspect-get-interface-names. Example:

(dbus-introspect-get-interface
 :session "org.freedesktop.xesam.searcher"
 "/org/freedesktop/xesam/searcher/main"
 "org.freedesktop.xesam.Search")

⇒ (interface ((name . "org.freedesktop.xesam.Search"))
     (method ((name . "GetHitData"))
       (arg ((name . "search") (type . "s") (direction . "in")))
       (arg ((name . "hit_ids") (type . "au") (direction . "in")))
       (arg ((name . "fields") (type . "as") (direction . "in")))
       (arg ((name . "hit_data") (type . "aav") (direction . "out"))))
     …
     (signal ((name . "HitsAdded"))
       (arg ((name . "search") (type . "s")))
       (arg ((name . "count") (type . "u")))))
With these functions, it is possible to retrieve all introspection data from a running system:

(progn
  (pop-to-buffer "*introspect*")
  (erase-buffer)
  (dolist (service (dbus-list-known-names :session))
    (dolist (path (dbus-introspect-get-all-nodes :session service "/"))
      ;; We want to introspect only elements, which have more than
      ;; the default interface "org.freedesktop.DBus.Introspectable".
      (when (delete
             "org.freedesktop.DBus.Introspectable"
             (dbus-introspect-get-interface-names :session service path))
        (insert (format "\nservice: \"%s\" path: \"%s\"\n" service path)
                (dbus-introspect :session service path))
        (redisplay t)))))

*** Applying the functionality

Methods and signals are the communication means to D-Bus. The following functions return their specifications.

Function: dbus-introspect-get-method-names bus service path interface ¶
This function returns a list of strings of all method names of interface of service in D-Bus bus at object path path. Example:

(dbus-introspect-get-method-names
 :session "org.freedesktop.xesam.searcher"
 "/org/freedesktop/xesam/searcher/main"
 "org.freedesktop.xesam.Search")

⇒ ("GetState" "StartSearch" "GetHitCount" "GetHits" "NewSession"
    "CloseSession" "GetHitData" "SetProperty" "NewSearch"
    "GetProperty" "CloseSearch")
Function: dbus-introspect-get-method bus service path interface method ¶
This function returns method of interface as an XML element. It must be located at service in D-Bus bus at object path path. method must be a string and a member of the list returned by dbus-introspect-get-method-names. Example:

(dbus-introspect-get-method
 :session "org.freedesktop.xesam.searcher"
 "/org/freedesktop/xesam/searcher/main"
 "org.freedesktop.xesam.Search" "GetHitData")

⇒ (method ((name . "GetHitData"))
     (arg ((name . "search") (type . "s") (direction . "in")))
     (arg ((name . "hit_ids") (type . "au") (direction . "in")))
     (arg ((name . "fields") (type . "as") (direction . "in")))
     (arg ((name . "hit_data") (type . "aav") (direction . "out"))))
Function: dbus-introspect-get-signal-names bus service path interface ¶
This function returns a list of strings of all signal names of interface of service in D-Bus bus at object path path. Example:

(dbus-introspect-get-signal-names
 :session "org.freedesktop.xesam.searcher"
 "/org/freedesktop/xesam/searcher/main"
 "org.freedesktop.xesam.Search")

⇒ ("StateChanged" "SearchDone" "HitsModified"
    "HitsRemoved" "HitsAdded")
Function: dbus-introspect-get-signal bus service path interface signal ¶
This function returns signal of interface as an XML element. It must be located at service in D-Bus bus at object path path. signal must be a string and a member of the list returned by dbus-introspect-get-signal-names. Example:

(dbus-introspect-get-signal
 :session "org.freedesktop.xesam.searcher"
 "/org/freedesktop/xesam/searcher/main"
 "org.freedesktop.xesam.Search" "HitsAdded")

⇒ (signal ((name . "HitsAdded"))
     (arg ((name . "search") (type . "s")))
     (arg ((name . "count") (type . "u"))))

*** What else to know about interfaces

Interfaces can have properties. These can be exposed via the ‘org.freedesktop.DBus.Properties’ interface3. That is, properties can be retrieved and changed during the lifetime of an element.

A generalized interface is ‘org.freedesktop.DBus.Objectmanager’4, which returns objects, their interfaces and properties for a given service in just one call.

Annotations, on the other hand, are static values for an element. Often, they are used to instruct generators, how to generate code from the interface for a given language binding.

Function: dbus-introspect-get-property-names bus service path interface ¶
This function returns a list of strings with all property names of interface of service in D-Bus bus at object path path. Example:

(dbus-introspect-get-property-names
 :session "org.kde.kded" "/modules/networkstatus"
 "org.kde.Solid.Networking.Client")

⇒ ("Status")
If an interface declares properties, the corresponding element supports also the ‘org.freedesktop.DBus.Properties’ interface.

Function: dbus-introspect-get-property bus service path interface property ¶
This function returns property of interface as an XML element. It must be located at service in D-Bus bus at object path path. property must be a string and a member of the list returned by dbus-introspect-get-property-names.

A property value can be retrieved by the function dbus-introspect-get-attribute. Example:

(dbus-introspect-get-property
 :session "org.kde.kded" "/modules/networkstatus"
 "org.kde.Solid.Networking.Client" "Status")

⇒ (property ((access . "read") (type . "u") (name . "Status")))

(dbus-introspect-get-attribute
 (dbus-introspect-get-property
  :session "org.kde.kded" "/modules/networkstatus"
  "org.kde.Solid.Networking.Client" "Status")
 "access")

⇒ "read"
Function: dbus-get-property bus service path interface property ¶
This function returns the value of property of interface. It will be checked at bus, service, path. The result can be any valid D-Bus value. If there is no property, or property cannot be read, an error is raised. Example:

(dbus-get-property
 :session "org.kde.kded" "/modules/networkstatus"
 "org.kde.Solid.Networking.Client" "Status")

⇒ 4
Function: dbus-set-property bus service path interface property [type] value ¶
This function sets the value of property of interface to value. It will be checked at bus, service, path. value can be preceded by a type keyword. When the value is successfully set, this function returns value. Example:

(dbus-set-property
 :session "org.kde.kaccess" "/MainApplication"
 "com.trolltech.Qt.QApplication" "doubleClickInterval" :uint16 500)

⇒ 500
Function: dbus-get-all-properties bus service path interface ¶
This function returns all readable properties of interface. It will be checked at bus, service, path. The result is a list of cons cells. Every cons cell contains the name of the property, and its value. If there are no properties, nil is returned. Example:

(dbus-get-all-properties
 :session "org.kde.kaccess" "/MainApplication"
 "com.trolltech.Qt.QApplication")

⇒ (("cursorFlashTime" . 1000) ("doubleClickInterval" . 500)
    ("keyboardInputInterval" . 400) ("wheelScrollLines" . 3)
    ("globalStrut" 0 0) ("startDragTime" . 500)
    ("startDragDistance" . 4) ("quitOnLastWindowClosed" . t)
    ("styleSheet" . ""))
Function: dbus-get-all-managed-objects bus service path ¶
This function returns all objects at bus, service, path, and the children of path. The result is a list of objects. Every object is a cons cell of an existing path name, and the list of available interface objects. An interface object is another cons, whose car is the interface name and cdr is the list of properties as returned by dbus-get-all-properties for that path and interface. Example:

(dbus-get-all-managed-objects
 :session "org.gnome.SettingsDaemon" "/")

⇒ (("/org/gnome/SettingsDaemon/Power"
     ("org.gnome.SettingsDaemon.Power.Keyboard")
     ("org.gnome.SettingsDaemon.Power.Screen")
     ("org.gnome.SettingsDaemon.Power"
      ("Icon" . ". GThemedIcon battery-full-charged-symbolic ")
      ("Tooltip" . "Laptop battery is charged"))
     ("org.freedesktop.DBus.Peer")
     ("org.freedesktop.DBus.Introspectable")
     ("org.freedesktop.DBus.Properties")
     ("org.freedesktop.DBus.ObjectManager"))
    …)
If possible, ‘org.freedesktop.DBus.ObjectManager.GetManagedObjects’ is used for retrieving the information. Otherwise, the information is collected via ‘org.freedesktop.DBus.Introspectable.Introspect’ and ‘org.freedesktop.DBus.Properties.GetAll’, which is slow.

An overview of all existing object paths, their interfaces and properties could be retrieved by the following code:

(let ((result (mapcar (lambda (service)
                        (cons service
                              (dbus-get-all-managed-objects
                               :session service "/")))
                      (dbus-list-known-names :session))))
  (pop-to-buffer "*objectmanager*")
  (erase-buffer)
  (pp result (current-buffer)))
Function: dbus-introspect-get-annotation-names bus service path interface &optional name ¶
This function returns a list of all annotation names as list of strings. If name is nil, the annotations are children of interface, otherwise name must be a method, signal, or property XML element, where the annotations belong to. Example:

(dbus-introspect-get-annotation-names
 :session "de.berlios.Pinot" "/de/berlios/Pinot"
 "de.berlios.Pinot" "GetStatistics")

⇒ ("de.berlios.Pinot.GetStatistics")
Default annotation names5 are

‘org.freedesktop.DBus.Deprecated’
Whether or not the entity is deprecated; defaults to nil

‘org.freedesktop.DBus.GLib.CSymbol’
The C symbol; may be used for methods and interfaces

‘org.freedesktop.DBus.Method.NoReply’
If set, don’t expect a reply to the method call; defaults to nil

Function: dbus-introspect-get-annotation bus service path interface name annotation ¶
This function returns annotation as an XML object. If name is nil, annotation is a child of interface, otherwise name must be the name of a method, signal, or property XML element, where the annotation belongs to.

An attribute value can be retrieved by dbus-introspect-get-attribute. Example:

(dbus-introspect-get-annotation
 :session "de.berlios.Pinot" "/de/berlios/Pinot"
 "de.berlios.Pinot" "GetStatistics"
 "de.berlios.Pinot.GetStatistics")

⇒ (annotation ((name . "de.berlios.Pinot.GetStatistics")
                (value . "pinotDBus")))

(dbus-introspect-get-attribute
 (dbus-introspect-get-annotation
  :session "de.berlios.Pinot" "/de/berlios/Pinot"
  "de.berlios.Pinot" "GetStatistics"
  "de.berlios.Pinot.GetStatistics")
 "value")

⇒ "pinotDBus"
Footnotes
(3)
See https://dbus.freedesktop.org/doc/dbus-specification.html#standard-interfaces-properties

(4)
See https://dbus.freedesktop.org/doc/dbus-specification.html#standard-interfaces-objectmanager

(5)
See https://dbus.freedesktop.org/doc/dbus-specification.html#introspection-format


*** The final details

Methods and signals have arguments. They are described in the arg XML elements.

Function: dbus-introspect-get-argument-names bus service path interface name ¶
This function returns a list of all argument names as strings. name must be a method or signal XML element. Example:

(dbus-introspect-get-argument-names
 :session "org.freedesktop.xesam.searcher"
 "/org/freedesktop/xesam/searcher/main"
 "org.freedesktop.xesam.Search" "GetHitData")

⇒ ("search" "hit_ids" "fields" "hit_data")
Argument names are optional; the function can therefore return nil, even if the method or signal has arguments.

Function: dbus-introspect-get-argument bus service path interface name arg ¶
This function returns the argument arg as an XML object. name must be a method or signal XML element. Example:

(dbus-introspect-get-argument
 :session "org.freedesktop.xesam.searcher"
 "/org/freedesktop/xesam/searcher/main"
 "org.freedesktop.xesam.Search" "GetHitData" "search")

⇒ (arg ((name . "search") (type . "s") (direction . "in")))
Function: dbus-introspect-get-signature bus service path interface name &optional direction ¶
This function returns the signature of a method or signal, represented by name, as a string.

If name is a method, direction can be either ‘in’ or ‘out’. If direction is nil, ‘in’ is assumed.

If name is a signal, and direction is non-nil, direction must be ‘out’. Example:

(dbus-introspect-get-signature
 :session "org.freedesktop.xesam.searcher"
 "/org/freedesktop/xesam/searcher/main"
 "org.freedesktop.xesam.Search" "GetHitData" "in")

⇒ "sauas"

(dbus-introspect-get-signature
 :session "org.freedesktop.xesam.searcher"
 "/org/freedesktop/xesam/searcher/main"
 "org.freedesktop.xesam.Search" "HitsAdded")

⇒ "su"

** Mapping Lisp types and D-Bus types

D-Bus method calls and signals accept usually several arguments as parameters, either as input parameter, or as output parameter. Every argument belongs to a D-Bus type.

Such arguments must be mapped between the value encoded as a D-Bus type, and the corresponding type of Lisp objects. The mapping is applied Lisp object → D-Bus type for input parameters, and D-Bus type → Lisp object for output parameters.


*** Input parameters

Input parameters for D-Bus methods and signals occur as arguments of a Lisp function call. The following mapping to D-Bus types is applied, when the corresponding D-Bus message is created:

Lisp type
D-Bus type
t and nil
→
DBUS_TYPE_BOOLEAN
natural number
→
DBUS_TYPE_UINT32
negative integer
→
DBUS_TYPE_INT32
float
→
DBUS_TYPE_DOUBLE
string
→
DBUS_TYPE_STRING
list
→
DBUS_TYPE_ARRAY
Other Lisp objects, like symbols or hash tables, are not accepted as input parameters.

If it is necessary to use another D-Bus type, a corresponding type keyword can be prepended to the corresponding Lisp object. Basic D-Bus types are represented by the type keywords :byte, :boolean, :int16, :uint16, :int32, :uint32, :int64, :uint64, :double, :string, :object-path, :signature and :unix-fd.

Example:

(dbus-call-method … nat-number string)
is equivalent to

(dbus-call-method … :uint32 nat-number :string string)
but different to

(dbus-call-method … :int32 nat-number :signature string)
The value for a D-Bus byte type can be any natural number. If the number is larger than 255, it is truncated to the least significant byte. For example, :byte 1025 is equal to :byte 1. If a character is used as argument, modifiers represented outside this range are stripped off. For example, :byte ?x is equal to :byte ?\M-x, but it is not equal to :byte ?\C-x or :byte ?\M-\C-x.

Signed and unsigned D-Bus integer types expect a corresponding integer value. A unix file descriptor is restricted to the values 0…9.

If typed explicitly, a non-nil boolean value like :boolean 'symbol is handled like t or :boolean t.

A D-Bus compound type is always represented as a list. The CAR of this list can be the type keyword :array, :variant, :struct or :dict-entry, which would result in a corresponding D-Bus container. :array is optional, because this is the default compound D-Bus type for a list.

The objects being elements of the list are checked according to the D-Bus compound type rules.

An array must contain only elements of the same D-Bus type. It can be empty.
A variant must contain only a single element.
A dictionary entry must be an element of an array, and it must contain only a key-value pair of two elements, with a basic D-Bus type key.
There are no restrictions for structs.
If an empty array needs an element D-Bus type other than string, it can contain exactly one element of D-Bus type :signature. The value of this element (a string) is used as the signature of the elements of this array. Example:

(dbus-call-method
 :session "org.freedesktop.Notifications"
 "/org/freedesktop/Notifications"
 "org.freedesktop.Notifications" "Notify"
 "GNU Emacs"                   ; Application name.
 0                             ; No replacement of other notifications.
 ""                            ; No icon.
 "Notification summary"        ; Summary.
 (format                       ; Body.
  "This is a test notification, raised from\n%S" (emacs-version))
 '(:array)                     ; No actions (empty array of strings).
 '(:array :signature "{sv}")   ; No hints
                               ; (empty array of dictionary entries).
 :int32 -1)                    ; Default timeout.

⇒ 3
Function: dbus-string-to-byte-array string ¶
Sometimes, D-Bus methods require as input parameter an array of bytes, instead of a string. If it is guaranteed, that string is a UTF-8 string, this function performs the conversion. Example:

(dbus-string-to-byte-array "/etc/hosts")

⇒ (:array :byte 47 :byte 101 :byte 116 :byte 99 :byte 47
           :byte 104 :byte 111 :byte 115 :byte 116 :byte 115)
Function: dbus-escape-as-identifier string ¶
This function escapes an arbitrary string so it follows the rules for a C identifier. The escaped string can be used as object path component, interface element component, bus name component or member name in D-Bus.

The escaping consists of replacing all non-alphanumerics, and the first character if it’s a digit, with an underscore and two lower-case hex digits. As a special case, "" is escaped to "_". Example:

(dbus-escape-as-identifier "0123abc_xyz\x01\xff")

⇒ "_30123abc_5fxyz_01_ff"

*** Output parameters

Output parameters of D-Bus methods and signals are mapped to Lisp objects.

D-Bus type
Lisp type
DBUS_TYPE_BOOLEAN
→
t or nil
DBUS_TYPE_BYTE
→
natural number
DBUS_TYPE_UINT16
→
natural number
DBUS_TYPE_INT16
→
integer
DBUS_TYPE_UINT32
→
natural number
DBUS_TYPE_UNIX_FD
→
natural number
DBUS_TYPE_INT32
→
integer
DBUS_TYPE_UINT64
→
natural number
DBUS_TYPE_INT64
→
integer
DBUS_TYPE_DOUBLE
→
float
DBUS_TYPE_STRING
→
string
DBUS_TYPE_OBJECT_PATH
→
string
DBUS_TYPE_SIGNATURE
→
string
DBUS_TYPE_ARRAY
→
list
DBUS_TYPE_VARIANT
→
list
DBUS_TYPE_STRUCT
→
list
DBUS_TYPE_DICT_ENTRY
→
list
The resulting list of the last 4 D-Bus compound types contains as elements the elements of the D-Bus container, mapped according to the same rules.

The signal PropertyModified, discussed as an example in Inspection of D-Bus services., would offer as Lisp data the following object (bool stands here for either nil or t):

(integer ((string bool bool) (string bool bool) …))
Function: dbus-byte-array-to-string byte-array &optional multibyte ¶
If a D-Bus method or signal returns an array of bytes, which are known to represent a UTF-8 string, this function converts byte-array to the corresponding string. The string is unibyte encoded, unless multibyte is non-nil. Example:

(dbus-byte-array-to-string '(47 101 116 99 47 104 111 115 116 115))

⇒ "/etc/hosts"
Function: dbus-unescape-from-identifier string ¶
This function retrieves the original string from the encoded string as a unibyte string. The value of string must have been encoded with dbus-escape-as-identifier. Example:

(dbus-unescape-from-identifier "_30123abc_5fxyz_01_ff")

⇒ "0123abc_xyz\x01\xff"
If the original string used in dbus-escape-as-identifier is a multibyte string, it cannot be expected that this function returns that string:

(string-equal
 (dbus-unescape-from-identifier
  (dbus-escape-as-identifier "Grüß Göttin"))
 "Grüß Göttin")

⇒ nil


** Calling methods in a blocking way

Methods can be called synchronously (blocking) or asynchronously (non-blocking).

At the D-Bus level, a method call consist of two messages: one message which carries the input parameters to the object owning the method to be called, and a reply message returning the resulting output parameters from the object.

Function: dbus-call-method bus service path interface method &optional :timeout timeout &rest args ¶
This function calls method on the D-Bus bus. bus is either the keyword :system or the keyword :session.

service is the D-Bus service name to be used. path is the D-Bus object path, service is registered at. interface is an interface offered by service. It must provide method.

If the parameter :timeout is given, the following integer timeout specifies the maximum number of milliseconds before the method call must return. The default value is 25,000. If the method call doesn’t return in time, a D-Bus error is raised (see Errors and events.).

The remaining arguments args are passed to method as arguments. They are converted into D-Bus types as described in Mapping Lisp types and D-Bus types..

The function returns the resulting values of method as a list of Lisp objects, according to the type conversion rules described in Mapping Lisp types and D-Bus types.. Example:

(dbus-call-method
 :session "org.gnome.seahorse" "/org/gnome/seahorse/keys/openpgp"
 "org.gnome.seahorse.Keys" "GetKeyField"
 "openpgp:657984B8C7A966DD" "simple-name")

⇒ (t ("Philip R. Zimmermann"))
If the result of the method call is just one value, the converted Lisp object is returned instead of a list containing this single Lisp object. Example:

(dbus-call-method
 :system "org.freedesktop.Hal"
 "/org/freedesktop/Hal/devices/computer"
 "org.freedesktop.Hal.Device" "GetPropertyString"
 "system.kernel.machine")

⇒ "i686"
With the dbus-introspect function it is possible to explore the interfaces of ‘org.freedesktop.Hal’ service. It offers the interfaces ‘org.freedesktop.Hal.Manager’ for the object at the path ‘/org/freedesktop/Hal/Manager’ as well as the interface ‘org.freedesktop.Hal.Device’ for all objects prefixed with the path ‘/org/freedesktop/Hal/devices’. With the methods ‘GetAllDevices’ and ‘GetAllProperties’, it is simple to emulate the lshal command on GNU/Linux systems:

(dolist (device
         (dbus-call-method
          :system "org.freedesktop.Hal"
          "/org/freedesktop/Hal/Manager"
          "org.freedesktop.Hal.Manager" "GetAllDevices"))
  (message "\nudi = %s" device)
  (dolist (properties
           (dbus-call-method
            :system "org.freedesktop.Hal" device
            "org.freedesktop.Hal.Device" "GetAllProperties"))
    (message "  %s = %S"
             (car properties) (or (caadr properties) ""))))

-| "udi = /org/freedesktop/Hal/devices/computer
      info.addons = (\"hald-addon-acpi\")
      info.bus = \"unknown\"
      info.product = \"Computer\"
      info.subsystem = \"unknown\"
      info.udi = \"/org/freedesktop/Hal/devices/computer\"
      linux.sysfs_path_device = \"(none)\"
      power_management.acpi.linux.version = \"20051216\"
      power_management.can_suspend_to_disk = t
      power_management.can_suspend_to_ram = \"\"
      power_management.type = \"acpi\"
      smbios.bios.release_date = \"11/07/2001\"
      system.chassis.manufacturer = \"COMPAL\"
      system.chassis.type = \"Notebook\"
      system.firmware.release_date = \"03/19/2005\"
      …"

** Calling methods non-blocking

Function: dbus-call-method-asynchronously bus service path interface method handler &optional :timeout timeout &rest args ¶
This function calls method on the D-Bus bus asynchronously. bus is either the keyword :system or the keyword :session.

service is the D-Bus service name to be used. path is the D-Bus object path, service is registered at. interface is an interface offered by service. It must provide method.

handler is a Lisp function, which is called when the corresponding return message arrives. If handler is nil, no return message will be expected.

If the parameter :timeout is given, the following integer timeout specifies the maximum number of milliseconds before a reply message must arrive. The default value is 25,000. If there is no reply message in time, a D-Bus error is raised (see Errors and events.).

The remaining arguments args are passed to method as arguments. They are converted into D-Bus types as described in Mapping Lisp types and D-Bus types..

If handler is a Lisp function, the function returns a key into the hash table dbus-registered-objects-table. The corresponding entry in the hash table is removed, when the return message arrives, and handler is called. Example:

(dbus-call-method-asynchronously
 :system "org.freedesktop.Hal"
 "/org/freedesktop/Hal/devices/computer"
 "org.freedesktop.Hal.Device" "GetPropertyString"
 (lambda (msg) (message "%s" msg))
 "system.kernel.machine")

-| i686

⇒ (:serial :system 2)

** Offering own services

You can offer an own service in D-Bus, which will be visible by other D-Bus clients. See https://dbus.freedesktop.org/doc/dbus-api-design.html for a discussion of the design.

In order to register methods on the D-Bus, Emacs has to request a well known name on the D-Bus under which it will be available for other clients. Names on the D-Bus can be registered and unregistered using the following functions:

Function: dbus-register-service bus service &rest flags ¶
This function registers the known name service on D-Bus bus.

bus is either the keyword :system or the keyword :session.

service is the service name to be registered on the D-Bus. It must be a known name.

flags is a subset of the following keywords:

:allow-replacement
Allow another service to become the primary owner if requested.

:replace-existing
Request to replace the current primary owner.

:do-not-queue
If we can not become the primary owner do not place us in the queue.

One of the following keywords is returned:

:primary-owner
We have become the primary owner of the name service.

:in-queue
We could not become the primary owner and have been placed in the queue.

:exists
We already are in the queue.

:already-owner
We already are the primary owner.

Function: dbus-unregister-service bus service ¶
This function unregisters all objects from D-Bus bus, that were registered by Emacs for service.

bus is either the keyword :system or the keyword :session.

service is the D-Bus service name of the D-Bus. It must be a known name. Emacs releases its association to service from D-Bus.

One of the following keywords is returned:

:released
We successfully released the name service.

:non-existent
The name service does not exist on the bus.

:not-owner
We are not an owner of the name service.

When service is not a known name but a unique name, the function returns nil.

When a name has been chosen, Emacs can offer its own methods, which can be called by other applications. These methods could be an implementation of an interface of a well known service, like ‘org.freedesktop.TextEditor’.

They could also be an implementation of its own interface. In this case, the service name must be ‘org.gnu.Emacs’. The object path shall begin with ‘/org/gnu/Emacs/application’, and the interface name shall be org.gnu.Emacs.application, where application is the name of the application which provides the interface.

Constant: dbus-service-emacs ¶
The well known service name ‘org.gnu.Emacs’ of Emacs.

Constant: dbus-path-emacs ¶
The object path namespace ‘/org/gnu/Emacs’ used by Emacs.

Constant: dbus-interface-emacs ¶
The interface namespace org.gnu.Emacs used by Emacs.

Function: dbus-register-method bus service path interface method handler dont-register-service ¶
With this function, an application registers method on the D-Bus bus.

bus is either the keyword :system or the keyword :session.

service is the D-Bus service name of the D-Bus object method is registered for. It must be a known name (see discussion of dont-register-service below).

path is the D-Bus object path service is registered (see discussion of dont-register-service below).

interface is the interface offered by service. It must provide method.

handler is a Lisp function to be called when a method call is received. It must accept as arguments the input arguments of method. handler should return a list, whose elements are to be used as arguments for the reply message of method. This list can be composed like the input parameters in Mapping Lisp types and D-Bus types..

If handler wants to return just one Lisp object and it is not a cons cell, handler can return this object directly, instead of returning a list containing the object.

If handler returns a reply message with an empty argument list, handler must return the keyword :ignore in order to distinguish it from nil (the boolean false).

If handler detects an error, it shall return the list (:error error-name error-message). error-name is a namespaced string which characterizes the error type, and error-message is a free text string. Alternatively, any Emacs signal dbus-error in handler raises a D-Bus error message with the error name ‘org.freedesktop.DBus.Error.Failed’.

When dont-register-service is non-nil, the known name service is not registered. This means that other D-Bus clients have no way of noticing the newly registered method. When interfaces are constructed incrementally by adding single methods or properties at a time, dont-register-service can be used to prevent other clients from discovering the still incomplete interface.

The default D-Bus timeout when waiting for a message reply is 25 seconds. This value could be even smaller, depending on the calling client. Therefore, handler should not last longer than absolutely necessary.

dbus-register-method returns a Lisp object, which can be used as argument in dbus-unregister-object for removing the registration for method. Example:

(defun my-dbus-method-handler (filename)
  (if (find-file filename)
      '(:boolean t)
    '(:boolean nil)))

(dbus-register-method
 :session "org.freedesktop.TextEditor" "/org/freedesktop/TextEditor"
 "org.freedesktop.TextEditor" "OpenFile"
 #'my-dbus-method-handler)

⇒ ((:method :session "org.freedesktop.TextEditor" "OpenFile")
    ("org.freedesktop.TextEditor" "/org/freedesktop/TextEditor"
     my-dbus-method-handler))
If you invoke the method ‘org.freedesktop.TextEditor.OpenFile’ from another D-Bus application with a file name as parameter, the file is opened in Emacs, and the method returns either true or false, indicating the success of the method. As a test tool one could use the command line tool dbus-send in a shell:

# dbus-send --session --print-reply \
    --dest="org.freedesktop.TextEditor" \
    "/org/freedesktop/TextEditor" \
    "org.freedesktop.TextEditor.OpenFile" string:"/etc/hosts"

-| method return sender=:1.22 -> dest=:1.23 reply_serial=2
      boolean true
You can indicate an error by returning an :error list reply, or by raising the Emacs signal dbus-error. The handler above could be changed like this:

(defun my-dbus-method-handler (&rest args)
  (if (not (and (= (length args) 1) (stringp (car args))))
      (list :error
            "org.freedesktop.TextEditor.Error.InvalidArgs"
            (format "Wrong argument list: %S" args))
    (condition-case err
        (find-file (car args))
      (error (signal 'dbus-error (cdr err))))
    t))
The test then runs

# dbus-send --session --print-reply \
    --dest="org.freedesktop.TextEditor" \
    "/org/freedesktop/TextEditor" \
    "org.freedesktop.TextEditor.OpenFile" \
    string:"/etc/hosts" string:"/etc/passwd"

-| Error org.freedesktop.TextEditor.Error.InvalidArgs:
   Wrong argument list: ("/etc/hosts" "/etc/passwd")
# dbus-send --session --print-reply \
    --dest="org.freedesktop.TextEditor" \
    "/org/freedesktop/TextEditor" \
    "org.freedesktop.TextEditor.OpenFile" \
    string:"/etc/crypttab"

-| Error org.freedesktop.DBus.Error.Failed:
   D-Bus error: "File is not readable", "/etc/crypttab"
Function: dbus-register-property bus service path interface property access [type] value &optional emits-signal dont-register-service ¶
With this function, an application declares a property on the D-Bus bus.

bus is either the keyword :system or the keyword :session.

service is the D-Bus service name of the D-Bus. It must be a known name.

path is the D-Bus object path service is registered (see discussion of dont-register-service below).

interface is the name of the interface used at path, property is the name of the property of interface.

access indicates, whether the property can be changed by other services via D-Bus. It must be either the keyword :read, :write or :readwrite.

value is the initial value of the property, it can be of any valid type (See dbus-call-method, for details). value can be preceded by a type keyword.

If property already exists on path, it will be overwritten. For properties with access type :read this is the only way to change their values. Properties with access type :write or :readwrite can be changed by dbus-set-property.

The interface ‘org.freedesktop.DBus.Properties’ is added to path, including a default handler for the ‘Get’, ‘GetAll’ and ‘Set’ methods of this interface. When emits-signal is non-nil, the signal ‘PropertiesChanged’ is sent when the property is changed by dbus-set-property.

When dont-register-service is non-nil, the known name service is not registered. This means that other D-Bus clients have no way of noticing the newly registered method. When interfaces are constructed incrementally by adding single methods or properties at a time, dont-register-service can be used to prevent other clients from discovering the still incomplete interface.

dbus-register-property returns a Lisp object, which can be used as argument in dbus-unregister-object for removing the registration for property. Example:

(dbus-register-property
 :session "org.freedesktop.TextEditor" "/org/freedesktop/TextEditor"
 "org.freedesktop.TextEditor" "name" :read "GNU Emacs")

⇒ ((:property :session "org.freedesktop.TextEditor" "name")
    ("org.freedesktop.TextEditor" "/org/freedesktop/TextEditor"))

(dbus-register-property
 :session "org.freedesktop.TextEditor" "/org/freedesktop/TextEditor"
 "org.freedesktop.TextEditor" "version" :readwrite emacs-version t)

⇒ ((:property :session "org.freedesktop.TextEditor" "version")
    ("org.freedesktop.TextEditor" "/org/freedesktop/TextEditor"))
Other D-Bus applications can read the property via the default methods ‘org.freedesktop.DBus.Properties.Get’ and ‘org.freedesktop.DBus.Properties.GetAll’. Testing is also possible via the command line tool dbus-send in a shell:

# dbus-send --session --print-reply \
    --dest="org.freedesktop.TextEditor" \
    "/org/freedesktop/TextEditor" \
    "org.freedesktop.DBus.Properties.GetAll" \
    string:"org.freedesktop.TextEditor"

-| method return sender=:1.22 -> dest=:1.23 reply_serial=3
      array [
         dict entry(
            string "name"
            variant             string "GNU Emacs"
         )
         dict entry(
            string "version"
            variant             string "23.1.50.5"
         )
      ]
It is also possible to apply the dbus-get-property, dbus-get-all-properties and dbus-set-property functions (see What else to know about interfaces.).

(dbus-set-property
 :session "org.freedesktop.TextEditor" "/org/freedesktop/TextEditor"
 "org.freedesktop.TextEditor" "version" "23.1.50")

⇒ "23.1.50"

(dbus-get-property
 :session "org.freedesktop.TextEditor" "/org/freedesktop/TextEditor"
 "org.freedesktop.TextEditor" "version")

⇒ "23.1.50"
Function: dbus-unregister-object object ¶
This function unregisters object from the D-Bus. object must be the result of a preceding dbus-register-method, dbus-register-property, dbus-register-signal (see Sending and receiving signals.) or dbus-register-monitor call. It returns t if object has been unregistered, nil otherwise.

When object identifies the last method or property, which is registered for the respective service, Emacs releases its association to the service from D-Bus.


** Sending and receiving signals

Signals are one way messages. They carry input parameters, which are received by all objects which have registered for such a signal.

Function: dbus-send-signal bus service path interface signal &rest args ¶
This function is similar to dbus-call-method. The difference is, that there are no returning output parameters.

The function emits signal on the D-Bus bus. bus is either the keyword :system or the keyword :session. It doesn’t matter whether another object has registered for signal.

Signals can be unicast or broadcast messages. For broadcast messages, service must be nil. Otherwise, service is the D-Bus service name the signal is sent to as a unicast message.6 path is the D-Bus object path signal is sent from. interface is an interface available at path. It must provide signal.

The remaining arguments args are passed to signal as arguments. They are converted into D-Bus types as described in Mapping Lisp types and D-Bus types.. Example:

(dbus-send-signal
 :session nil dbus-path-emacs
 (concat dbus-interface-emacs ".FileManager") "FileModified"
 "/home/albinus/.emacs")
Function: dbus-register-signal bus service path interface signal handler &rest args ¶
With this function, an application registers for a signal on the D-Bus bus.

bus is either the keyword :system or the keyword :session.

service is the D-Bus service name used by the sending D-Bus object. It can be either a known name or the unique name of the D-Bus object sending the signal. A known name will be mapped onto the unique name of the object, owning service at registration time. When the corresponding D-Bus object disappears, signals will no longer be received.

path is the corresponding D-Bus object path that service is registered at. interface is an interface offered by service. It must provide signal.

service, path, interface and signal can be nil. This is interpreted as a wildcard for the respective argument.

handler is a Lisp function to be called when the signal is received. It must accept as arguments the output parameters signal is sending.

The remaining arguments args can be keywords or keyword string pairs.7 Their meaning is as follows:

:argn string
:pathn string
This stands for the nth argument of the signal. :pathn arguments can be used for object path wildcard matches as specified by D-Bus, while an :argN argument requires an exact match.

:arg-namespace string
Register for those signals, whose first argument names a service or interface within the namespace string.

:path-namespace string
Register for the object path namespace string. All signals sent from an object path, which has string as the preceding string, are matched. This requires path to be nil.

:eavesdrop
Register for unicast signals which are not directed to the D-Bus object Emacs is registered at D-Bus BUS, if the security policy of BUS allows this. Otherwise, this argument is ignored.

dbus-register-signal returns a Lisp object, which can be used as argument in dbus-unregister-object for removing the registration for signal. Example:

(defun my-dbus-signal-handler (device)
  (message "Device %s added" device))

(dbus-register-signal
 :system "org.freedesktop.Hal" "/org/freedesktop/Hal/Manager"
 "org.freedesktop.Hal.Manager" "DeviceAdded"
 #'my-dbus-signal-handler)

⇒ ((:signal :system "org.freedesktop.Hal.Manager" "DeviceAdded")
    ("org.freedesktop.Hal" "/org/freedesktop/Hal/Manager"
     my-signal-handler))
As we know from the introspection data of interface ‘org.freedesktop.Hal.Manager’, the signal ‘DeviceAdded’ provides one single parameter, which is mapped into a Lisp string. The callback function my-dbus-signal-handler must therefore define a single string argument. Plugging a USB device into your machine, when registered for signal ‘DeviceAdded’, will show you which objects the GNU/Linux hal daemon adds.

Some of the match rules have been added to a later version of D-Bus. In order to test the availability of such features, you could register for a dummy signal, and check the result:

(dbus-ignore-errors
  (dbus-register-signal
   :system nil nil nil nil #'ignore :path-namespace "/invalid/path"))

⇒ nil
Footnotes
(6)
For backward compatibility, a broadcast message is also emitted if service is the known or unique name Emacs is registered at D-Bus bus.

(7)
For backward compatibility, the arguments args can also be just strings. They stand for the respective arguments of signal in their order, and are used for filtering as well. A nil argument might be used to preserve the order.


** Alternative buses and environments

Until now, we have spoken about the system and the session buses, which are the default buses to be connected to. However, it is possible to connect to any bus with a known address. This is a UNIX domain or TCP/IP socket. Everywhere, where a bus is mentioned as argument of a function (the keyword :system or the keyword :session), this address can be used instead. The connection to this bus must be initialized first.

Function: dbus-init-bus bus &optional private ¶
This function establishes the connection to D-Bus bus.

bus can be either the keyword :system or the keyword :session, or it can be a string denoting the address of the corresponding bus. For the system and session buses, this function is called when loading dbus.el, there is no need to call it again.

If Emacs was invoked when there was no D-Bus session bus available yet, you can set the environment variable DBUS_SESSION_BUS_ADDRESS once the session bus daemon is running and offering the address. Calling dbus-init-bus initializes the connection to the session bus.

(setenv "DBUS_SESSION_BUS_ADDRESS" "unix:path=/run/user/1000/bus")

⇒ "unix:path=/run/user/1000/bus"

(dbus-init-bus :session)

⇒ 2
dbus-init-bus returns the number of connections this Emacs session has established to the bus under the same unique name (see dbus-get-unique-name). It depends on the libraries Emacs is linked with, and on the environment Emacs is running. For example, if Emacs is linked with the GTK+ toolkit, and it runs in a GTK+-aware environment like GNOME, another connection might already be established.

When private is non-nil, a new connection is established instead of reusing an existing one. It results in a new unique name at the bus. This can be used, if it is necessary to distinguish from another connection used in the same Emacs process, like the one established by GTK+. If bus is the keyword :system or the keyword :session, the new private connection is identified by the keywords :system-private or :session-private, respectively.

Example: You initialize a connection to the AT-SPI bus on your host:

(setq my-bus
      (dbus-call-method
       :session "org.a11y.Bus" "/org/a11y/bus"
       "org.a11y.Bus" "GetAddress"))

⇒ "unix:abstract=/tmp/dbus-2yzWHOCdSD,guid=a490dd26625870ca1298b6e10000fd7f"

;; If Emacs is built with GTK+ support, and you run in a GTK+-enabled
;; environment (like a GNOME session), the initialization reuses the
;; connection established by GTK+'s atk bindings.
(dbus-init-bus my-bus)

⇒ 2

(dbus-get-unique-name my-bus)

⇒ ":1.19"

;; Open a new connection to the same bus.  This supersedes the
;; previous one.
(dbus-init-bus my-bus 'private)

⇒ 1

(dbus-get-unique-name my-bus)

⇒ ":1.20"
D-Bus addresses can specify a different transport. A possible address could be based on TCP/IP sockets, see next example. Which transport is supported depends on the bus daemon configuration, however.

Function: dbus-setenv bus variable value ¶
This function sets the value of the bus environment variable to value.

bus is either a Lisp keyword, :system or :session, or a string denoting the bus address. Both variable and value should be strings.

Normally, services inherit the environment of the bus daemon. This function adds to or modifies that environment when activating services.

Some bus instances, such as :system, may disable setting the environment. In such cases, or if this feature is not available in older D-Bus versions, this function signals a dbus-error.

As an example, it might be desirable to start X11 enabled services on a remote host’s bus on the same X11 server the local Emacs is running. This could be achieved by

(setq my-bus "unix:host=example.gnu.org,port=4711")

⇒ "unix:host=example.gnu.org,port=4711"

(dbus-init-bus my-bus)

⇒ 1

(dbus-setenv my-bus "DISPLAY" (getenv "DISPLAY"))

⇒ nil

** Errors and events

The internal actions can be traced by running in a debug mode.

Variable: dbus-debug ¶
If this variable is non-nil, D-Bus specific debug messages are raised.

Input parameters of dbus-call-method, dbus-call-method-asynchronously, dbus-send-signal, dbus-register-method, dbus-register-property and dbus-register-signal are checked for correct D-Bus types. If there is a type mismatch, the Lisp error wrong-type-argument D-Bus arg is raised.

All errors raised by D-Bus are signaled with the error symbol dbus-error. If possible, error messages from D-Bus are appended to the dbus-error.

Special Form: dbus-ignore-errors forms… ¶
This executes forms exactly like a progn, except that dbus-error errors are ignored during the forms (the macro returns nil then). These errors can be made visible when dbus-debug is set to non-nil.

Incoming D-Bus messages are handled as Emacs events, see (elisp)Misc Events. They are retrieved only, when Emacs runs in interactive mode. The generated event has this form:

(dbus-event bus type serial service destination path interface member
            handler &rest args)
bus identifies the D-Bus the message is coming from. It is either a Lisp keyword, :system, :session, :system-private or :session-private, or a string denoting the bus address.

type is the D-Bus message type which has caused the event. It can be dbus-message-type-invalid, dbus-message-type-method-call, dbus-message-type-method-return, dbus-message-type-error, or dbus-message-type-signal. serial is the serial number of the received D-Bus message, unless type is equal dbus-message-type-error.

service and path are the unique name and the object path of the D-Bus object emitting the message. destination is the D-Bus name the message is dedicated to, or nil in case the message is a broadcast signal.

interface and member denote the message which has been sent. When type is dbus-message-type-error, member is the error name.

handler is the callback function which has been registered for this message (see Sending and receiving signals.). args are the typed arguments as returned from the message. They are passed to handler without type information, when it is called during event handling in dbus-handle-event.

In order to inspect the dbus-event data, you could extend the definition of the callback function in Sending and receiving signals.:

(defun my-dbus-signal-handler (&rest args)
  (message "my-dbus-signal-handler: %S" last-input-event))
There exist convenience functions which could be called inside a callback function in order to retrieve the information from the event.

Function: dbus-event-bus-name event ¶
This function returns the bus name event is coming from. The result is either the keyword :system or the keyword :session.

Function: dbus-event-message-type event ¶
This function returns the message type of the corresponding D-Bus message. The result is a natural number.

Function: dbus-event-serial-number event ¶
This function returns the serial number of the corresponding D-Bus message. The result is a natural number.

Function: dbus-event-service-name event ¶
This function returns the unique name of the D-Bus object event is coming from.

Function: dbus-event-destination-name event ¶
This function returns the unique name of the D-Bus object event is dedicated to.

Function: dbus-event-path-name event ¶
This function returns the object path of the D-Bus object event is coming from.

Function: dbus-event-interface-name event ¶
This function returns the interface name of the D-Bus object event is coming from.

Function: dbus-event-member-name event ¶
This function returns the member name of the D-Bus object event is coming from. It is either a signal name or a method name.

Function: dbus-event-handler event ¶
This function returns the handler the D-Bus object event is applied with.

Function: dbus-event-arguments event ¶
This function returns the arguments the D-Bus object event is carrying on.

D-Bus errors are not propagated during event handling, because it is usually not desired. D-Bus errors in events can be made visible by setting the variable dbus-debug to non-nil. They can also be handled by a hook function.

Variable: dbus-event-error-functions ¶
This hook variable keeps a list of functions, which are called when a D-Bus error happens in the event handler. Every function must accept two arguments, the event and the error variable caught in condition-case by dbus-error.

Such functions can be used to adapt the error signal to be raised. Example:

(defun my-dbus-event-error-handler (event error)
  (when (string-equal (concat dbus-interface-emacs ".FileManager")
                      (dbus-event-interface-name event))
    (message "my-dbus-event-error-handler: %S %S" event error)
    (signal 'file-error (cdr error))))

(add-hook 'dbus-event-error-functions #'my-dbus-event-error-handler)
Hook functions should take into account that there might be other D-Bus applications running. They should therefore check carefully, whether a given D-Bus error is related to them.


** Monitoring messages

Function: dbus-register-monitor bus &optional handler &key type sender destination path interface member ¶
This function registers handler for monitoring messages on the D-Bus bus.

bus is either a Lisp keyword, :system or :session, or a string denoting the bus address.

handler is the function to be called when a D-Bus event to be monitored arrives. It is called with the args slot of the D-Bus event (see Errors and events.), which are stripped off the type keywords. If handler is nil, the default handler dbus-monitor-handler is applied. This default handler behaves similar to the dbus-monitor program.

The other arguments are keyword-value pairs. :type type defines the message type to be monitored. If given, it must be equal one of the strings ‘method_call’, ‘method_return’, ‘error’ or ‘signal’.

:sender sender and :destination destination are D-Bus names. They can be unique names, or well-known service names.

:path path is the D-Bus object to be monitored. :interface interface is the name of an interface, and :member member is either a method name, a signal name, or an error name.

dbus-register-monitor returns a Lisp object, which can be used as argument in dbus-unregister-object for removing the monitor.

The following form shows all D-Bus events on the session bus in buffer ‘*D-Bus Monitor*’:

(dbus-register-monitor :session)
And this form restricts the monitoring on D-Bus errors:

(dbus-register-monitor :session nil :type "error")
Command: dbus-monitor &optional bus ¶
This command invokes dbus-register-monitor interactively, and switches to the monitor buffer.





